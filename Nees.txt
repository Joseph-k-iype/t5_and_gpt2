import logging
from typing import List, Dict, Any, Optional
import json
from pydantic import BaseModel, Field
from azure.identity import DefaultAzureCredential, get_bearer_token_provider
from openai import AzureOpenAI
from app.config.environment import get_os_env

logger = logging.getLogger(__name__)

class MyDocument(BaseModel):
    """Model representing a document with its embedding."""
    id: str = ""
    text: str = ""
    embedding: List[float] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class EmbeddingClient:
    """Client for generating embeddings for documents."""
    
    def __init__(self, azure_api_version: str = "2023-05-15", embeddings_model: str = "text-embedding-3-large"):
        """Initialize the embedding client."""
        self.env = get_os_env()
        self.azure_api_version = azure_api_version
        self.embeddings_model = embeddings_model
        self.direct_azure_client = self._get_direct_azure_client()
    
    def _get_direct_azure_client(self):
        """Get the Azure OpenAI client for generating embeddings."""
        try:
            token_provider = get_bearer_token_provider(
                self.env._get_credential(),
                "https://cognitiveservices.azure.com/.default"
            )
            azure_endpoint = self.env.get("AZURE_ENDPOINT", "")
            
            return AzureOpenAI(
                azure_endpoint=azure_endpoint,
                api_version=self.azure_api_version,
                azure_ad_token_provider=token_provider
            )
        except Exception as e:
            logger.error(f"Error initializing Azure OpenAI client: {e}")
            raise
    
    def generate_embedding(self, text: str) -> List[float]:
        """Generate an embedding for a single text."""
        try:
            response = self.direct_azure_client.embeddings.create(
                model=self.embeddings_model,
                input=text
            )
            return response.data[0].embedding
        except Exception as e:
            logger.error(f"Error generating embedding: {e}")
            raise
    
    def generate_embeddings_for_document(self, doc: MyDocument) -> MyDocument:
        """Generate embeddings for a document and update it."""
        try:
            doc.embedding = self.generate_embedding(doc.text)
            return doc
        except Exception as e:
            logger.error(f"Error generating embeddings for document: {e}")
            return doc
    
    def generate_embeddings_batch(self, documents: List[MyDocument]) -> List[MyDocument]:
        """Generate embeddings for a batch of documents."""
        results = []
        for doc in documents:
            try:
                results.append(self.generate_embeddings_for_document(doc))
            except Exception as e:
                logger.error(f"Error generating embedding for document {doc.id}: {e}")
                results.append(doc)  # Return the original document without embedding
        return results
    
    def compute_similarity(self, embedding1: List[float], embedding2: List[float]) -> float:
        """
        Compute the cosine similarity between two embeddings.
        
        Args:
            embedding1: First embedding vector
            embedding2: Second embedding vector
            
        Returns:
            float: Cosine similarity (higher means more similar)
        """
        if not embedding1 or not embedding2 or len(embedding1) != len(embedding2):
            return 0.0
            
        # Compute dot product
        dot_product = sum(a * b for a, b in zip(embedding1, embedding2))
        
        # Compute magnitudes
        magnitude1 = sum(a * a for a in embedding1) ** 0.5
        magnitude2 = sum(b * b for b in embedding2) ** 0.5
        
        # Avoid division by zero
        if magnitude1 == 0 or magnitude2 == 0:
            return 0.0
            
        # Compute cosine similarity
        return dot_product / (magnitude1 * magnitude2)
    
    def find_similar_documents(self, query_embedding: List[float], 
                             documents: List[MyDocument], 
                             top_k: int = 5) -> List[Dict[str, Any]]:
        """
        Find the most similar documents to a query embedding.
        
        Args:
            query_embedding: Embedding of the query
            documents: List of documents with embeddings
            top_k: Number of top results to return
            
        Returns:
            List of dictionaries with document ID, similarity score, and document
        """
        # Filter documents that have embeddings
        valid_docs = [doc for doc in documents if doc.embedding]
        
        if not valid_docs:
            return []
            
        # Compute similarities
        similarities = []
        for doc in valid_docs:
            similarity = self.compute_similarity(query_embedding, doc.embedding)
            similarities.append({
                "id": doc.id,
                "similarity": similarity,
                "document": doc
            })
            
        # Sort by similarity (highest first)
        sorted_similarities = sorted(similarities, key=lambda x: x["similarity"], reverse=True)
        
        # Return top-k results
        return sorted_similarities[:top_k]
