import sys
import os
import logging
import chromadb
import time
from langchain_openai import AzureChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.document_loaders import CSVLoader
from typing import List, Dict

# ‚úÖ Add the parent directory to the system path to import custom modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../oaai_client_sdk_core')))
from azoi_embedding_client import EmbeddingClient
from genai_env_setup import OSEnv

# ‚úÖ Logging Configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("chatbot.log"),  # ‚úÖ Logs to file
        logging.StreamHandler()  # ‚úÖ Logs to console
    ]
)
logger = logging.getLogger(__name__)

class KnowledgeBase:
    """Handles document loading, embedding storage, and retrieval."""

    def __init__(self, base_dir: str, knowledge_dir: str):
        try:
            self.env = OSEnv(base_dir)
            self.embedding_client = EmbeddingClient(base_dir)
            self.knowledge_dir = knowledge_dir
            self.chroma_client = chromadb.PersistentClient(path="./chroma_db")
            self.collection = self.chroma_client.get_or_create_collection(name="csv_knowledge")

            logger.info("‚úÖ KnowledgeBase initialized successfully.")
        except Exception as e:
            logger.error(f"‚ùå Error initializing KnowledgeBase: {e}")
            raise

    def load_csv_documents(self) -> List[Dict]:
        """Load CSV documents and return their contents as a list of dictionaries."""
        try:
            csv_files = [f for f in os.listdir(self.knowledge_dir) if f.endswith(".csv")]
            documents = []

            if not csv_files:
                logger.warning("‚ö†Ô∏è No CSV files found in the knowledge directory.")
                return []

            for file in csv_files:
                file_path = os.path.join(self.knowledge_dir, file)
                loader = CSVLoader(file_path=file_path)
                docs = loader.load()

                for doc in docs:
                    documents.append({"content": doc.page_content, "source": file})

            logger.info(f"‚úÖ Loaded {len(documents)} documents from CSV files.")
            return documents

        except Exception as e:
            logger.error(f"‚ùå Error loading CSV files: {e}")
            return []

    def store_embeddings(self):
        """Generate and store embeddings for CSV documents in ChromaDB."""
        try:
            documents = self.load_csv_documents()
            if not documents:
                logger.warning("‚ö†Ô∏è No data to store in ChromaDB.")
                return

            for i, doc in enumerate(documents):
                retries = 3
                while retries > 0:
                    try:
                        embedding = self.embedding_client.generate_embeddings(doc["content"])
                        self.collection.add(
                            ids=[f"doc_{i}"],
                            embeddings=[embedding],
                            metadatas=[{"source": doc["source"], "text": doc["content"]}]
                        )
                        logger.info(f"‚úÖ Stored embedding for document {i}")
                        break
                    except Exception as e:
                        retries -= 1
                        logger.warning(f"‚ö†Ô∏è Retrying embedding generation ({3 - retries}/3) for doc {i}: {e}")
                        time.sleep(2)

            logger.info("‚úÖ Document embeddings successfully stored in ChromaDB.")

        except Exception as e:
            logger.error(f"‚ùå Error storing embeddings: {e}")

    def retrieve_relevant_documents(self, query: str, top_k: int = 3) -> List[str]:
        """Retrieve the top relevant document texts from ChromaDB for a given query."""
        try:
            query_embedding = self.embedding_client.generate_embeddings(query)
            results = self.collection.query(query_embeddings=[query_embedding], n_results=top_k)
            retrieved_docs = [res["text"] for res in results["metadatas"]] if results else []

            logger.info(f"‚úÖ Retrieved {len(retrieved_docs)} relevant documents for query.")
            return retrieved_docs

        except Exception as e:
            logger.error(f"‚ùå Error retrieving documents: {e}")
            return []

class AzureChatbot:
    """Azure OpenAI chatbot using RAG (Retrieval-Augmented Generation)."""

    def __init__(self, base_dir: str, knowledge_dir: str):
        try:
            self.env = OSEnv(base_dir)
            self.knowledge_base = KnowledgeBase(base_dir, knowledge_dir)

            os.environ["HTTP_PROXY"] = self.env.get("HTTPS_PROXY_DOMAIN", "")
            os.environ["HTTPS_PROXY"] = self.env.get("HTTPS_PROXY_DOMAIN", "")
            os.environ["NO_PROXY"] = "localhost,127.0.0.1,azure.com"

            self.llm = AzureChatOpenAI(
                model_name=os.getenv("MODEL_NAME", "gpt-4"),
                azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
                azure_ad_token=os.getenv("AZURE_TOKEN")
            )

            self.memory = ConversationBufferMemory()
            logger.info("‚úÖ AzureChatbot initialized successfully.")

        except Exception as e:
            logger.error(f"‚ùå Error initializing chatbot: {e}")
            raise

    def chat(self, message: str) -> str:
        """Process a user message with RAG."""
        try:
            relevant_context = self.knowledge_base.retrieve_relevant_documents(message)

            if relevant_context:
                context_text = "\n".join(relevant_context)
                final_prompt = (
                    f"Use the following retrieved knowledge to answer the user's question:\n\n"
                    f"{context_text}\n\n"
                    f"User Query: {message}"
                )
            else:
                final_prompt = f"User Query: {message}"

            response = self.llm.predict(final_prompt)
            return response

        except Exception as e:
            logger.error(f"‚ùå Error processing chat request: {e}")
            return "‚ùå An error occurred while processing your request."

def main():
    """Main function to initialize and run the chatbot."""
    try:
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        knowledge_dir = os.path.join(base_dir, "knowledge")

        # ‚úÖ Print the knowledge folder path
        print(f"üìÇ Knowledge Folder Path: {knowledge_dir}")
        logger.info(f"üìÇ Knowledge Folder Path: {knowledge_dir}")

        chatbot = AzureChatbot(base_dir, knowledge_dir)
        chatbot.knowledge_base.store_embeddings()  # ‚úÖ Load CSV knowledge into ChromaDB

        print("\nüöÄ Chatbot initialized! You can now ask questions based on the CSV data.")
        print("Type 'quit' to exit.\n")

        while True:
            user_input = input("You: ").strip()
            if user_input.lower() in ['quit', 'exit', 'bye']:
                print("Goodbye!")
                break

            response = chatbot.chat(user_input)
            print(f"\nBot: {response}\n")

    except Exception as e:
        logger.error(f"‚ùå Unexpected error in main function: {e}")
        print("‚ùå A critical error occurred. Check logs for details.")

if __name__ == "__main__":
    main()
