import chromadb
from chromadb.config import Settings
from langchain_community.vectorstores import Chroma

class ChromaVectorStore:
    """ChromaDB vector store manager with multi-column support and local-only processing"""
    
    def __init__(self, env: OSEnv):
        """Initialize the vector store with environment configuration."""
        self.env = env
        self._validate_azure_credentials()
        self.embeddings = self._init_embeddings()
        self.vector_store = None
        self.collection_name = None
        self.client = None
        self._init_chroma_client()
        logger.info("ChromaVectorStore initialized successfully")

    def _init_chroma_client(self) -> None:
        """Initialize ChromaDB client with telemetry disabled and local settings."""
        try:
            persist_directory = self.env.get("CHROMA_PERSIST_DIR", "./chroma_db")
            os.makedirs(persist_directory, exist_ok=True)
            
            # Configure ChromaDB for local-only operation with telemetry disabled
            self.client = chromadb.Client(Settings(
                anonymized_telemetry=False,
                is_persistent=True,
                persist_directory=persist_directory,
                allow_reset=True
            ))
            
            logger.info("ChromaDB client initialized with telemetry disabled")
            
        except Exception as e:
            logger.error(f"Failed to initialize ChromaDB client: {str(e)}")
            raise

    def create_collection(self, csv_path: Path, text_columns: List[str], 
                        chunk_size: int = 1000, chunk_overlap: int = 100,
                        separator: str = " | ") -> None:
        """Create Chroma collection from CSV with local storage."""
        try:
            logger.info(f"Reading CSV file: {csv_path}")
            df = self._read_csv_safely(csv_path)
            
            # Validate columns
            missing_cols = [col for col in text_columns if col not in df.columns]
            if missing_cols:
                raise ValueError(f"Columns not found in CSV: {', '.join(missing_cols)}")
            
            logger.info(f"Processing columns: {', '.join(text_columns)}")
            documents = self._process_csv_multi_column(
                df, text_columns, chunk_size, chunk_overlap, separator
            )
            
            self.collection_name = csv_path.stem.lower()
            persist_directory = self.env.get("CHROMA_PERSIST_DIR", "./chroma_db")
            
            # Create collection with telemetry disabled
            self.vector_store = Chroma.from_documents(
                documents=documents,
                embedding=self.embeddings,
                collection_name=self.collection_name,
                persist_directory=persist_directory,
                client=self.client  # Use our configured client
            )
            
            logger.info(f"Created collection '{self.collection_name}' with {len(documents)} documents")
            self.vector_store.persist()
            logger.info("Collection persisted to local storage")
            
        except Exception as e:
            logger.error(f"Collection creation failed: {str(e)}")
            raise

    def load_existing_collection(self, collection_name: str) -> None:
        """Load an existing local Chroma collection."""
        try:
            persist_directory = self.env.get("CHROMA_PERSIST_DIR", "./chroma_db")
            if not os.path.exists(persist_directory):
                raise ValueError(f"Persist directory not found: {persist_directory}")
            
            collection_path = Path(persist_directory) / collection_name
            if not collection_path.exists():
                raise ValueError(f"Collection '{collection_name}' not found in {persist_directory}")
            
            self.collection_name = collection_name
            
            # Load collection using our configured client
            self.vector_store = Chroma(
                collection_name=collection_name,
                embedding_function=self.embeddings,
                persist_directory=persist_directory,
                client=self.client  # Use our configured client
            )
            
            collection_count = len(self.vector_store.get()['ids'])
            logger.info(f"Loaded existing collection '{collection_name}' with {collection_count} documents")
            
        except Exception as e:
            logger.error(f"Failed to load collection: {str(e)}")
            raise

    def delete_collection(self, collection_name: str) -> None:
        """Delete a local Chroma collection."""
        try:
            if collection_name in self.client.list_collections():
                self.client.delete_collection(collection_name)
                logger.info(f"Deleted collection '{collection_name}'")
                
                # Reset current store if it was the active collection
                if self.collection_name == collection_name:
                    self.vector_store = None
                    self.collection_name = None
            else:
                raise ValueError(f"Collection '{collection_name}' not found")
                
        except Exception as e:
            logger.error(f"Failed to delete collection: {str(e)}")
            raise

    def list_collections(self) -> List[str]:
        """List all available local collections."""
        try:
            collections = [col.name for col in self.client.list_collections()]
            logger.info(f"Found {len(collections)} local collections: {collections}")
            return collections
            
        except Exception as e:
            logger.error(f"Failed to list collections: {str(e)}")
            raise

    def get_collection_stats(self) -> Dict[str, Any]:
        """Get statistics about the current local collection."""
        try:
            if not self.collection_name or not self.vector_store:
                raise ValueError("No collection loaded")
            
            collection = self.client.get_collection(self.collection_name)
            count = collection.count()
            
            # Get sample document to determine embedding dimension
            if count > 0:
                sample = collection.peek(1)
                embedding_dim = len(sample['embeddings'][0]) if sample['embeddings'] else None
            else:
                embedding_dim = None
            
            stats = {
                "collection_name": self.collection_name,
                "document_count": count,
                "embedding_dimension": embedding_dim,
                "storage_path": self.env.get("CHROMA_PERSIST_DIR", "./chroma_db")
            }
            
            logger.info(f"Collection statistics: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get collection statistics: {str(e)}")
            raise

    def search(self, query: str, k: int = 5, 
              min_relevance_score: float = 0.0) -> List[Tuple[str, float, Dict]]:
        """Perform local similarity search."""
        try:
            if not self.vector_store:
                raise ValueError("No collection loaded")
                
            logger.info(f"Performing local search with query: {query}")
            results = self.vector_store.similarity_search_with_score(query, k=k)
            
            processed_results = []
            for doc, score in results:
                relevance = 1 - score
                if relevance >= min_relevance_score:
                    processed_results.append((doc.page_content, relevance, doc.metadata))
            
            logger.info(f"Found {len(processed_results)} relevant results")
            return processed_results
            
        except Exception as e:
            logger.error(f"Search failed: {str(e)}")
            raise

    def close(self) -> None:
        """Clean up resources and persist data locally."""
        try:
            if self.vector_store:
                self.vector_store.persist()
                logger.info("Vector store persisted to local storage")
            
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")
            raise

# The rest of the implementation (OSEnv class, helper functions, and main()) remains the same
