import os
import time
import logging
import glob
from pathlib import Path
from typing import Optional

from dotenv import dotenv_values
from azure.identity import ClientSecretCredential

# Import the new Azure-specific classes from langchain_openai.
from langchain_openai import AzureChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
# We'll use CSVLoader to load CSV files.
from langchain.document_loaders import CSVLoader

# --------------------- Logging Configuration ---------------------
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --------------------- Utility Functions ---------------------
def is_file_readable(filepath: str) -> bool:
    """Check if a file exists and is readable."""
    if not os.path.isfile(filepath) or not os.access(filepath, os.R_OK):
        raise FileNotFoundError(f"The file '{filepath}' does not exist or is not readable")
    return True

def str_to_bool(s: str) -> bool:
    """Convert a string to a boolean."""
    if s == 'True':
        return True
    elif s == 'False':
        return False
    else:
        raise ValueError(f"Invalid boolean string: {s}")

# --------------------- Environment Setup ---------------------
class OSEnv:
    """Environment variable and certificate management."""
    def __init__(self, config_file: str, creds_file: str, certificate_path: str):
        self.var_list = []  # Track environment variables set via this class
        
        # Load main configuration and credentials
        self.bulk_set(config_file, print_val=True)
        logger.info(f"Loaded main configuration from {config_file}")
        self.bulk_set(creds_file, print_val=False)
        logger.info(f"Loaded credentials from {creds_file}")
        
        # Set up certificates
        self.set_certificate_path(certificate_path)
        logger.info("Certificate path configured")
        
        # Configure proxy if enabled
        if str_to_bool(self.get("PROXY_ENABLED", "False")):
            self.set_proxy()
            logger.info("Proxy configured")
        
        # Acquire Azure token if secure endpoints are enabled
        if str_to_bool(self.get("SECURED_ENDPOINTS", "False")):
            logger.info("Securing endpoints")
            self.token = self.get_azure_token()
        else:
            self.token = None

    def set_certificate_path(self, certificate_path: str) -> None:
        """Set up the certificate path for SSL verification."""
        if not os.path.isabs(certificate_path):
            certificate_path = os.path.abspath(certificate_path)
        if not is_file_readable(certificate_path):
            raise Exception("Certificate file missing or not readable")
        self.set("REQUESTS_CA_BUNDLE", certificate_path)
        self.set("SSL_CERT_FILE", certificate_path)
        self.set("CURL_CA_BUNDLE", certificate_path)
        logger.info(f"Certificate path set to: {certificate_path}")

    def bulk_set(self, dotenvfile: str, print_val: bool = False) -> None:
        """Load and set environment variables from a dotenv file."""
        if not os.path.isabs(dotenvfile):
            dotenvfile = os.path.abspath(dotenvfile)
        if is_file_readable(dotenvfile):
            logger.info(f"Loading environment variables from {dotenvfile}")
            temp_dict = dotenv_values(dotenvfile)
            for k, v in temp_dict.items():
                self.set(k, v, print_val)
        else:
            raise FileNotFoundError(f"{dotenvfile} not found.")

    def set(self, var_name: str, val: str, print_val: bool = True) -> None:
        """Set an individual environment variable."""
        os.environ[var_name] = val
        if var_name not in self.var_list:
            self.var_list.append(var_name)
        if print_val:
            logger.info(f"Set {var_name}={val}")

    def get(self, var_name: str, default: Optional[str] = None) -> Optional[str]:
        """Retrieve an environment variable value."""
        return os.environ.get(var_name, default)

    def set_proxy(self) -> None:
        """Configure proxy settings."""
        ad_username = self.get("AD_USERNAME")
        ad_password = self.get("AD_USER_PW")
        proxy_domain = self.get("HTTPS_PROXY_DOMAIN")
        if not all([ad_username, ad_password, proxy_domain]):
            raise ValueError("Missing proxy credentials")
        proxy_url = f"http://{ad_username}:{ad_password}@{proxy_domain}"
        self.set("HTTP_PROXY", proxy_url, print_val=False)
        self.set("HTTPS_PROXY", proxy_url, print_val=False)
        no_proxy_domains = [
            'cognitiveservices.azure.com',
            'search.windows.net',
            'openai.azure.com',
            'core.windows.net',
            'azurewebsites.net'
        ]
        self.set("NO_PROXY", ",".join(no_proxy_domains))
        logger.info("Proxy configuration completed")

    def get_azure_token(self) -> str:
        """Acquire an Azure authentication token."""
        try:
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET")
            )
            token = credential.get_token("https://cognitiveservices.azure.com/.default")
            self.set("AZURE_TOKEN", token.token, print_val=False)
            logger.info("Azure token acquired successfully")
            return token.token
        except Exception as e:
            logger.error(f"Failed to get Azure token: {str(e)}")
            raise

    def list_env_vars(self) -> None:
        """Print all environment variables set by this class."""
        for var in self.var_list:
            if var in {'AZURE_TOKEN', 'AD_USER_PW', 'AZURE_CLIENT_SECRET'}:
                logger.info(f"{var}: [HIDDEN]")
            else:
                logger.info(f"{var}: {self.get(var)}")

# --------------------- Agent-Based Chatbot with CSV Knowledge ---------------------
class AzureChatbot:
    """
    An agent-based chatbot that uses an Azure OpenAI chat model.
    Additionally, it loads CSV file(s) from a knowledge folder, concatenates their contents,
    and injects that content as a system message to inform the agent.
    """
    def __init__(self, config_file: str, creds_file: str, cert_file: str, knowledge_dir: Optional[str] = None):
        logger.info("Initializing agent-based chatbot...")
        self.env = OSEnv(config_file, creds_file, cert_file)
        self.knowledge_dir = knowledge_dir
        self.knowledge_context = ""
        if self.knowledge_dir:
            self.knowledge_context = self.load_csv_context(self.knowledge_dir)
        self._setup_chat_model()

    def load_csv_context(self, directory: str) -> str:
        """
        Load all CSV files from the given directory and combine their content into a single context string.
        """
        try:
            # Use glob to find all CSV files recursively
            csv_files = glob.glob(os.path.join(directory, "**/*.csv"), recursive=True)
            if not csv_files:
                logger.info("No CSV files found in the knowledge directory.")
                return ""
            all_text = []
            for csv_file in csv_files:
                logger.info(f"Loading CSV file: {csv_file}")
                loader = CSVLoader(file_path=csv_file)
                docs = loader.load()
                # Each document's page_content holds the CSV content (or a string representation thereof)
                all_text.extend([doc.page_content for doc in docs])
            combined_text = "\n\n".join(all_text)
            logger.info(f"Combined CSV context length: {len(combined_text)} characters")
            return combined_text
        except Exception as e:
            logger.error(f"Error loading CSV knowledge: {str(e)}")
            return ""

    def _setup_chat_model(self) -> None:
        """Set up the Azure chat model and conversation chain; include CSV knowledge context if available."""
        try:
            self.llm = AzureChatOpenAI(
                model_name=self.env.get("MODEL_NAME", "gpt-4"),
                deployment_name=self.env.get("CHAT_MODEL_DEPLOYMENT", self.env.get("MODEL_NAME", "gpt-4")),
                temperature=float(self.env.get("MODEL_TEMPERATURE", "0.7")),
                max_tokens=int(self.env.get("MAX_TOKENS", "800")),
                openai_api_version=self.env.get("API_VERSION", "2024-02-01"),
                azure_endpoint=self.env.get("AZURE_OPENAI_ENDPOINT"),
                azure_ad_token=self.env.token
            )
            self.memory = ConversationBufferMemory()
            self.conversation = ConversationChain(
                llm=self.llm,
                memory=self.memory,
                verbose=True
            )
            # If CSV knowledge is available, inject it as a system message for context.
            if self.knowledge_context:
                system_prompt = (
                    "The following CSV data has been loaded from the knowledge base. "
                    "Use this background information to help answer any related questions.\n\n"
                    f"{self.knowledge_context}"
                )
                # Insert the system message at the beginning of the conversation memory.
                self.memory.chat_memory.messages.insert(0, SystemMessage(content=system_prompt))
                logger.info("CSV knowledge context injected as a system message.")
            logger.info("Chat model initialized successfully.")
        except Exception as e:
            logger.error(f"Failed to initialize chat model: {str(e)}")
            raise

    def chat(self, message: str) -> str:
        """Process a user message and return the chatbot's response."""
        if not message.strip():
            return "Please provide a non-empty message."
        try:
            response = self.conversation.predict(input=message)
            return response
        except Exception as e:
            logger.error(f"Error during chat: {str(e)}")
            return f"An error occurred: {str(e)}"

# --------------------- Main Function ---------------------
def main():
    """Main function to run the agent-based chatbot with CSV knowledge context."""
    try:
        base_dir = os.path.dirname(os.path.abspath(__file__))
        env_dir = os.path.join(base_dir, '..', 'env')
        config_path = os.path.join(env_dir, 'config.env')
        creds_path = os.path.join(env_dir, 'credentials.env')
        cert_path = os.path.join(env_dir, 'cacert.pem')
        # Set the knowledge directory to where your CSV file is located.
        knowledge_dir = os.path.join(base_dir, '..', 'knowledge')
        
        print("\nInitializing agent-based chatbot with CSV knowledge...")
        chatbot = AzureChatbot(
            config_file=config_path,
            creds_file=creds_path,
            cert_file=cert_path,
            knowledge_dir=knowledge_dir
        )
        print("\nChatbot initialized successfully!")
        print("\nType your message to begin chatting (type 'quit', 'exit', or 'bye' to stop):")
        print("-" * 50)
        
        while True:
            user_input = input("\nYou: ").strip()
            if user_input.lower() in ['quit', 'exit', 'bye']:
                print("Goodbye!")
                break
            if user_input.lower() == 'env':
                chatbot.env.list_env_vars()
                continue
            response = chatbot.chat(user_input)
            print(f"\nBot: {response}")
            
    except FileNotFoundError as e:
        print(f"\nFile Error: {str(e)}")
        print("Please check your configuration files and certificate path.")
    except ValueError as e:
        print(f"\nConfiguration Error: {str(e)}")
        print("Please check your environment variables and settings.")
    except Exception as e:
        print(f"\nUnexpected Error: {str(e)}")
        logger.exception("Unexpected error occurred")

if __name__ == "__main__":
    main()
