import os
import pandas as pd
import openai
import chromadb
from chromadb.config import Settings
from dotenv import load_dotenv
import logging

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("chatbot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Set OpenAI API credentials
openai.api_type = "azure"
openai.api_base = os.getenv("AZURE_OPENAI_ENDPOINT")
openai.api_key = os.getenv("AZURE_OPENAI_API_KEY")
openai.api_version = "2024-02-01"  # Ensure this matches your deployment

# Initialize ChromaDB client
client = chromadb.Client(Settings(
    chroma_db_impl="duckdb+parquet",
    persist_directory="chroma_db"  # Directory to persist the database
))

# Create or get a collection
collection = client.get_or_create_collection(name="definitions")

def load_and_store_embeddings(csv_path):
    """Load CSV data, generate embeddings, and store them in ChromaDB."""
    try:
        df = pd.read_csv(csv_path)
        if 'name' not in df.columns or 'definition' not in df.columns:
            raise ValueError("CSV must contain 'name' and 'definition' columns.")
        
        for idx, row in df.iterrows():
            name = row['name']
            definition = row['definition']
            response = openai.Embedding.create(
                input=definition,
                engine="text-embedding-3-large"  # Ensure this matches your deployment
            )
            embedding = response['data'][0]['embedding']
            collection.add(
                documents=[definition],
                metadatas=[{"name": name}],
                ids=[f"id_{idx}"],
                embeddings=[embedding]
            )
        logger.info("‚úÖ Embeddings successfully stored in ChromaDB.")
    except Exception as e:
        logger.error(f"‚ùå Error in load_and_store_embeddings: {e}")

def query_chatbot(user_query):
    """Generate embedding for user query and retrieve the most relevant name."""
    try:
        response = openai.Embedding.create(
            input=user_query,
            engine="text-embedding-3-large"
        )
        query_embedding = response['data'][0]['embedding']

        results = collection.query(
            query_embeddings=[query_embedding],
            n_results=1,  # Retrieve the most relevant name
            include=["metadatas"]
        )

        if results['metadatas']:
            most_relevant = results['metadatas'][0]
            return f"The most relevant name for your query is: {most_relevant['name']}"
        else:
            return "No relevant name found for your query."
    except Exception as e:
        logger.error(f"‚ùå Error in query_chatbot: {e}")
        return "An error occurred while processing your request."

def main():
    """Main function to initialize and run the chatbot."""
    try:
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        knowledge_dir = os.path.join(base_dir, "knowledge")
        csv_path = os.path.join(knowledge_dir, "your_data.csv")  # Update with your CSV filename

        # Print the knowledge folder path
        print(f"üìÇ Knowledge Folder Path: {knowledge_dir}")
        logger.info(f"üìÇ Knowledge Folder Path: {knowledge_dir}")

        # Load CSV data and store embeddings
        load_and_store_embeddings(csv_path)

        print("\nüöÄ Chatbot initialized! You can now ask questions based on the CSV data.")
        print("Type 'quit' to exit.\n")

        while True:
            user_input = input("You: ").strip()
            if user_input.lower() in ['quit', 'exit', 'bye']:
                print("Goodbye!")
                break

            response = query_chatbot(user_input)
            print(f"\nBot: {response}\n")

    except Exception as e:
        logger.error(f"‚ùå Unexpected error in main function: {e}")
        print("‚ùå A critical error occurred. Check logs for details.")

if __name__ == "__main__":
    main()
