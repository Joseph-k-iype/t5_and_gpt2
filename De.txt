"""
HSBC Token Translation Service
Handles authentication and token management for HSBC internal APIs
Uses error-driven refresh instead of time-based expiry
"""
import logging
import requests
from typing import Optional
from threading import Lock

logger = logging.getLogger(__name__)


class HSBCTokenManager:
    """Manages HSBC token translation with error-driven refresh."""
    
    def __init__(
        self,
        token_api_url: str,
        username: str,
        password: str,
        max_retry_attempts: int = 3
    ):
        """
        Initialize HSBC Token Manager
        
        Args:
            token_api_url: HSBC token translation API endpoint
            username: HSBC username
            password: HSBC password
            max_retry_attempts: Maximum number of token refresh attempts
        """
        self.token_api_url = token_api_url
        self.username = username
        self.password = password
        self.max_retry_attempts = max_retry_attempts
        
        self._issued_token: Optional[str] = None
        self._refresh_lock = Lock()  # Prevent concurrent refresh attempts
        self._refresh_in_progress = False
        
        logger.info(f"Initialized HSBC Token Manager for user: {username}")
        logger.info("Using error-driven token refresh (no time limits)")
    
    def get_token(self, force_refresh: bool = False) -> str:
        """
        Get issued token, refreshing if needed.
        
        Args:
            force_refresh: Force token refresh regardless of current state
            
        Returns:
            Valid issued token
            
        Raises:
            Exception: If token translation fails
        """
        # Force refresh or first-time fetch
        if force_refresh or not self._issued_token:
            self._refresh_token()
        
        return self._issued_token
    
    def handle_auth_error(self, error_response=None) -> str:
        """
        Handle authentication error by refreshing token.
        Call this when you receive 401/403 or authentication errors.
        
        Args:
            error_response: Optional error response for logging
            
        Returns:
            New token after refresh
            
        Raises:
            Exception: If token refresh fails
        """
        logger.warning("Authentication error detected - refreshing token...")
        if error_response:
            logger.debug(f"Error details: {error_response}")
        
        # Prevent multiple simultaneous refresh attempts
        with self._refresh_lock:
            if self._refresh_in_progress:
                logger.info("Token refresh already in progress, waiting...")
                return self._issued_token
            
            self._refresh_in_progress = True
            try:
                self._refresh_token()
                return self._issued_token
            finally:
                self._refresh_in_progress = False
    
    def _refresh_token(self) -> None:
        """Fetch new token from HSBC API."""
        attempt = 0
        last_error = None
        
        while attempt < self.max_retry_attempts:
            try:
                attempt += 1
                logger.info(f"Requesting new token from HSBC API (attempt {attempt}/{self.max_retry_attempts})...")
                
                payload = {
                    "input_token_state": {
                        "token_type": "CREDENTIAL",
                        "username": self.username,
                        "password": self.password
                    },
                    "output_token_state": {
                        "token_type": "JWT"
                    }
                }
                
                response = requests.post(
                    self.token_api_url,
                    json=payload,
                    verify=False,  # May need to adjust based on HSBC's cert setup
                    timeout=30
                )
                
                response.raise_for_status()
                
                data = response.json()
                self._issued_token = data.get("issued_token")
                
                if not self._issued_token:
                    raise ValueError("No issued_token in response")
                
                logger.info(f"âœ“ Token obtained successfully")
                logger.info(f"  Token preview: {self._issued_token[:20]}...")
                logger.info("  Token will be auto-refreshed on authentication errors")
                
                return  # Success!
                
            except requests.exceptions.HTTPError as e:
                last_error = e
                logger.error(f"HTTP error getting token (attempt {attempt}): {e}")
                if e.response.status_code in [401, 403]:
                    logger.error("Credentials may be invalid")
                    
            except requests.exceptions.RequestException as e:
                last_error = e
                logger.error(f"Network error getting token (attempt {attempt}): {e}")
                
            except Exception as e:
                last_error = e
                logger.error(f"Error processing token response (attempt {attempt}): {e}")
            
            # Don't retry on last attempt
            if attempt < self.max_retry_attempts:
                import time
                wait_time = attempt * 2  # Exponential backoff
                logger.info(f"Retrying in {wait_time} seconds...")
                time.sleep(wait_time)
        
        # All attempts failed
        logger.error(f"Failed to get token after {self.max_retry_attempts} attempts")
        raise Exception(f"Token refresh failed: {last_error}")
    
    def invalidate_token(self) -> None:
        """Manually invalidate cached token to force refresh on next request."""
        logger.info("Token invalidated manually - will refresh on next request")
        self._issued_token = None
    
    def is_token_available(self) -> bool:
        """Check if token is currently available (doesn't validate it)."""
        return self._issued_token is not None
