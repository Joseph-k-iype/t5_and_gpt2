"""
Enhanced Legal Summary Generator - Professional Legal Format
UPDATED: Generates machine-readable table output, preserves exact terminology
Generates documents suitable for legal review without technical jargon
Location: src/generators/legal_summary_generator_enhanced.py
"""

from typing import Dict, List, Any, Optional
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.style import WD_STYLE_TYPE
from datetime import datetime
import os
import re
import json
import csv


class LegalSummaryGenerator:
    """Generates Word documents and machine-readable tables in professional legal format"""
    
    def __init__(self, output_dir: str = "output/legal_summaries"):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Create machine-readable subdirectory
        self.machine_readable_dir = os.path.join(output_dir, "machine_readable")
        os.makedirs(self.machine_readable_dir, exist_ok=True)
    
    def _ensure_proper_sentence(self, text: str) -> str:
        """Ensure text is a proper sentence"""
        if not text or len(text) < 3:
            return text
        
        text = text.strip()
        
        if text and text[0].islower():
            text = text[0].upper() + text[1:]
        
        if text and text[-1] not in '.!?':
            text += '.'
        
        return text
    
    def _format_as_paragraph(self, text: str) -> str:
        """Format text as grammatically correct paragraph"""
        if not text:
            return ""
        
        sentences = re.split(r'(?<=[.!?])\s+', text)
        
        clean_sentences = []
        for sentence in sentences:
            sentence = sentence.strip()
            if sentence:
                sentence = self._ensure_proper_sentence(sentence)
                clean_sentences.append(sentence)
        
        return " ".join(clean_sentences)
    
    def create_document(self, analysis: Dict[str, Any]) -> Document:
        """Create formatted Word document"""
        doc = Document()
        self._setup_styles(doc)
        
        self._add_title(doc, analysis)
        self._add_metadata(doc, analysis)
        self._add_classification(doc, analysis)
        self._add_terminology_section(doc, analysis)
        self._add_description(doc, analysis)
        self._add_analysis_approach(doc, analysis)
        self._add_citations_section(doc, analysis)
        self._add_data_actions_section(doc, analysis)
        self._add_evidence_section(doc, analysis)
        self._add_constraints_section(doc, analysis)
        self._add_enterprise_policies_section(doc, analysis)
        self._add_machine_readable_reference(doc, analysis)
        self._add_duplicate_warnings(doc, analysis)
        self._add_footer(doc, analysis)
        
        return doc
    
    def _setup_styles(self, doc: Document):
        """Setup document styles"""
        styles = doc.styles
        
        if 'CustomTitle' not in styles:
            title_style = styles.add_style('CustomTitle', WD_STYLE_TYPE.PARAGRAPH)
            title_style.font.name = 'Calibri'
            title_style.font.size = Pt(24)
            title_style.font.bold = True
            title_style.font.color.rgb = RGBColor(0, 51, 102)
        
        for level, size, color in [
            (1, 16, RGBColor(0, 51, 102)),
            (2, 14, RGBColor(0, 102, 204)),
            (3, 12, RGBColor(0, 102, 204))
        ]:
            heading = styles[f'Heading {level}']
            heading.font.name = 'Calibri'
            heading.font.size = Pt(size)
            heading.font.color.rgb = color
        
        normal = styles['Normal']
        normal.font.name = 'Calibri'
        normal.font.size = Pt(11)
    
    def _add_title(self, doc: Document, analysis: Dict[str, Any]):
        """Add title"""
        metadata = analysis.get("metadata", {})
        rule_name = metadata.get("rule_name", "Legal Rule Analysis")
        
        title = doc.add_paragraph(rule_name, style='CustomTitle')
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        jurisdiction = metadata.get("jurisdiction", "General")
        subtitle = doc.add_paragraph(f"Jurisdiction: {jurisdiction}")
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle.runs[0].font.size = Pt(12)
        subtitle.runs[0].font.italic = True
        subtitle.runs[0].font.color.rgb = RGBColor(80, 80, 80)
        
        doc.add_paragraph()
    
    def _add_metadata(self, doc: Document, analysis: Dict[str, Any]):
        """Add metadata table"""
        metadata = analysis.get("metadata", {})
        
        table = doc.add_table(rows=0, cols=2)
        table.style = 'Light Grid Accent 1'
        
        def add_row(label: str, value: str):
            row = table.add_row()
            row.cells[0].text = label
            row.cells[1].text = value
            row.cells[0].paragraphs[0].runs[0].font.bold = True
        
        add_row("Rule Name", metadata.get("rule_name", "N/A"))
        add_row("Jurisdiction", metadata.get("jurisdiction", "N/A"))
        add_row("Analysis Date", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        
        total_chunks = (metadata.get("level_1_chunks", 0) +
                       metadata.get("level_2_chunks", 0) +
                       metadata.get("level_3_chunks", 0))
        add_row("Document Sections Analyzed", str(total_chunks))
        
        add_row("Total Source Citations", str(metadata.get("total_citations", 0)))
        add_row("Total Data Operations Identified", str(metadata.get("total_actions", 0)))
        add_row("Machine-Readable Rules Generated", str(metadata.get("total_machine_readable_rules", 0)))
        
        # Add duplicate warning if any
        total_dupes = metadata.get("total_potential_duplicates", 0)
        if total_dupes > 0:
            add_row("âš  Potential Duplicates Detected", str(total_dupes))
        
        enterprise_context = metadata.get("enterprise_context", {})
        if enterprise_context:
            if enterprise_context.get("organization"):
                add_row("Organization", enterprise_context["organization"])
            if enterprise_context.get("internal_tools"):
                tools = enterprise_context["internal_tools"]
                tools_str = ", ".join(tools)
                add_row("Internal Systems Referenced", tools_str)
                
                if "DataVisa" in tools:
                    add_row("DataVisa", "Internal Data Governance System")
        
        doc.add_paragraph()
    
    def _add_classification(self, doc: Document, analysis: Dict[str, Any]):
        """Add classification section"""
        doc.add_heading("Rule Classification", level=1)
        
        classification = analysis.get("classification", "permission")
        
        para = doc.add_paragraph()
        para.add_run("Classification: ").bold = True
        
        class_run = para.add_run(classification.upper())
        class_run.bold = True
        class_run.font.size = Pt(14)
        
        if classification == "permission":
            class_run.font.color.rgb = RGBColor(0, 128, 0)
            explanation = doc.add_paragraph()
            explanation.add_run("This rule describes actions that are permitted subject to specific conditions being met. ")
            explanation.add_run("Legal compliance requires satisfying all stated conditions before undertaking the specified actions.")
        else:
            class_run.font.color.rgb = RGBColor(178, 34, 34)
            explanation = doc.add_paragraph()
            explanation.add_run("This rule describes actions that are prohibited or heavily restricted. ")
            explanation.add_run("Legal compliance requires refraining from these actions or obtaining explicit authorization where permitted.")
        
        reasoning = analysis.get("classification_reasoning", "")
        if reasoning:
            doc.add_paragraph()
            reasoning_formatted = self._format_as_paragraph(reasoning)
            para = doc.add_paragraph()
            para.add_run("Basis for Classification: ").bold = True
            para.add_run(reasoning_formatted).italic = True
        
        doc.add_paragraph()
    
    def _add_terminology_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add section showing preserved original terminology"""
        original_terms = analysis.get("original_terminology", [])
        
        if not original_terms or len(original_terms) == 0:
            return
        
        doc.add_heading("Key Terminology from Source Documents", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("The following key terms were preserved exactly as they appear in the source documents. ")
        intro.add_run("This analysis maintains the precise legal terminology without paraphrasing or substitution.")
        intro.italic = True
        intro.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
        
        # Display unique terms
        unique_terms = sorted(set(original_terms))
        
        for term in unique_terms:
            para = doc.add_paragraph(style='List Bullet')
            para.add_run(f'"{term}"')
            para.runs[0].font.color.rgb = RGBColor(0, 51, 102)
        
        doc.add_paragraph()
    
    def _add_description(self, doc: Document, analysis: Dict[str, Any]):
        """Add description with proper grammar"""
        doc.add_heading("Summary of Legal Requirements", level=1)
        
        description = analysis.get("description", "")
        
        if not description:
            doc.add_paragraph("No substantive requirements were extracted from the source documents.")
            doc.add_paragraph()
            return
        
        description_formatted = self._format_as_paragraph(description)
        
        sentences = re.split(r'(?<=[.!?])\s+', description_formatted)
        
        current_para = []
        for i, sentence in enumerate(sentences):
            current_para.append(sentence)
            
            if (i + 1) % 3 == 0 or i == len(sentences) - 1:
                para_text = " ".join(current_para)
                doc.add_paragraph(para_text, style='Normal')
                current_para = []
        
        doc.add_paragraph()
    
    def _add_analysis_approach(self, doc: Document, analysis: Dict[str, Any]):
        """Add analysis methodology section - NO TECHNICAL JARGON"""
        doc.add_heading("Analysis Methodology", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("This analysis was conducted through a systematic multi-stage review process ")
        intro.add_run("designed to ensure comprehensive extraction and accurate interpretation of legal requirements. ")
        intro.add_run("The analysis incorporated the following approaches:")
        intro.bold = True
        
        doc.add_paragraph()
        
        approaches = [
            ("Terminology Preservation", 
             "All key legal terms were preserved exactly as they appear in the source documents. "
             "No paraphrasing or substitution of legal terminology was performed, ensuring that "
             "the analysis reflects the precise language used by the legislators or policy authors."),
            
            ("Systematic Reasoning", 
             "The source text was analyzed through step-by-step logical reasoning, "
             "explicitly articulating each inference to ensure that every conclusion "
             "can be traced back to specific source language."),
            
            ("Multi-Perspective Review",
             "Multiple specialized analytical perspectives were applied to the text, "
             "including legal interpretation, data privacy considerations, technical implementation requirements, "
             "and practical compliance assessment. This comprehensive approach ensures that "
             "all relevant dimensions of the requirements are identified and considered."),
            
            ("Alternative Interpretation Analysis",
             "Different possible interpretations of the requirements were systematically explored, "
             "considering conservative, balanced, and expansive readings. The most legally sound "
             "interpretation was selected based on established principles of legal construction "
             "and practical application."),
            
            ("Duplicate Detection",
             "All extracted requirements were analyzed for potential duplicates using semantic similarity "
             "analysis to ensure that redundant rules are identified and flagged for review."),
            
            ("Machine-Readable Output Generation",
             "Structured, machine-readable representations of all rules were generated to facilitate "
             "automated compliance checking, policy enforcement, and integration with technical systems."),
            
            ("Relationship Mapping",
             "All extracted requirements, actions, and constraints were analyzed for their interrelationships, "
             "enabling identification of dependencies, potential conflicts, and implementation considerations "
             "that may not be apparent from isolated review of individual provisions."),
            
            ("Source Verification",
             "Every substantive finding was verified against the source documents with specific citations "
             "to the originating text, ensuring traceability and enabling independent verification "
             "of the analysis.")
        ]
        
        for approach_name, description in approaches:
            para = doc.add_paragraph(style='List Bullet')
            para.add_run(f"{approach_name}: ").bold = True
            para.add_run(self._format_as_paragraph(description))
        
        doc.add_paragraph()
    
    def _add_citations_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add citations with source references"""
        doc.add_heading("Source Citations and References", level=1)
        
        citations = analysis.get("citations", [])
        
        if not citations:
            doc.add_paragraph("No specific citations were extracted from the source documents.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run(f"This analysis is supported by {len(citations)} citations ")
        intro.add_run("extracted from the source documents. ")
        intro.add_run("Each citation provides the exact text from the source document and explains ")
        intro.add_run("its relevance to the analysis.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by level
        by_level = {1: [], 2: [], 3: []}
        for cite in citations:
            level = cite.get("level", 1)
            by_level[level].append(cite)
        
        level_names = {
            1: "Primary Legislation",
            2: "Regulatory Guidance and Interpretation",
            3: "Enterprise-Specific Policies and Implementation"
        }
        
        for level in [1, 2, 3]:
            level_cites = by_level[level]
            if not level_cites:
                continue
            
            doc.add_heading(f"Level {level}: {level_names[level]}", level=2)
            
            for i, cite in enumerate(level_cites, 1):
                para = doc.add_paragraph()
                
                # Citation number
                para.add_run(f"[{i}] ").bold = True
                
                # Source reference
                source_ref = cite.get("source_reference", f"Level {level}")
                para.add_run(f"{source_ref}")
                para.runs[-1].italic = True
                para.runs[-1].font.color.rgb = RGBColor(0, 102, 204)
                para.add_run("\n")
                
                # Text excerpt
                text = cite.get("text", "")[:400]
                if len(cite.get("text", "")) > 400:
                    text += "..."
                para.add_run(f'"{text}"')
                
                # Reasoning
                reasoning = cite.get("reasoning", "")
                if reasoning:
                    reasoning_formatted = self._format_as_paragraph(reasoning)
                    sub_para = doc.add_paragraph(style='List Bullet 2')
                    sub_para.add_run("Relevance: ").italic = True
                    sub_para.add_run(reasoning_formatted)
                    sub_para.runs[-1].font.size = Pt(10)
        
        doc.add_paragraph()
    
    def _add_data_actions_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add data actions with proper sentences - UPDATED TAXONOMY"""
        doc.add_heading("Data Operations Governed by This Rule", level=1)
        
        data_actions = analysis.get("data_actions", [])
        
        if not data_actions:
            doc.add_paragraph("No specific data operations were identified as being governed by this rule.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("The following data operations are regulated by this rule. ")
        intro.add_run("Each operation describes a specific activity that must be controlled, ")
        intro.add_run("managed, or executed in accordance with the stated requirements.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by type using new taxonomy
        by_type = {
            "sharing": [],
            "hosting": [],
            "usage": [],
            "processing": [],
            "deletion": [],
            "collection": [],
            "access": []
        }
        
        for action in data_actions:
            action_type = action.get("type", "usage")
            if action_type in by_type:
                by_type[action_type].append(action)
            else:
                by_type["usage"].append(action)
        
        categories = {
            "sharing": ("Data Sharing Operations", "ðŸ¤", "These operations involve transferring data to third parties or sharing data across organizational boundaries."),
            "hosting": ("Data Storage and Hosting Operations", "ðŸ’¾", "These operations involve storing data on infrastructure, hosting data in repositories, or maintaining data retention."),
            "usage": ("Data Usage Operations", "âš™ï¸", "These operations involve using data for specified purposes or applying data in business processes."),
            "processing": ("Data Processing Operations", "ðŸ”„", "These operations involve transforming, analyzing, or deriving insights from data."),
            "deletion": ("Data Deletion Operations", "ðŸ—‘ï¸", "These operations involve removing, destroying, or disposing of data."),
            "collection": ("Data Collection Operations", "ðŸ“¥", "These operations involve gathering data from sources or acquiring new data."),
            "access": ("Data Access Operations", "ðŸ”“", "These operations involve viewing, retrieving, or obtaining access to data.")
        }
        
        for action_type, (category_name, emoji, description) in categories.items():
            actions = by_type[action_type]
            if not actions:
                continue
            
            doc.add_heading(f"{emoji} {category_name}", level=2)
            
            category_intro = doc.add_paragraph()
            category_intro.add_run(description)
            category_intro.italic = True
            category_intro.runs[0].font.size = Pt(10)
            
            doc.add_paragraph()
            
            for i, action in enumerate(actions, 1):
                desc = action.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                # Actor
                actor = action.get("actor", "")
                if actor:
                    actor_para = doc.add_paragraph(style='List Bullet 2')
                    if actor == "user":
                        actor_para.add_run("Implementation Responsibility: Individual users must perform or control this action.")
                    else:
                        actor_para.add_run("Implementation Responsibility: This action must be implemented through technical systems or controls.")
                    actor_para.runs[0].font.size = Pt(10)
                    actor_para.runs[0].font.italic = True
                
                # Citations
                citations = action.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Source Reference: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:150]
                    source_ref = citations[0].get("source_reference", "Source document")
                    cite_para.add_run(f'{source_ref} - "{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        
        doc.add_paragraph()
    
    def _add_evidence_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add evidence with proper sentences"""
        doc.add_heading("Compliance Requirements and Duties", level=1)
        
        user_evidence = analysis.get("user_evidence", [])
        system_evidence = analysis.get("system_evidence", [])
        
        if not user_evidence and not system_evidence:
            doc.add_paragraph("No specific compliance requirements were identified.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("This section describes compliance requirements from two perspectives: ")
        intro.add_run("duties and obligations that apply to individual users or personnel, ")
        intro.add_run("and duties or technical controls that must be implemented by systems.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # User perspective
        doc.add_heading("ðŸ‘¤ User Duties and Responsibilities", level=2)
        
        user_intro = doc.add_paragraph()
        user_intro.add_run("The following duties apply to individual users, personnel, or human actors. ")
        user_intro.add_run("These describe actions that individuals must take, permissions they must obtain, ")
        user_intro.add_run("procedures they must follow, or restrictions they must observe.")
        user_intro.italic = True
        user_intro.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
        
        if user_evidence:
            for i, evidence in enumerate(user_evidence, 1):
                desc = evidence.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                citations = evidence.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Source Reference: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:200]
                    source_ref = citations[0].get("source_reference", "Source document")
                    cite_para.add_run(f'{source_ref} - "{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        else:
            doc.add_paragraph("No user-specific duties were identified in this analysis.")
        
        doc.add_paragraph()
        
        # System perspective
        doc.add_heading("ðŸ–¥ï¸ System Duties and Requirements", level=2)
        
        system_intro = doc.add_paragraph()
        system_intro.add_run("The following duties apply to technical systems, infrastructure, and automated controls. ")
        system_intro.add_run("These describe technical capabilities that must be implemented, ")
        system_intro.add_run("system configurations that must be maintained, ")
        system_intro.add_run("or automated processes that must be established.")
        system_intro.italic = True
        system_intro.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
        
        if system_evidence:
            for i, evidence in enumerate(system_evidence, 1):
                desc = evidence.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                citations = evidence.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Source Reference: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:200]
                    source_ref = citations[0].get("source_reference", "Source document")
                    cite_para.add_run(f'{source_ref} - "{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        else:
            doc.add_paragraph("No system-specific duties were identified in this analysis.")
        
        doc.add_paragraph()
    
    def _add_constraints_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add constraints with proper sentences"""
        doc.add_heading("Constraints and Conditions", level=1)
        
        constraints = analysis.get("constraints", [])
        
        if not constraints:
            doc.add_paragraph("No specific constraints or conditions were identified.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("The following constraints and conditions apply to this rule. ")
        intro.add_run("These define the scope, boundaries, and specific conditions ")
        intro.add_run("under which the requirements operate.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by type
        by_type = {}
        for constraint in constraints:
            ctype = constraint.get("type", "general")
            if ctype not in by_type:
                by_type[ctype] = []
            by_type[ctype].append(constraint)
        
        type_info = {
            "temporal": ("â°", "Temporal Constraints", "These constraints relate to time periods, deadlines, durations, or temporal sequencing."),
            "spatial": ("ðŸŒ", "Geographic and Jurisdictional Constraints", "These constraints relate to geographic locations, territorial scope, or jurisdictional boundaries."),
            "technical": ("ðŸ”§", "Technical Constraints", "These constraints relate to technical specifications, system requirements, or technological capabilities."),
            "procedural": ("ðŸ“‹", "Procedural Constraints", "These constraints relate to processes, procedures, or methodological requirements that must be followed."),
            "purpose": ("ðŸŽ¯", "Purpose Limitations", "These constraints relate to the permitted purposes for which actions may be undertaken."),
            "general": ("ðŸ“Œ", "General Constraints", "These are general constraints and conditions that apply to the rule.")
        }
        
        for ctype, constraints_list in by_type.items():
            emoji, title, description = type_info.get(ctype, ("ðŸ“Œ", ctype.title() + " Constraints", ""))
            
            doc.add_heading(f"{emoji} {title}", level=2)
            
            if description:
                type_intro = doc.add_paragraph(description)
                type_intro.italic = True
                type_intro.runs[0].font.size = Pt(10)
                doc.add_paragraph()
            
            for i, constraint in enumerate(constraints_list, 1):
                desc = constraint.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                # Citations
                citations = constraint.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Source Reference: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:150]
                    source_ref = citations[0].get("source_reference", "Source document")
                    cite_para.add_run(f'{source_ref} - "{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        
        doc.add_paragraph()
    
    def _add_enterprise_policies_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add enterprise policies"""
        enterprise_policies = analysis.get("enterprise_policies", [])
        metadata = analysis.get("metadata", {})
        enterprise_context = metadata.get("enterprise_context", {})
        
        if not enterprise_context and not enterprise_policies:
            return
        
        doc.add_heading("ðŸ¢ Organization-Specific Implementation", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("The following information represents organization-specific implementation ")
        intro.add_run("of the legal requirements described above. ")
        intro.add_run("These policies demonstrate how the organization has operationalized ")
        intro.add_run("the legal obligations into concrete procedures, systems, and controls.")
        intro.italic = True
        
        doc.add_paragraph()
        
        if enterprise_context:
            if enterprise_context.get("organization"):
                para = doc.add_paragraph()
                para.add_run("Organization: ").bold = True
                para.add_run(enterprise_context["organization"])
            
            if enterprise_context.get("internal_tools"):
                tools = enterprise_context["internal_tools"]
                para = doc.add_paragraph()
                para.add_run("Internal Systems Referenced: ").bold = True
                para.add_run(", ".join(tools))
                
                if "DataVisa" in tools:
                    datavisa_para = doc.add_paragraph(style='List Bullet 2')
                    datavisa_para.add_run("DataVisa is the organization's internal data governance system, ")
                    datavisa_para.add_run("used for managing data handling requests, approvals, and compliance tracking.")
                    datavisa_para.runs[0].font.size = Pt(10)
                    datavisa_para.runs[0].font.italic = True
            
            if enterprise_context.get("business_units"):
                para = doc.add_paragraph()
                para.add_run("Affected Business Units: ").bold = True
                para.add_run(", ".join(enterprise_context["business_units"]))
            
            doc.add_paragraph()
        
        if enterprise_policies:
            doc.add_heading("Specific Organizational Policies", level=2)
            
            for i, policy in enumerate(enterprise_policies, 1):
                policy_name = policy.get("policy_name", "")
                desc = policy.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. {policy_name}: ").bold = True
                para.add_run(desc_formatted)
                
                applies_to = policy.get("applies_to", [])
                if applies_to:
                    applies_para = doc.add_paragraph(style='List Bullet 2')
                    applies_para.add_run("Applicable to: ")
                    applies_para.add_run(", ".join(applies_to))
                    applies_para.runs[0].font.size = Pt(10)
                    applies_para.runs[0].font.italic = True
        
        doc.add_paragraph()
    
    def _add_machine_readable_reference(self, doc: Document, analysis: Dict[str, Any]):
        """Add reference to machine-readable output files"""
        machine_readable = analysis.get("machine_readable_rules", [])
        
        if not machine_readable or len(machine_readable) == 0:
            return
        
        doc.add_heading("ðŸ“Š Machine-Readable Output", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("This analysis has generated ")
        intro.add_run(f"{len(machine_readable)} machine-readable rules ").bold = True
        intro.add_run("in structured table format. These rules are available in separate files ")
        intro.add_run("for automated processing, compliance checking, and system integration.")
        intro.italic = True
        
        doc.add_paragraph()
        
        metadata = analysis.get("metadata", {})
        rule_name = metadata.get("rule_name", "rule")
        safe_name = "".join(c if c.isalnum() or c in (' ', '_') else '_' for c in rule_name).replace(' ', '_')
        
        para = doc.add_paragraph()
        para.add_run("Output Files:").bold = True
        
        file_list = doc.add_paragraph(style='List Bullet')
        file_list.add_run(f"{safe_name}_machine_readable.json - JSON format for programmatic access")
        
        file_list = doc.add_paragraph(style='List Bullet')
        file_list.add_run(f"{safe_name}_machine_readable.csv - CSV format for spreadsheet analysis")
        
        doc.add_paragraph()
        
        para = doc.add_paragraph()
        para.add_run("The machine-readable output includes:").bold = True
        
        features = [
            "Permission/Prohibition classification for each rule",
            "Action type using standardized taxonomy (sharing, hosting, usage, processing, deletion, collection, access)",
            "Constraints and conditions for each permission or prohibition",
            "User duties associated with each rule",
            "System duties and technical requirements",
            "Source citations with traceability to original documents"
        ]
        
        for feature in features:
            para = doc.add_paragraph(style='List Bullet 2')
            para.add_run(feature)
            para.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
    
    def _add_duplicate_warnings(self, doc: Document, analysis: Dict[str, Any]):
        """Add duplicate detection warnings"""
        potential_dupes = analysis.get("potential_duplicates", [])
        
        if not potential_dupes or len(potential_dupes) == 0:
            return
        
        doc.add_heading("âš ï¸ Duplicate Detection Alerts", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("ATTENTION: ").bold = True
        intro.add_run(f"The analysis detected {len(potential_dupes)} potential duplicate rules ")
        intro.add_run("with high semantic similarity (>90%). ")
        intro.add_run("These duplicates should be reviewed to determine if they represent:")
        
        reasons = [
            "Redundant requirements that can be consolidated",
            "The same requirement stated at different levels of abstraction",
            "Similar but distinct requirements with subtle differences",
            "Requirements that apply to different contexts or scenarios"
        ]
        
        for reason in reasons:
            para = doc.add_paragraph(style='List Bullet')
            para.add_run(reason)
        
        doc.add_paragraph()
        
        doc.add_heading("Potential Duplicate Rules", level=2)
        
        for i, dupe in enumerate(potential_dupes[:10], 1):  # Show top 10
            para = doc.add_paragraph()
            para.add_run(f"{i}. ").bold = True
            para.add_run(f"Node ID: {dupe.get('node_id', 'Unknown')} ")
            para.add_run(f"(Similarity: {dupe.get('similarity_score', 0):.2%})")
            para.runs[-1].font.color.rgb = RGBColor(178, 34, 34)
            
            desc_para = doc.add_paragraph(style='List Bullet 2')
            desc_text = dupe.get('description', '')[:200]
            if len(dupe.get('description', '')) > 200:
                desc_text += "..."
            desc_para.add_run(desc_text)
            desc_para.runs[0].font.size = Pt(9)
            desc_para.runs[0].italic = True
        
        if len(potential_dupes) > 10:
            para = doc.add_paragraph()
            para.add_run(f"... and {len(potential_dupes) - 10} more potential duplicates")
            para.italic = True
        
        doc.add_paragraph()
    
    def _add_footer(self, doc: Document, analysis: Dict[str, Any]):
        """Add footer"""
        doc.add_paragraph()
        doc.add_paragraph()
        
        disclaimer = doc.add_paragraph()
        disclaimer.add_run("âš ï¸ Disclaimer: ").bold = True
        disclaimer.add_run("This analysis was generated through automated review and extraction ")
        disclaimer.add_run("using advanced analytical techniques. ")
        disclaimer.add_run("While comprehensive measures were taken to ensure accuracy and completeness, ")
        disclaimer.add_run("including preservation of exact terminology from source documents, ")
        disclaimer.add_run("this analysis should be independently reviewed by qualified legal counsel ")
        disclaimer.add_run("before being relied upon for compliance purposes. ")
        disclaimer.add_run("The analysis is based on the documents provided at the time of generation ")
        disclaimer.add_run("and may require updates as regulations, guidance, or organizational policies evolve.")
        disclaimer.runs[1].font.italic = True
        disclaimer.runs[1].font.size = Pt(9)
        disclaimer.runs[1].font.color.rgb = RGBColor(100, 100, 100)
        
        doc.add_paragraph()
        
        timestamp = doc.add_paragraph()
        timestamp.add_run(f"Document generated on {datetime.now().strftime('%Y-%m-%d at %H:%M:%S')} ")
        timestamp.add_run(f"using Automated Legal Analysis System v3.0 ")
        timestamp.add_run(f"with Terminology Preservation, Duplicate Detection, and Machine-Readable Output")
        timestamp.alignment = WD_ALIGN_PARAGRAPH.CENTER
        timestamp.runs[0].font.size = Pt(9)
        timestamp.runs[0].font.color.rgb = RGBColor(150, 150, 150)
    
    def generate_machine_readable_files(self, analysis: Dict[str, Any], 
                                   rule_name: str) -> List[str]:
        """
        Generate machine-readable output files (JSON and CSV)
        FIXED: Deduplicates rules before writing
        """
        machine_readable = analysis.get("machine_readable_rules", [])
        
        if not machine_readable or len(machine_readable) == 0:
            return []
        
        print(f"\n  Deduplicating machine-readable rules...")
        print(f"    Before deduplication: {len(machine_readable)} rules")
        
        # Deduplicate at document level (might have duplicates across chunks)
        deduplicated = self._deduplicate_rules_with_citation_merge(machine_readable)
        
        print(f"    After deduplication: {len(deduplicated)} rules")
        if len(machine_readable) > len(deduplicated):
            print(f"    Merged {len(machine_readable) - len(deduplicated)} duplicate rules")
        
        safe_name = "".join(c if c.isalnum() or c in (' ', '_') else '_' for c in rule_name).replace(' ', '_')
        
        generated_files = []
        
        # Generate JSON file
        json_path = os.path.join(self.machine_readable_dir, f"{safe_name}_machine_readable.json")
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(deduplicated, f, indent=2, ensure_ascii=False)
        generated_files.append(json_path)
        print(f"  âœ“ Generated machine-readable JSON: {json_path}")
        
        # Generate CSV file
        csv_path = os.path.join(self.machine_readable_dir, f"{safe_name}_machine_readable.csv")
        
        if deduplicated:
            # Flatten the nested structure for CSV
            csv_rows = []
            
            for rule in deduplicated:
                # Base row data
                row = {
                    "Rule ID": rule.get("rule_id", ""),
                    "Rule Name": rule.get("rule_name", ""),
                    "Level": rule.get("level", ""),
                    "Permission/Prohibition": rule.get("permission_or_prohibition", ""),
                    "Action Type": rule.get("action_type", ""),
                    "Action Description": rule.get("action_description", ""),
                    "Actor": rule.get("actor", ""),
                    "Number of Citations": len(rule.get('citations', [])),
                    "Constraints": "; ".join([c.get('description', '') for c in rule.get('constraints', [])]),
                    "User Duties": "; ".join([d.get('description', '') for d in rule.get('user_duties', [])]),
                    "System Duties": "; ".join([d.get('description', '') for d in rule.get('system_duties', [])]),
                    "Citations": self._format_citations_for_csv(rule.get('citations', []))
                }
                
                csv_rows.append(row)
            
            with open(csv_path, 'w', encoding='utf-8', newline='') as f:
                if csv_rows:
                    fieldnames = csv_rows[0].keys()
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(csv_rows)
            
            generated_files.append(csv_path)
            print(f"  âœ“ Generated machine-readable CSV: {csv_path}")
        
        return generated_files
    def _deduplicate_rules_with_citation_merge(self, rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Deduplicate rules and merge citations
        NEW METHOD - Add to LegalSummaryGenerator class
        
        Rules are considered duplicates if they have:
        - Same action_type
        - Very similar action_description (normalized)
        - Same permission_or_prohibition
        - Same actor
        """
        if not rules:
            return []
        
        deduplicated = []
        seen_rules = {}  # composite key -> index in deduplicated
        
        for rule in rules:
            # Extract key attributes
            action_type = rule.get('action_type', '')
            action_desc = rule.get('action_description', '')
            classification = rule.get('permission_or_prohibition', '')
            actor = rule.get('actor', '')
            
            # Normalize description for comparison
            normalized_desc = ' '.join(action_desc.lower().split())
            
            # Create composite key
            rule_key = (action_type, normalized_desc[:150], classification, actor)
            
            if rule_key in seen_rules:
                # Duplicate found - merge citations and other data
                existing_idx = seen_rules[rule_key]
                existing_rule = deduplicated[existing_idx]
                
                # Merge citations (avoid citation duplicates)
                existing_citations = existing_rule.get('citations', [])
                new_citations = rule.get('citations', [])
                
                # Track existing citation texts to avoid duplicates
                existing_texts = {
                    (cite.get('text', '')[:100], cite.get('source_reference', ''))
                    for cite in existing_citations
                }
                
                # Add new unique citations
                for cite in new_citations:
                    cite_key = (cite.get('text', '')[:100], cite.get('source_reference', ''))
                    if cite_key[0] and cite_key not in existing_texts:
                        existing_citations.append(cite)
                        existing_texts.add(cite_key)
                
                existing_rule['citations'] = existing_citations
                
                # Also merge constraints, duties if different
                self._merge_rule_attributes(existing_rule, rule)
                
            else:
                # New unique rule - assign clean rule ID
                rule['rule_id'] = f"{rule.get('rule_name', 'rule')}_{len(deduplicated)}"
                seen_rules[rule_key] = len(deduplicated)
                deduplicated.append(rule)
        
        return deduplicated
    
    def _format_citations_for_csv(self, citations: List[Dict[str, Any]]) -> str:
        """
        Format citations for CSV output
        NEW METHOD - Add to LegalSummaryGenerator class
        """
        if not citations:
            return ""
        
        formatted = []
        for i, cite in enumerate(citations[:5], 1):  # Limit to first 5 for CSV
            text = cite.get('text', '')[:80]  # Truncate long citations
            source = cite.get('source_reference', 'Unknown')
            formatted.append(f"[{i}] {source}: {text}...")
        
        if len(citations) > 5:
            formatted.append(f"... and {len(citations) - 5} more citations")
        
        return " | ".join(formatted)

    def _merge_rule_attributes(self, existing_rule: Dict[str, Any], new_rule: Dict[str, Any]):
        """
        Merge constraints and duties from new_rule into existing_rule
        NEW METHOD - Add to LegalSummaryGenerator class
        """
        # Merge constraints
        existing_constraints = existing_rule.get('constraints', [])
        new_constraints = new_rule.get('constraints', [])
        
        existing_constraint_texts = {c.get('description', '') for c in existing_constraints}
        for constraint in new_constraints:
            desc = constraint.get('description', '')
            if desc and desc not in existing_constraint_texts:
                existing_constraints.append(constraint)
                existing_constraint_texts.add(desc)
        
        existing_rule['constraints'] = existing_constraints
        
        # Merge user duties
        existing_user_duties = existing_rule.get('user_duties', [])
        new_user_duties = new_rule.get('user_duties', [])
        
        existing_user_texts = {d.get('description', '') for d in existing_user_duties}
        for duty in new_user_duties:
            desc = duty.get('description', '')
            if desc and desc not in existing_user_texts:
                existing_user_duties.append(duty)
                existing_user_texts.add(desc)
        
        existing_rule['user_duties'] = existing_user_duties
        
        # Merge system duties
        existing_system_duties = existing_rule.get('system_duties', [])
        new_system_duties = new_rule.get('system_duties', [])
        
        existing_system_texts = {d.get('description', '') for d in existing_system_duties}
        for duty in new_system_duties:
            desc = duty.get('description', '')
            if desc and desc not in existing_system_texts:
                existing_system_duties.append(duty)
                existing_system_texts.add(desc)
        
        existing_rule['system_duties'] = existing_system_duties

    def save_document(self, doc: Document, rule_name: str, 
                     jurisdiction: str, filename: Optional[str] = None) -> str:
        """Save document"""
        if filename is None:
            safe_rule_name = "".join(
                c if c.isalnum() or c in (' ', '_') else '_' 
                for c in rule_name
            ).replace(' ', '_')
            safe_jurisdiction = jurisdiction.replace(' ', '_')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_rule_name}_{safe_jurisdiction}_{timestamp}.docx"
        
        filepath = os.path.join(self.output_dir, filename)
        doc.save(filepath)
        return filepath
    
    def generate_legal_summary(self, analysis: Dict[str, Any],
                              filename: Optional[str] = None) -> str:
        """Generate complete legal summary with machine-readable output"""
        # Generate Word document
        doc = self.create_document(analysis)
        
        metadata = analysis.get("metadata", {})
        rule_name = metadata.get("rule_name", "Legal_Rule")
        jurisdiction = metadata.get("jurisdiction", "General")
        
        doc_path = self.save_document(doc, rule_name, jurisdiction, filename)
        
        # Generate machine-readable files
        machine_readable_files = self.generate_machine_readable_files(analysis, rule_name)
        
        print(f"\n{'='*60}")
        print(f"GENERATED OUTPUTS:")
        print(f"  Word Document: {doc_path}")
        for mr_file in machine_readable_files:
            print(f"  Machine-Readable: {mr_file}")
        print(f"{'='*60}\n")
        
        return doc_path
    
    def create_index_document(self, analyses: Dict[str, Dict[str, Any]],
                             output_filename: str = "Legal_Summaries_Index.docx") -> str:
        """Create index document"""
        doc = Document()
        self._setup_styles(doc)
        
        title = doc.add_paragraph("Legal Rules Summary Index", style='CustomTitle')
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        subtitle = doc.add_paragraph(
            f"Generated on {datetime.now().strftime('%Y-%m-%d')}"
        )
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle.runs[0].font.size = Pt(12)
        subtitle.runs[0].font.italic = True
        
        doc.add_paragraph()
        
        doc.add_heading("Summary Statistics", level=1)
        
        total_rules = len(analyses)
        para = doc.add_paragraph()
        para.add_run(f"This index covers {total_rules} legal rules that were analyzed ")
        para.add_run("through systematic multi-stage review with terminology preservation, ")
        para.add_run("duplicate detection, and machine-readable output generation.")
        
        doc.add_paragraph()
        
        # Classification counts
        classification_counts = {}
        for analysis in analyses.values():
            classification = analysis.get("classification", "unknown")
            classification_counts[classification] = classification_counts.get(classification, 0) + 1
        
        if classification_counts:
            doc.add_paragraph("Rules by Classification:")
            for classification, count in classification_counts.items():
                para = doc.add_paragraph(style='List Bullet')
                para.add_run(f"{classification.title()}: {count} rules")
        
        # Machine-readable counts
        total_machine_readable = sum(
            len(a.get('machine_readable_rules', [])) for a in analyses.values()
        )
        
        para = doc.add_paragraph()
        para.add_run(f"Total Machine-Readable Rules: {total_machine_readable}")
        
        # Duplicate detection summary
        total_duplicates = sum(
            len(a.get('potential_duplicates', [])) for a in analyses.values()
        )
        
        if total_duplicates > 0:
            para = doc.add_paragraph()
            para.add_run(f"âš ï¸ Total Potential Duplicates Detected: {total_duplicates}")
            para.runs[0].font.color.rgb = RGBColor(178, 34, 34)
        
        doc.add_paragraph()
        
        doc.add_heading("Rules Analyzed", level=1)
        
        table = doc.add_table(rows=1, cols=6)
        table.style = 'Light Grid Accent 1'
        
        headers = table.rows[0].cells
        headers[0].text = "Rule Name"
        headers[1].text = "Jurisdiction"
        headers[2].text = "Classification"
        headers[3].text = "Data Operations"
        headers[4].text = "Duties"
        headers[5].text = "Machine-Readable"
        
        for cell in headers:
            cell.paragraphs[0].runs[0].font.bold = True
        
        for rule_name, analysis in analyses.items():
            metadata = analysis.get("metadata", {})
            row = table.add_row()
            
            row.cells[0].text = rule_name
            row.cells[1].text = metadata.get("jurisdiction", "N/A")
            row.cells[2].text = analysis.get("classification", "N/A").title()
            row.cells[3].text = str(len(analysis.get("data_actions", [])))
            
            duties_count = (len(analysis.get("user_evidence", [])) +
                          len(analysis.get("system_evidence", [])))
            row.cells[4].text = str(duties_count)
            
            row.cells[5].text = str(len(analysis.get("machine_readable_rules", [])))
        
        filepath = os.path.join(self.output_dir, output_filename)
        doc.save(filepath)
        return filepath
