"""
Custom middleware for the Enhanced RDF Knowledge Graph Chatbot API.
"""

import time
import logging
import json
import uuid
from typing import Callable, Dict, Any, Optional
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response, JSONResponse
from starlette.types import ASGIApp
from fastapi import HTTPException

from app.utils.exceptions import ChatbotException

logger = logging.getLogger(__name__)

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Middleware for comprehensive request/response logging."""
    
    def __init__(self, app: ASGIApp, log_level: str = "INFO"):
        super().__init__(app)
        self.log_level = getattr(logging, log_level.upper())
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Process request and log details."""
        # Generate request ID
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
        
        # Start timing
        start_time = time.time()
        
        # Extract request info
        client_ip = self._get_client_ip(request)
        user_agent = request.headers.get("User-Agent", "unknown")
        
        # Log request start
        logger.log(
            self.log_level,
            f"Request {request_id}: {request.method} {request.url.path} "
            f"from {client_ip} ({user_agent})"
        )
        
        # Add request ID to state for other middleware/handlers
        request.state.request_id = request_id
        request.state.start_time = start_time
        request.state.client_ip = client_ip
        
        try:
            # Process request
            response = await call_next(request)
            
            # Calculate duration
            duration = time.time() - start_time
            
            # Log response
            logger.log(
                self.log_level,
                f"Response {request_id}: {response.status_code} "
                f"in {duration:.3f}s"
            )
            
            # Add headers
            response.headers["X-Request-ID"] = request_id
            response.headers["X-Process-Time"] = f"{duration:.3f}"
            
            # Log slow requests as warnings
            if duration > 5.0:
                logger.warning(
                    f"Slow request {request_id}: {request.method} {request.url.path} "
                    f"took {duration:.3f}s"
                )
            
            return response
            
        except Exception as e:
            duration = time.time() - start_time
            
            # Log error
            logger.error(
                f"Request {request_id} failed after {duration:.3f}s: {str(e)}",
                exc_info=True
            )
            
            # Return error response
            if isinstance(e, HTTPException):
                return JSONResponse(
                    status_code=e.status_code,
                    content={"detail": e.detail, "request_id": request_id},
                    headers={"X-Request-ID": request_id}
                )
            else:
                return JSONResponse(
                    status_code=500,
                    content={
                        "detail": "Internal server error",
                        "request_id": request_id
                    },
                    headers={"X-Request-ID": request_id}
                )
    
    def _get_client_ip(self, request: Request) -> str:
        """Extract client IP from request."""
        # Check forwarded headers
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
            
        return request.client.host if request.client else "unknown"

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Middleware to add security headers to all responses."""
    
    def __init__(self, app: ASGIApp):
        super().__init__(app)
        self.security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Referrer-Policy": "strict-origin-when-cross-origin",
            "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
            "Permissions-Policy": "geolocation=(), microphone=(), camera=()",
        }
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Add security headers to response."""
        response = await call_next(request)
        
        # Add security headers
        for header, value in self.security_headers.items():
            response.headers[header] = value
        
        return response

class CORSMiddleware(BaseHTTPMiddleware):
    """Custom CORS middleware with enhanced configuration."""
    
    def __init__(
        self,
        app: ASGIApp,
        allow_origins: list = None,
        allow_methods: list = None,
        allow_headers: list = None,
        expose_headers: list = None,
        allow_credentials: bool = False,
        max_age: int = 600
    ):
        super().__init__(app)
        self.allow_origins = allow_origins or ["*"]
        self.allow_methods = allow_methods or ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
        self.allow_headers = allow_headers or ["*"]
        self.expose_headers = expose_headers or ["X-Request-ID", "X-Process-Time"]
        self.allow_credentials = allow_credentials
        self.max_age = max_age
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Handle CORS preflight and add CORS headers."""
        # Handle preflight requests
        if request.method == "OPTIONS":
            return self._create_preflight_response(request)
        
        # Process normal request
        response = await call_next(request)
        
        # Add CORS headers
        self._add_cors_headers(request, response)
        
        return response
    
    def _create_preflight_response(self, request: Request) -> Response:
        """Create response for OPTIONS preflight request."""
        response = Response()
        self._add_cors_headers(request, response)
        return response
    
    def _add_cors_headers(self, request: Request, response: Response) -> None:
        """Add CORS headers to response."""
        origin = request.headers.get("Origin")
        
        # Check if origin is allowed
        if origin and (self.allow_origins == ["*"] or origin in self.allow_origins):
            response.headers["Access-Control-Allow-Origin"] = origin
        elif self.allow_origins == ["*"]:
            response.headers["Access-Control-Allow-Origin"] = "*"
        
        if self.allow_credentials:
            response.headers["Access-Control-Allow-Credentials"] = "true"
        
        response.headers["Access-Control-Allow-Methods"] = ", ".join(self.allow_methods)
        response.headers["Access-Control-Allow-Headers"] = ", ".join(self.allow_headers)
        response.headers["Access-Control-Expose-Headers"] = ", ".join(self.expose_headers)
        response.headers["Access-Control-Max-Age"] = str(self.max_age)

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """Middleware for centralized error handling and formatting."""
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Handle errors and format responses consistently."""
        try:
            return await call_next(request)
            
        except HTTPException:
            # Let HTTPExceptions pass through
            raise
            
        except ChatbotException as e:
            # Handle custom chatbot exceptions
            logger.error(f"Chatbot error: {str(e)}", exc_info=True)
            
            return JSONResponse(
                status_code=500,
                content={
                    "error": "Chatbot Error",
                    "message": str(e),
                    "type": type(e).__name__,
                    "request_id": getattr(request.state, "request_id", "unknown")
                }
            )
            
        except ValueError as e:
            # Handle validation errors
            logger.warning(f"Validation error: {str(e)}")
            
            return JSONResponse(
                status_code=400,
                content={
                    "error": "Validation Error",
                    "message": str(e),
                    "request_id": getattr(request.state, "request_id", "unknown")
                }
            )
            
        except Exception as e:
            # Handle unexpected errors
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            
            return JSONResponse(
                status_code=500,
                content={
                    "error": "Internal Server Error",
                    "message": "An unexpected error occurred",
                    "request_id": getattr(request.state, "request_id", "unknown")
                }
            )

class PerformanceMonitoringMiddleware(BaseHTTPMiddleware):
    """Middleware for performance monitoring and metrics."""
    
    def __init__(self, app: ASGIApp, slow_request_threshold: float = 2.0):
        super().__init__(app)
        self.slow_request_threshold = slow_request_threshold
        self.metrics = {
            "total_requests": 0,
            "total_errors": 0,
            "slow_requests": 0,
            "average_response_time": 0.0
        }
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Monitor request performance."""
        start_time = time.time()
        
        try:
            response = await call_next(request)
            
            # Update metrics
            self._update_metrics(start_time, response.status_code)
            
            return response
            
        except Exception as e:
            # Update error metrics
            self._update_metrics(start_time, 500)
            raise
    
    def _update_metrics(self, start_time: float, status_code: int) -> None:
        """Update performance metrics."""
        duration = time.time() - start_time
        
        self.metrics["total_requests"] += 1
        
        if status_code >= 400:
            self.metrics["total_errors"] += 1
        
        if duration > self.slow_request_threshold:
            self.metrics["slow_requests"] += 1
        
        # Update average response time (simple moving average)
        current_avg = self.metrics["average_response_time"]
        total_requests = self.metrics["total_requests"]
        
        self.metrics["average_response_time"] = (
            (current_avg * (total_requests - 1) + duration) / total_requests
        )
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get current performance metrics."""
        return self.metrics.copy()

class ContentValidationMiddleware(BaseHTTPMiddleware):
    """Middleware for request content validation and sanitization."""
    
    def __init__(self, app: ASGIApp, max_content_length: int = 10 * 1024 * 1024):  # 10MB
        super().__init__(app)
        self.max_content_length = max_content_length
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Validate request content."""
        # Check content length
        content_length = request.headers.get("Content-Length")
        if content_length and int(content_length) > self.max_content_length:
            return JSONResponse(
                status_code=413,
                content={
                    "error": "Request Entity Too Large",
                    "message": f"Content length exceeds {self.max_content_length} bytes"
                }
            )
        
        # Validate content type for POST/PUT requests
        if request.method in ["POST", "PUT"]:
            content_type = request.headers.get("Content-Type", "")
            
            if content_type and not self._is_allowed_content_type(content_type):
                return JSONResponse(
                    status_code=415,
                    content={
                        "error": "Unsupported Media Type",
                        "message": f"Content type '{content_type}' is not supported"
                    }
                )
        
        return await call_next(request)
    
    def _is_allowed_content_type(self, content_type: str) -> bool:
        """Check if content type is allowed."""
        allowed_types = [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
            "text/plain"
        ]
        
        return any(content_type.startswith(allowed) for allowed in allowed_types)

class MetricsMiddleware(BaseHTTPMiddleware):
    """Middleware for collecting application metrics."""
    
    def __init__(self, app: ASGIApp):
        super().__init__(app)
        self.endpoint_metrics = {}
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Collect endpoint-specific metrics."""
        endpoint = self._get_endpoint(request)
        start_time = time.time()
        
        try:
            response = await call_next(request)
            duration = time.time() - start_time
            
            # Update endpoint metrics
            self._update_endpoint_metrics(endpoint, duration, response.status_code)
            
            return response
            
        except Exception as e:
            duration = time.time() - start_time
            self._update_endpoint_metrics(endpoint, duration, 500)
            raise
    
    def _get_endpoint(self, request: Request) -> str:
        """Extract endpoint from request path."""
        path = request.url.path
        method = request.method
        
        # Normalize path parameters
        normalized_path = path
        if "/entity/" in path:
            normalized_path = "/entity/{uri}"
        elif "/entities/type/" in path:
            normalized_path = "/entities/type/{type}"
        
        return f"{method} {normalized_path}"
    
    def _update_endpoint_metrics(self, endpoint: str, duration: float, status_code: int) -> None:
        """Update metrics for specific endpoint."""
        if endpoint not in self.endpoint_metrics:
            self.endpoint_metrics[endpoint] = {
                "count": 0,
                "total_time": 0.0,
                "errors": 0,
                "min_time": float('inf'),
                "max_time": 0.0
            }
        
        metrics = self.endpoint_metrics[endpoint]
        metrics["count"] += 1
        metrics["total_time"] += duration
        metrics["min_time"] = min(metrics["min_time"], duration)
        metrics["max_time"] = max(metrics["max_time"], duration)
        
        if status_code >= 400:
            metrics["errors"] += 1
    
    def get_endpoint_metrics(self) -> Dict[str, Dict[str, Any]]:
        """Get metrics for all endpoints."""
        result = {}
        
        for endpoint, metrics in self.endpoint_metrics.items():
            result[endpoint] = {
                "count": metrics["count"],
                "average_time": metrics["total_time"] / metrics["count"] if metrics["count"] > 0 else 0,
                "min_time": metrics["min_time"] if metrics["min_time"] != float('inf') else 0,
                "max_time": metrics["max_time"],
                "error_rate": metrics["errors"] / metrics["count"] if metrics["count"] > 0 else 0,
                "errors": metrics["errors"]
            }
        
        return result

# Global middleware instances for metrics access
performance_monitor = PerformanceMonitoringMiddleware(None)
metrics_collector = MetricsMiddleware(None)

def get_middleware_metrics() -> Dict[str, Any]:
    """Get combined metrics from all middleware."""
    return {
        "performance": performance_monitor.get_metrics(),
        "endpoints": metrics_collector.get_endpoint_metrics()
    }
