"""
Entity data models and schemas for the Enhanced RDF Knowledge Graph Chatbot.
"""

from typing import List, Dict, Any, Optional, Union, Set
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict, field_validator, computed_field
from dataclasses import dataclass
import re

class OWLEntityType(str, Enum):
    """OWL entity types."""
    CLASS = "owl:Class"
    OBJECT_PROPERTY = "owl:ObjectProperty"
    DATATYPE_PROPERTY = "owl:DatatypeProperty"
    NAMED_INDIVIDUAL = "owl:NamedIndividual"
    ANNOTATION_PROPERTY = "owl:AnnotationProperty"

class RDFSEntityType(str, Enum):
    """RDFS entity types."""
    CLASS = "rdfs:Class"
    PROPERTY = "rdf:Property"
    RESOURCE = "rdfs:Resource"

class EntityTypeCategory(str, Enum):
    """High-level entity type categories."""
    CLASS = "Class"
    PROPERTY = "Property"
    INDIVIDUAL = "Individual"
    INSTANCE = "Instance"
    ANNOTATION = "Annotation"

class RelationshipDirection(str, Enum):
    """Relationship direction."""
    INCOMING = "incoming"
    OUTGOING = "outgoing"
    BIDIRECTIONAL = "bidirectional"

class NamespaceInfo(BaseModel):
    """Namespace information."""
    model_config = ConfigDict(extra="allow")
    
    prefix: str = Field(..., description="Namespace prefix")
    uri: str = Field(..., description="Namespace URI")
    description: Optional[str] = Field(None, description="Namespace description")
    is_standard: bool = Field(False, description="Whether this is a standard namespace")

class EntityReference(BaseModel):
    """Reference to another entity."""
    model_config = ConfigDict(extra="forbid")
    
    uri: str = Field(..., description="Entity URI")
    local_name: str = Field(..., description="Entity local name")
    namespace: Optional[str] = Field(None, description="Entity namespace")
    label: Optional[str] = Field(None, description="Human-readable label")
    type: Optional[str] = Field(None, description="Entity type")

class PropertyValue(BaseModel):
    """Property value with metadata."""
    model_config = ConfigDict(extra="forbid")
    
    property_uri: str = Field(..., description="Property URI")
    property_name: str = Field(..., description="Property local name")
    value: Union[str, int, float, bool] = Field(..., description="Property value")
    datatype: Optional[str] = Field(None, description="Value datatype")
    language: Optional[str] = Field(None, description="Language tag")
    is_literal: bool = Field(True, description="Whether value is a literal")

class Relationship(BaseModel):
    """Relationship between entities."""
    model_config = ConfigDict(extra="forbid")
    
    predicate: str = Field(..., description="Relationship predicate")
    predicate_uri: str = Field(..., description="Predicate URI")
    target: EntityReference = Field(..., description="Target entity")
    direction: RelationshipDirection = Field(..., description="Relationship direction")
    depth: int = Field(1, ge=1, description="Relationship depth from source")
    path: List[str] = Field(default_factory=list, description="Relationship path")
    weight: Optional[float] = Field(None, description="Relationship weight/strength")

class HierarchyInfo(BaseModel):
    """Hierarchical information for classes."""
    model_config = ConfigDict(extra="forbid")
    
    superclasses: List[EntityReference] = Field(default_factory=list, description="Direct superclasses")
    subclasses: List[EntityReference] = Field(default_factory=list, description="Direct subclasses")
    ancestors: List[EntityReference] = Field(default_factory=list, description="All ancestors")
    descendants: List[EntityReference] = Field(default_factory=list, description="All descendants")
    hierarchy_level: int = Field(0, ge=0, description="Level in hierarchy (0=root)")
    is_root: bool = Field(False, description="Whether this is a root class")
    is_leaf: bool = Field(False, description="Whether this is a leaf class")

class PropertyDomainRange(BaseModel):
    """Domain and range information for properties."""
    model_config = ConfigDict(extra="forbid")
    
    domains: List[EntityReference] = Field(default_factory=list, description="Property domains")
    ranges: List[EntityReference] = Field(default_factory=list, description="Property ranges")
    is_functional: bool = Field(False, description="Whether property is functional")
    is_inverse_functional: bool = Field(False, description="Whether property is inverse functional")
    inverse_properties: List[EntityReference] = Field(default_factory=list, description="Inverse properties")
    equivalent_properties: List[EntityReference] = Field(default_factory=list, description="Equivalent properties")

class InstanceInfo(BaseModel):
    """Information about class instances."""
    model_config = ConfigDict(extra="forbid")
    
    instance_of: List[EntityReference] = Field(default_factory=list, description="Classes this is an instance of")
    property_values: List[PropertyValue] = Field(default_factory=list, description="Property values")
    same_as: List[EntityReference] = Field(default_factory=list, description="Equivalent instances")
    different_from: List[EntityReference] = Field(default_factory=list, description="Different instances")

class EntityStatistics(BaseModel):
    """Statistical information about an entity."""
    model_config = ConfigDict(extra="forbid")
    
    instance_count: int = Field(0, ge=0, description="Number of instances (for classes)")
    usage_count: int = Field(0, ge=0, description="Usage frequency")
    relationship_count: int = Field(0, ge=0, description="Number of relationships")
    property_count: int = Field(0, ge=0, description="Number of properties")
    centrality_score: Optional[float] = Field(None, description="Graph centrality score")
    importance_score: Optional[float] = Field(None, description="Importance score")

class EntityMetadata(BaseModel):
    """Comprehensive entity metadata."""
    model_config = ConfigDict(extra="forbid")
    
    created_at: Optional[datetime] = Field(None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")
    indexed_at: Optional[datetime] = Field(None, description="Indexing timestamp")
    source_file: Optional[str] = Field(None, description="Source ontology file")
    confidence_score: Optional[float] = Field(None, description="Extraction confidence")
    validation_status: Optional[str] = Field(None, description="Validation status")
    tags: Set[str] = Field(default_factory=set, description="Custom tags")
    annotations: Dict[str, Any] = Field(default_factory=dict, description="Custom annotations")

class TextualContent(BaseModel):
    """Textual content for entity."""
    model_config = ConfigDict(extra="forbid")
    
    labels: List[str] = Field(default_factory=list, description="Human-readable labels")
    comments: List[str] = Field(default_factory=list, description="Comments and descriptions")
    definitions: List[str] = Field(default_factory=list, description="Formal definitions")
    examples: List[str] = Field(default_factory=list, description="Usage examples")
    aliases: List[str] = Field(default_factory=list, description="Alternative names")
    full_text: str = Field("", description="Complete textual representation")
    
    @computed_field
    @property
    def search_text(self) -> str:
        """Generate optimized text for search indexing."""
        all_text = []
        
        # Add labels with higher weight
        for label in self.labels:
            all_text.extend([label] * 3)  # Triple weight for labels
        
        # Add comments and definitions
        all_text.extend(self.comments)
        all_text.extend(self.definitions)
        
        # Add examples and aliases
        all_text.extend(self.examples)
        all_text.extend(self.aliases)
        
        # Add full text
        if self.full_text:
            all_text.append(self.full_text)
        
        return " ".join(all_text)

class EntityValidation(BaseModel):
    """Entity validation results."""
    model_config = ConfigDict(extra="forbid")
    
    is_valid: bool = Field(True, description="Whether entity is valid")
    warnings: List[str] = Field(default_factory=list, description="Validation warnings")
    errors: List[str] = Field(default_factory=list, description="Validation errors")
    completeness_score: float = Field(1.0, ge=0.0, le=1.0, description="Completeness score")
    consistency_score: float = Field(1.0, ge=0.0, le=1.0, description="Consistency score")

class EntityCore(BaseModel):
    """Core entity information."""
    model_config = ConfigDict(extra="forbid")
    
    uri: str = Field(..., description="Unique entity URI")
    local_name: str = Field(..., description="Local name (without namespace)")
    namespace: str = Field(..., description="Entity namespace")
    qname: Optional[str] = Field(None, description="Qualified name (prefix:local)")
    
    @field_validator('uri')
    @classmethod
    def validate_uri(cls, v: str) -> str:
        """Validate URI format."""
        if not v or not v.strip():
            raise ValueError("URI cannot be empty")
        
        # Basic URI validation
        uri_pattern = re.compile(
            r'^[a-zA-Z][a-zA-Z0-9+.-]*:'  # scheme
            r'[^\s]*$'                     # rest of URI
        )
        
        if not uri_pattern.match(v):
            raise ValueError(f"Invalid URI format: {v}")
        
        return v.strip()
    
    @field_validator('local_name')
    @classmethod
    def validate_local_name(cls, v: str) -> str:
        """Validate local name."""
        if not v or not v.strip():
            raise ValueError("Local name cannot be empty")
        return v.strip()

class RDFEntity(EntityCore):
    """Complete RDF entity model with all information."""
    model_config = ConfigDict(extra="forbid")
    
    # Core type information
    entity_type: EntityTypeCategory = Field(..., description="High-level entity category")
    owl_type: Optional[OWLEntityType] = Field(None, description="Specific OWL type")
    rdf_types: List[str] = Field(default_factory=list, description="All RDF types")
    
    # Textual content
    textual_content: TextualContent = Field(default_factory=TextualContent, description="Textual content")
    
    # Relationships and structure
    relationships: List[Relationship] = Field(default_factory=list, description="Entity relationships")
    hierarchy_info: Optional[HierarchyInfo] = Field(None, description="Hierarchical information")
    property_info: Optional[PropertyDomainRange] = Field(None, description="Property domain/range info")
    instance_info: Optional[InstanceInfo] = Field(None, description="Instance information")
    
    # Statistics and metadata
    statistics: EntityStatistics = Field(default_factory=EntityStatistics, description="Entity statistics")
    metadata: EntityMetadata = Field(default_factory=EntityMetadata, description="Entity metadata")
    validation: EntityValidation = Field(default_factory=EntityValidation, description="Validation results")
    
    # Indexing and search
    embedding_vector: Optional[List[float]] = Field(None, description="Vector embedding")
    search_keywords: Set[str] = Field(default_factory=set, description="Search keywords")
    
    @computed_field
    @property
    def display_name(self) -> str:
        """Get the best display name for the entity."""
        if self.textual_content.labels:
            return self.textual_content.labels[0]
        return self.local_name
    
    @computed_field
    @property
    def summary(self) -> str:
        """Generate a summary description of the entity."""
        parts = [f"{self.display_name} is a {self.entity_type.value.lower()}"]
        
        if self.textual_content.comments:
            parts.append(self.textual_content.comments[0])
        
        if self.entity_type == EntityTypeCategory.CLASS and self.hierarchy_info:
            if self.hierarchy_info.superclasses:
                superclass_names = [ref.local_name for ref in self.hierarchy_info.superclasses[:2]]
                parts.append(f"Subclass of: {', '.join(superclass_names)}")
        
        return ". ".join(parts)
    
    def get_related_entities(self, 
                           relationship_type: Optional[str] = None,
                           max_depth: int = 1) -> List[EntityReference]:
        """Get related entities with optional filtering."""
        related = []
        
        for rel in self.relationships:
            if relationship_type and rel.predicate != relationship_type:
                continue
            if rel.depth > max_depth:
                continue
            related.append(rel.target)
        
        return related
    
    def add_relationship(self, 
                        predicate: str,
                        predicate_uri: str,
                        target: EntityReference,
                        direction: RelationshipDirection = RelationshipDirection.OUTGOING,
                        depth: int = 1) -> None:
        """Add a new relationship to the entity."""
        relationship = Relationship(
            predicate=predicate,
            predicate_uri=predicate_uri,
            target=target,
            direction=direction,
            depth=depth
        )
        
        # Avoid duplicates
        for existing in self.relationships:
            if (existing.predicate_uri == predicate_uri and 
                existing.target.uri == target.uri and
                existing.direction == direction):
                return
        
        self.relationships.append(relationship)
    
    def update_statistics(self) -> None:
        """Update entity statistics based on current data."""
        self.statistics.relationship_count = len(self.relationships)
        self.statistics.property_count = len(self.instance_info.property_values) if self.instance_info else 0
        
        # Update metadata
        self.metadata.updated_at = datetime.now()

class EntityGraph(BaseModel):
    """Collection of entities forming a graph."""
    model_config = ConfigDict(extra="forbid")
    
    entities: Dict[str, RDFEntity] = Field(default_factory=dict, description="Entities by URI")
    namespaces: Dict[str, NamespaceInfo] = Field(default_factory=dict, description="Namespace information")
    statistics: Dict[str, Any] = Field(default_factory=dict, description="Graph statistics")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Graph metadata")
    
    def add_entity(self, entity: RDFEntity) -> None:
        """Add an entity to the graph."""
        self.entities[entity.uri] = entity
        
        # Update namespace info
        if entity.namespace not in self.namespaces:
            # Extract prefix from common namespace patterns
            prefix = self._extract_prefix(entity.namespace)
            self.namespaces[entity.namespace] = NamespaceInfo(
                prefix=prefix,
                uri=entity.namespace
            )
    
    def get_entity(self, uri: str) -> Optional[RDFEntity]:
        """Get an entity by URI."""
        return self.entities.get(uri)
    
    def get_entities_by_type(self, entity_type: EntityTypeCategory) -> List[RDFEntity]:
        """Get all entities of a specific type."""
        return [entity for entity in self.entities.values() 
                if entity.entity_type == entity_type]
    
    def get_entities_by_namespace(self, namespace: str) -> List[RDFEntity]:
        """Get all entities in a specific namespace."""
        return [entity for entity in self.entities.values() 
                if entity.namespace == namespace]
    
    def calculate_statistics(self) -> Dict[str, Any]:
        """Calculate graph statistics."""
        stats = {
            "total_entities": len(self.entities),
            "entity_types": {},
            "namespaces": len(self.namespaces),
            "total_relationships": 0,
            "avg_relationships_per_entity": 0.0
        }
        
        # Count by type
        for entity in self.entities.values():
            entity_type = entity.entity_type.value
            stats["entity_types"][entity_type] = stats["entity_types"].get(entity_type, 0) + 1
            stats["total_relationships"] += len(entity.relationships)
        
        # Calculate averages
        if len(self.entities) > 0:
            stats["avg_relationships_per_entity"] = stats["total_relationships"] / len(self.entities)
        
        self.statistics = stats
        return stats
    
    def _extract_prefix(self, namespace: str) -> str:
        """Extract a reasonable prefix from namespace URI."""
        # Common namespace prefixes
        common_prefixes = {
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf",
            "http://www.w3.org/2000/01/rdf-schema#": "rdfs",
            "http://www.w3.org/2002/07/owl#": "owl",
            "http://www.w3.org/2004/02/skos/core#": "skos",
            "http://xmlns.com/foaf/0.1/": "foaf",
            "http://purl.org/dc/elements/1.1/": "dc",
            "http://purl.org/dc/terms/": "dcterms"
        }
        
        if namespace in common_prefixes:
            return common_prefixes[namespace]
        
        # Try to extract from domain or path
        if "://" in namespace:
            parts = namespace.replace("://", "/").split("/")
            for part in reversed(parts):
                if part and not part.startswith("www.") and len(part) < 20:
                    return part.lower().replace(".", "").replace("-", "")
        
        return f"ns{len(self.namespaces)}"

# Factory functions
def create_class_entity(uri: str, local_name: str, namespace: str) -> RDFEntity:
    """Create a class entity with appropriate defaults."""
    return RDFEntity(
        uri=uri,
        local_name=local_name,
        namespace=namespace,
        entity_type=EntityTypeCategory.CLASS,
        owl_type=OWLEntityType.CLASS,
        hierarchy_info=HierarchyInfo()
    )

def create_property_entity(uri: str, local_name: str, namespace: str, 
                          is_object_property: bool = True) -> RDFEntity:
    """Create a property entity with appropriate defaults."""
    return RDFEntity(
        uri=uri,
        local_name=local_name,
        namespace=namespace,
        entity_type=EntityTypeCategory.PROPERTY,
        owl_type=OWLEntityType.OBJECT_PROPERTY if is_object_property else OWLEntityType.DATATYPE_PROPERTY,
        property_info=PropertyDomainRange()
    )

def create_individual_entity(uri: str, local_name: str, namespace: str) -> RDFEntity:
    """Create an individual entity with appropriate defaults."""
    return RDFEntity(
        uri=uri,
        local_name=local_name,
        namespace=namespace,
        entity_type=EntityTypeCategory.INDIVIDUAL,
        owl_type=OWLEntityType.NAMED_INDIVIDUAL,
        instance_info=InstanceInfo()
    )
