def query_sparql(self, query: str) -> List[Dict[str, Any]]:
    """
    Execute a SPARQL query with comprehensive debug logging.
    
    Args:
        query: SPARQL query string
        
    Returns:
        List of result dictionaries
    """
    print("=" * 80)
    print("üîç SPARQL QUERY DEBUG")
    print("=" * 80)
    print("üìù ORIGINAL QUERY:")
    print(query)
    print("-" * 40)
    
    # Clean and validate the query first
    cleaned_query = self._clean_and_validate_sparql_query(query)
    if not cleaned_query:
        print("‚ùå QUERY VALIDATION FAILED")
        logger.error(f"Invalid SPARQL query: {query}")
        return []
    
    print("‚úÖ CLEANED QUERY:")
    print(cleaned_query)
    print("-" * 40)
    
    # Add prefixes if needed
    query_with_prefixes = self._add_common_prefixes(cleaned_query)
    
    print("üîß QUERY WITH PREFIXES:")
    print(query_with_prefixes)
    print("-" * 40)
    
    # Try to use remote SPARQL endpoint first if available
    if (self.vector_store and 
        hasattr(self.vector_store, 'execute_sparql_query') and
        self.vector_store.sparql_endpoint_url):
        
        try:
            print("üåê EXECUTING ON REMOTE ENDPOINT:")
            print(f"   Endpoint: {self.vector_store.sparql_endpoint_url}")
            logger.info("Executing SPARQL query on remote endpoint")
            
            results = self.vector_store.execute_sparql_query(query_with_prefixes)
            print(f"‚úÖ REMOTE QUERY SUCCESS: {len(results)} results")
            print("=" * 80)
            return results
            
        except Exception as e:
            print(f"‚ùå REMOTE QUERY FAILED: {e}")
            print(f"   Error type: {type(e).__name__}")
            print(f"   Error details: {str(e)}")
            logger.warning(f"Remote SPARQL query failed: {e}")
            logger.info("Falling back to local graph")
    
    # Fallback to local graph
    try:
        print("üè† EXECUTING ON LOCAL GRAPH:")
        logger.info("Executing SPARQL query on local graph")
        
        results = []
        query_result = self.graph.query(query_with_prefixes)
        
        for row in query_result:
            result_dict = {}
            for i, var in enumerate(query_result.vars):
                value = row[i]
                if value is not None:
                    if isinstance(value, URIRef):
                        result_dict[str(var)] = str(value)
                    elif isinstance(value, Literal):
                        result_dict[str(var)] = str(value)
                    else:
                        result_dict[str(var)] = str(value)
                else:
                    result_dict[str(var)] = None
            results.append(result_dict)
        
        print(f"‚úÖ LOCAL QUERY SUCCESS: {len(results)} results")
        if results and len(results) <= 3:
            print("üìä SAMPLE RESULTS:")
            for i, result in enumerate(results[:3]):
                print(f"   {i+1}: {result}")
        
        print("=" * 80)
        return results
        
    except Exception as e:
        print(f"‚ùå LOCAL QUERY FAILED: {e}")
        print(f"   Error type: {type(e).__name__}")
        print(f"   Error details: {str(e)}")
        logger.error(f"Error executing SPARQL query on local graph: {e}")
        logger.error(f"Query was: {query_with_prefixes}")
        print("=" * 80)
        return []

def _clean_and_validate_sparql_query(self, query: str) -> str:
    """Clean and validate a SPARQL query with debug output."""
    print("üßπ CLEANING AND VALIDATING QUERY...")
    
    if not query or not query.strip():
        print("‚ùå Empty query provided")
        return ""
    
    print(f"üìè Original query length: {len(query)} characters")
    
    # Remove excessive whitespace and normalize
    import re
    original_query = query
    query = re.sub(r'\s+', ' ', query.strip())
    
    if query != original_query.strip():
        print("üîß Normalized whitespace")
    
    # Basic validation - must contain SELECT, ASK, CONSTRUCT, or DESCRIBE
    query_upper = query.upper()
    valid_keywords = ['SELECT', 'ASK', 'CONSTRUCT', 'DESCRIBE']
    found_keywords = [kw for kw in valid_keywords if kw in query_upper]
    
    if not found_keywords:
        print(f"‚ùå Query must contain one of: {valid_keywords}")
        print(f"   Found in query: {found_keywords}")
        return ""
    else:
        print(f"‚úÖ Found valid keywords: {found_keywords}")
    
    # Check for balanced braces
    open_braces = query.count('{')
    close_braces = query.count('}')
    if open_braces != close_braces:
        print(f"‚ùå Unbalanced braces: {open_braces} opening, {close_braces} closing")
        return ""
    else:
        print(f"‚úÖ Balanced braces: {open_braces} pairs")
    
    # Fix common issues
    fixed_query = self._fix_common_sparql_issues(query)
    
    if fixed_query != query:
        print("üîß Applied syntax fixes")
        print(f"   Before: {query[:100]}...")
        print(f"   After:  {fixed_query[:100]}...")
    else:
        print("‚úÖ No syntax fixes needed")
    
    return fixed_query

def _fix_common_sparql_issues(self, query: str) -> str:
    """Fix common SPARQL syntax issues with debug output."""
    print("üîß Applying common SPARQL fixes...")
    
    import re
    original_query = query
    fixes_applied = []
    
    # Fix missing dots before closing braces
    before = query
    query = re.sub(r'([^\s\.])\s*}', r'\1 . }', query)
    if query != before:
        fixes_applied.append("Added missing dots before closing braces")
    
    # Fix missing spaces around operators
    before = query
    query = re.sub(r'([<>=!])([^=\s])', r'\1 \2', query)
    query = re.sub(r'([^=\s])([<>=!])', r'\1 \2', query)
    if query != before:
        fixes_applied.append("Fixed spacing around operators")
    
    # Fix FILTER syntax
    before = query
    query = re.sub(r'FILTER\s*\(([^)]+)\)', lambda m: f"FILTER({m.group(1).strip()})", query)
    if query != before:
        fixes_applied.append("Fixed FILTER syntax")
    
    # Ensure proper URI brackets
    before = query
    query = re.sub(r'([^<\s])([a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9_-]*)', r'\1 \2', query)
    if query != before:
        fixes_applied.append("Fixed URI spacing")
    
    if fixes_applied:
        print(f"   Applied fixes: {', '.join(fixes_applied)}")
    else:
        print("   No fixes needed")
    
    return query

def _add_common_prefixes(self, query: str) -> str:
    """Add common prefixes to a SPARQL query with debug output."""
    print("üìã Adding prefixes...")
    
    prefixes = []
    
    # Check if query already has PREFIX declarations
    if 'PREFIX' not in query.upper():
        print("   No existing prefixes found, adding common ones...")
        
        # Add common prefixes
        common_prefixes = {
            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
            'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
            'owl': 'http://www.w3.org/2002/07/owl#',
            'xsd': 'http://www.w3.org/2001/XMLSchema#'
        }
        
        # Add prefixes that are used in the query
        for prefix, namespace in common_prefixes.items():
            if f'{prefix}:' in query:
                prefixes.append(f'PREFIX {prefix}: <{namespace}>')
                print(f"   Added {prefix}: {namespace}")
        
        # Add custom namespaces from the graph
        for prefix, namespace in self.namespaces.items():
            if prefix and f'{prefix}:' in query and prefix not in ['rdf', 'rdfs', 'owl', 'xsd']:
                prefixes.append(f'PREFIX {prefix}: <{namespace}>')
                print(f"   Added custom {prefix}: {namespace}")
    else:
        print("   Query already has PREFIX declarations")
    
    if prefixes:
        final_query = '\n'.join(prefixes) + '\n\n' + query
        print(f"   Added {len(prefixes)} prefixes")
        return final_query
    else:
        print("   No prefixes added")
        return query

def query_with_langchain(self, question: str) -> Dict[str, Any]:
    """
    Query using LangChain's GraphSparqlQAChain with comprehensive debug logging.
    
    Args:
        question: Natural language question
        
    Returns:
        Dictionary with answer and SPARQL query
    """
    print("=" * 80)
    print("ü§ñ LANGCHAIN SPARQL QUERY DEBUG")
    print("=" * 80)
    print(f"üìù QUESTION: {question}")
    print("-" * 40)
    
    try:
        if self.sparql_chain is None:
            print("‚ùå SPARQL chain not initialized")
            return {
                'error': 'SPARQL chain not initialized',
                'answer': None,
                'sparql_query': None
            }
        
        print("üîÑ Processing with LangChain GraphSparqlQAChain...")
        logger.info(f"Processing question with LangChain: {question}")
        
        # Try the query with error handling
        result = self.sparql_chain.invoke({"query": question})
        
        print("üìä LANGCHAIN RESULT:")
        print(f"   Result keys: {list(result.keys())}")
        
        # Extract and validate the generated SPARQL query
        sparql_query = result.get('sparql_query', '')
        answer = result.get('result', '')
        
        print(f"üìù GENERATED SPARQL QUERY:")
        if sparql_query:
            print(sparql_query)
            print("-" * 40)
            
            # Clean and validate the generated query
            print("üßπ VALIDATING GENERATED QUERY...")
            cleaned_query = self._clean_and_validate_sparql_query(sparql_query)
            if not cleaned_query:
                print("‚ùå LangChain generated invalid SPARQL query")
                logger.warning("LangChain generated invalid SPARQL query")
                return {
                    'error': 'Generated SPARQL query is invalid',
                    'answer': answer,
                    'sparql_query': sparql_query,
                    'cleaned_query': cleaned_query
                }
            
            # Test the query if it's different from the original
            if cleaned_query != sparql_query:
                print("üß™ Testing cleaned SPARQL query...")
                logger.info("Testing cleaned SPARQL query...")
                try:
                    test_results = self.query_sparql(cleaned_query)
                    print(f"‚úÖ Cleaned query executed successfully with {len(test_results)} results")
                    logger.info(f"Cleaned query executed successfully with {len(test_results)} results")
                except Exception as test_error:
                    print(f"‚ùå Cleaned query still failed: {test_error}")
                    logger.warning(f"Cleaned query still failed: {test_error}")
        else:
            print("‚ö†Ô∏è No SPARQL query generated by LangChain")
        
        print(f"üí¨ GENERATED ANSWER:")
        print(f"   {answer}")
        print("=" * 80)
        
        return {
            'answer': answer,
            'sparql_query': sparql_query,
            'cleaned_query': cleaned_query if sparql_query else None,
            'error': None
        }
        
    except Exception as e:
        print(f"‚ùå LANGCHAIN QUERY FAILED: {e}")
        print(f"   Error type: {type(e).__name__}")
        print(f"   Error details: {str(e)}")
        logger.error(f"Error querying with LangChain: {e}")
        
        # Try to extract more specific error information
        error_msg = str(e)
        if "QueryBadFormed" in error_msg:
            print("üö® QUERY BAD FORMED ERROR DETECTED")
            return {
                'error': 'SPARQL query syntax error - query is malformed',
                'answer': None,
                'sparql_query': None,
                'suggestion': 'Try rephrasing your question or using simpler terms'
            }
        elif "timeout" in error_msg.lower():
            print("‚è∞ TIMEOUT ERROR DETECTED")
            return {
                'error': 'Query timeout - question may be too complex',
                'answer': None,
                'sparql_query': None,
                'suggestion': 'Try asking a more specific question'
            }
        else:
            return {
                'error': f'Query execution failed: {error_msg}',
                'answer': None,
                'sparql_query': None
            }

# Also add debug logging to the vector store SPARQL execution:
def execute_sparql_query(self, query: str) -> List[Dict[str, Any]]:
    """Execute a SPARQL query on the remote endpoint with debug logging."""
    print("=" * 80)
    print("üåê VECTOR STORE SPARQL EXECUTION")
    print("=" * 80)
    print(f"üîó ENDPOINT: {self.sparql_endpoint_url}")
    print(f"üìù QUERY TO EXECUTE:")
    print(query)
    print("-" * 40)
    
    if not SPARQLWRAPPER_AVAILABLE or not self.sparql_wrapper:
        print("‚ùå SPARQL wrapper not available or not configured")
        logger.error("SPARQL wrapper not available or not configured")
        return []
    
    try:
        print("üîÑ Setting query on SPARQLWrapper...")
        self.sparql_wrapper.setQuery(query)
        
        print("üöÄ Executing query...")
        results = self.sparql_wrapper.query()
        
        print("üì• Processing response...")
        if hasattr(results, 'response') and results.response.read():
            result_data = results.convert()
            print(f"üìä Raw result data keys: {list(result_data.keys()) if isinstance(result_data, dict) else 'Not a dict'}")
            
            # Convert to list of dictionaries
            processed_results = []
            if "results" in result_data and "bindings" in result_data["results"]:
                bindings = result_data["results"]["bindings"]
                print(f"üìã Found {len(bindings)} bindings")
                
                for i, binding in enumerate(bindings):
                    result_dict = {}
                    for var, value in binding.items():
                        result_dict[var] = value["value"]
                    processed_results.append(result_dict)
                    
                    if i < 3:  # Show first 3 results
                        print(f"   Result {i+1}: {result_dict}")
                
                print(f"‚úÖ SPARQL query successful: {len(processed_results)} results")
                print("=" * 80)
                return processed_results
            else:
                print("‚ùå Unexpected result format")
                print(f"   Expected 'results.bindings', got: {result_data}")
                print("=" * 80)
                return []
        else:
            print("‚ùå No response data")
            print("=" * 80)
            return []
            
    except SPARQLWrapperException as e:
        print(f"‚ùå SPARQL WRAPPER EXCEPTION: {e}")
        print(f"   Exception type: {type(e).__name__}")
        logger.error(f"SPARQL query execution failed: {e}")
        print("=" * 80)
        return []
    except Exception as e:
        print(f"‚ùå GENERAL EXCEPTION: {e}")
        print(f"   Exception type: {type(e).__name__}")
        logger.error(f"Error executing SPARQL query: {e}")
        print("=" * 80)
        return []





def _generate_targeted_sparql_queries(self, 
                                     query: str, 
                                     classification: Dict[str, Any], 
                                     concepts: List[str]) -> List[Dict[str, str]]:
    """Generate targeted SPARQL queries with comprehensive debug logging."""
    print("=" * 80)
    print("üîß GENERATING TARGETED SPARQL QUERIES")
    print("=" * 80)
    print(f"üìù USER QUERY: {query}")
    print(f"üéØ PRIMARY INTENT: {classification['primary_intent']}")
    print(f"üîë CONCEPTS: {concepts}")
    print("-" * 40)
    
    queries = []
    primary_intent = classification['primary_intent']
    
    try:
        if primary_intent == 'listing':
            print("üìã GENERATING LISTING QUERIES...")
            # Generate queries to list entities
            for i, concept in enumerate(concepts[:3]):  # Limit to first 3 concepts
                print(f"\n   Concept {i+1}: '{concept}'")
                
                # List classes containing the concept
                print("      üè∑Ô∏è Building list classes query...")
                classes_query = self._build_list_classes_query(concept)
                queries.append({
                    'type': 'list_classes',
                    'query': classes_query,
                    'description': f'Classes related to "{concept}"'
                })
                print("      ‚úÖ List classes query generated")
                
                # List properties containing the concept
                print("      üîó Building list properties query...")
                props_query = self._build_list_properties_query(concept)
                queries.append({
                    'type': 'list_properties',
                    'query': props_query,
                    'description': f'Properties related to "{concept}"'
                })
                print("      ‚úÖ List properties query generated")
        
        elif primary_intent == 'hierarchical':
            print("üå≥ GENERATING HIERARCHICAL QUERIES...")
            for i, concept in enumerate(concepts[:2]):
                print(f"\n   Concept {i+1}: '{concept}'")
                
                # Find subclasses
                print("      ‚¨áÔ∏è Building subclasses query...")
                sub_query = self._build_subclasses_query(concept)
                queries.append({
                    'type': 'subclasses',
                    'query': sub_query,
                    'description': f'Subclasses of classes related to "{concept}"'
                })
                print("      ‚úÖ Subclasses query generated")
                
                # Find superclasses
                print("      ‚¨ÜÔ∏è Building superclasses query...")
                super_query = self._build_superclasses_query(concept)
                queries.append({
                    'type': 'superclasses',
                    'query': super_query,
                    'description': f'Superclasses of classes related to "{concept}"'
                })
                print("      ‚úÖ Superclasses query generated")
        
        elif primary_intent == 'relationship':
            print("üîó GENERATING RELATIONSHIP QUERIES...")
            if len(concepts) >= 2:
                concept1, concept2 = concepts[0], concepts[1]
                print(f"   Concept 1: '{concept1}'")
                print(f"   Concept 2: '{concept2}'")
                
                # Find relationships between concepts
                print("      ü§ù Building relationships query...")
                rel_query = self._build_relationships_query(concept1, concept2)
                queries.append({
                    'type': 'relationships',
                    'query': rel_query,
                    'description': f'Relationships between "{concept1}" and "{concept2}"'
                })
                print("      ‚úÖ Relationships query generated")
            else:
                print("   ‚ö†Ô∏è Not enough concepts for relationship query (need at least 2)")
        
        elif primary_intent == 'count':
            print("üî¢ GENERATING COUNT QUERIES...")
            for i, concept in enumerate(concepts[:2]):
                print(f"\n   Concept {i+1}: '{concept}'")
                
                # Count entities related to concept
                print("      üìä Building count classes query...")
                count_query = self._build_count_classes_query(concept)
                queries.append({
                    'type': 'count_classes',
                    'query': count_query,
                    'description': f'Count of classes related to "{concept}"'
                })
                print("      ‚úÖ Count classes query generated")
        
        else:
            print(f"‚ö†Ô∏è UNKNOWN INTENT: {primary_intent}")
        
        print(f"\nüìä TOTAL QUERIES GENERATED: {len(queries)}")
        print("=" * 80)
        
        # Print all generated queries for debugging
        for i, query_info in enumerate(queries, 1):
            print(f"\nüîç QUERY {i}: {query_info['description']}")
            print(f"üìù TYPE: {query_info['type']}")
            print("üìÑ SPARQL:")
            print(query_info['query'])
            print("-" * 40)
        
        return queries
        
    except Exception as e:
        print(f"‚ùå ERROR GENERATING QUERIES: {e}")
        logger.error(f"Error generating SPARQL queries: {e}")
        print("=" * 80)
        return []

def _build_list_classes_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to list classes with debug output."""
    print(f"         üèóÔ∏è Building list classes query for: '{concept}'")
    
    escaped_concept = self._escape_sparql_string(concept)
    print(f"         üîí Escaped concept: '{escaped_concept}'")
    
    query = f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?class ?label WHERE {{
    ?class rdf:type owl:Class .
    OPTIONAL {{ ?class rdfs:label ?label }}
    FILTER(
        CONTAINS(LCASE(STR(?class)), LCASE("{escaped_concept}")) || 
        CONTAINS(LCASE(STR(?label)), LCASE("{escaped_concept}"))
    )
}} 
ORDER BY ?class
LIMIT 20
"""
    
    print(f"         ‚úÖ Generated query ({len(query)} chars)")
    return query

def _build_list_properties_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to list properties with debug output."""
    print(f"         üèóÔ∏è Building list properties query for: '{concept}'")
    
    escaped_concept = self._escape_sparql_string(concept)
    print(f"         üîí Escaped concept: '{escaped_concept}'")
    
    query = f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?property ?label ?type WHERE {{
    {{
        ?property rdf:type owl:ObjectProperty .
        BIND("ObjectProperty" AS ?type)
    }} UNION {{
        ?property rdf:type owl:DatatypeProperty .
        BIND("DatatypeProperty" AS ?type)
    }}
    OPTIONAL {{ ?property rdfs:label ?label }}
    FILTER(
        CONTAINS(LCASE(STR(?property)), LCASE("{escaped_concept}")) || 
        CONTAINS(LCASE(STR(?label)), LCASE("{escaped_concept}"))
    )
}} 
ORDER BY ?property
LIMIT 15
"""
    
    print(f"         ‚úÖ Generated query ({len(query)} chars)")
    return query

def _build_relationships_query(self, concept1: str, concept2: str) -> str:
    """Build a well-formed SPARQL query to find relationships with debug output."""
    print(f"         üèóÔ∏è Building relationships query for: '{concept1}' <-> '{concept2}'")
    
    escaped_concept1 = self._escape_sparql_string(concept1)
    escaped_concept2 = self._escape_sparql_string(concept2)
    print(f"         üîí Escaped concept1: '{escaped_concept1}'")
    print(f"         üîí Escaped concept2: '{escaped_concept2}'")
    
    query = f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?subject ?predicate ?object ?subjectLabel ?objectLabel WHERE {{
    ?subject ?predicate ?object .
    OPTIONAL {{ ?subject rdfs:label ?subjectLabel }}
    OPTIONAL {{ ?object rdfs:label ?objectLabel }}
    FILTER(
        (
            CONTAINS(LCASE(STR(?subject)), LCASE("{escaped_concept1}")) || 
            CONTAINS(LCASE(STR(?subjectLabel)), LCASE("{escaped_concept1}"))
        ) && (
            CONTAINS(LCASE(STR(?object)), LCASE("{escaped_concept2}")) || 
            CONTAINS(LCASE(STR(?objectLabel)), LCASE("{escaped_concept2}"))
        )
    ) || (
        (
            CONTAINS(LCASE(STR(?subject)), LCASE("{escaped_concept2}")) || 
            CONTAINS(LCASE(STR(?subjectLabel)), LCASE("{escaped_concept2}"))
        ) && (
            CONTAINS(LCASE(STR(?object)), LCASE("{escaped_concept1}")) || 
            CONTAINS(LCASE(STR(?objectLabel)), LCASE("{escaped_concept1}"))
        )
    )
    FILTER(?predicate != rdf:type)
}} 
ORDER BY ?subject ?predicate
LIMIT 20
"""
    
    print(f"         ‚úÖ Generated query ({len(query)} chars)")
    return query

def _escape_sparql_string(self, text: str) -> str:
    """Escape special characters in SPARQL string literals with debug output."""
    if not text:
        print(f"         ‚ö†Ô∏è Empty text provided for escaping")
        return ""
    
    original_text = text
    print(f"         üîí Escaping: '{original_text}'")
    
    # Replace quotes and backslashes that could break SPARQL
    text = text.replace('\\', '\\\\')  # Escape backslashes first
    text = text.replace('"', '\\"')    # Escape double quotes
    text = text.replace("'", "\\'")    # Escape single quotes
    text = text.replace('\n', '\\n')   # Escape newlines
    text = text.replace('\r', '\\r')   # Escape carriage returns
    text = text.replace('\t', '\\t')   # Escape tabs
    
    # Remove any other potentially problematic characters
    import re
    before_regex = text
    text = re.sub(r'[^\w\s\-_.]', '', text)
    
    changes = []
    if '\\\\' in text and '\\\\' not in original_text:
        changes.append("escaped backslashes")
    if '\\"' in text and '\\"' not in original_text:
        changes.append("escaped quotes")
    if before_regex != text:
        changes.append("removed special chars")
    
    if changes:
        print(f"         üîß Applied escaping: {', '.join(changes)}")
        print(f"         üì§ Result: '{text}'")
    else:
        print(f"         ‚úÖ No escaping needed")
    
    return text

# Add debug method to test all query generation:
def debug_test_all_query_types(self) -> None:
    """Test all query generation methods with debug output."""
    print("=" * 80)
    print("üß™ TESTING ALL QUERY GENERATION METHODS")
    print("=" * 80)
    
    test_cases = [
        {
            "intent": "listing",
            "concepts": ["Person", "Vehicle", "Color"],
            "description": "Test listing queries"
        },
        {
            "intent": "hierarchical", 
            "concepts": ["Animal", "Mammal"],
            "description": "Test hierarchical queries"
        },
        {
            "intent": "relationship",
            "concepts": ["Person", "hasName", "owns"],
            "description": "Test relationship queries"
        },
        {
            "intent": "count",
            "concepts": ["Class", "Property"],
            "description": "Test count queries"
        }
    ]
    
    for test_case in test_cases:
        print(f"\nüß™ TEST CASE: {test_case['description']}")
        print(f"   Intent: {test_case['intent']}")
        print(f"   Concepts: {test_case['concepts']}")
        
        try:
            classification = {'primary_intent': test_case['intent']}
            queries = self._generate_targeted_sparql_queries(
                f"test query for {test_case['intent']}", 
                classification, 
                test_case['concepts']
            )
            
            print(f"   ‚úÖ Generated {len(queries)} queries successfully")
            
            # Test each query syntax
            for i, query_info in enumerate(queries):
                try:
                    # Basic syntax validation
                    query = query_info['query']
                    
                    # Check for basic requirements
                    if 'SELECT' not in query.upper():
                        print(f"   ‚ùå Query {i+1}: Missing SELECT")
                        continue
                    
                    if query.count('{') != query.count('}'):
                        print(f"   ‚ùå Query {i+1}: Unbalanced braces")
                        continue
                    
                    print(f"   ‚úÖ Query {i+1}: Basic syntax OK")
                    
                except Exception as e:
                    print(f"   ‚ùå Query {i+1}: Validation error - {e}")
                    
        except Exception as e:
            print(f"   ‚ùå Test case failed: {e}")
    
    print("=" * 80)
