"""
HSBC OpenAI Client wrapper - FULLY FIXED VERSION
Creates properly configured clients for HSBC authentication with token refresh
Uses custom httpx transport for token management
FIXED: Proper LangChain integration
"""
import logging
import uuid
import httpx
from typing import Any, Optional
from openai import OpenAI

from .hsbc_token_service import HSBCTokenService
from ..config import Config

logger = logging.getLogger(__name__)


class TokenRefreshingHTTPClient(httpx.Client):
    """
    Custom httpx Client that handles HSBC token refresh.
    Intercepts 401 errors and retries with fresh token.
    """
    
    def __init__(self, token_service: HSBCTokenService, user_id: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.token_service = token_service
        self.user_id = user_id
        self._max_retries = 3
        logger.info("Token-refreshing HTTP client initialized")
    
    def send(self, request: httpx.Request, *args, **kwargs) -> httpx.Response:
        """
        Override send to handle token refresh on 401.
        This is the method httpx calls for every request.
        """
        retry_count = 0
        
        while retry_count < self._max_retries:
            try:
                # Get fresh token (will auto-refresh if expiring)
                force_refresh = retry_count > 0
                fresh_token = self.token_service.get_token(force_refresh=force_refresh)
                
                # Update headers with fresh token and new correlation IDs
                request.headers["X-HSBC-E2E-Trust-Token"] = fresh_token
                request.headers["Token_Type"] = "SESSION_TOKEN"
                request.headers["x-correlation-id"] = str(uuid.uuid4())
                request.headers["x-usersession-id"] = str(uuid.uuid4())
                request.headers["Content-Type"] = "application/json"
                
                if retry_count > 0:
                    logger.info(f"ðŸ”„ Retrying request with fresh token (attempt {retry_count + 1}/{self._max_retries})")
                
                # Make the actual request
                response = super().send(request, *args, **kwargs)
                
                # Check for 401 Unauthorized
                if response.status_code == 401:
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"âŒ Token refresh failed after {self._max_retries} attempts")
                        return response
                    
                    logger.warning(f"âš ï¸ Got 401 Unauthorized - refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate current token to force refresh
                    self.token_service.invalidate_token()
                    
                    # Continue to next iteration for retry
                    continue
                
                # Success or non-401 error - return response
                return response
                
            except Exception as e:
                # Check if it's an auth-related error
                error_msg = str(e).lower()
                if any(keyword in error_msg for keyword in ['unauthorized', 'token', 'expired', 'sso', 'credential']):
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"âŒ Request failed after {self._max_retries} token refresh attempts")
                        raise
                    
                    logger.warning(f"âš ï¸ Authentication error: {e}")
                    logger.warning(f"   Refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate and retry
                    self.token_service.invalidate_token()
                    continue
                else:
                    # Not an auth error, raise immediately
                    raise
        
        # Should not reach here, but just in case
        raise Exception(f"Request failed after {self._max_retries} attempts")


def create_hsbc_client() -> OpenAI:
    """
    Factory function to create OpenAI client with HSBC authentication and token refresh.
    
    Returns:
        OpenAI: Standard OpenAI client with custom HTTP client for token management
    """
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("Creating HSBC token service...")
    
    token_service = HSBCTokenService(
        token_endpoint=Config.HSBC_TOKEN_ENDPOINT,
        username=Config.HSBC_USERNAME,
        password=Config.HSBC_PASSWORD,
        token_buffer_seconds=300  # Refresh 5 minutes before expiry
    )
    
    # Get initial token
    initial_token = token_service.get_token()
    
    # Get base httpx client from token service (has truststore SSL)
    base_httpx_client = token_service.get_httpx_client()
    
    # Create custom httpx client with token refresh capability
    logger.info("Creating custom HTTP client with token refresh...")
    custom_httpx_client = TokenRefreshingHTTPClient(
        token_service=token_service,
        user_id=Config.HSBC_USER_ID,
        http2=True,
        timeout=30.0,
        verify=base_httpx_client._transport._pool._ssl_context  # Use truststore SSL context
    )
    
    # Initial headers
    default_headers = {
        "X-HSBC-E2E-Trust-Token": initial_token,
        "Token_Type": "SESSION_TOKEN",
        "x-correlation-id": str(uuid.uuid4()),
        "x-usersession-id": str(uuid.uuid4()),
        "Content-Type": "application/json"
    }
    
    logger.info("Creating OpenAI client with HSBC authentication...")
    
    # Create standard OpenAI client with custom http client
    client = OpenAI(
        api_key=initial_token,
        base_url=Config.BASE_URL,
        http_client=custom_httpx_client,
        default_headers=default_headers
    )
    
    # Store token service reference for external access if needed
    client._hsbc_token_service = token_service
    client._hsbc_user_id = Config.HSBC_USER_ID
    
    logger.info(f"âœ“ HSBC OpenAI Client initialized")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User ID: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: âœ“ Automatic on 401")
    
    return client


def create_langchain_client():
    """
    Create a properly configured ChatOpenAI instance for LangChain
    WITH automatic token refresh through custom HTTP client
    
    FIXED: Properly integrates with LangChain's expected client structure
    
    Returns:
        ChatOpenAI instance configured for HSBC with token management
    """
    from langchain_openai import ChatOpenAI
    
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("=" * 60)
    logger.info("Creating LangChain ChatOpenAI with HSBC authentication")
    logger.info("=" * 60)
    
    # Create the HSBC client with custom HTTP client
    hsbc_openai_client = create_hsbc_client()
    
    logger.info(f"LangChain client configuration:")
    logger.info(f"  Model: {Config.CHAT_MODEL}")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: âœ“ Enabled (auto-refresh on 401)")
    
    # Get initial token for LangChain initialization
    initial_token = hsbc_openai_client._hsbc_token_service.get_token()
    
    # CRITICAL: Create ChatOpenAI and pass the HSBC OpenAI client directly
    # LangChain will use this client for all API calls
    llm = ChatOpenAI(
        model=Config.CHAT_MODEL,
        openai_api_key=initial_token,  # Initial token (will be refreshed by client)
        openai_api_base=Config.BASE_URL,
        # Pass our custom client that has token refresh built in
        client=hsbc_openai_client,
        model_kwargs={
            "user": Config.HSBC_USER_ID
        }
    )
    
    # Store references for external access
    llm._hsbc_openai_client = hsbc_openai_client
    llm._hsbc_token_service = hsbc_openai_client._hsbc_token_service
    
    # Create a wrapper for the _generate method to update the API key
    # This ensures LangChain always has the latest token
    original_generate = llm._generate
    
    def wrapped_generate(*args, **kwargs):
        """Wrap generate to ensure fresh token in LangChain's API key"""
        try:
            # Get fresh token and update
            fresh_token = hsbc_openai_client._hsbc_token_service.get_token()
            llm.openai_api_key = fresh_token
            
            # Call original generate
            return original_generate(*args, **kwargs)
        except Exception as e:
            logger.error(f"Error in wrapped generate: {e}")
            raise
    
    llm._generate = wrapped_generate
    
    logger.info("=" * 60)
    logger.info("âœ“ LangChain ChatOpenAI created with HSBC token management")
    logger.info("  Custom HTTP client with automatic token refresh")
    logger.info("  All requests will auto-retry on 401 errors")
    logger.info("=" * 60)
    
    return llm
