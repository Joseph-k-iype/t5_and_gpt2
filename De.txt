def query_sparql(self, query: str) -> List[Dict[str, Any]]:
    """
    Execute a SPARQL query on the graph or remote endpoint with improved error handling.
    
    Args:
        query: SPARQL query string
        
    Returns:
        List of result dictionaries
    """
    # Clean and validate the query first
    cleaned_query = self._clean_and_validate_sparql_query(query)
    if not cleaned_query:
        logger.error(f"Invalid SPARQL query: {query}")
        return []
    
    # Try to use remote SPARQL endpoint first if available
    if (self.vector_store and 
        hasattr(self.vector_store, 'execute_sparql_query') and
        self.vector_store.sparql_endpoint_url):
        
        try:
            logger.info("Executing SPARQL query on remote endpoint")
            logger.debug(f"Query: {cleaned_query}")
            return self.vector_store.execute_sparql_query(cleaned_query)
        except Exception as e:
            logger.warning(f"Remote SPARQL query failed: {e}")
            logger.info("Falling back to local graph")
    
    # Fallback to local graph
    try:
        logger.info("Executing SPARQL query on local graph")
        logger.debug(f"Query: {cleaned_query}")
        
        results = []
        
        # Add common prefixes to the query if not present
        query_with_prefixes = self._add_common_prefixes(cleaned_query)
        
        query_result = self.graph.query(query_with_prefixes)
        
        for row in query_result:
            result_dict = {}
            for i, var in enumerate(query_result.vars):
                value = row[i]
                if value is not None:
                    if isinstance(value, URIRef):
                        result_dict[str(var)] = str(value)
                    elif isinstance(value, Literal):
                        result_dict[str(var)] = str(value)
                    else:
                        result_dict[str(var)] = str(value)
                else:
                    result_dict[str(var)] = None
            results.append(result_dict)
        
        logger.debug(f"Local SPARQL query returned {len(results)} results")
        return results
        
    except Exception as e:
        logger.error(f"Error executing SPARQL query on local graph: {e}")
        logger.error(f"Query was: {cleaned_query}")
        return []

def _clean_and_validate_sparql_query(self, query: str) -> str:
    """Clean and validate a SPARQL query."""
    if not query or not query.strip():
        return ""
    
    # Remove excessive whitespace and normalize
    import re
    query = re.sub(r'\s+', ' ', query.strip())
    
    # Basic validation - must contain SELECT, ASK, CONSTRUCT, or DESCRIBE
    query_upper = query.upper()
    if not any(keyword in query_upper for keyword in ['SELECT', 'ASK', 'CONSTRUCT', 'DESCRIBE']):
        logger.error("Query must contain SELECT, ASK, CONSTRUCT, or DESCRIBE")
        return ""
    
    # Check for balanced braces
    if query.count('{') != query.count('}'):
        logger.error("Unbalanced braces in SPARQL query")
        return ""
    
    # Fix common issues
    query = self._fix_common_sparql_issues(query)
    
    return query

def _fix_common_sparql_issues(self, query: str) -> str:
    """Fix common SPARQL syntax issues."""
    import re
    
    # Fix missing dots before closing braces
    query = re.sub(r'([^\s\.])\s*}', r'\1 . }', query)
    
    # Fix missing spaces around operators
    query = re.sub(r'([<>=!])([^=\s])', r'\1 \2', query)
    query = re.sub(r'([^=\s])([<>=!])', r'\1 \2', query)
    
    # Fix FILTER syntax
    query = re.sub(r'FILTER\s*\(([^)]+)\)', lambda m: f"FILTER({m.group(1).strip()})", query)
    
    # Ensure proper URI brackets
    query = re.sub(r'([^<\s])([a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9_-]*)', r'\1 \2', query)
    
    return query

def _add_common_prefixes(self, query: str) -> str:
    """Add common prefixes to a SPARQL query if they're not already present."""
    prefixes = []
    
    # Check if query already has PREFIX declarations
    if 'PREFIX' not in query.upper():
        # Add common prefixes
        common_prefixes = {
            'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
            'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
            'owl': 'http://www.w3.org/2002/07/owl#',
            'xsd': 'http://www.w3.org/2001/XMLSchema#'
        }
        
        # Add prefixes that are used in the query
        for prefix, namespace in common_prefixes.items():
            if f'{prefix}:' in query:
                prefixes.append(f'PREFIX {prefix}: <{namespace}>')
        
        # Add custom namespaces from the graph
        for prefix, namespace in self.namespaces.items():
            if prefix and f'{prefix}:' in query and prefix not in ['rdf', 'rdfs', 'owl', 'xsd']:
                prefixes.append(f'PREFIX {prefix}: <{namespace}>')
    
    if prefixes:
        return '\n'.join(prefixes) + '\n\n' + query
    return query

def query_with_langchain(self, question: str) -> Dict[str, Any]:
    """
    Query using LangChain's GraphSparqlQAChain with improved error handling.
    
    Args:
        question: Natural language question
        
    Returns:
        Dictionary with answer and SPARQL query
    """
    try:
        if self.sparql_chain is None:
            return {
                'error': 'SPARQL chain not initialized',
                'answer': None,
                'sparql_query': None
            }
        
        logger.info(f"Processing question with LangChain: {question}")
        
        # Try the query with error handling
        result = self.sparql_chain.invoke({"query": question})
        
        # Extract and validate the generated SPARQL query
        sparql_query = result.get('sparql_query', '')
        if sparql_query:
            # Clean and validate the generated query
            cleaned_query = self._clean_and_validate_sparql_query(sparql_query)
            if not cleaned_query:
                logger.warning("LangChain generated invalid SPARQL query")
                return {
                    'error': 'Generated SPARQL query is invalid',
                    'answer': result.get('result', ''),
                    'sparql_query': sparql_query,
                    'cleaned_query': cleaned_query
                }
            
            # Test the query if it's different from the original
            if cleaned_query != sparql_query:
                logger.info("Testing cleaned SPARQL query...")
                try:
                    test_results = self.query_sparql(cleaned_query)
                    logger.info(f"Cleaned query executed successfully with {len(test_results)} results")
                except Exception as test_error:
                    logger.warning(f"Cleaned query still failed: {test_error}")
        
        return {
            'answer': result.get('result', ''),
            'sparql_query': sparql_query,
            'cleaned_query': cleaned_query if sparql_query else None,
            'error': None
        }
        
    except Exception as e:
        logger.error(f"Error querying with LangChain: {e}")
        
        # Try to extract more specific error information
        error_msg = str(e)
        if "QueryBadFormed" in error_msg:
            return {
                'error': 'SPARQL query syntax error - query is malformed',
                'answer': None,
                'sparql_query': None,
                'suggestion': 'Try rephrasing your question or using simpler terms'
            }
        elif "timeout" in error_msg.lower():
            return {
                'error': 'Query timeout - question may be too complex',
                'answer': None,
                'sparql_query': None,
                'suggestion': 'Try asking a more specific question'
            }
        else:
            return {
                'error': f'Query execution failed: {error_msg}',
                'answer': None,
                'sparql_query': None
            }

def test_sparql_endpoint(self) -> Dict[str, Any]:
    """Test SPARQL endpoint with a simple, safe query."""
    try:
        # Simple test query that should work on any RDF endpoint
        test_query = """
        SELECT ?s ?p ?o 
        WHERE { 
            ?s ?p ?o 
        } 
        LIMIT 1
        """
        
        logger.info("Testing SPARQL endpoint with simple query...")
        results = self.query_sparql(test_query)
        
        if results:
            return {
                'success': True,
                'message': f'SPARQL endpoint working - returned {len(results)} results',
                'sample_result': results[0] if results else None
            }
        else:
            return {
                'success': False,
                'message': 'SPARQL endpoint returned no results',
                'query_used': test_query
            }
            
    except Exception as e:
        logger.error(f"SPARQL endpoint test failed: {e}")
        return {
            'success': False,
            'message': f'SPARQL endpoint test failed: {e}',
            'error_type': type(e).__name__
        }

def validate_sparql_query_syntax(self, query: str) -> Dict[str, Any]:
    """Validate SPARQL query syntax without executing it."""
    try:
        from rdflib.plugins.sparql import prepareQuery
        
        # Clean the query first
        cleaned_query = self._clean_and_validate_sparql_query(query)
        if not cleaned_query:
            return {
                'valid': False,
                'error': 'Query failed basic validation',
                'original_query': query
            }
        
        # Add prefixes
        query_with_prefixes = self._add_common_prefixes(cleaned_query)
        
        # Try to parse the query
        try:
            prepared_query = prepareQuery(query_with_prefixes)
            return {
                'valid': True,
                'message': 'Query syntax is valid',
                'cleaned_query': cleaned_query,
                'query_with_prefixes': query_with_prefixes
            }
        except Exception as parse_error:
            return {
                'valid': False,
                'error': f'SPARQL parsing error: {parse_error}',
                'cleaned_query': cleaned_query,
                'query_with_prefixes': query_with_prefixes
            }
            
    except Exception as e:
        return {
            'valid': False,
            'error': f'Query validation failed: {e}',
            'original_query': query
        }








def _generate_targeted_sparql_queries(self, 
                                     query: str, 
                                     classification: Dict[str, Any], 
                                     concepts: List[str]) -> List[Dict[str, str]]:
    """Generate targeted SPARQL queries based on query classification with improved syntax."""
    queries = []
    primary_intent = classification['primary_intent']
    
    try:
        if primary_intent == 'listing':
            # Generate queries to list entities
            for concept in concepts[:3]:  # Limit to first 3 concepts
                # List classes containing the concept
                queries.append({
                    'type': 'list_classes',
                    'query': self._build_list_classes_query(concept),
                    'description': f'Classes related to "{concept}"'
                })
                
                # List properties containing the concept
                queries.append({
                    'type': 'list_properties',
                    'query': self._build_list_properties_query(concept),
                    'description': f'Properties related to "{concept}"'
                })
        
        elif primary_intent == 'hierarchical':
            for concept in concepts[:2]:
                # Find subclasses
                queries.append({
                    'type': 'subclasses',
                    'query': self._build_subclasses_query(concept),
                    'description': f'Subclasses of classes related to "{concept}"'
                })
                
                # Find superclasses
                queries.append({
                    'type': 'superclasses',
                    'query': self._build_superclasses_query(concept),
                    'description': f'Superclasses of classes related to "{concept}"'
                })
        
        elif primary_intent == 'relationship':
            if len(concepts) >= 2:
                concept1, concept2 = concepts[0], concepts[1]
                # Find relationships between concepts
                queries.append({
                    'type': 'relationships',
                    'query': self._build_relationships_query(concept1, concept2),
                    'description': f'Relationships between "{concept1}" and "{concept2}"'
                })
        
        elif primary_intent == 'count':
            for concept in concepts[:2]:
                # Count entities related to concept
                queries.append({
                    'type': 'count_classes',
                    'query': self._build_count_classes_query(concept),
                    'description': f'Count of classes related to "{concept}"'
                })
        
        return queries
        
    except Exception as e:
        logger.error(f"Error generating SPARQL queries: {e}")
        return []

def _build_list_classes_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to list classes."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?class ?label WHERE {{
    ?class rdf:type owl:Class .
    OPTIONAL {{ ?class rdfs:label ?label }}
    FILTER(
        CONTAINS(LCASE(STR(?class)), LCASE("{self._escape_sparql_string(concept)}")) || 
        CONTAINS(LCASE(STR(?label)), LCASE("{self._escape_sparql_string(concept)}"))
    )
}} 
ORDER BY ?class
LIMIT 20
"""

def _build_list_properties_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to list properties."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?property ?label ?type WHERE {{
    {{
        ?property rdf:type owl:ObjectProperty .
        BIND("ObjectProperty" AS ?type)
    }} UNION {{
        ?property rdf:type owl:DatatypeProperty .
        BIND("DatatypeProperty" AS ?type)
    }}
    OPTIONAL {{ ?property rdfs:label ?label }}
    FILTER(
        CONTAINS(LCASE(STR(?property)), LCASE("{self._escape_sparql_string(concept)}")) || 
        CONTAINS(LCASE(STR(?label)), LCASE("{self._escape_sparql_string(concept)}"))
    )
}} 
ORDER BY ?property
LIMIT 15
"""

def _build_subclasses_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to find subclasses."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?subclass ?label WHERE {{
    ?class rdf:type owl:Class .
    ?subclass rdfs:subClassOf ?class .
    ?subclass rdf:type owl:Class .
    OPTIONAL {{ ?subclass rdfs:label ?label }}
    OPTIONAL {{ ?class rdfs:label ?classLabel }}
    FILTER(
        CONTAINS(LCASE(STR(?class)), LCASE("{self._escape_sparql_string(concept)}")) || 
        CONTAINS(LCASE(STR(?classLabel)), LCASE("{self._escape_sparql_string(concept)}"))
    )
}} 
ORDER BY ?subclass
LIMIT 15
"""

def _build_superclasses_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to find superclasses."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?superclass ?label WHERE {{
    ?class rdf:type owl:Class .
    ?class rdfs:subClassOf ?superclass .
    ?superclass rdf:type owl:Class .
    OPTIONAL {{ ?superclass rdfs:label ?label }}
    OPTIONAL {{ ?class rdfs:label ?classLabel }}
    FILTER(
        CONTAINS(LCASE(STR(?class)), LCASE("{self._escape_sparql_string(concept)}")) || 
        CONTAINS(LCASE(STR(?classLabel)), LCASE("{self._escape_sparql_string(concept)}"))
    )
}} 
ORDER BY ?superclass
LIMIT 15
"""

def _build_relationships_query(self, concept1: str, concept2: str) -> str:
    """Build a well-formed SPARQL query to find relationships between concepts."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT ?subject ?predicate ?object ?subjectLabel ?objectLabel WHERE {{
    ?subject ?predicate ?object .
    OPTIONAL {{ ?subject rdfs:label ?subjectLabel }}
    OPTIONAL {{ ?object rdfs:label ?objectLabel }}
    FILTER(
        (
            CONTAINS(LCASE(STR(?subject)), LCASE("{self._escape_sparql_string(concept1)}")) || 
            CONTAINS(LCASE(STR(?subjectLabel)), LCASE("{self._escape_sparql_string(concept1)}"))
        ) && (
            CONTAINS(LCASE(STR(?object)), LCASE("{self._escape_sparql_string(concept2)}")) || 
            CONTAINS(LCASE(STR(?objectLabel)), LCASE("{self._escape_sparql_string(concept2)}"))
        )
    ) || (
        (
            CONTAINS(LCASE(STR(?subject)), LCASE("{self._escape_sparql_string(concept2)}")) || 
            CONTAINS(LCASE(STR(?subjectLabel)), LCASE("{self._escape_sparql_string(concept2)}"))
        ) && (
            CONTAINS(LCASE(STR(?object)), LCASE("{self._escape_sparql_string(concept1)}")) || 
            CONTAINS(LCASE(STR(?objectLabel)), LCASE("{self._escape_sparql_string(concept1)}"))
        )
    )
    FILTER(?predicate != rdf:type)
}} 
ORDER BY ?subject ?predicate
LIMIT 20
"""

def _build_count_classes_query(self, concept: str) -> str:
    """Build a well-formed SPARQL query to count classes."""
    return f"""
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

SELECT (COUNT(DISTINCT ?class) AS ?count) WHERE {{
    ?class rdf:type owl:Class .
    OPTIONAL {{ ?class rdfs:label ?label }}
    FILTER(
        CONTAINS(LCASE(STR(?class)), LCASE("{self._escape_sparql_string(concept)}")) || 
        CONTAINS(LCASE(STR(?label)), LCASE("{self._escape_sparql_string(concept)}"))
    )
}}
"""

def _escape_sparql_string(self, text: str) -> str:
    """Escape special characters in SPARQL string literals."""
    if not text:
        return ""
    
    # Replace quotes and backslashes that could break SPARQL
    text = text.replace('\\', '\\\\')  # Escape backslashes first
    text = text.replace('"', '\\"')    # Escape double quotes
    text = text.replace("'", "\\'")    # Escape single quotes
    text = text.replace('\n', '\\n')   # Escape newlines
    text = text.replace('\r', '\\r')   # Escape carriage returns
    text = text.replace('\t', '\\t')   # Escape tabs
    
    # Remove any other potentially problematic characters
    import re
    text = re.sub(r'[^\w\s\-_.]', '', text)
    
    return text

def test_sparql_query_generation(self) -> Dict[str, Any]:
    """Test SPARQL query generation with various inputs."""
    try:
        test_results = {}
        
        # Test basic query generation
        test_cases = [
            ("listing", ["Person", "Class"]),
            ("hierarchical", ["Animal", "Vehicle"]),
            ("relationship", ["Person", "hasName"]),
            ("count", ["Property"])
        ]
        
        for intent, concepts in test_cases:
            try:
                classification = {'primary_intent': intent}
                queries = self._generate_targeted_sparql_queries("test query", classification, concepts)
                
                test_results[intent] = {
                    'success': True,
                    'query_count': len(queries),
                    'queries': [q['query'] for q in queries]
                }
                
                # Test syntax validation for each query
                for query_info in queries:
                    validation = self.rdf_manager.validate_sparql_query_syntax(query_info['query'])
                    if not validation.get('valid', False):
                        test_results[intent]['syntax_errors'] = test_results[intent].get('syntax_errors', [])
                        test_results[intent]['syntax_errors'].append(validation.get('error', 'Unknown error'))
                        
            except Exception as e:
                test_results[intent] = {
                    'success': False,
                    'error': str(e)
                }
        
        return {
            'overall_success': all(result.get('success', False) for result in test_results.values()),
            'test_results': test_results
        }
        
    except Exception as e:
        return {
            'overall_success': False,
            'error': str(e)
        }
