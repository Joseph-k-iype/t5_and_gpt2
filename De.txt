from rdflib import Graph, URIRef, RDF, RDFS, OWL, XSD
from rdflib.namespace import NamespaceManager
import argparse

def extract_ontology_schema(input_ttl, output_ttl):
    """
    Extract ontology schema (classes, subclasses, object properties, data properties) 
    from a TTL file and save as a new TTL file.
    
    Args:
        input_ttl (str): Path to input TTL file
        output_ttl (str): Path to output TTL file
    """
    
    # Load the ontology
    g = Graph()
    g.parse(input_ttl, format="turtle")
    
    # Create a new graph for the schema
    schema_graph = Graph()
    
    # Copy namespaces from original graph
    for prefix, namespace in g.namespace_manager.namespaces():
        schema_graph.bind(prefix, namespace)
    
    # Extract classes and subclasses
    classes_extracted = set()
    
    # Get all owl:Class entities
    for cls in g.subjects(RDF.type, OWL.Class):
        if isinstance(cls, URIRef):  # Only include URI resources, not blank nodes
            classes_extracted.add(cls)
            # Add the class declaration
            schema_graph.add((cls, RDF.type, OWL.Class))
    
    # Get all rdfs:Class entities (for completeness)
    for cls in g.subjects(RDF.type, RDFS.Class):
        if isinstance(cls, URIRef):
            classes_extracted.add(cls)
            schema_graph.add((cls, RDF.type, RDFS.Class))
    
    # Extract subclass relationships
    for subcls, supercls in g.subject_objects(RDFS.subClassOf):
        if (isinstance(subcls, URIRef) and isinstance(supercls, URIRef) and
            subcls in classes_extracted and supercls in classes_extracted):
            schema_graph.add((subcls, RDFS.subClassOf, supercls))
    
    # Extract object properties
    for prop in g.subjects(RDF.type, OWL.ObjectProperty):
        if isinstance(prop, URIRef):
            schema_graph.add((prop, RDF.type, OWL.ObjectProperty))
            
            # Extract domain and range for object properties
            for domain in g.objects(prop, RDFS.domain):
                if isinstance(domain, URIRef) and domain in classes_extracted:
                    schema_graph.add((prop, RDFS.domain, domain))
            
            for range_obj in g.objects(prop, RDFS.range):
                if isinstance(range_obj, URIRef) and range_obj in classes_extracted:
                    schema_graph.add((prop, RDFS.range, range_obj))
            
            # Extract subproperty relationships
            for superprop in g.objects(prop, RDFS.subPropertyOf):
                if isinstance(superprop, URIRef):
                    schema_graph.add((prop, RDFS.subPropertyOf, superprop))
    
    # Extract data properties
    for prop in g.subjects(RDF.type, OWL.DatatypeProperty):
        if isinstance(prop, URIRef):
            schema_graph.add((prop, RDF.type, OWL.DatatypeProperty))
            
            # Extract domain and range for data properties
            for domain in g.objects(prop, RDFS.domain):
                if isinstance(domain, URIRef) and domain in classes_extracted:
                    schema_graph.add((prop, RDFS.domain, domain))
            
            for range_obj in g.objects(prop, RDFS.range):
                # For data properties, range can be datatypes like xsd:string
                if isinstance(range_obj, URIRef):
                    schema_graph.add((prop, RDFS.range, range_obj))
            
            # Extract subproperty relationships
            for superprop in g.objects(prop, RDFS.subPropertyOf):
                if isinstance(superprop, URIRef):
                    schema_graph.add((prop, RDFS.subPropertyOf, superprop))
    
    # Extract annotation properties (optional but useful for schema)
    for prop in g.subjects(RDF.type, OWL.AnnotationProperty):
        if isinstance(prop, URIRef):
            schema_graph.add((prop, RDF.type, OWL.AnnotationProperty))
    
    # Extract ontology header information
    for ontology in g.subjects(RDF.type, OWL.Ontology):
        schema_graph.add((ontology, RDF.type, OWL.Ontology))
        
        # Copy ontology annotations (title, version, imports, etc.)
        for p, o in g.predicate_objects(ontology):
            if p in [OWL.versionInfo, RDFS.label, RDFS.comment, OWL.imports]:
                schema_graph.add((ontology, p, o))
    
    # Save the schema graph
    schema_graph.serialize(destination=output_ttl, format="turtle", encoding="utf-8")
    
    # Print summary
    print(f"Schema extraction completed!")
    print(f"Classes extracted: {len(list(schema_graph.subjects(RDF.type, OWL.Class)) + list(schema_graph.subjects(RDF.type, RDFS.Class)))}")
    print(f"Subclass relationships: {len(list(schema_graph.subject_objects(RDFS.subClassOf)))}")
    print(f"Object properties: {len(list(schema_graph.subjects(RDF.type, OWL.ObjectProperty)))}")
    print(f"Data properties: {len(list(schema_graph.subjects(RDF.type, OWL.DatatypeProperty)))}")
    print(f"Output saved to: {output_ttl}")

def main():
    parser = argparse.ArgumentParser(description="Extract ontology schema from a TTL file")
    parser.add_argument("input", help="Input TTL file path")
    parser.add_argument("output", help="Output TTL file path")
    
    args = parser.parse_args()
    
    try:
        extract_ontology_schema(args.input, args.output)
    except Exception as e:
        print(f"Error: {e}")
        print("Make sure the input file exists and is a valid TTL file.")

if __name__ == "__main__":
    main()
