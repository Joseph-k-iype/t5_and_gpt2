"""
Enhancer Agent - Enhances data elements to meet ISO/IEC 11179 standards.
"""

import re
import os
import logging
import pandas as pd
import asyncio
from typing import Dict, Any, List, Tuple, Optional
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import AzureChatOpenAI
from app.core.models import DataElement, EnhancementResult, ValidationResult, DataQualityStatus, Process
from app.agents.validator_agent import ValidatorAgent
from app.utils.cache import cache_manager

logger = logging.getLogger(__name__)

class EnhancerAgent:
    """
    Agent that enhances data elements to meet ISO/IEC 11179 standards.
    """

    def __init__(self, llm: AzureChatOpenAI, acronym_file_path=None):
        """
        Initialize the enhancer agent.

        Args:
            llm: Language model instance
            acronym_file_path: Path to acronym definitions file
        """
        self.llm = llm
        self.acronyms = self._load_acronyms(acronym_file_path)
        self._setup_enhancement_chain()
        # Initialize validator agent for quality feedback
        self.validator = ValidatorAgent(llm)

    def _load_acronyms(self, acronym_file_path=None):
        """
        Load acronyms and their definitions from a CSV file.

        Args:
            acronym_file_path: Path to acronym definitions file

        Returns:
            Dict mapping acronyms to definitions
        """
        acronyms = {}
        try:
            # Use default path if not provided
            if not acronym_file_path:
                # Try to construct path relative to this file's directory if needed
                base_dir = os.path.dirname(os.path.abspath(__file__))
                default_path = os.path.join(base_dir, "..", "..", "data", "acronyms.csv") # Adjusted path
                acronym_file_path = default_path
            
            # Normalize path
            acronym_file_path = os.path.normpath(acronym_file_path)

            if os.path.exists(acronym_file_path):
                df = pd.read_csv(acronym_file_path)
                if 'acronym' in df.columns and 'definition' in df.columns:
                    for acronym, group in df.groupby('acronym'):
                        acronyms[acronym.strip().upper()] = group['definition'].tolist()
                    logger.info(f"Loaded {len(acronyms)} acronyms from {acronym_file_path}")
                else:
                    logger.warning(f"CSV file {acronym_file_path} does not contain required columns 'acronym' and 'definition'")
            else:
                logger.warning(f"Acronym file not found at {acronym_file_path}")
        except Exception as e:
            logger.error(f"Error loading acronyms from {acronym_file_path}: {e}")
        return acronyms

    def _setup_enhancement_chain(self):
        """Set up the LangChain chain for enhancement."""
        template = """
        You are an expert in data governance and ISO/IEC 11179 metadata standards. Your task is to enhance the
        given data element name and description to meet these standards and represent high-quality metadata.

        **ISO/IEC 11179 Standards for Data Element Names (Business-Friendly Adaptation):**
        1.  **Format:** Names MUST be in lowercase with single spaces between words.
        2.  **No Technical Casing:** Names MUST NOT use technical formatting like camelCase, snake_case, or PascalCase.
        3.  **No Special Characters:** Names MUST NOT contain underscores, hyphens, or any special characters (e.g., %, &, *, #, /). Only alphanumeric characters and spaces are allowed.
        4.  **Clarity & Unambiguity:** Names should be clear, unambiguous, and self-describing. Avoid vague terms.
        5.  **Acronyms/Abbreviations:** Avoid acronyms or abbreviations unless they are universally understood within the business context (e.g., ID, URL, SKU). If used, ensure they are common knowledge.
        6.  **Conciseness & Descriptiveness:** Names should be concise yet descriptive enough to convey meaning.
        7.  **Standard Terminology:** Use standard terminology relevant to the data element's domain.
        8.  **Business Language:** Use business language that non-technical users can easily understand.

        **ISO/IEC 11179 Standards for Data Element Descriptions:**
        1.  **Clarity of Definition:** Descriptions MUST clearly and precisely define what the data element represents.
        2.  **Completeness:** Descriptions should be complete, fully covering the concept of the data element.
        3.  **Precision:** Descriptions should be specific enough to distinguish the data element from other related concepts.
        4.  **Objectivity:** Descriptions must be objective and factual, not based on opinion.
        5.  **Grammar & Punctuation:** Descriptions MUST use complete sentences with proper grammar and punctuation. Each description should start with a capital letter and end with a period.
        6.  **Business Language:** Descriptions should be written in clear business language, avoiding technical jargon.
        7.  **Avoid Vague Language:** Do not use imprecise phrases like "etc.", "and so on", or "various".

        **Data Element to Enhance:**
        - ID: {id}
        - Current Name: {name}
        - Current Description: {description}
        - Example (if provided): {example}
        {processes_info}

        **Additional Context:**
        {additional_context}

        **Validation Feedback (from previous enhancement attempts, if any):**
        {validation_feedback}

        **Acronym Information (expand appropriately):**
        {acronym_info}

        **Examples of High-Quality Enhanced Data Elements:**
        * Original Name: cust_id
            Enhanced Name: customer identifier
            Original Description: Customer ID in the system
            Enhanced Description: A unique alphanumeric code assigned to identify an individual customer within the organization's systems.
            Quality Assessment: GOOD
        * Original Name: LN
            Enhanced Name: last name
            Original Description: Last name
            Enhanced Description: The legal surname of an individual as it appears on official identification documents.
            Quality Assessment: GOOD
        * Original Name: trans_amt
            Enhanced Name: transaction amount
            Original Description: The $ amnt of the trans.
            Enhanced Description: The monetary value of a financial transaction, expressed in the currency of the transaction.
            Quality Assessment: GOOD
        * Original Name: DOB
            Enhanced Name: date of birth
            Original Description: DOB of customer
            Enhanced Description: The specific calendar date on which an individual was born, typically recorded in a standardized date format.
            Quality Assessment: GOOD

        **Instructions for Enhancement:**
        1.  Analyze the "Current Name" and "Current Description" along with any provided "Example", "Processes Info", "Acronym Information", and "Validation Feedback".
        2.  Create an "Enhanced Name" that strictly adheres to all the ISO/IEC 11179 name standards listed above. It must be plain text.
        3.  Create an "Enhanced Description" that strictly adheres to all the ISO/IEC 11179 description standards. It must be plain text, start with a capital letter, and end with a period.
        4.  Expand acronyms and abbreviations based on the "Acronym Information" or common knowledge, unless the acronym is universally understood (e.g., ID, URL).
        5.  Ensure the enhanced element would receive a "GOOD" quality assessment if re-validated.
        6.  The language should be business-friendly and easily understood by non-technical users.
        7.  Use the "Example" and "Processes Info" to provide context for your enhancements.

        **Output Format:**
        Provide your response *strictly* in the following format, with each item on a new line. Do not include any extra formatting, numbering, or markdown like asterisks:
        Enhanced Name: [Provide the improved name as plain text here]
        Enhanced Description: [Provide the improved description as plain text here. Start with a capital and end with a period.]
        Enhancement Notes: [Explain the changes made and why they align with the standards and improve quality. Be specific.]
        Confidence Score (0.0-1.0): [Provide a numerical confidence score for your enhancement, e.g., 0.9]
        """

        self.enhancement_prompt = PromptTemplate(
            input_variables=[
                "id", "name", "description", "example", "processes_info",
                "validation_feedback", "acronym_info", "additional_context"
            ],
            template=template)
        self.enhancement_chain = self.enhancement_prompt | self.llm | StrOutputParser()

    def _prepare_acronym_info(self, data_element: DataElement) -> str:
        name = data_element.existing_name or ""
        description = data_element.existing_description or ""
        potential_acronyms = set(re.findall(r'\b[A-Z]{2,5}\b', name + " " + description))
        
        if not self.acronyms and not potential_acronyms:
            return "No specific acronym information provided for this element. Expand acronyms based on common business understanding."

        acronym_info_parts = []
        if potential_acronyms:
            found_in_element = False
            for acronym in potential_acronyms:
                if acronym.upper() in self.acronyms:
                    definitions = self.acronyms[acronym.upper()]
                    found_in_element = True
                    if len(definitions) == 1:
                        acronym_info_parts.append(f"- {acronym}: {definitions[0]}")
                    else:
                        def_list_str = "; ".join(definitions)
                        acronym_info_parts.append(f"- {acronym}: (Multiple: {def_list_str}) - Choose the most contextually relevant.")
            if found_in_element:
                 acronym_info = "Acronyms detected in the element with known definitions:\n" + "\n".join(acronym_info_parts)
            else:
                acronym_info = "No definitions found for acronyms detected in the element. Expand based on common knowledge if possible."
        else:
            acronym_info = "No specific acronyms detected in the element itself."
        
        # Add a small sample of general acronyms if space allows and relevant
        if self.acronyms:
            sample_acronyms = []
            count = 0
            for acr, defs in self.acronyms.items():
                if acr not in potential_acronyms and count < 5: # Limit sample size
                    sample_acronyms.append(f"- {acr}: {defs[0] if defs else 'N/A'}")
                    count +=1
            if sample_acronyms:
                 acronym_info += "\n\nSample of other known acronyms (for general awareness):\n" + "\n".join(sample_acronyms)

        acronym_info += "\n\nGeneral Acronym Handling Rule: Expand all acronyms unless they are universally understood in a business context (e.g., ID, URL, KPI, ETA, VAT, SKU, API)."
        return acronym_info


    def _format_processes_info(self, data_element: DataElement) -> str:
        if not data_element.processes:
            return "Related Processes: None"

        processes = data_element.processes
        process_list = []
        for p_data in processes:
            if isinstance(p_data, Process):
                process_list.append(p_data)
            elif isinstance(p_data, dict):
                try:
                    process_list.append(Process(**p_data))
                except Exception as e:
                    logger.warning(f"Could not convert dict to Process object: {p_data}. Error: {e}")
            else:
                logger.warning(f"Unknown process type encountered: {type(p_data)}")

        if not process_list:
            return "Related Processes: None available after formatting."

        processes_info = "Related Processes:\n"
        for i, process in enumerate(process_list, 1):
            processes_info += f"  Process {i} ID: {process.process_id}\n"
            processes_info += f"  Process {i} Name: {process.process_name}\n"
            if process.process_description:
                processes_info += f"  Process {i} Description: {process.process_description}\n"
            processes_info += "\n"
        return processes_info.strip()

    def _parse_enhancement_result(self, result: str) -> EnhancementResult:
        enhanced_name = ""
        enhanced_description = ""
        feedback = ""
        confidence = 0.5  # Default confidence

        lines = result.strip().split("\n")

        for line in lines:
            if line.startswith("Enhanced Name:"):
                enhanced_name = line.replace("Enhanced Name:", "").strip()
                # Further clean potential markdown or numbering remnants
                enhanced_name = re.sub(r"^\s*[\d\W]*\s*", "", enhanced_name) # Remove leading numbers/symbols
                enhanced_name = enhanced_name.strip().lower() # Ensure lowercase as per standard
                break # Found name, move on

        description_found = False
        description_lines = []
        for line in lines:
            if line.startswith("Enhanced Description:"):
                description_found = True
                # Capture the first line of description, strip prefix
                first_desc_line = line.replace("Enhanced Description:", "").strip()
                # Further clean potential markdown or numbering remnants
                first_desc_line = re.sub(r"^\s*[\d\W]*\s*", "", first_desc_line)
                if first_desc_line: # Only add if there's content
                    description_lines.append(first_desc_line)
                continue # Move to next line to capture multi-line description
            if description_found and not (line.startswith("Enhancement Notes:") or line.startswith("Confidence Score:")):
                description_lines.append(line.strip()) # Append subsequent lines of the description
            elif description_found and (line.startswith("Enhancement Notes:") or line.startswith("Confidence Score:")):
                break # Description section ended

        if description_lines:
            enhanced_description = " ".join(description_lines).strip()
            # Ensure starts with capital and ends with period
            if enhanced_description:
                enhanced_description = enhanced_description[0].upper() + enhanced_description[1:]
                if not enhanced_description.endswith(('.', '!', '?')):
                    enhanced_description += "."


        feedback_found = False
        feedback_lines_list = []
        for line in lines:
            if line.startswith("Enhancement Notes:"):
                feedback_found = True
                # Capture the first line of feedback, strip prefix
                first_feedback_line = line.replace("Enhancement Notes:", "").strip()
                if first_feedback_line: # Only add if there's content
                     feedback_lines_list.append(first_feedback_line)
                continue
            if feedback_found and not line.startswith("Confidence Score:"):
                feedback_lines_list.append(line.strip())
            elif feedback_found and line.startswith("Confidence Score:"):
                break # Feedback section ended
        
        if feedback_lines_list:
            feedback = " ".join(feedback_lines_list).strip()


        for line in lines:
            if line.startswith("Confidence Score:"):
                score_text = line.replace("Confidence Score:", "").strip()
                match = re.search(r"(\d{1}\.\d{1,})", score_text) # More specific regex for 0.0-1.0
                if match:
                    try:
                        confidence = float(match.group(1))
                        confidence = max(0.0, min(1.0, confidence))  # Clamp to 0.0-1.0
                    except ValueError:
                        logger.warning(f"Failed to parse confidence score from: {score_text} in line: {line}")
                else:
                     logger.warning(f"No confidence score found or invalid format in line: {line}")
                break

        return EnhancementResult(
            enhanced_name=enhanced_name,
            enhanced_description=enhanced_description,
            feedback=feedback,
            confidence=confidence
        )

    async def validate_enhanced_element(self, data_element: DataElement) -> ValidationResult:
        return await self.validator.validate(data_element)

    @cache_manager.async_cached(ttl=3600)
    async def enhance_until_quality(self, data_element: DataElement,
                                  validation_feedback: str = "",
                                  additional_context: str = "",
                                  max_iterations: int = 3) -> Tuple[EnhancementResult, ValidationResult]:
        current_element = data_element
        current_feedback = validation_feedback
        iteration = 0
        last_enhancement = None
        last_validation = None

        for iteration_count in range(max_iterations):
            iteration = iteration_count + 1
            logger.info(f"Enhancement iteration {iteration} for element: {current_element.id} - {current_element.existing_name}")

            enhancement_result = await self.enhance(current_element, current_feedback, additional_context)

            # Create a temporary DataElement with the new enhanced name and description for validation
            # Ensure processes and other fields are correctly passed if they are part of DataElement
            temp_enhanced_data_element = DataElement(
                id=current_element.id,
                existing_name=enhancement_result.enhanced_name, # Use enhanced as existing for validation
                existing_description=enhancement_result.enhanced_description, # Use enhanced as existing for validation
                example=current_element.example,
                processes=current_element.processes, # Pass processes along
                cdm=current_element.cdm # Pass cdm along
            )

            validation_result = await self.validate_enhanced_element(temp_enhanced_data_element)

            last_enhancement = enhancement_result
            last_validation = validation_result

            if validation_result.quality_status == DataQualityStatus.GOOD:
                logger.info(f"Enhancement reached GOOD quality after {iteration} iterations for {current_element.id}")
                break
            
            # Prepare for next iteration
            current_element = temp_enhanced_data_element # The input for next iteration is the just-enhanced version
            current_feedback = validation_result.feedback # Feedback from the latest validation
            if validation_result.suggested_improvements:
                current_feedback += "\n\nFurther suggestions:\n" + "\n".join(
                    f"- {imp}" for imp in validation_result.suggested_improvements
                )
        else: # Loop finished without break (max_iterations reached)
            logger.warning(
                f"Reached maximum iterations ({max_iterations}) for {data_element.id}. "
                f"Final quality: {last_validation.quality_status if last_validation else 'N/A'}"
            )

        # Ensure we return non-None results even if loop didn't run or broke early
        if last_enhancement is None: # Should not happen if max_iterations >= 1
             last_enhancement = EnhancementResult(
                enhanced_name=data_element.existing_name, 
                enhanced_description=data_element.existing_description,
                feedback="No enhancement performed.",
                confidence=0.0
            )
        if last_validation is None: # Should not happen
            # Create a default poor validation if none occurred
            last_validation = await self.validate_enhanced_element(data_element)

        return last_enhancement, last_validation


    @cache_manager.async_cached(ttl=3600)
    async def enhance(self, data_element: DataElement, validation_feedback: str = "", additional_context: str = "") -> EnhancementResult:
        try:
            acronym_info = self._prepare_acronym_info(data_element)
            processes_info = self._format_processes_info(data_element)

            result_str = await self.enhancement_chain.ainvoke({
                "id": data_element.id,
                "name": data_element.existing_name,
                "description": data_element.existing_description,
                "example": data_element.example or "Not provided",
                "processes_info": processes_info,
                "validation_feedback": validation_feedback or "No prior validation feedback.",
                "acronym_info": acronym_info,
                "additional_context": additional_context or "No additional context."
            })

            enhancement_result = self._parse_enhancement_result(result_str)

            logger.info(f"Enhancement for {data_element.id}: Name='{enhancement_result.enhanced_name}', Desc='{enhancement_result.enhanced_description[:50]}...', Conf={enhancement_result.confidence}")
            
            # Basic check if parsing failed significantly
            if not enhancement_result.enhanced_name or not enhancement_result.enhanced_description:
                 logger.warning(f"Parsing of LLM output might have failed for element {data_element.id}. Raw LLM output: {result_str[:200]}")
                 # Fallback to original if enhancement is clearly broken
                 if not enhancement_result.enhanced_name and data_element.existing_name:
                     enhancement_result.enhanced_name = data_element.existing_name
                 if not enhancement_result.enhanced_description and data_element.existing_description:
                     enhancement_result.enhanced_description = data_element.existing_description
                 enhancement_result.feedback = "Warning: LLM output parsing may have failed. Review result."
                 enhancement_result.confidence = 0.1 # Low confidence if parsing failed

            return enhancement_result
        except Exception as e:
            logger.error(f"Error enhancing data element {data_element.id}: {e}", exc_info=True)
            return EnhancementResult(
                enhanced_name=data_element.existing_name, # Fallback to original
                enhanced_description=data_element.existing_description, # Fallback to original
                feedback=f"Error during enhancement: {str(e)}",
                confidence=0.0
            )

    async def batch_enhance(self, data_elements: List[DataElement], validation_feedback: str = "", additional_context: str = "") -> List[EnhancementResult]:
        tasks = [self.enhance(element, validation_feedback, additional_context) for element in data_elements]
        return await asyncio.gather(*tasks)
