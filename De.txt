"""
Excel processor for reading and validating rule framework input files.
Handles DSS and DataVISA rule frameworks with restriction/condition types.

Location: src/processors/excel_processor.py

Dependencies:
    pip install openpyxl
"""
import logging
from typing import List, Dict, Optional, Any
from pathlib import Path
from pydantic import BaseModel, Field, field_validator
from enum import Enum
import openpyxl
from openpyxl.worksheet.worksheet import Worksheet

logger = logging.getLogger(__name__)


class DataDomain(Enum):
    """Data domain categories."""
    DATA_SHARING_AND_ACCESS = "data_sharing_and_access"
    DATA_STORAGE_AND_HOSTING = "data_storage_and_hosting"
    DATA_TRANSFER = "data_transfer"
    DATA_COLLECTION = "data_collection"
    DATA_DELETION = "data_deletion"
    DATA_USAGE = "data_usage"


class DecisionType(Enum):
    """Decision type categories."""
    DATA_SHARING_AND_ACCESS = "data_sharing_and_access"
    DATA_STORAGE_AND_HOSTING = "data_storage_and_hosting"
    DATA_TRANSFER = "data_transfer"
    DATA_PROCESSING = "data_processing"
    DATA_COLLECTION = "data_collection"
    DATA_DELETION = "data_deletion"
    CONSENT_REQUIREMENT = "consent_requirement"
    COMPLIANCE_STATUS = "compliance_status"


class RuleFrameworkEntry(BaseModel):
    """Model for a single rule framework entry from Excel."""
    
    id: str = Field(..., description="Unique identifier for the rule")
    rule_framework: str = Field(..., description="Framework type: DSS or DataVISA")
    restriction_condition: str = Field(..., description="Type: restriction or condition")
    rule_name: str = Field(..., description="Title/name of the rule")
    guidance: str = Field(..., description="Complete guidance text with details, actions, evidence")
    
    @field_validator('rule_framework')
    @classmethod
    def validate_framework(cls, v):
        """Validate framework type."""
        if not v:
            raise ValueError("Framework type cannot be empty")
        valid_frameworks = ['DSS', 'DataVISA', 'dss', 'datavisa']
        if v not in valid_frameworks:
            logger.warning(f"Unknown framework type: {v}. Expected DSS or DataVISA.")
        return v.upper() if v.lower() in ['dss', 'datavisa'] else v
    
    @field_validator('restriction_condition')
    @classmethod
    def validate_type(cls, v):
        """Validate restriction/condition type."""
        if not v:
            raise ValueError("Restriction/condition type cannot be empty")
        valid_types = ['restriction', 'condition', 'Restriction', 'Condition']
        if v not in valid_types:
            logger.warning(f"Unknown type: {v}. Expected restriction or condition.")
        return v.lower()
    
    @field_validator('guidance')
    @classmethod
    def validate_guidance(cls, v):
        """Ensure guidance is not empty."""
        if not v or len(str(v).strip()) == 0:
            raise ValueError("Guidance text cannot be empty")
        return str(v).strip()


class ExcelProcessor:
    """Processor for Excel input files containing rule framework data."""
    
    def __init__(self):
        """Initialize Excel processor."""
        self.entries: List[RuleFrameworkEntry] = []
        self.statistics = {
            'total_entries': 0,
            'dss_count': 0,
            'datavisa_count': 0,
            'restriction_count': 0,
            'condition_count': 0,
            'validation_errors': 0
        }
    
    def read_excel(
        self, 
        filepath: str, 
        sheet_name: Optional[str] = None,
        header_row: int = 1
    ) -> List[RuleFrameworkEntry]:
        """
        Read Excel file and parse entries.
        
        Expected Excel columns:
        - id: Unique identifier
        - rule_framework: DSS or DataVISA
        - restriction_condition: restriction or condition
        - rule_name: Title of the rule
        - guidance: Complete guidance text
        
        Args:
            filepath: Path to Excel file (.xlsx, .xlsm)
            sheet_name: Name of sheet to read (default: first sheet)
            header_row: Row number containing headers (1-indexed, default: 1)
            
        Returns:
            List of validated RuleFrameworkEntry objects
        """
        logger.info(f"Reading Excel file: {filepath}")
        
        file_path = Path(filepath)
        if not file_path.exists():
            raise FileNotFoundError(f"Excel file not found: {filepath}")
        
        if file_path.suffix not in ['.xlsx', '.xlsm', '.xls']:
            raise ValueError(f"Invalid file type. Expected .xlsx, .xlsm, or .xls, got: {file_path.suffix}")
        
        entries = []
        
        try:
            # Load workbook
            workbook = openpyxl.load_workbook(filepath, read_only=True, data_only=True)
            
            # Select worksheet
            if sheet_name:
                if sheet_name not in workbook.sheetnames:
                    raise ValueError(
                        f"Sheet '{sheet_name}' not found. Available sheets: {workbook.sheetnames}"
                    )
                worksheet = workbook[sheet_name]
            else:
                worksheet = workbook.active
                logger.info(f"Using active sheet: {worksheet.title}")
            
            # Read all rows
            rows = list(worksheet.iter_rows(values_only=True))
            
            if len(rows) < header_row:
                raise ValueError(f"Excel file has fewer than {header_row} rows")
            
            # Get headers from specified row
            headers = rows[header_row - 1]
            
            # Clean headers (strip whitespace and convert to lowercase for matching)
            headers_clean = [str(h).strip().lower() if h else '' for h in headers]
            
            # Validate headers
            expected_headers = {'id', 'rule_framework', 'restriction_condition', 'rule_name', 'guidance'}
            actual_headers = set(headers_clean)
            
            if not expected_headers.issubset(actual_headers):
                missing = expected_headers - actual_headers
                raise ValueError(
                    f"Missing required Excel columns: {missing}\n"
                    f"Found columns: {headers_clean}\n"
                    f"Expected: {expected_headers}"
                )
            
            # Create column index mapping
            column_map = {}
            for expected_col in expected_headers:
                try:
                    column_map[expected_col] = headers_clean.index(expected_col)
                except ValueError:
                    raise ValueError(f"Required column '{expected_col}' not found in headers")
            
            logger.info(f"Excel columns detected: {headers}")
            logger.info(f"Column mapping: {column_map}")
            
            # Process data rows (skip header row)
            for row_num, row in enumerate(rows[header_row:], start=header_row + 1):
                try:
                    # Skip completely empty rows
                    if not row or all(cell is None or str(cell).strip() == '' for cell in row):
                        continue
                    
                    # Extract values using column mapping
                    def get_cell_value(col_name: str) -> str:
                        """Get cell value and convert to string."""
                        col_idx = column_map[col_name]
                        if col_idx >= len(row):
                            return ''
                        value = row[col_idx]
                        if value is None:
                            return ''
                        return str(value).strip()
                    
                    # Create entry
                    entry = RuleFrameworkEntry(
                        id=get_cell_value('id'),
                        rule_framework=get_cell_value('rule_framework'),
                        restriction_condition=get_cell_value('restriction_condition'),
                        rule_name=get_cell_value('rule_name'),
                        guidance=get_cell_value('guidance')
                    )
                    
                    entries.append(entry)
                    
                    # Update statistics
                    self.statistics['total_entries'] += 1
                    
                    if entry.rule_framework.upper() == 'DSS':
                        self.statistics['dss_count'] += 1
                    elif entry.rule_framework.upper() == 'DATAVISA':
                        self.statistics['datavisa_count'] += 1
                    
                    if entry.restriction_condition == 'restriction':
                        self.statistics['restriction_count'] += 1
                    elif entry.restriction_condition == 'condition':
                        self.statistics['condition_count'] += 1
                    
                except ValueError as ve:
                    logger.error(f"Validation error in row {row_num}: {ve}")
                    self.statistics['validation_errors'] += 1
                    continue
                except Exception as e:
                    logger.error(f"Error parsing row {row_num}: {e}")
                    logger.error(f"Row data: {row}")
                    self.statistics['validation_errors'] += 1
                    continue
            
            workbook.close()
        
        except openpyxl.utils.exceptions.InvalidFileException as e:
            logger.error(f"Invalid Excel file format: {e}")
            raise ValueError(f"Invalid Excel file format: {e}")
        except Exception as e:
            logger.error(f"Error reading Excel file: {e}")
            raise
        
        self.entries = entries
        logger.info(f"Successfully loaded {len(entries)} entries from Excel")
        
        if len(entries) == 0:
            logger.warning("No valid entries found in Excel file")
        
        return entries
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get processing statistics."""
        return self.statistics
    
    def filter_by_framework(self, framework: str) -> List[RuleFrameworkEntry]:
        """Filter entries by rule framework."""
        framework_upper = framework.upper()
        return [e for e in self.entries if e.rule_framework.upper() == framework_upper]
    
    def filter_by_type(self, entry_type: str) -> List[RuleFrameworkEntry]:
        """Filter entries by restriction/condition type."""
        type_lower = entry_type.lower()
        return [e for e in self.entries if e.restriction_condition == type_lower]
    
    def get_entry_by_id(self, entry_id: str) -> Optional[RuleFrameworkEntry]:
        """Get specific entry by ID."""
        for entry in self.entries:
            if entry.id == entry_id:
                return entry
        return None
    
    def validate_all_entries(self) -> Dict[str, List[str]]:
        """
        Validate all entries and return validation report.
        
        Returns:
            Dictionary with 'valid', 'invalid', and 'warnings' lists
        """
        validation_report = {
            'valid': [],
            'invalid': [],
            'warnings': []
        }
        
        for entry in self.entries:
            try:
                # Check for potential issues
                if len(entry.guidance) < 50:
                    validation_report['warnings'].append(
                        f"{entry.id}: Guidance text is very short ({len(entry.guidance)} chars)"
                    )
                
                if not entry.id:
                    validation_report['invalid'].append("Empty ID found")
                    continue
                
                validation_report['valid'].append(entry.id)
                
            except Exception as e:
                validation_report['invalid'].append(f"{entry.id}: {str(e)}")
        
        return validation_report
    
    def export_to_dict(self) -> List[Dict[str, Any]]:
        """Export entries as list of dictionaries."""
        return [entry.model_dump() for entry in self.entries]
    
    def print_statistics(self):
        """Print processing statistics."""
        print("\n" + "="*60)
        print("EXCEL PROCESSING STATISTICS")
        print("="*60)
        print(f"Total Entries:        {self.statistics['total_entries']}")
        print(f"DSS Framework:        {self.statistics['dss_count']}")
        print(f"DataVISA Framework:   {self.statistics['datavisa_count']}")
        print(f"Restrictions:         {self.statistics['restriction_count']}")
        print(f"Conditions:           {self.statistics['condition_count']}")
        print(f"Validation Errors:    {self.statistics['validation_errors']}")
        print("="*60)
    
    def get_sheet_names(self, filepath: str) -> List[str]:
        """
        Get list of sheet names from Excel file without reading full data.
        
        Args:
            filepath: Path to Excel file
            
        Returns:
            List of sheet names
        """
        try:
            workbook = openpyxl.load_workbook(filepath, read_only=True)
            sheet_names = workbook.sheetnames
            workbook.close()
            return sheet_names
        except Exception as e:
            logger.error(f"Error reading sheet names: {e}")
            raise
