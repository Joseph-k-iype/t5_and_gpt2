"""
HSBC OpenAI Client wrapper - FIXED VERSION
Creates properly configured clients for HSBC authentication with token refresh
Uses custom httpx transport for token management
"""
import logging
import uuid
import httpx
from typing import Any, Optional
from openai import OpenAI

from .hsbc_token_service import HSBCTokenService
from ..config import Config

logger = logging.getLogger(__name__)


class HSBCHTTPTransport(httpx.HTTPTransport):
    """
    Custom HTTP transport that handles HSBC token refresh.
    Intercepts 401 errors and retries with fresh token.
    """
    
    def __init__(self, token_service: HSBCTokenService, user_id: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.token_service = token_service
        self.user_id = user_id
        self._max_retries = 3
        logger.info("HSBC HTTP Transport initialized with token refresh capability")
    
    def handle_request(self, request: httpx.Request) -> httpx.Response:
        """
        Handle request with automatic token refresh on 401.
        This is called by httpx for every request.
        """
        retry_count = 0
        
        while retry_count < self._max_retries:
            try:
                # Get fresh token (will auto-refresh if expiring)
                force_refresh = retry_count > 0
                fresh_token = self.token_service.get_token(force_refresh=force_refresh)
                
                # Update headers with fresh token and new correlation IDs
                request.headers["X-HSBC-E2E-Trust-Token"] = fresh_token
                request.headers["Token_Type"] = "SESSION_TOKEN"
                request.headers["x-correlation-id"] = str(uuid.uuid4())
                request.headers["x-usersession-id"] = str(uuid.uuid4())
                request.headers["Content-Type"] = "application/json"
                
                if retry_count > 0:
                    logger.info(f"ðŸ”„ Retrying request with fresh token (attempt {retry_count + 1}/{self._max_retries})")
                
                # Make the actual request
                response = super().handle_request(request)
                
                # Check for 401 Unauthorized
                if response.status_code == 401:
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"âŒ Token refresh failed after {self._max_retries} attempts")
                        return response
                    
                    logger.warning(f"âš ï¸ Got 401 Unauthorized - refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate current token to force refresh
                    self.token_service.invalidate_token()
                    
                    # Continue to next iteration for retry
                    continue
                
                # Success or non-401 error - return response
                return response
                
            except Exception as e:
                # Check if it's an auth-related error
                error_msg = str(e).lower()
                if any(keyword in error_msg for keyword in ['unauthorized', 'token', 'expired', 'sso', 'credential']):
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"âŒ Request failed after {self._max_retries} token refresh attempts")
                        raise
                    
                    logger.warning(f"âš ï¸ Authentication error: {e}")
                    logger.warning(f"   Refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate and retry
                    self.token_service.invalidate_token()
                    continue
                else:
                    # Not an auth error, raise immediately
                    raise
        
        # Should not reach here, but just in case
        raise Exception(f"Request failed after {self._max_retries} attempts")


def create_hsbc_client() -> OpenAI:
    """
    Factory function to create OpenAI client with HSBC authentication and token refresh.
    
    Returns:
        OpenAI: Standard OpenAI client with custom transport for token management
    """
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("Creating HSBC token service...")
    
    token_service = HSBCTokenService(
        token_endpoint=Config.HSBC_TOKEN_ENDPOINT,
        username=Config.HSBC_USERNAME,
        password=Config.HSBC_PASSWORD,
        token_buffer_seconds=300  # Refresh 5 minutes before expiry
    )
    
    # Get initial token
    initial_token = token_service.get_token()
    
    # Create custom transport with token management
    logger.info("Creating custom HTTP transport with token refresh...")
    custom_transport = HSBCHTTPTransport(
        token_service=token_service,
        user_id=Config.HSBC_USER_ID,
        verify=token_service.get_httpx_client()._transport._pool._ssl_context  # Use truststore SSL context
    )
    
    # Create httpx client with custom transport
    httpx_client = httpx.Client(
        transport=custom_transport,
        http2=True,
        timeout=30.0
    )
    
    # Initial headers
    default_headers = {
        "X-HSBC-E2E-Trust-Token": initial_token,
        "Token_Type": "SESSION_TOKEN",
        "x-correlation-id": str(uuid.uuid4()),
        "x-usersession-id": str(uuid.uuid4()),
        "Content-Type": "application/json"
    }
    
    logger.info("Creating OpenAI client with HSBC authentication...")
    
    # Create standard OpenAI client with custom http client
    client = OpenAI(
        api_key=initial_token,
        base_url=Config.BASE_URL,
        http_client=httpx_client,
        default_headers=default_headers
    )
    
    # Store token service reference for external access if needed
    client._hsbc_token_service = token_service
    client._hsbc_user_id = Config.HSBC_USER_ID
    
    logger.info(f"âœ“ HSBC OpenAI Client initialized")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User ID: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: âœ“ Automatic on 401")
    
    return client


def create_langchain_client():
    """
    Create a properly configured ChatOpenAI instance for LangChain
    WITH automatic token refresh through custom transport
    
    Returns:
        ChatOpenAI instance configured for HSBC with token management
    """
    from langchain_openai import ChatOpenAI
    
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("=" * 60)
    logger.info("Creating LangChain ChatOpenAI with HSBC authentication")
    logger.info("=" * 60)
    
    # Create the HSBC client with custom transport
    hsbc_client = create_hsbc_client()
    
    logger.info(f"LangChain client configuration:")
    logger.info(f"  Model: {Config.CHAT_MODEL}")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: âœ“ Enabled (auto-refresh on 401)")
    
    # Get initial token
    initial_token = hsbc_client._hsbc_token_service.get_token()
    
    # Create LangChain ChatOpenAI with the HSBC client
    llm = ChatOpenAI(
        model=Config.CHAT_MODEL,
        openai_api_key=initial_token,
        openai_api_base=Config.BASE_URL,
        http_client=hsbc_client._client,  # Pass the httpx client with custom transport
        model_kwargs={
            "user": Config.HSBC_USER_ID
        }
    )
    
    # CRITICAL: Replace LangChain's internal client with our HSBC client
    # This ensures all requests go through our custom transport with token refresh
    llm.client = hsbc_client
    
    # Store references for external access
    llm._hsbc_client = hsbc_client
    llm._hsbc_token_service = hsbc_client._hsbc_token_service
    
    # Wrap the generate method to ensure fresh tokens
    original_generate = llm._generate
    
    def wrapped_generate(*args, **kwargs):
        """Wrap generate to ensure fresh token"""
        # Update API key before each generation
        fresh_token = hsbc_client._hsbc_token_service.get_token()
        llm.openai_api_key = fresh_token
        return original_generate(*args, **kwargs)
    
    llm._generate = wrapped_generate
    
    logger.info("=" * 60)
    logger.info("âœ“ LangChain ChatOpenAI created with HSBC token management")
    logger.info("  Custom HTTP transport with automatic token refresh")
    logger.info("  All requests will auto-retry on 401 errors")
    logger.info("=" * 60)
    
    return llm
