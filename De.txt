#!/usr/bin/env python3
"""
Complete Schema Extractor with Property-Class Relationships
Extracts full ontology schema including how properties relate to classes.
"""

import argparse
import sys
from pathlib import Path
from rdflib import Graph, Literal


def extract_complete_schema(input_file, output_file):
    """
    Extract complete ontology schema with all relationships.
    """
    try:
        # Load the input TTL file
        print(f"Loading ontology from: {input_file}")
        input_graph = Graph()
        input_graph.parse(input_file, format="turtle")
        print(f"Loaded {len(input_graph)} triples")
        
        # Create a new graph for the schema
        schema_graph = Graph()
        
        # Copy namespace prefixes from input graph
        for prefix, namespace in input_graph.namespaces():
            schema_graph.bind(prefix, namespace)
        
        print("\nExtracting complete schema with relationships...")
        
        # Single comprehensive SPARQL query to get everything
        comprehensive_query = """
        CONSTRUCT {
            # Classes and their types
            ?class a ?classType .
            
            # Properties and their types  
            ?prop a ?propType .
            
            # Subclass relationships
            ?sub rdfs:subClassOf ?super .
            
            # Subproperty relationships
            ?subProp rdfs:subPropertyOf ?superProp .
            
            # Domain and range (the key relationships!)
            ?prop rdfs:domain ?domain .
            ?prop rdfs:range ?range .
            
            # Equivalent classes and properties
            ?x owl:equivalentClass ?y .
            ?x owl:equivalentProperty ?y .
            
            # Disjoint relationships
            ?x owl:disjointWith ?y .
            ?x owl:propertyDisjointWith ?y .
            
            # Inverse properties
            ?p1 owl:inverseOf ?p2 .
            
            # OWL restrictions
            ?restriction a owl:Restriction .
            ?restriction owl:onProperty ?onProp .
            ?restriction owl:someValuesFrom ?someValue .
            ?restriction owl:allValuesFrom ?allValue .
            ?restriction owl:hasValue ?hasValue .
            ?restriction owl:cardinality ?card .
            ?restriction owl:minCardinality ?minCard .
            ?restriction owl:maxCardinality ?maxCard .
            ?restriction owl:qualifiedCardinality ?qualCard .
            ?restriction owl:minQualifiedCardinality ?minQualCard .
            ?restriction owl:maxQualifiedCardinality ?maxQualCard .
            ?restriction owl:onClass ?onClass .
            ?restriction owl:onDataRange ?onDataRange .
            
            # Complex class expressions
            ?class owl:unionOf ?union .
            ?class owl:intersectionOf ?intersection .
            ?class owl:complementOf ?complement .
            ?class owl:oneOf ?enumeration .
            
            # Ontology metadata
            ?ont a owl:Ontology .
            ?ont owl:versionInfo ?version .
            ?ont owl:imports ?import .
            ?ont rdfs:label ?ontLabel .
            ?ont rdfs:comment ?ontComment .
            
            # Labels and comments for ALL schema elements
            ?element rdfs:label ?label .
            ?element rdfs:comment ?comment .
            ?element rdfs:seeAlso ?seeAlso .
            ?element rdfs:isDefinedBy ?definedBy .
            
            # Additional property characteristics
            ?prop owl:propertyChainAxiom ?chain .
        }
        WHERE {
            {
                # Explicitly declared classes
                ?class a ?classType .
                FILTER(?classType IN (rdfs:Class, owl:Class))
            } UNION {
                # Implicitly declared classes (used as types)
                ?instance a ?class .
                FILTER(isURI(?class))
                BIND(rdfs:Class AS ?classType)
            } UNION {
                # Explicitly declared properties
                ?prop a ?propType .
                FILTER(?propType IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, 
                                   owl:AnnotationProperty, owl:FunctionalProperty, 
                                   owl:InverseFunctionalProperty, owl:TransitiveProperty, 
                                   owl:SymmetricProperty, owl:AsymmetricProperty,
                                   owl:ReflexiveProperty, owl:IrreflexiveProperty))
            } UNION {
                # Implicitly declared properties (used as predicates)
                ?s ?prop ?o .
                FILTER(isURI(?prop))
                FILTER(?prop != rdf:type)
                FILTER NOT EXISTS { ?prop a ?explicitType . 
                                   FILTER(?explicitType IN (rdf:Property, owl:ObjectProperty, 
                                                          owl:DatatypeProperty, owl:AnnotationProperty)) }
                # Determine property type based on object
                BIND(IF(isLiteral(?o), owl:DatatypeProperty, owl:ObjectProperty) AS ?propType)
            } UNION {
                # Subclass relationships
                ?sub rdfs:subClassOf ?super .
            } UNION {
                # Subproperty relationships  
                ?subProp rdfs:subPropertyOf ?superProp .
            } UNION {
                # Domain relationships
                ?prop rdfs:domain ?domain .
            } UNION {
                # Range relationships
                ?prop rdfs:range ?range .
            } UNION {
                # Equivalent classes
                ?x owl:equivalentClass ?y .
            } UNION {
                # Equivalent properties
                ?x owl:equivalentProperty ?y .
            } UNION {
                # Disjoint classes
                ?x owl:disjointWith ?y .
            } UNION {
                # Disjoint properties
                ?x owl:propertyDisjointWith ?y .
            } UNION {
                # Inverse properties
                ?p1 owl:inverseOf ?p2 .
            } UNION {
                # OWL restrictions
                ?restriction a owl:Restriction .
                ?restriction owl:onProperty ?onProp .
                OPTIONAL { ?restriction owl:someValuesFrom ?someValue . }
                OPTIONAL { ?restriction owl:allValuesFrom ?allValue . }
                OPTIONAL { ?restriction owl:hasValue ?hasValue . }
                OPTIONAL { ?restriction owl:cardinality ?card . }
                OPTIONAL { ?restriction owl:minCardinality ?minCard . }
                OPTIONAL { ?restriction owl:maxCardinality ?maxCard . }
                OPTIONAL { ?restriction owl:qualifiedCardinality ?qualCard . }
                OPTIONAL { ?restriction owl:minQualifiedCardinality ?minQualCard . }
                OPTIONAL { ?restriction owl:maxQualifiedCardinality ?maxQualCard . }
                OPTIONAL { ?restriction owl:onClass ?onClass . }
                OPTIONAL { ?restriction owl:onDataRange ?onDataRange . }
            } UNION {
                # Complex class expressions
                {
                    ?class owl:unionOf ?union .
                } UNION {
                    ?class owl:intersectionOf ?intersection .
                } UNION {
                    ?class owl:complementOf ?complement .
                } UNION {
                    ?class owl:oneOf ?enumeration .
                }
            } UNION {
                # Ontology metadata
                ?ont a owl:Ontology .
                OPTIONAL { ?ont owl:versionInfo ?version . }
                OPTIONAL { ?ont owl:imports ?import . }
                OPTIONAL { ?ont rdfs:label ?ontLabel . }
                OPTIONAL { ?ont rdfs:comment ?ontComment . }
            } UNION {
                # Labels and comments for schema elements
                {
                    # Get all schema elements first
                    {
                        ?element a ?type .
                        FILTER(?type IN (rdfs:Class, owl:Class, rdf:Property, owl:ObjectProperty, 
                                       owl:DatatypeProperty, owl:AnnotationProperty))
                    } UNION {
                        ?instance a ?element .
                        FILTER(isURI(?element))
                    } UNION {
                        ?s ?element ?o .
                        FILTER(isURI(?element))
                        FILTER(?element != rdf:type)
                    }
                    
                    # Get their annotations
                    {
                        ?element rdfs:label ?label .
                    } UNION {
                        ?element rdfs:comment ?comment .
                    } UNION {
                        ?element rdfs:seeAlso ?seeAlso .
                    } UNION {
                        ?element rdfs:isDefinedBy ?definedBy .
                    }
                }
            } UNION {
                # Property chains
                ?prop owl:propertyChainAxiom ?chain .
            }
        }
        """
        
        print("Executing comprehensive schema extraction query...")
        try:
            results = input_graph.query(comprehensive_query)
            for triple in results:
                schema_graph.add(triple)
            print(f"Extracted {len(schema_graph)} triples")
        except Exception as e:
            print(f"Main query failed: {e}")
            print("Falling back to individual queries...")
            
            # Fallback: individual queries
            individual_queries = [
                # Classes
                "CONSTRUCT { ?c a ?type } WHERE { ?c a ?type . FILTER(?type IN (rdfs:Class, owl:Class)) }",
                
                # Properties with types
                """CONSTRUCT { ?p a ?type } WHERE { 
                    ?p a ?type . 
                    FILTER(?type IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty)) 
                }""",
                
                # Find object properties by usage
                """CONSTRUCT { ?p a owl:ObjectProperty } WHERE {
                    ?s ?p ?o .
                    FILTER(isURI(?p) && isURI(?o))
                    FILTER(?p != rdf:type)
                    FILTER NOT EXISTS { ?p a ?explicitType }
                }""",
                
                # Find data properties by usage  
                """CONSTRUCT { ?p a owl:DatatypeProperty } WHERE {
                    ?s ?p ?o .
                    FILTER(isURI(?p) && isLiteral(?o))
                    FILTER NOT EXISTS { ?p a ?explicitType }
                }""",
                
                # Domain and range
                "CONSTRUCT { ?p rdfs:domain ?d } WHERE { ?p rdfs:domain ?d }",
                "CONSTRUCT { ?p rdfs:range ?r } WHERE { ?p rdfs:range ?r }",
                
                # Subclass relationships
                "CONSTRUCT { ?sub rdfs:subClassOf ?super } WHERE { ?sub rdfs:subClassOf ?super }",
                
                # Labels and comments
                """CONSTRUCT { ?x rdfs:label ?label } WHERE { 
                    ?x rdfs:label ?label .
                    { ?x a ?type . FILTER(?type IN (rdfs:Class, owl:Class, rdf:Property, owl:ObjectProperty, owl:DatatypeProperty)) }
                    UNION { ?instance a ?x . FILTER(isURI(?x)) }
                    UNION { ?s ?x ?o . FILTER(isURI(?x) && ?x != rdf:type) }
                }""",
                
                """CONSTRUCT { ?x rdfs:comment ?comment } WHERE { 
                    ?x rdfs:comment ?comment .
                    { ?x a ?type . FILTER(?type IN (rdfs:Class, owl:Class, rdf:Property, owl:ObjectProperty, owl:DatatypeProperty)) }
                    UNION { ?instance a ?x . FILTER(isURI(?x)) }
                    UNION { ?s ?x ?o . FILTER(isURI(?x) && ?x != rdf:type) }
                }"""
            ]
            
            for i, query in enumerate(individual_queries):
                try:
                    results = input_graph.query(query)
                    count = 0
                    for triple in results:
                        schema_graph.add(triple)
                        count += 1
                    print(f"Query {i+1}: added {count} triples")
                except Exception as e:
                    print(f"Query {i+1} failed: {e}")
        
        # Final count
        final_count = len(schema_graph)
        
        # Save the schema graph
        print(f"\nSaving complete schema with {final_count} triples to: {output_file}")
        schema_graph.serialize(destination=output_file, format="turtle")
        
        # Detailed analysis
        print("\n" + "="*60)
        print("COMPLETE SCHEMA EXTRACTION SUMMARY")
        print("="*60)
        print(f"Input file: {input_file}")
        print(f"Output file: {output_file}")
        print(f"Original triples: {len(input_graph)}")
        print(f"Schema triples: {final_count}")
        print(f"Extraction ratio: {final_count/len(input_graph)*100:.1f}%")
        
        # Count specific elements
        analysis_queries = {
            "Classes (rdfs:Class)": "SELECT ?c WHERE { ?c a rdfs:Class }",
            "Classes (owl:Class)": "SELECT ?c WHERE { ?c a owl:Class }",
            "Object Properties": "SELECT ?p WHERE { ?p a owl:ObjectProperty }",
            "Data Properties": "SELECT ?p WHERE { ?p a owl:DatatypeProperty }",
            "RDF Properties": "SELECT ?p WHERE { ?p a rdf:Property }",
            "Domain statements": "SELECT * WHERE { ?p rdfs:domain ?d }",
            "Range statements": "SELECT * WHERE { ?p rdfs:range ?r }",
            "Subclass relationships": "SELECT * WHERE { ?sub rdfs:subClassOf ?super }",
            "Property labels": "SELECT * WHERE { ?p rdfs:label ?l . ?p a ?type . FILTER(?type IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty)) }",
            "Class labels": "SELECT * WHERE { ?c rdfs:label ?l . ?c a ?type . FILTER(?type IN (rdfs:Class, owl:Class)) }"
        }
        
        print(f"\nDetailed Analysis:")
        for desc, query in analysis_queries.items():
            try:
                results = list(schema_graph.query(query))
                print(f"  {desc}: {len(results)}")
            except Exception as e:
                print(f"  {desc}: Error - {e}")
        
        # Show sample domain/range relationships
        print(f"\nSample Property-Class Relationships:")
        domain_query = """
        SELECT ?prop ?propType ?domain WHERE { 
            ?prop a ?propType . 
            ?prop rdfs:domain ?domain .
            FILTER(?propType IN (owl:ObjectProperty, owl:DatatypeProperty, rdf:Property))
        } LIMIT 10
        """
        
        try:
            domain_results = list(schema_graph.query(domain_query))
            if domain_results:
                for prop, prop_type, domain in domain_results:
                    prop_name = str(prop).split('#')[-1] if '#' in str(prop) else str(prop).split('/')[-1]
                    prop_type_name = str(prop_type).split('#')[-1] if '#' in str(prop_type) else str(prop_type)
                    domain_name = str(domain).split('#')[-1] if '#' in str(domain) else str(domain).split('/')[-1]
                    print(f"  {prop_name} ({prop_type_name}) -> domain: {domain_name}")
            else:
                print("  No domain relationships found")
        except Exception as e:
            print(f"  Error analyzing relationships: {e}")
        
        print("\nComplete schema extraction finished!")
        
    except Exception as e:
        print(f"Error processing ontology: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="Extract complete ontology schema with property-class relationships")
    parser.add_argument("input_file", help="Input TTL file path")
    parser.add_argument("-o", "--output", 
                       help="Output TTL file path (default: input_schema.ttl)")
    
    args = parser.parse_args()
    
    # Validate input file
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: Input file '{args.input_file}' does not exist")
        sys.exit(1)
    
    # Set output file
    if args.output:
        output_file = args.output
    else:
        output_file = input_path.stem + "_schema.ttl"
    
    # Extract schema
    extract_complete_schema(args.input_file, output_file)


if __name__ == "__main__":
    main()
