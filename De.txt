from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel, Field
import requests
import json
from urllib.parse import urlparse, unquote
from typing import Dict, List, Optional, Any
import uvicorn
import typer

# --- Application Configuration ---
class AppConfig:
    ENDPOINT_URL: str = ""
    BEARER_TOKEN: Optional[str] = None
config = AppConfig()

# --- Constants ---
RDFS_LABEL_URI = "http://www.w3.org/2000/01/rdf-schema#label"

# --- Helper Functions ---
def _get_label_from_uri(uri_str: str) -> str:
    if not isinstance(uri_str, str): return str(uri_str)
    try:
        parsed_uri = urlparse(uri_str)
        if parsed_uri.fragment: return unquote(parsed_uri.fragment)
        path_segments = [seg for seg in parsed_uri.path.split('/') if seg]
        if path_segments: return unquote(path_segments[-1])
        if parsed_uri.scheme and parsed_uri.opaque:
            opaque_parts = parsed_uri.opaque.split(':')
            return unquote(opaque_parts[-1]) if len(opaque_parts) > 1 else unquote(parsed_uri.opaque)
        return uri_str
    except Exception: return uri_str

def _add_value_to_json_ld_object(obj: Dict[str, Any], key: str, value_to_add: Any):
    if key not in obj:
        obj[key] = value_to_add
    else:
        if not isinstance(obj[key], list): obj[key] = [obj[key]]
        is_new_value_dict = isinstance(value_to_add, dict)
        should_add = True
        for existing_item in obj[key]:
            if is_new_value_dict and isinstance(existing_item, dict):
                if existing_item == value_to_add: should_add = False; break
            elif not is_new_value_dict and not isinstance(existing_item, dict):
                 if existing_item == value_to_add: should_add = False; break
        if should_add: obj[key].append(value_to_add)

def _execute_sparql_query(query: str, query_type_label: str) -> Dict[str, Any]:
    headers = {'Accept': 'application/sparql-results+json', 'Content-Type': 'application/x-www-form-urlencoded'}
    if config.BEARER_TOKEN: headers['Authorization'] = f'Bearer {config.BEARER_TOKEN}'
    payload = {'query': query}
    try:
        response = requests.post(config.ENDPOINT_URL, data=payload, headers=headers, timeout=60)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        details = e.response.text
        try: details = e.response.json()
        except json.JSONDecodeError: pass
        return {"error": f"HTTP error for {query_type_label}: {e.response.status_code} {e.response.reason}", "details": details}
    except requests.exceptions.RequestException as e:
        return {"error": f"Request failed for {query_type_label}: {e}"}
    except json.JSONDecodeError as e_json:
        return {"error": f"Failed to decode JSON response for {query_type_label}: {e_json}", "details": response.text if 'response' in locals() else "No response text available"}

def _ensure_minimal_jsonld_node_entry(node_id: str, json_ld_graph_objects: Dict[str, Any]):
    if node_id not in json_ld_graph_objects:
        json_ld_graph_objects[node_id] = {"@id": node_id}

# --- Core Logic Function ---
def generate_separate_jsonld_outputs(
    nodes_query: str,
    edges_query: str,
    groups_query: Optional[str] = None,
    json_ld_group_predicate_uri: Optional[str] = None 
) -> Dict[str, Any]:
    nodes_graph_objects: Dict[str, Any] = {}
    edges_graph_objects: Dict[str, Any] = {}

    shared_context: Dict[str, Any] = {
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
    }
    if json_ld_group_predicate_uri:
        group_short_name = _get_label_from_uri(json_ld_group_predicate_uri).lower().replace(" ", "")
        if group_short_name and (group_short_name not in shared_context or shared_context[group_short_name] == json_ld_group_predicate_uri):
            shared_context[group_short_name] = json_ld_group_predicate_uri

    # 1. Process Node Query (expects ?node, optional ?label, optional ?node_group_id)
    node_results_json = _execute_sparql_query(nodes_query, "Nodes Query")
    if "error" in node_results_json: return node_results_json
    
    node_query_vars = node_results_json.get('head', {}).get('vars', [])
    if "node" not in node_query_vars:
        return {"error": "Nodes Query Convention Error: Must select a '?node' variable for node IDs."}

    for binding in node_results_json.get('results', {}).get('bindings', []):
        if "node" not in binding: continue
        node_id = binding["node"]['value']
        _ensure_minimal_jsonld_node_entry(node_id, nodes_graph_objects)
        json_ld_node_obj = nodes_graph_objects[node_id]
        
        if "label" in binding:
            label_binding = binding["label"]
            label_obj = {"@value": label_binding['value']}
            if 'xml:lang' in label_binding: label_obj["@language"] = label_binding['xml:lang']
            _add_value_to_json_ld_object(json_ld_node_obj, RDFS_LABEL_URI, label_obj)

        if json_ld_group_predicate_uri and "node_group_id" in binding:
            group_id_val = binding["node_group_id"]['value']
            _ensure_minimal_jsonld_node_entry(group_id_val, nodes_graph_objects)
            _add_value_to_json_ld_object(json_ld_node_obj, json_ld_group_predicate_uri, {"@id": group_id_val})

    # 2. Process Group Query (optional, expects ?group_id, optional ?group_label)
    if groups_query:
        group_results_json = _execute_sparql_query(groups_query, "Groups Query")
        if "error" in group_results_json: return group_results_json
        
        group_query_vars = group_results_json.get('head', {}).get('vars', [])
        if "group_id" not in group_query_vars:
             return {"error": "Groups Query Convention Error: Must select a '?group_id' variable."}

        for binding in group_results_json.get('results', {}).get('bindings', []):
            if "group_id" in binding:
                gid = binding["group_id"]['value']
                _ensure_minimal_jsonld_node_entry(gid, nodes_graph_objects)
                json_ld_group_obj = nodes_graph_objects[gid]
                if "group_label" in binding:
                    glabel_binding = binding["group_label"]
                    label_obj = {"@value": glabel_binding['value']}
                    if 'xml:lang' in glabel_binding: label_obj["@language"] = glabel_binding['xml:lang']
                    _add_value_to_json_ld_object(json_ld_group_obj, RDFS_LABEL_URI, label_obj)

    # 3. Process Edge Query (expects ?source, ?target, and optional ?predicate)
    edge_results_json = _execute_sparql_query(edges_query, "Edges Query")
    if "error" in edge_results_json: return edge_results_json

    edge_query_vars = edge_results_json.get('head', {}).get('vars', [])
    # ?source and ?target are mandatory in the SELECT clause. ?predicate is now optional.
    mandatory_edge_vars_in_select = ["source", "target"]
    if not all(v in edge_query_vars for v in mandatory_edge_vars_in_select):
        return {"error": f"Edges Query Convention Error: Must select at least '?source' and '?target' variables."}

    for binding in edge_results_json.get('results', {}).get('bindings', []):
        # For an edge to be formed, source, target, AND predicate must be bound in this specific result row.
        # If ?predicate was not SELECTed by the user's query, it won't be in binding.
        # If ?predicate was SELECTed but is unbound for this row, it also won't form an edge.
        if not ("source" in binding and "target" in binding and "predicate" in binding):
            continue # Skip this binding if it doesn't define a complete edge with a predicate
        
        source_id = binding["source"]['value']
        # Only proceed if predicate is actually bound for this row
        if "predicate" not in binding or not binding["predicate"].get('value'):
            continue # Skip if predicate is missing or has no value

        predicate_uri = binding["predicate"]['value']
        target_id = binding["target"]['value']
        
        _ensure_minimal_jsonld_node_entry(source_id, nodes_graph_objects)
        _ensure_minimal_jsonld_node_entry(target_id, nodes_graph_objects)
        
        _ensure_minimal_jsonld_node_entry(source_id, edges_graph_objects)
        json_ld_edge_source_obj = edges_graph_objects[source_id]
        _add_value_to_json_ld_object(json_ld_edge_source_obj, predicate_uri, {"@id": target_id})

    final_output = {
        "nodes_json_ld": {
            "@context": shared_context,
            "@graph": list(nodes_graph_objects.values())
        },
        "edges_json_ld": {
            "@context": shared_context,
            "@graph": list(edges_graph_objects.values())
        }
    }
    return final_output

# --- FastAPI Pydantic Model for Simplified API Request Body ---
class SparqlQueriesInput(BaseModel):
    nodes_query: str = Field(..., description="SPARQL query for nodes. Must select '?node' for ID, optionally '?label' and '?node_group_id'.")
    edges_query: str = Field(..., description="SPARQL query for edges. Must select '?source' and '?target'. Optionally, select '?predicate' for the relationship type. If '?predicate' is not selected or is unbound for a row, that edge will not be formed. '?target' must be a resource URI/BNode.")
    groups_query: Optional[str] = Field(None, description="Optional SPARQL query for group labels. Must select '?group_id', optionally '?group_label'.")
    json_ld_group_predicate_uri: Optional[str] = Field(None, description="Optional: Predicate URI to link nodes to groups in JSON-LD (e.g., 'http://example.org/belongsToGroup').")

    class Config:
        json_schema_extra = {
            "example": {
                "nodes_query": "SELECT ?node ?label ?node_group_id WHERE { ?node a <http://xmlns.com/foaf/0.1/Person> ; rdfs:label ?label ; <http://example.org/memberOf> ?node_group_id . } LIMIT 10",
                "edges_query": "SELECT ?source ?predicate ?target WHERE { ?source ?predicate ?target . FILTER(?predicate != rdf:type && isIRI(?target)) } LIMIT 50",
                "groups_query": "SELECT ?group_id ?group_label WHERE { ?group_id a <http://example.org/Group> ; rdfs:label ?group_label . } LIMIT 5",
                "json_ld_group_predicate_uri": "http://example.org/memberOf"
            }
        }

# --- FastAPI App & Endpoint ---
app = FastAPI(
    title="Simplified SPARQL to Separated JSON-LD Service",
    description="Connects to a pre-configured SPARQL endpoint. Accepts SPARQL queries (following specific variable naming conventions) and returns separate JSON-LD for nodes and edges. The '?predicate' variable in the edges_query is now optional.",
    version="3.1.1" # Incremented version
)

@app.post("/query-to-separated-jsonld", summary="Transform SPARQL Queries to Separated JSON-LD (Optional Predicate)")
async def convert_sparql_to_separated_jsonld(queries: SparqlQueriesInput = Body(...)):
    if not config.ENDPOINT_URL:
        raise HTTPException(status_code=503, detail="SPARQL endpoint not configured. Start service with --endpoint option.")
    
    result = generate_separate_jsonld_outputs(
        nodes_query=queries.nodes_query,
        edges_query=queries.edges_query,
        groups_query=queries.groups_query,
        json_ld_group_predicate_uri=queries.json_ld_group_predicate_uri
    )

    if "error" in result:
        status_code = 400 
        if "HTTP error" in result.get("error", ""): status_code = 502
        elif "Request failed" in result.get("error", ""): status_code = 504
        raise HTTPException(status_code=status_code, detail=result)
    return result

# --- Command-Line Interface to run the App ---
cli = typer.Typer()
@cli.command()
def start(
    endpoint: str = typer.Option(..., "--endpoint", "-e", help="Full URL of the SPARQL endpoint."),
    token: Optional[str] = typer.Option(None, "--token", "-t", help="Optional Bearer token for authentication."),
    host: str = typer.Option("127.0.0.1", help="Server host."),
    port: int = typer.Option(8000, help="Server port.")
):
    config.ENDPOINT_URL = endpoint
    config.BEARER_TOKEN = token
    typer.echo(f"🚀 Starting server for SPARQL endpoint: {config.ENDPOINT_URL}")
    if config.BEARER_TOKEN: typer.echo(f"🔑 Using Bearer Token.")
    typer.echo(f"API at http://{host}:{port}, Docs at http://{host}:{port}/docs")
    uvicorn.run(app, host=host, port=port)

if __name__ == "__main__":
    cli()
