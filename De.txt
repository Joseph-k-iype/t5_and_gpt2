#!/usr/bin/env python3
"""
Simple SPARQL-based Ontology Schema Extractor
Uses SPARQL queries to extract schema elements from TTL files.
"""

import argparse
import sys
from pathlib import Path
from rdflib import Graph


def extract_schema_with_sparql(input_file, output_file):
    """
    Extract ontology schema using SPARQL queries.
    """
    try:
        # Load the input TTL file
        print(f"Loading ontology from: {input_file}")
        input_graph = Graph()
        input_graph.parse(input_file, format="turtle")
        print(f"Loaded {len(input_graph)} triples")
        
        # Create a new graph for the schema
        schema_graph = Graph()
        
        # Copy namespace prefixes from input graph
        for prefix, namespace in input_graph.namespaces():
            schema_graph.bind(prefix, namespace)
        
        print("\nExtracting schema using SPARQL queries...")
        
        # SPARQL queries to extract different schema elements
        schema_queries = [
            
            # 1. Extract all class declarations
            """
            CONSTRUCT { ?class a ?classType }
            WHERE {
                ?class a ?classType .
                FILTER(?classType IN (rdfs:Class, owl:Class))
            }
            """,
            
            # 2. Extract all property declarations  
            """
            CONSTRUCT { ?prop a ?propType }
            WHERE {
                ?prop a ?propType .
                FILTER(?propType IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, 
                                   owl:AnnotationProperty, owl:FunctionalProperty, 
                                   owl:InverseFunctionalProperty, owl:TransitiveProperty, 
                                   owl:SymmetricProperty))
            }
            """,
            
            # 3. Extract subclass relationships
            """
            CONSTRUCT { ?sub rdfs:subClassOf ?super }
            WHERE {
                ?sub rdfs:subClassOf ?super .
            }
            """,
            
            # 4. Extract subproperty relationships
            """
            CONSTRUCT { ?sub rdfs:subPropertyOf ?super }
            WHERE {
                ?sub rdfs:subPropertyOf ?super .
            }
            """,
            
            # 5. Extract domain and range
            """
            CONSTRUCT { 
                ?prop rdfs:domain ?domain .
                ?prop rdfs:range ?range .
            }
            WHERE {
                {
                    ?prop rdfs:domain ?domain .
                } UNION {
                    ?prop rdfs:range ?range .
                }
            }
            """,
            
            # 6. Extract equivalent classes and properties
            """
            CONSTRUCT { 
                ?x owl:equivalentClass ?y .
                ?x owl:equivalentProperty ?y .
            }
            WHERE {
                {
                    ?x owl:equivalentClass ?y .
                } UNION {
                    ?x owl:equivalentProperty ?y .
                }
            }
            """,
            
            # 7. Extract disjoint relationships
            """
            CONSTRUCT { 
                ?x owl:disjointWith ?y .
                ?x owl:propertyDisjointWith ?y .
            }
            WHERE {
                {
                    ?x owl:disjointWith ?y .
                } UNION {
                    ?x owl:propertyDisjointWith ?y .
                }
            }
            """,
            
            # 8. Extract inverse properties
            """
            CONSTRUCT { ?p1 owl:inverseOf ?p2 }
            WHERE {
                ?p1 owl:inverseOf ?p2 .
            }
            """,
            
            # 9. Extract OWL restrictions
            """
            CONSTRUCT { 
                ?restriction a owl:Restriction .
                ?restriction owl:onProperty ?prop .
                ?restriction owl:someValuesFrom ?value .
                ?restriction owl:allValuesFrom ?value .
                ?restriction owl:hasValue ?value .
                ?restriction owl:cardinality ?card .
                ?restriction owl:minCardinality ?card .
                ?restriction owl:maxCardinality ?card .
            }
            WHERE {
                ?restriction a owl:Restriction .
                ?restriction owl:onProperty ?prop .
                {
                    ?restriction owl:someValuesFrom ?value .
                } UNION {
                    ?restriction owl:allValuesFrom ?value .
                } UNION {
                    ?restriction owl:hasValue ?value .
                } UNION {
                    ?restriction owl:cardinality ?card .
                } UNION {
                    ?restriction owl:minCardinality ?card .
                } UNION {
                    ?restriction owl:maxCardinality ?card .
                }
            }
            """,
            
            # 10. Extract union, intersection, complement
            """
            CONSTRUCT { 
                ?class owl:unionOf ?list .
                ?class owl:intersectionOf ?list .
                ?class owl:complementOf ?comp .
            }
            WHERE {
                {
                    ?class owl:unionOf ?list .
                } UNION {
                    ?class owl:intersectionOf ?list .
                } UNION {
                    ?class owl:complementOf ?comp .
                }
            }
            """,
            
            # 11. Extract ontology metadata
            """
            CONSTRUCT { 
                ?ont a owl:Ontology .
                ?ont owl:versionInfo ?version .
                ?ont owl:imports ?import .
                ?ont rdfs:label ?label .
                ?ont rdfs:comment ?comment .
            }
            WHERE {
                ?ont a owl:Ontology .
                OPTIONAL { ?ont owl:versionInfo ?version . }
                OPTIONAL { ?ont owl:imports ?import . }
                OPTIONAL { ?ont rdfs:label ?label . }
                OPTIONAL { ?ont rdfs:comment ?comment . }
            }
            """,
            
            # 12. Find classes that are used as types (even if not explicitly declared)
            """
            CONSTRUCT { ?type a rdfs:Class }
            WHERE {
                ?instance a ?type .
                FILTER(isURI(?type))
                FILTER NOT EXISTS { ?type a ?explicitType . 
                                   FILTER(?explicitType IN (rdfs:Class, owl:Class)) }
            }
            """,
            
            # 13. Find properties that are used as predicates (even if not explicitly declared)
            """
            CONSTRUCT { ?prop a rdf:Property }
            WHERE {
                ?s ?prop ?o .
                FILTER(isURI(?prop))
                FILTER(?prop != rdf:type)
                FILTER NOT EXISTS { ?prop a ?explicitType . 
                                   FILTER(?explicitType IN (rdf:Property, owl:ObjectProperty, 
                                                          owl:DatatypeProperty, owl:AnnotationProperty)) }
            }
            """,
            
            # 14. Extract labels, comments, and other annotations for schema elements
            """
            CONSTRUCT { 
                ?element rdfs:label ?label .
                ?element rdfs:comment ?comment .
                ?element rdfs:seeAlso ?seeAlso .
                ?element rdfs:isDefinedBy ?definedBy .
            }
            WHERE {
                {
                    # For classes
                    ?element a ?classType .
                    FILTER(?classType IN (rdfs:Class, owl:Class))
                } UNION {
                    # For properties
                    ?element a ?propType .
                    FILTER(?propType IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty))
                } UNION {
                    # For things used as types
                    ?instance a ?element .
                    FILTER(isURI(?element))
                } UNION {
                    # For things used as predicates
                    ?s ?element ?o .
                    FILTER(isURI(?element))
                    FILTER(?element != rdf:type)
                }
                
                {
                    ?element rdfs:label ?label .
                } UNION {
                    ?element rdfs:comment ?comment .
                } UNION {
                    ?element rdfs:seeAlso ?seeAlso .
                } UNION {
                    ?element rdfs:isDefinedBy ?definedBy .
                }
            }
            """
        ]
        
        total_extracted = 0
        
        # Execute each query and add results to schema graph
        for i, query in enumerate(schema_queries, 1):
            print(f"Executing query {i}/{len(schema_queries)}...")
            try:
                results = input_graph.query(query)
                query_triples = 0
                for triple in results:
                    schema_graph.add(triple)
                    query_triples += 1
                print(f"  Added {query_triples} triples")
                total_extracted += query_triples
            except Exception as e:
                print(f"  Warning: Query {i} failed: {e}")
        
        # Remove duplicates (rdflib handles this automatically)
        final_count = len(schema_graph)
        
        # Save the schema graph
        print(f"\nSaving schema with {final_count} triples to: {output_file}")
        schema_graph.serialize(destination=output_file, format="turtle")
        
        # Print summary
        print("\n" + "="*50)
        print("SCHEMA EXTRACTION SUMMARY")
        print("="*50)
        print(f"Input file: {input_file}")
        print(f"Output file: {output_file}")
        print(f"Original triples: {len(input_graph)}")
        print(f"Schema triples: {final_count}")
        print(f"Extraction ratio: {final_count/len(input_graph)*100:.1f}%")
        
        # Quick analysis of what was extracted
        classes = len(list(schema_graph.query("SELECT ?c WHERE { ?c a ?type . FILTER(?type IN (rdfs:Class, owl:Class)) }")))
        properties = len(list(schema_graph.query("""
            SELECT ?p WHERE { 
                ?p a ?type . 
                FILTER(?type IN (rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, owl:AnnotationProperty)) 
            }
        """)))
        subclass_rels = len(list(schema_graph.query("SELECT * WHERE { ?s rdfs:subClassOf ?o }")))
        
        print(f"\nExtracted Elements:")
        print(f"  Classes: {classes}")
        print(f"  Properties: {properties}")
        print(f"  Subclass relationships: {subclass_rels}")
        
        print("\nSchema extraction completed successfully!")
        
    except Exception as e:
        print(f"Error processing ontology: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="Extract ontology schema from TTL file using SPARQL")
    parser.add_argument("input_file", help="Input TTL file path")
    parser.add_argument("-o", "--output", 
                       help="Output TTL file path (default: input_schema.ttl)")
    
    args = parser.parse_args()
    
    # Validate input file
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: Input file '{args.input_file}' does not exist")
        sys.exit(1)
    
    # Set output file
    if args.output:
        output_file = args.output
    else:
        output_file = input_path.stem + "_schema.ttl"
    
    # Extract schema
    extract_schema_with_sparql(args.input_file, output_file)


if __name__ == "__main__":
    main()
