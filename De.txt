import React, { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
  useReactFlow,
} from 'reactflow';
import 'reactflow/dist/style.css';

import CustomNode from './CustomNode';
import ControlPanel from './ControlPanel';
import Legend from './Legend';
import { lineageApi } from '@/services/api';
import { Country, Stats, CustomNode as CustomNodeType, CustomEdge } from '@/types/lineage';
import {
  convertToFlowNodes,
  convertToFlowEdges,
  toggleNodeCollapse,
  getDescendants,
} from '@/utils/lineageUtils';
import {
  calculateHierarchicalLayout,
  filterVisibleEdges,
} from '@/utils/layoutUtils';

const nodeTypes = {
  customNode: CustomNode,
};

const LineageFlow: React.FC = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [countries, setCountries] = useState<Country[]>([]);
  const [stats, setStats] = useState<Stats | null>(null);
  const [selectedCountry, setSelectedCountry] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(true);
  const [highlightedNodeIds, setHighlightedNodeIds] = useState<Set<string>>(new Set());
  const [highlightedEdgeIds, setHighlightedEdgeIds] = useState<Set<string>>(new Set());

  const { fitView, zoomIn, zoomOut } = useReactFlow();

  // Fetch initial data
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const [lineageData, countriesData, statsData] = await Promise.all([
          lineageApi.getLineageGraph(),
          lineageApi.getCountries(),
          lineageApi.getStats(),
        ]);

        setCountries(countriesData);
        setStats(statsData);

        // Convert and layout nodes
        const flowNodes = convertToFlowNodes(lineageData.nodes);
        const flowEdges = convertToFlowEdges(lineageData.edges);
        const layoutedNodes = calculateHierarchicalLayout(flowNodes, flowEdges);
        const visibleEdges = filterVisibleEdges(flowEdges, layoutedNodes);

        setNodes(layoutedNodes);
        setEdges(visibleEdges);

        setTimeout(() => fitView({ padding: 0.2 }), 50);
      } catch (error) {
        console.error('Error fetching lineage data:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  // Handle country filter change
  const handleCountryChange = async (country: string) => {
    setSelectedCountry(country);
    try {
      const lineageData = await lineageApi.getLineageGraph(country || undefined);
      const flowNodes = convertToFlowNodes(lineageData.nodes, highlightedNodeIds);
      const flowEdges = convertToFlowEdges(lineageData.edges, highlightedEdgeIds);
      const layoutedNodes = calculateHierarchicalLayout(flowNodes, flowEdges);
      const visibleEdges = filterVisibleEdges(flowEdges, layoutedNodes);

      setNodes(layoutedNodes);
      setEdges(visibleEdges);

      setTimeout(() => fitView({ padding: 0.2 }), 50);
    } catch (error) {
      console.error('Error filtering by country:', error);
    }
  };

  // Handle node click - highlight lineage path
  const handleNodeClick = useCallback(
    async (event: React.MouseEvent, node: Node) => {
      try {
        const customNode = node as CustomNodeType;

        // If clicking the chevron area (collapse/expand)
        const target = event.target as HTMLElement;
        if (target.tagName === 'svg' || target.closest('svg')) {
          // Toggle collapse state
          const updatedNodes = toggleNodeCollapse(nodes as CustomNodeType[], node.id);

          // Get descendants to hide/show
          const descendants = getDescendants(node.id, updatedNodes);

          // Update visibility
          const finalNodes = updatedNodes.map((n) => ({
            ...n,
            hidden:
              descendants.has(n.id) && updatedNodes.find((un) => un.id === node.id)?.data.is_collapsed,
          }));

          const layoutedNodes = calculateHierarchicalLayout(
            finalNodes,
            edges as CustomEdge[]
          );
          const visibleEdges = filterVisibleEdges(edges as CustomEdge[], layoutedNodes);

          setNodes(layoutedNodes);
          setEdges(visibleEdges);
          return;
        }

        // Otherwise, highlight lineage
        let highlightData;
        if (customNode.data.nodeType === 'attribute') {
          highlightData = await lineageApi.highlightPath(undefined, customNode.data.label);
        } else {
          highlightData = await lineageApi.highlightPath(node.id);
        }

        const newHighlightedNodeIds = new Set(highlightData.highlighted_nodes);
        const newHighlightedEdgeIds = new Set(highlightData.highlighted_edges);

        setHighlightedNodeIds(newHighlightedNodeIds);
        setHighlightedEdgeIds(newHighlightedEdgeIds);

        // Update nodes and edges with highlight state
        const updatedNodes = (nodes as CustomNodeType[]).map((n) => ({
          ...n,
          data: {
            ...n.data,
            isHighlighted: newHighlightedNodeIds.has(n.id),
          },
        }));

        const updatedEdges = (edges as CustomEdge[]).map((e) => {
          const isHighlighted = newHighlightedEdgeIds.has(e.id);
          return {
            ...e,
            animated: isHighlighted,
            data: {
              ...e.data,
              isHighlighted,
            },
            style: {
              stroke: isHighlighted ? '#3b82f6' : '#94a3b8',
              strokeWidth: isHighlighted ? 3 : 1.5,
            },
          };
        });

        setNodes(updatedNodes);
        setEdges(updatedEdges);
      } catch (error) {
        console.error('Error highlighting path:', error);
      }
    },
    [nodes, edges]
  );

  // Handle reset
  const handleReset = () => {
    setHighlightedNodeIds(new Set());
    setHighlightedEdgeIds(new Set());
    setSelectedCountry('');
    handleCountryChange('');
  };

  if (loading) {
    return (
      <div
        style={{
          width: '100%',
          height: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          background: '#f8fafc',
        }}
      >
        <div style={{ textAlign: 'center' }}>
          <div
            style={{
              fontSize: '24px',
              fontWeight: 700,
              color: '#1e293b',
              marginBottom: '8px',
            }}
          >
            Loading Data Lineage...
          </div>
          <div style={{ fontSize: '14px', color: '#64748b' }}>
            Connecting to FalkorDB
          </div>
        </div>
      </div>
    );
  }

  return (
    <div style={{ width: '100%', height: '100vh' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodeClick={handleNodeClick}
        nodeTypes={nodeTypes}
        fitView
        minZoom={0.1}
        maxZoom={2}
        defaultEdgeOptions={{
          type: 'smoothstep',
          animated: false,
          style: { strokeWidth: 1.5, stroke: '#94a3b8' },
        }}
      >
        <Background color="#e2e8f0" gap={16} />
        <Controls />
        <MiniMap
          nodeColor={(node) => {
            const customNode = node as CustomNodeType;
            if (customNode.data.isHighlighted) {
              switch (customNode.data.nodeType) {
                case 'country':
                  return '#3b82f6';
                case 'database':
                  return '#8b5cf6';
                case 'attribute':
                  return '#ec4899';
              }
            }
            return '#94a3b8';
          }}
          style={{
            background: '#f8fafc',
            border: '2px solid #e2e8f0',
            borderRadius: '8px',
          }}
        />
        <ControlPanel
          countries={countries}
          stats={stats}
          selectedCountry={selectedCountry}
          onCountryChange={handleCountryChange}
          onReset={handleReset}
          onZoomIn={() => zoomIn({ duration: 300 })}
          onZoomOut={() => zoomOut({ duration: 300 })}
          onFitView={() => fitView({ padding: 0.2, duration: 300 })}
        />
        <Legend />
      </ReactFlow>
    </div>
  );
};

export default LineageFlow;
