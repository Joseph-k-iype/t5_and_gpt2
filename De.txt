# backend/app/main.py
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
import logging
import sys
import os
from typing import Dict, List

# Import our API routers
from app.api import chat, research, knowledge_graph
from app.core.config import get_settings
from app.core.session_manager import SessionManager
from app.core.research_engine import ResearchEngineWrapper

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Global instances
session_manager = None
research_engine_wrapper = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifespan events"""
    # Startup
    logger.info("üöÄ Initializing Deep Research Chatbot API")
    
    global session_manager, research_engine_wrapper
    
    try:
        # Initialize session manager
        session_manager = SessionManager()
        logger.info("‚úÖ Session manager initialized")
        
        # Initialize the research engine wrapper
        research_engine_wrapper = ResearchEngineWrapper()
        await research_engine_wrapper.initialize()
        logger.info("‚úÖ Research engine initialized successfully")
        
        # Set global reference for dependency injection
        app.state.research_engine = research_engine_wrapper
        app.state.session_manager = session_manager
        
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize components: {e}")
        sys.exit(1)
    
    yield
    
    # Shutdown
    logger.info("üîÑ Shutting down Deep Research Chatbot API")
    
    try:
        # Cleanup research engine
        if research_engine_wrapper:
            await research_engine_wrapper.cleanup()
            logger.info("‚úÖ Research engine cleanup completed")
        
        # Cleanup session manager
        if session_manager:
            await session_manager.cleanup()
            logger.info("‚úÖ Session manager cleanup completed")
            
    except Exception as e:
        logger.error(f"‚ùå Error during shutdown: {e}")
    
    logger.info("‚úÖ Shutdown complete")

# Create FastAPI app with lifespan management
app = FastAPI(
    title="Deep Research Chatbot API",
    description="Advanced AI-powered research assistant with knowledge graph generation",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Configure CORS
settings = get_settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API routers
app.include_router(chat.router, prefix="/api/v1/chat", tags=["chat"])
app.include_router(research.router, prefix="/api/v1/research", tags=["research"])
app.include_router(knowledge_graph.router, prefix="/api/v1/knowledge-graph", tags=["knowledge-graph"])

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, websocket: WebSocket, session_id: str):
        await websocket.accept()
        self.active_connections[session_id] = websocket
        logger.info(f"WebSocket connected: {session_id}")
    
    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]
            logger.info(f"WebSocket disconnected: {session_id}")
    
    async def send_personal_message(self, message: dict, session_id: str):
        if session_id in self.active_connections:
            try:
                await self.active_connections[session_id].send_json(message)
            except Exception as e:
                logger.error(f"Error sending message to {session_id}: {e}")
                self.disconnect(session_id)

connection_manager = ConnectionManager()

# WebSocket endpoint for real-time communication
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await connection_manager.connect(websocket, session_id)
    try:
        while True:
            # Keep connection alive and handle any incoming messages
            data = await websocket.receive_text()
            # Echo back for now - can be extended for real-time features
            await connection_manager.send_personal_message(
                {"type": "echo", "data": data}, session_id
            )
    except WebSocketDisconnect:
        connection_manager.disconnect(session_id)
    except Exception as e:
        logger.error(f"WebSocket error for {session_id}: {e}")
        connection_manager.disconnect(session_id)

# Dependency to get research engine
async def get_research_engine():
    if not hasattr(app.state, 'research_engine') or app.state.research_engine is None:
        raise HTTPException(status_code=503, detail="Research engine not available")
    return app.state.research_engine

# Dependency to get session manager
async def get_session_manager():
    if not hasattr(app.state, 'session_manager') or app.state.session_manager is None:
        raise HTTPException(status_code=503, detail="Session manager not available")
    return app.state.session_manager

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Check if components are available
        engine_status = "healthy" if (hasattr(app.state, 'research_engine') and app.state.research_engine) else "unavailable"
        session_status = "healthy" if (hasattr(app.state, 'session_manager') and app.state.session_manager) else "unavailable"
        
        session_count = 0
        if hasattr(app.state, 'session_manager') and app.state.session_manager:
            session_count = len(app.state.session_manager.sessions)
        
        return {
            "status": "healthy",
            "research_engine": engine_status,
            "session_manager": session_status,
            "active_sessions": session_count,
            "active_websockets": len(connection_manager.active_connections)
        }
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail="Service unavailable")

# Root endpoint
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Deep Research Chatbot API",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health",
        "features": [
            "Quick Chat with AI Assistant",
            "Deep Multi-Agent Research",
            "Real-time Knowledge Graph Generation",
            "Session Management",
            "WebSocket Support"
        ]
    }

# Error handlers
@app.exception_handler(404)
async def not_found_handler(request, exc):
    return {"error": "Endpoint not found", "detail": str(exc)}

@app.exception_handler(500)
async def internal_error_handler(request, exc):
    logger.error(f"Internal server error: {exc}")
    return {"error": "Internal server error", "detail": "Please try again later"}

if __name__ == "__main__":
    import uvicorn
    
    # Development server
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
