"""
OpenAI API service for the legislation rules converter.
Updated to always use base_url parameter
Location: src/services/openai_service.py
"""
import logging
from typing import List, Union, Dict, Optional, Any
from openai import OpenAI
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

from ..config import Config

logger = logging.getLogger(__name__)


class OpenAIService:
    """Service for OpenAI API interactions with base_url support."""

    def __init__(self, api_key: str = None, base_url: str = None):
        """
        Initialize OpenAI service
        
        Args:
            api_key: OpenAI API key (defaults to Config.API_KEY)
            base_url: OpenAI API base URL (defaults to Config.BASE_URL)
        """
        self.api_key = api_key or Config.API_KEY
        self.base_url = base_url or Config.BASE_URL
        
        if not self.api_key:
            raise ValueError("API key is required. Set OPENAI_API_KEY environment variable.")
        
        logger.info(f"Initializing OpenAI Service:")
        logger.info(f"  Base URL: {self.base_url}")
        logger.info(f"  API Key: ***{self.api_key[-4:] if self.api_key else 'NOT SET'}")
        
        # Initialize client with base_url
        self.client = OpenAI(
            api_key=self.api_key,
            base_url=self.base_url
        )
        
        logger.info("âœ“ OpenAI client initialized")

    async def get_embeddings(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings using base_url connection."""
        try:
            response = self.client.embeddings.create(
                model=Config.EMBEDDING_MODEL,
                input=texts,
                encoding_format="float"
            )
            embeddings = [data.embedding for data in response.data]
            logger.info(f"Generated {len(embeddings)} embeddings")
            return embeddings
        except Exception as e:
            logger.error(f"Error generating embeddings: {e}")
            logger.error(f"Base URL used: {self.base_url}")
            logger.error(f"Model: {Config.EMBEDDING_MODEL}")
            raise

    async def chat_completion(self, messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]) -> str:
        """
        Generate chat completion with default settings.
        
        Args:
            messages: List of messages in the conversation
            
        Returns:
            String response from the model
        """
        try:
            formatted_messages = []
            for msg in messages:
                if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                    if isinstance(msg, SystemMessage):
                        formatted_messages.append({"role": "system", "content": msg.content})
                    elif isinstance(msg, HumanMessage):
                        formatted_messages.append({"role": "user", "content": msg.content})
                    elif isinstance(msg, AIMessage):
                        formatted_messages.append({"role": "assistant", "content": msg.content})
                elif isinstance(msg, dict):
                    formatted_messages.append(msg)
                else:
                    formatted_messages.append({"role": "user", "content": str(msg)})

            response = self.client.chat.completions.create(
                model=Config.CHAT_MODEL,
                messages=formatted_messages
            )
            return response.choices[0].message.content
        except Exception as e:
            logger.error(f"Error in chat completion: {e}")
            logger.error(f"Base URL used: {self.base_url}")
            logger.error(f"Model: {Config.CHAT_MODEL}")
            raise

    async def get_completion(
        self,
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> Any:
        """
        Generate chat completion with default settings.
        
        Args:
            messages: List of messages in the conversation
            
        Returns:
            Response object with content attribute
        """
        try:
            formatted_messages = []
            for msg in messages:
                if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                    if isinstance(msg, SystemMessage):
                        formatted_messages.append({"role": "system", "content": msg.content})
                    elif isinstance(msg, HumanMessage):
                        formatted_messages.append({"role": "user", "content": msg.content})
                    elif isinstance(msg, AIMessage):
                        formatted_messages.append({"role": "assistant", "content": msg.content})
                elif isinstance(msg, dict):
                    formatted_messages.append(msg)
                else:
                    formatted_messages.append({"role": "user", "content": str(msg)})

            response = self.client.chat.completions.create(
                model=Config.CHAT_MODEL,
                messages=formatted_messages
            )
            
            # Return a simple object with content attribute for compatibility
            class CompletionResponse:
                def __init__(self, content):
                    self.content = content
            
            return CompletionResponse(response.choices[0].message.content)
            
        except Exception as e:
            logger.error(f"Error in get_completion: {e}")
            logger.error(f"Base URL used: {self.base_url}")
            logger.error(f"Model: {Config.CHAT_MODEL}")
            raise
