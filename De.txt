import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ReactFlow, {
  Node,
  Edge,
  addEdge,
  useNodesState,
  useEdgesState,
  MiniMap,
  Controls,
  Background,
  Connection,
  NodeTypes,
  Position,
  MarkerType,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { cn } from '../utils/lib';

interface GraphVisualizationProps {
  message: string;
  metadata?: any;
  messageType: string;
}

// Custom Node Components
const ConceptNode = ({ data, selected }: { data: any; selected: boolean }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={cn(
      "px-4 py-2 rounded-lg border-2 shadow-lg min-w-[120px] text-center cursor-pointer",
      "bg-gradient-to-br from-blue-100 to-blue-200 border-blue-300",
      selected ? "ring-2 ring-blue-500" : ""
    )}
  >
    <div className="text-sm font-semibold text-blue-800">{data.label}</div>
    {data.type && (
      <div className="text-xs text-blue-600 mt-1">{data.type}</div>
    )}
  </motion.div>
);

const JurisdictionNode = ({ data, selected }: { data: any; selected: boolean }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={cn(
      "px-4 py-2 rounded-lg border-2 shadow-lg min-w-[100px] text-center cursor-pointer",
      "bg-gradient-to-br from-green-100 to-green-200 border-green-300",
      selected ? "ring-2 ring-green-500" : ""
    )}
  >
    <div className="text-sm font-semibold text-green-800">{data.label}</div>
    <div className="text-xs text-green-600 mt-1">Jurisdiction</div>
  </motion.div>
);

const RegulationNode = ({ data, selected }: { data: any; selected: boolean }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={cn(
      "px-4 py-2 rounded-lg border-2 shadow-lg min-w-[140px] text-center cursor-pointer",
      "bg-gradient-to-br from-purple-100 to-purple-200 border-purple-300",
      selected ? "ring-2 ring-purple-500" : ""
    )}
  >
    <div className="text-sm font-semibold text-purple-800">{data.label}</div>
    <div className="text-xs text-purple-600 mt-1">Regulation</div>
  </motion.div>
);

const RequirementNode = ({ data, selected }: { data: any; selected: boolean }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={cn(
      "px-3 py-2 rounded-lg border-2 shadow-lg min-w-[120px] text-center cursor-pointer",
      "bg-gradient-to-br from-orange-100 to-orange-200 border-orange-300",
      selected ? "ring-2 ring-orange-500" : ""
    )}
  >
    <div className="text-sm font-semibold text-orange-800">{data.label}</div>
    <div className="text-xs text-orange-600 mt-1">Requirement</div>
  </motion.div>
);

const CentralTopicNode = ({ data, selected }: { data: any; selected: boolean }) => (
  <motion.div
    whileHover={{ scale: 1.05 }}
    className={cn(
      "px-6 py-4 rounded-xl border-3 shadow-xl min-w-[160px] text-center cursor-pointer",
      "bg-gradient-to-br from-indigo-200 to-indigo-300 border-indigo-400",
      selected ? "ring-3 ring-indigo-600" : ""
    )}
  >
    <div className="text-base font-bold text-indigo-900">{data.label}</div>
    <div className="text-sm text-indigo-700 mt-1">Main Topic</div>
  </motion.div>
);

const nodeTypes: NodeTypes = {
  concept: ConceptNode,
  jurisdiction: JurisdictionNode,
  regulation: RegulationNode,
  requirement: RequirementNode,
  central: CentralTopicNode,
};

const GraphVisualization: React.FC<GraphVisualizationProps> = ({
  message,
  metadata,
  messageType
}) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedLayout, setSelectedLayout] = useState<'hierarchical' | 'circular' | 'force'>('hierarchical');
  const [isLoading, setIsLoading] = useState(true);
  const [showLegend, setShowLegend] = useState(true);

  // Extract concepts from message content
  const extractConcepts = useCallback((text: string) => {
    const concepts = new Set<string>();
    const jurisdictions = new Set<string>();
    const regulations = new Set<string>();
    const requirements = new Set<string>();

    // Privacy-related terms (comprehensive list)
    const privacyTerms = [
      'personal data', 'consent', 'processing', 'controller', 'processor',
      'data subject', 'data protection', 'privacy', 'breach', 'notification',
      'rights', 'access', 'rectification', 'erasure', 'portability',
      'encryption', 'pseudonymization', 'anonymization', 'security',
      'compliance', 'assessment', 'audit', 'penalty', 'fine',
      'legitimate interest', 'lawful basis', 'data minimization',
      'purpose limitation', 'accuracy', 'storage limitation',
      'accountability', 'transparency', 'fairness', 'lawfulness',
      'special categories', 'sensitive data', 'biometric data',
      'genetic data', 'health data', 'children', 'minors',
      'opt-in', 'opt-out', 'withdrawal', 'profiling', 'automated decision',
      'privacy by design', 'privacy by default', 'data sharing',
      'third party', 'vendor', 'sub-processor', 'joint controller',
      'data transfer', 'cross-border', 'adequacy decision',
      'binding corporate rules', 'standard contractual clauses',
      'certification', 'code of conduct', 'supervisory authority',
      'lead authority', 'one-stop-shop', 'consistency mechanism'
    ];

    // Jurisdictions and frameworks
    const jurisdictionTerms = [
      'GDPR', 'EU', 'European Union', 'CCPA', 'California', 'CPRA',
      'LGPD', 'Brazil', 'PIPEDA', 'Canada', 'PDPA', 'Singapore',
      'UK GDPR', 'United Kingdom', 'Brexit', 'Privacy Act', 'Australia',
      'PIPL', 'China', 'PDPB', 'India', 'POPIA', 'South Africa',
      'DPA', 'Switzerland', 'FADP', 'KVKK', 'Turkey', 'PDPL', 'Thailand',
      'Virginia', 'Colorado', 'Connecticut', 'Utah', 'Nevada'
    ];

    // Specific regulations
    const regulationTerms = [
      'General Data Protection Regulation', 'California Consumer Privacy Act',
      'California Privacy Rights Act', 'Lei Geral de Proteção de Dados',
      'Personal Information Protection and Electronic Documents Act',
      'Personal Data Protection Act', 'Data Protection Act',
      'Personal Information Protection Law', 'Protection of Personal Information Act',
      'Virginia Consumer Data Protection Act', 'Colorado Privacy Act',
      'Connecticut Data Privacy Act', 'Utah Consumer Privacy Act'
    ];

    // Requirements and mechanisms
    const requirementTerms = [
      'notification requirements', 'consent mechanisms', 'data subject rights',
      'security measures', 'impact assessment', 'record keeping',
      'data transfer mechanisms', 'lawful basis requirements',
      'legitimate interest assessment', 'privacy notice requirements',
      'cookie consent', 'withdrawal mechanisms', 'breach notification',
      '72 hour notification', 'supervisory authority reporting',
      'data protection officer', 'DPO appointment', 'privacy policy',
      'terms of service', 'user agreements', 'vendor agreements',
      'data processing agreements', 'joint controllership agreements',
      'processor agreements', 'international transfer agreements',
      'adequacy decisions', 'standard contractual clauses implementation',
      'binding corporate rules approval', 'certification schemes',
      'codes of conduct', 'privacy seals', 'audit requirements',
      'compliance monitoring', 'staff training requirements'
    ];

    const textLower = text.toLowerCase();

    // Extract different types of concepts with better matching
    privacyTerms.forEach(term => {
      if (textLower.includes(term.toLowerCase())) {
        concepts.add(term);
      }
    });

    jurisdictionTerms.forEach(term => {
      if (textLower.includes(term.toLowerCase())) {
        jurisdictions.add(term);
      }
    });

    regulationTerms.forEach(term => {
      if (textLower.includes(term.toLowerCase())) {
        // Shorten long regulation names for display
        const shortName = term.length > 30 ? term.substring(0, 30) + '...' : term;
        regulations.add(shortName);
      }
    });

    requirementTerms.forEach(term => {
      if (textLower.includes(term.toLowerCase())) {
        requirements.add(term);
      }
    });

    return {
      concepts: Array.from(concepts),
      jurisdictions: Array.from(jurisdictions),
      regulations: Array.from(regulations),
      requirements: Array.from(requirements)
    };
  }, []);

  // Generate graph layout
  const generateLayout = useCallback((layout: string, nodeCount: number) => {
    const centerX = 400;
    const centerY = 300;
    const radius = 200;

    switch (layout) {
      case 'circular':
        return (index: number, level: number = 0) => {
          const angle = (index * 2 * Math.PI) / Math.max(nodeCount, 1);
          return {
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          };
        };
      case 'force':
        return (index: number, level: number = 0) => ({
          x: centerX + (Math.random() - 0.5) * 600,
          y: centerY + (Math.random() - 0.5) * 400
        });
      case 'hierarchical':
      default:
        return (index: number, level: number = 0) => ({
          x: centerX + (index % 4 - 1.5) * 200,
          y: 100 + level * 120
        });
    }
  }, []);

  // Create nodes and edges
  const createGraph = useCallback(() => {
    setIsLoading(true);
    
    const extracted = extractConcepts(message);
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];
    
    // Determine main topic from metadata or message content
    let mainTopic = 'Privacy Query';
    if (metadata?.intent) {
      mainTopic = metadata.intent.charAt(0).toUpperCase() + metadata.intent.slice(1);
    } else {
      // Extract a meaningful topic from the message
      const topicKeywords = ['consent', 'breach', 'transfer', 'rights', 'processing', 'compliance'];
      for (const keyword of topicKeywords) {
        if (message.toLowerCase().includes(keyword)) {
          mainTopic = keyword.charAt(0).toUpperCase() + keyword.slice(1);
          break;
        }
      }
    }
    
    // Add central topic node
    newNodes.push({
      id: 'central',
      type: 'central',
      position: { x: 400, y: 50 },
      data: { label: mainTopic }
    });

    let nodeIndex = 1;
    const getPosition = generateLayout(selectedLayout, 15);

    // Add jurisdiction nodes
    extracted.jurisdictions.slice(0, 5).forEach((jurisdiction, index) => {
      const id = `jurisdiction-${index}`;
      const position = selectedLayout === 'hierarchical' 
        ? { x: 100 + index * 150, y: 150 }
        : getPosition(nodeIndex++, 1);
      
      newNodes.push({
        id,
        type: 'jurisdiction',
        position,
        data: { label: jurisdiction }
      });

      newEdges.push({
        id: `central-${id}`,
        source: 'central',
        target: id,
        type: 'smoothstep',
        markerEnd: { type: MarkerType.ArrowClosed },
        style: { stroke: '#10b981', strokeWidth: 2 },
        animated: true
      });
    });

    // Add regulation nodes
    extracted.regulations.slice(0, 4).forEach((regulation, index) => {
      const id = `regulation-${index}`;
      const position = selectedLayout === 'hierarchical'
        ? { x: 150 + index * 170, y: 280 }
        : getPosition(nodeIndex++, 2);

      newNodes.push({
        id,
        type: 'regulation',
        position,
        data: { label: regulation }
      });

      newEdges.push({
        id: `central-${id}`,
        source: 'central',
        target: id,
        type: 'smoothstep',
        markerEnd: { type: MarkerType.ArrowClosed },
        style: { stroke: '#8b5cf6', strokeWidth: 2 },
        animated: true
      });
    });

    // Add concept nodes
    extracted.concepts.slice(0, 8).forEach((concept, index) => {
      const id = `concept-${index}`;
      const position = selectedLayout === 'hierarchical'
        ? { x: 50 + index * 100, y: 410 }
        : getPosition(nodeIndex++, 3);

      newNodes.push({
        id,
        type: 'concept',
        position,
        data: { label: concept, type: 'concept' }
      });

      newEdges.push({
        id: `central-${id}`,
        source: 'central',
        target: id,
        type: 'smoothstep',
        markerEnd: { type: MarkerType.ArrowClosed },
        style: { stroke: '#3b82f6', strokeWidth: 1.5 }
      });
    });

    // Add requirement nodes
    extracted.requirements.slice(0, 6).forEach((requirement, index) => {
      const id = `requirement-${index}`;
      const position = selectedLayout === 'hierarchical'
        ? { x: 100 + index * 130, y: 540 }
        : getPosition(nodeIndex++, 4);

      const displayName = requirement.length > 25 ? requirement.substring(0, 25) + '...' : requirement;

      newNodes.push({
        id,
        type: 'requirement',
        position,
        data: { label: displayName }
      });

      newEdges.push({
        id: `central-${id}`,
        source: 'central',
        target: id,
        type: 'smoothstep',
        markerEnd: { type: MarkerType.ArrowClosed },
        style: { stroke: '#f97316', strokeWidth: 1.5 }
      });
    });

    // Create smart connections between related nodes
    extracted.jurisdictions.forEach((_, jurisdictionIndex) => {
      extracted.regulations.forEach((_, regulationIndex) => {
        // Connect jurisdictions to their relevant regulations
        if (Math.random() > 0.5) {
          newEdges.push({
            id: `jurisdiction-${jurisdictionIndex}-regulation-${regulationIndex}`,
            source: `jurisdiction-${jurisdictionIndex}`,
            target: `regulation-${regulationIndex}`,
            type: 'smoothstep',
            style: { stroke: '#6b7280', strokeWidth: 1, strokeDasharray: '5,5' }
          });
        }
      });
    });

    // Connect concepts to requirements
    extracted.concepts.slice(0, 4).forEach((_, conceptIndex) => {
      extracted.requirements.slice(0, 3).forEach((_, reqIndex) => {
        if (Math.random() > 0.7) {
          newEdges.push({
            id: `concept-${conceptIndex}-requirement-${reqIndex}`,
            source: `concept-${conceptIndex}`,
            target: `requirement-${reqIndex}`,
            type: 'smoothstep',
            style: { stroke: '#9ca3af', strokeWidth: 1, strokeDasharray: '3,3' }
          });
        }
      });
    });

    setNodes(newNodes);
    setEdges(newEdges);
    
    setTimeout(() => setIsLoading(false), 800);
  }, [message, metadata, selectedLayout, extractConcepts, generateLayout]);

  // Initialize graph
  useEffect(() => {
    createGraph();
  }, [createGraph]);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const layoutOptions = [
    { key: 'hierarchical', label: 'Hierarchical', icon: '📊', description: 'Structured top-down layout' },
    { key: 'circular', label: 'Circular', icon: '🔄', description: 'Circular relationship view' },
    { key: 'force', label: 'Force', icon: '🌟', description: 'Dynamic force-directed layout' }
  ];

  // Loading state
  if (isLoading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="w-full h-full bg-gradient-to-br from-blue-50 to-purple-50 rounded-xl border border-blue-200/50 flex items-center justify-center"
      >
        <div className="text-center">
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            className="w-12 h-12 border-4 border-blue-200 border-t-blue-500 rounded-full mx-auto mb-4"
          />
          <p className="text-blue-600 font-medium">Analyzing concepts and generating knowledge graph...</p>
          <p className="text-blue-500 text-sm mt-2">This may take a moment for complex topics</p>
        </div>
      </motion.div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.4 }}
      className="w-full h-full bg-white/80 backdrop-blur-sm rounded-xl border border-white/30 shadow-lg overflow-hidden relative"
    >
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        fitView
        fitViewOptions={{ padding: 0.15, maxZoom: 1.2 }}
        className="bg-gradient-to-br from-blue-50/50 to-purple-50/50"
        minZoom={0.3}
        maxZoom={2}
      >
        <Background 
          color="#e5e7eb" 
          gap={20} 
          size={1}
        />
        
        <MiniMap 
          className="bg-white/90 border border-white/50 rounded-lg shadow-md"
          nodeColor={(node) => {
            switch (node.type) {
              case 'jurisdiction': return '#10b981';
              case 'regulation': return '#8b5cf6';
              case 'concept': return '#3b82f6';
              case 'requirement': return '#f97316';
              case 'central': return '#6366f1';
              default: return '#6b7280';
            }
          }}
          maskColor="rgba(255, 255, 255, 0.2)"
        />
        
        <Controls 
          className="bg-white/90 backdrop-blur-sm border border-white/50 rounded-lg shadow-md"
          showInteractive={false}
        />
        
        {/* Layout Controls */}
        <Panel position="top-left" className="bg-transparent">
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="flex flex-wrap gap-2 mb-2"
          >
            {layoutOptions.map((option) => (
              <motion.button
                key={option.key}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                onClick={() => setSelectedLayout(option.key as any)}
                title={option.description}
                className={cn(
                  "flex items-center gap-1 px-3 py-2 rounded-lg text-sm font-medium transition-all shadow-sm",
                  selectedLayout === option.key
                    ? "bg-blue-500 text-white shadow-lg scale-105"
                    : "bg-white/90 text-gray-700 hover:bg-white border border-white/50"
                )}
              >
                <span>{option.icon}</span>
                <span className="hidden sm:inline">{option.label}</span>
              </motion.button>
            ))}
          </motion.div>
        </Panel>

        {/* Legend Panel */}
        <Panel position="top-right" className="bg-transparent">
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            className="bg-white/95 backdrop-blur-sm rounded-lg p-3 border border-white/50 shadow-lg max-w-xs"
          >
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-sm font-semibold text-gray-800">Legend</h3>
              <motion.button
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.9 }}
                onClick={() => setShowLegend(!showLegend)}
                className="text-xs text-gray-500 hover:text-gray-700"
              >
                {showLegend ? '−' : '+'}
              </motion.button>
            </div>
            
            <AnimatePresence>
              {showLegend && (
                <motion.div
                  initial={{ opacity: 0, height: 0 }}
                  animate={{ opacity: 1, height: 'auto' }}
                  exit={{ opacity: 0, height: 0 }}
                  className="space-y-1 text-xs"
                >
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-gradient-to-br from-green-100 to-green-200 border border-green-300 rounded"></div>
                    <span>Jurisdictions</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-gradient-to-br from-purple-100 to-purple-200 border border-purple-300 rounded"></div>
                    <span>Regulations</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-gradient-to-br from-blue-100 to-blue-200 border border-blue-300 rounded"></div>
                    <span>Concepts</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-gradient-to-br from-orange-100 to-orange-200 border border-orange-300 rounded"></div>
                    <span>Requirements</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-gradient-to-br from-indigo-200 to-indigo-300 border border-indigo-400 rounded"></div>
                    <span>Main Topic</span>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        </Panel>

        {/* Graph Stats Panel */}
        <Panel position="bottom-left" className="bg-transparent">
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="bg-white/90 backdrop-blur-sm rounded-lg p-2 border border-white/50 shadow-md"
          >
            <div className="text-xs text-gray-600">
              <div>Nodes: {nodes.length}</div>
              <div>Connections: {edges.length}</div>
            </div>
          </motion.div>
        </Panel>
      </ReactFlow>
    </motion.div>
  );
};

export default GraphVisualization;
