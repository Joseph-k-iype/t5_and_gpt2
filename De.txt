"""
Diagnostic script to identify and fix query timeout issue
Run this FIRST to diagnose the problem
"""

from falkordb import FalkorDB
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def diagnose_database():
    """Run diagnostics on the database"""
    
    logger.info("="*60)
    logger.info("FALKORDB DIAGNOSTIC SCRIPT")
    logger.info("="*60)
    
    try:
        # Connect
        db = FalkorDB(host='localhost', port=6379)
        graph = db.select_graph('DataTransferGraph')
        logger.info("✅ Connected to FalkorDB")
        
        # Test 1: Simple count
        logger.info("\n[Test 1] Counting Case nodes...")
        try:
            result = graph.query("MATCH (c:Case) RETURN count(c) as count", timeout=5000)
            count = result.result_set[0][0]
            logger.info(f"✅ Found {count:,} Case nodes")
        except Exception as e:
            logger.error(f"❌ Failed: {e}")
            return
        
        # Test 2: Check indexes
        logger.info("\n[Test 2] Checking indexes...")
        try:
            # Note: FalkorDB doesn't have a direct "SHOW INDEXES" but we can check if they exist
            queries = [
                "MATCH (c:Case) WHERE c.case_id = 'test' RETURN count(c)",
                "MATCH (c:Country) WHERE c.name = 'test' RETURN count(c)",
                "MATCH (j:Jurisdiction) WHERE j.name = 'test' RETURN count(j)",
            ]
            for q in queries:
                result = graph.query(q, timeout=2000)
                logger.info(f"✅ Index query works: {q.split('MATCH')[1].split('WHERE')[0].strip()}")
        except Exception as e:
            logger.error(f"⚠️ Index check failed: {e}")
        
        # Test 3: Count relationships
        logger.info("\n[Test 3] Counting relationships...")
        rel_queries = [
            ("ORIGINATES_FROM", "MATCH ()-[r:ORIGINATES_FROM]->() RETURN count(r)"),
            ("TRANSFERS_TO", "MATCH ()-[r:TRANSFERS_TO]->() RETURN count(r)"),
            ("HAS_PERSONAL_DATA", "MATCH ()-[r:HAS_PERSONAL_DATA]->() RETURN count(r)"),
        ]
        
        for rel_name, query in rel_queries:
            try:
                result = graph.query(query, timeout=5000)
                count = result.result_set[0][0]
                logger.info(f"✅ {rel_name}: {count:,} relationships")
            except Exception as e:
                logger.error(f"❌ {rel_name} failed: {e}")
        
        # Test 4: Simple join query
        logger.info("\n[Test 4] Testing simple join...")
        try:
            query = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            RETURN count(c) as count
            """
            result = graph.query(query, timeout=5000)
            count = result.result_set[0][0]
            logger.info(f"✅ Simple join works: {count:,} cases with origin")
        except Exception as e:
            logger.error(f"❌ Simple join failed: {e}")
        
        # Test 5: Double join query
        logger.info("\n[Test 5] Testing double join...")
        try:
            query = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
            RETURN count(c) as count
            """
            result = graph.query(query, timeout=5000)
            count = result.result_set[0][0]
            logger.info(f"✅ Double join works: {count:,} cases")
        except Exception as e:
            logger.error(f"❌ Double join failed: {e}")
        
        # Test 6: OPTIONAL MATCH query
        logger.info("\n[Test 6] Testing OPTIONAL MATCH...")
        try:
            query = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
            OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
            RETURN count(c) as count
            """
            result = graph.query(query, timeout=5000)
            count = result.result_set[0][0]
            logger.info(f"✅ OPTIONAL MATCH works: {count:,} cases")
        except Exception as e:
            logger.error(f"❌ OPTIONAL MATCH failed: {e}")
            logger.info("⚠️ This is likely the problem!")
        
        # Test 7: Full query with aggregation
        logger.info("\n[Test 7] Testing full query with aggregation...")
        try:
            query = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
            OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
            WITH c, origin, dest, collect(DISTINCT pd.name) AS personal_data
            RETURN count(c) as count
            """
            result = graph.query(query, timeout=10000)
            count = result.result_set[0][0]
            logger.info(f"✅ Full aggregation works: {count:,} cases")
        except Exception as e:
            logger.error(f"❌ Full aggregation failed: {e}")
            logger.info("⚠️ Problem is in the aggregation!")
        
        # Test 8: Try fetching actual data (limited)
        logger.info("\n[Test 8] Testing data fetch (10 records)...")
        try:
            query = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
            OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
            WITH c, origin, dest, collect(DISTINCT pd.name) AS personal_data
            RETURN 
                c.case_id,
                origin.name,
                dest.name,
                personal_data
            LIMIT 10
            """
            result = graph.query(query, timeout=10000)
            logger.info(f"✅ Fetched {len(result.result_set)} sample records")
            
            # Show first record
            if result.result_set:
                row = result.result_set[0]
                logger.info(f"   Sample: Case {row[0]}, {row[1]} → {row[2]}")
        except Exception as e:
            logger.error(f"❌ Data fetch failed: {e}")
        
        logger.info("\n" + "="*60)
        logger.info("DIAGNOSTIC COMPLETE")
        logger.info("="*60)
        
    except Exception as e:
        logger.error(f"Fatal error: {e}")


def test_alternative_queries():
    """Test alternative query approaches"""
    
    logger.info("\n" + "="*60)
    logger.info("TESTING ALTERNATIVE QUERY APPROACHES")
    logger.info("="*60)
    
    db = FalkorDB(host='localhost', port=6379)
    graph = db.select_graph('DataTransferGraph')
    
    # Approach 1: Break into smaller queries
    logger.info("\n[Approach 1] Fetch in parts...")
    try:
        # Get cases with origins and destinations
        query1 = """
        MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
        MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
        RETURN 
            c.case_id,
            origin.name,
            dest.name,
            c.pia_module,
            c.tia_module,
            c.hrpr_module,
            c.eim_id,
            c.business_app_id
        LIMIT 100
        """
        result = graph.query(query1, timeout=10000)
        logger.info(f"✅ Fetched {len(result.result_set)} cases without personal data")
        
        # Get personal data separately
        query2 = """
        MATCH (c:Case)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
        RETURN c.case_id, collect(DISTINCT pd.name) as personal_data
        LIMIT 100
        """
        result = graph.query(query2, timeout=10000)
        logger.info(f"✅ Fetched personal data for {len(result.result_set)} cases")
        
    except Exception as e:
        logger.error(f"❌ Approach 1 failed: {e}")
    
    # Approach 2: Simpler aggregation
    logger.info("\n[Approach 2] Simpler query without collect...")
    try:
        query = """
        MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
        MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
        RETURN 
            c.case_id,
            origin.name,
            dest.name,
            c.pia_module,
            c.tia_module,
            c.hrpr_module
        LIMIT 100
        """
        result = graph.query(query, timeout=10000)
        logger.info(f"✅ Fetched {len(result.result_set)} cases (simple query)")
    except Exception as e:
        logger.error(f"❌ Approach 2 failed: {e}")


if __name__ == "__main__":
    diagnose_database()
    test_alternative_queries()
