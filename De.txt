import { useState, useEffect, useRef, useCallback } from 'react';
import { io, type Socket } from 'socket.io-client';

interface UseWebSocketOptions {
  onMessage?: (event: string, data: any) => void;
  onConnect?: () => void;
  onDisconnect?: () => void;
  onError?: (error: any) => void;
  autoConnect?: boolean;
  reconnection?: boolean;
  reconnectionAttempts?: number;
  reconnectionDelay?: number;
}

interface UseWebSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  isConnecting: boolean;
  error: string | null;
  connect: () => void;
  disconnect: () => void;
  emit: (event: string, data?: any) => void;
}

const getWebSocketUrl = (): string => {
  if (typeof import.meta !== 'undefined' && import.meta?.env) {
    return (import.meta.env as any).VITE_WEBSOCKET_URL || 'http://localhost:5000';
  }
  return 'http://localhost:5000';
};

const WEBSOCKET_URL = getWebSocketUrl();

export const useWebSocket = ({
  onMessage,
  onConnect,
  onDisconnect,
  onError,
  autoConnect = true,
  reconnection = true,
  reconnectionAttempts = 5,
  reconnectionDelay = 1000
}: UseWebSocketOptions = {}): UseWebSocketReturn => {
  
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const socketRef = useRef<Socket | null>(null);
  const reconnectTimeoutRef = useRef<number | null>(null);
  const reconnectAttemptsRef = useRef(0);
  
  // Stable callback refs
  const onMessageRef = useRef(onMessage);
  const onConnectRef = useRef(onConnect);
  const onDisconnectRef = useRef(onDisconnect);
  const onErrorRef = useRef(onError);
  
  // Update callback refs when they change
  useEffect(() => {
    onMessageRef.current = onMessage;
  }, [onMessage]);
  
  useEffect(() => {
    onConnectRef.current = onConnect;
  }, [onConnect]);
  
  useEffect(() => {
    onDisconnectRef.current = onDisconnect;
  }, [onDisconnect]);
  
  useEffect(() => {
    onErrorRef.current = onError;
  }, [onError]);

  // Connect function
  const connect = useCallback(() => {
    if (socketRef.current?.connected) {
      console.log('WebSocket already connected');
      return;
    }

    try {
      setIsConnecting(true);
      setError(null);
      
      console.log('Connecting to WebSocket:', WEBSOCKET_URL);
      
      const socket = io(WEBSOCKET_URL, {
        transports: ['websocket', 'polling'],
        timeout: 10000,
        reconnection,
        reconnectionAttempts,
        reconnectionDelay,
        reconnectionDelayMax: 5000,
        forceNew: true
      });

      // Connection event handlers
      socket.on('connect', () => {
        console.log('WebSocket connected:', socket.id);
        setIsConnected(true);
        setIsConnecting(false);
        setError(null);
        reconnectAttemptsRef.current = 0;
        
        if (onConnectRef.current) {
          onConnectRef.current();
        }
      });

      socket.on('disconnect', (reason: string) => {
        console.log('WebSocket disconnected:', reason);
        setIsConnected(false);
        setIsConnecting(false);
        
        if (onDisconnectRef.current) {
          onDisconnectRef.current();
        }
        
        // Handle unexpected disconnections
        if (reason === 'io server disconnect') {
          // Server initiated disconnect, don't reconnect
          setError('Server disconnected the connection');
        } else if (reason === 'transport close' || reason === 'transport error') {
          // Network issues, try to reconnect
          handleReconnection();
        }
      });

      socket.on('connect_error', (err: Error) => {
        console.error('WebSocket connection error:', err);
        setIsConnecting(false);
        setError(err.message || 'Connection failed');
        
        if (onErrorRef.current) {
          onErrorRef.current(err);
        }
        
        handleReconnection();
      });

      // Message event handlers
      socket.on('connected', (data: any) => {
        console.log('WebSocket handshake completed:', data);
      });

      socket.on('message_response', (data: any) => {
        console.log('Received message response:', data);
        if (onMessageRef.current) {
          onMessageRef.current('message_response', data);
        }
      });

      socket.on('message_error', (data: any) => {
        console.log('Received message error:', data);
        if (onMessageRef.current) {
          onMessageRef.current('message_error', data);
        }
      });

      socket.on('thinking_start', (data: any) => {
        console.log('AI thinking started:', data);
        if (onMessageRef.current) {
          onMessageRef.current('thinking_start', data);
        }
      });

      socket.on('thinking_update', (data: any) => {
        console.log('AI thinking update:', data);
        if (onMessageRef.current) {
          onMessageRef.current('thinking_update', data);
        }
      });

      socket.on('research_start', (data: any) => {
        console.log('Research started:', data);
        if (onMessageRef.current) {
          onMessageRef.current('research_start', data);
        }
      });

      socket.on('research_complete', (data: any) => {
        console.log('Research completed:', data);
        if (onMessageRef.current) {
          onMessageRef.current('research_complete', data);
        }
      });

      socket.on('research_error', (data: any) => {
        console.log('Research error:', data);
        if (onMessageRef.current) {
          onMessageRef.current('research_error', data);
        }
      });

      socket.on('session_joined', (data: any) => {
        console.log('Session joined:', data);
        if (onMessageRef.current) {
          onMessageRef.current('session_joined', data);
        }
      });

      socket.on('session_error', (data: any) => {
        console.log('Session error:', data);
        if (onMessageRef.current) {
          onMessageRef.current('session_error', data);
        }
      });

      socketRef.current = socket;
      
    } catch (err) {
      console.error('Failed to create WebSocket connection:', err);
      setIsConnecting(false);
      setError(err instanceof Error ? err.message : 'Failed to connect');
      
      if (onErrorRef.current) {
        onErrorRef.current(err);
      }
    }
  }, [reconnection, reconnectionAttempts, reconnectionDelay]);

  // Disconnect function
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    if (socketRef.current) {
      console.log('Disconnecting WebSocket');
      socketRef.current.disconnect();
      socketRef.current = null;
    }
    
    setIsConnected(false);
    setIsConnecting(false);
    setError(null);
  }, []);

  // Emit function
  const emit = useCallback((event: string, data?: any) => {
    if (socketRef.current?.connected) {
      console.log('Emitting WebSocket event:', event, data);
      socketRef.current.emit(event, data);
    } else {
      console.warn('Cannot emit event - WebSocket not connected:', event);
      setError('WebSocket not connected');
    }
  }, []);

  // Handle reconnection logic
  const handleReconnection = useCallback(() => {
    if (reconnectAttemptsRef.current >= reconnectionAttempts) {
      console.log('Max reconnection attempts reached');
      setError('Connection failed after multiple attempts');
      return;
    }

    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    const delay = Math.min(reconnectionDelay * (reconnectAttemptsRef.current + 1), 5000);
    console.log(`Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current + 1}/${reconnectionAttempts})`);
    
    reconnectTimeoutRef.current = window.setTimeout(() => {
      reconnectAttemptsRef.current += 1;
      setIsConnecting(true);
      connect();
    }, delay);
  }, [connect, reconnectionAttempts, reconnectionDelay]);

  // Auto-connect on mount
  useEffect(() => {
    if (autoConnect) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [autoConnect, connect, disconnect]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      disconnect();
    };
  }, [disconnect]);

  // Connection health check
  useEffect(() => {
    if (!isConnected || !socketRef.current) return;

    const healthCheckInterval = setInterval(() => {
      if (socketRef.current?.connected) {
        socketRef.current.emit('ping');
      } else {
        console.warn('WebSocket health check failed - not connected');
        setIsConnected(false);
        if (reconnection) {
          handleReconnection();
        }
      }
    }, 30000); // Check every 30 seconds

    return () => clearInterval(healthCheckInterval);
  }, [isConnected, reconnection, handleReconnection]);

  return {
    socket: socketRef.current,
    isConnected,
    isConnecting,
    error,
    connect,
    disconnect,
    emit
  };
};
