// frontend/src/components/KnowledgeGraph/KnowledgeGraph.jsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  MarkerType,
  Panel,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { motion } from 'framer-motion';
import { RefreshCw, Download, Maximize2, Settings } from 'lucide-react';
import { knowledgeGraphService } from '../../services/knowledgeGraphService';
import { useSession } from '../../hooks/useSession';
import { useChat } from '../../hooks/useChat';
import LoadingSpinner from '../Common/LoadingSpinner';
import CustomNode from './CustomNode';
import CustomEdge from './CustomEdge';

// Custom node types
const nodeTypes = {
  custom: CustomNode,
};

// Custom edge types
const edgeTypes = {
  custom: CustomEdge,
};

const KnowledgeGraph = () => {
  const { sessionId } = useSession();
  const { messages } = useChat();
  
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [graphStats, setGraphStats] = useState({ nodes: 0, edges: 0, confidence: 0 });

  // Generate graph from latest assistant messages
  const generateGraphFromMessages = useCallback(async () => {
    if (!sessionId || messages.length === 0) return;

    try {
      setIsLoading(true);
      setError(null);

      // Get content from recent assistant messages
      const assistantMessages = messages
        .filter(msg => msg.role === 'assistant')
        .slice(-3) // Last 3 assistant messages
        .map(msg => msg.content)
        .join('\n\n');

      if (!assistantMessages.trim()) {
        setNodes([]);
        setEdges([]);
        return;
      }

      const response = await knowledgeGraphService.generateKnowledgeGraph({
        content: assistantMessages,
        session_id: sessionId,
        max_nodes: 25,
        max_edges: 40,
      });

      // Transform API response to React Flow format
      const transformedNodes = response.nodes.map((node, index) => ({
        id: node.id,
        type: 'custom',
        position: calculateNodePosition(index, response.nodes.length),
        data: {
          label: node.label,
          type: node.type,
          properties: node.properties,
          size: node.size,
        },
        style: {
          backgroundColor: node.color,
          color: getTextColor(node.color),
          border: `2px solid ${darkenColor(node.color)}`,
          borderRadius: '8px',
          padding: '8px 12px',
          fontSize: '12px',
          fontWeight: '500',
          minWidth: `${Math.max(node.size, 80)}px`,
          textAlign: 'center',
        },
      }));

      const transformedEdges = response.edges.map((edge) => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        type: 'custom',
        label: edge.label,
        data: {
          type: edge.type,
          properties: edge.properties,
          weight: edge.weight,
        },
        style: {
          strokeWidth: Math.max(1, edge.weight * 3),
          stroke: '#94a3b8',
        },
        markerEnd: {
          type: MarkerType.ArrowClosed,
          color: '#94a3b8',
        },
        labelStyle: {
          fontSize: '10px',
          color: '#64748b',
        },
      }));

      setNodes(transformedNodes);
      setEdges(transformedEdges);
      setGraphStats({
        nodes: transformedNodes.length,
        edges: transformedEdges.length,
        confidence: response.metadata?.confidence || 0,
      });

    } catch (err) {
      console.error('Error generating knowledge graph:', err);
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  }, [sessionId, messages]);

  // Auto-generate graph when messages change
  useEffect(() => {
    const timer = setTimeout(() => {
      generateGraphFromMessages();
    }, 1000); // Debounce updates

    return () => clearTimeout(timer);
  }, [generateGraphFromMessages]);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // Calculate node positions in a circle or grid layout
  const calculateNodePosition = (index, totalNodes) => {
    if (totalNodes <= 8) {
      // Circular layout for small graphs
      const angle = (index * 2 * Math.PI) / totalNodes;
      const radius = Math.min(150, 50 + totalNodes * 10);
      return {
        x: 250 + radius * Math.cos(angle),
        y: 200 + radius * Math.sin(angle),
      };
    } else {
      // Grid layout for larger graphs
      const cols = Math.ceil(Math.sqrt(totalNodes));
      const row = Math.floor(index / cols);
      const col = index % cols;
      return {
        x: 100 + col * 120,
        y: 100 + row * 100,
      };
    }
  };

  const getTextColor = (backgroundColor) => {
    // Simple contrast calculation
    const hex = backgroundColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    return brightness > 128 ? '#000000' : '#ffffff';
  };

  const darkenColor = (color) => {
    const hex = color.replace('#', '');
    const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - 30);
    const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - 30);
    const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - 30);
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  };

  const handleDownload = () => {
    // Implement graph download functionality
    const graphData = { nodes, edges, metadata: graphStats };
    const blob = new Blob([JSON.stringify(graphData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `knowledge-graph-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const miniMapStyle = {
    backgroundColor: '#f8fafc',
    border: '1px solid #e2e8f0',
  };

  if (error) {
    return (
      <div className="h-full flex items-center justify-center p-4">
        <div className="text-center">
          <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-3">
            <RefreshCw size={24} className="text-red-600" />
          </div>
          <h4 className="text-lg font-medium text-newyorker-black mb-2">
            Graph Generation Failed
          </h4>
          <p className="text-newyorker-muted text-sm mb-4">
            {error}
          </p>
          <button
            onClick={generateGraphFromMessages}
            className="btn btn-primary"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="lg" />
          <p className="text-newyorker-muted text-sm mt-4">
            Generating knowledge graph...
          </p>
        </div>
      </div>
    );
  }

  if (nodes.length === 0) {
    return (
      <div className="h-full flex items-center justify-center p-4">
        <div className="text-center">
          <div className="w-12 h-12 bg-newyorker-gray-100 rounded-full flex items-center justify-center mx-auto mb-3">
            <RefreshCw size={24} className="text-newyorker-muted" />
          </div>
          <h4 className="text-lg font-medium text-newyorker-black mb-2">
            No Graph Available
          </h4>
          <p className="text-newyorker-muted text-sm mb-4">
            Start a conversation to generate a knowledge graph from the discussion.
          </p>
          <button
            onClick={generateGraphFromMessages}
            className="btn btn-primary"
          >
            Generate Graph
          </button>
        </div>
      </div>
    );
  }

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="h-full relative bg-newyorker-paper"
    >
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        fitView
        attributionPosition="bottom-left"
        minZoom={0.1}
        maxZoom={2}
        defaultEdgeOptions={{
          type: 'custom',
          markerEnd: { type: MarkerType.ArrowClosed },
        }}
      >
        <Background color="#e2e8f0" gap={20} />
        
        <Controls
          style={{
            backgroundColor: 'white',
            border: '1px solid #e2e8f0',
            borderRadius: '8px',
          }}
        />
        
        <MiniMap
          style={miniMapStyle}
          zoomable
          pannable
          nodeColor={(node) => node.style?.backgroundColor || '#94a3b8'}
        />

        {/* Graph Controls Panel */}
        <Panel position="top-right">
          <div className="bg-white border border-newyorker-gray-200 rounded-lg p-3 shadow-sm space-y-3">
            {/* Graph Stats */}
            <div className="text-xs text-newyorker-muted space-y-1">
              <div className="flex justify-between">
                <span>Nodes:</span>
                <span className="font-medium">{graphStats.nodes}</span>
              </div>
              <div className="flex justify-between">
                <span>Edges:</span>
                <span className="font-medium">{graphStats.edges}</span>
              </div>
              <div className="flex justify-between">
                <span>Confidence:</span>
                <span className="font-medium">
                  {Math.round(graphStats.confidence * 100)}%
                </span>
              </div>
            </div>

            {/* Controls */}
            <div className="flex space-x-1">
              <button
                onClick={generateGraphFromMessages}
                className="p-2 text-newyorker-muted hover:text-newyorker-black transition-colors"
                title="Refresh Graph"
                disabled={isLoading}
              >
                <RefreshCw size={14} className={isLoading ? 'animate-spin' : ''} />
              </button>
              
              <button
                onClick={handleDownload}
                className="p-2 text-newyorker-muted hover:text-newyorker-black transition-colors"
                title="Download Graph"
              >
                <Download size={14} />
              </button>
              
              <button
                className="p-2 text-newyorker-muted hover:text-newyorker-black transition-colors"
                title="Fullscreen"
              >
                <Maximize2 size={14} />
              </button>
              
              <button
                className="p-2 text-newyorker-muted hover:text-newyorker-black transition-colors"
                title="Settings"
              >
                <Settings size={14} />
              </button>
            </div>
          </div>
        </Panel>
      </ReactFlow>
    </motion.div>
  );
};

export default KnowledgeGraph;

// frontend/src/components/KnowledgeGraph/CustomNode.jsx
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';

const CustomNode = ({ data, selected }) => {
  return (
    <div
      className={`px-3 py-2 rounded-lg border-2 text-center transition-all ${
        selected
          ? 'shadow-lg ring-2 ring-newyorker-accent ring-opacity-50'
          : 'shadow-sm hover:shadow-md'
      }`}
      style={{
        backgroundColor: data.color || '#ffffff',
        borderColor: data.borderColor || '#e2e8f0',
        minWidth: `${Math.max(data.size || 80, 60)}px`,
      }}
    >
      <Handle type="target" position={Position.Top} style={{ opacity: 0 }} />
      
      <div className="text-xs font-medium">
        {data.label}
      </div>
      
      {data.type && (
        <div className="text-xs opacity-75 mt-1 capitalize">
          {data.type.replace('_', ' ')}
        </div>
      )}
      
      Handle type="source" position={Position.Bottom} style={{ opacity: 0 }} />
    </div>
  );
};

export default memo(CustomNode);

// frontend/src/components/KnowledgeGraph/CustomEdge.jsx
import React from 'react';
import { getBezierPath, EdgeLabelRenderer, BaseEdge } from 'reactflow';

const CustomEdge = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  data,
  label,
  style = {},
  markerEnd,
}) => {
  const [edgePath, labelX, labelY] = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  });

  return (
    <>
      <BaseEdge path={edgePath} style={style} markerEnd={markerEnd} />
      {label && (
        <EdgeLabelRenderer>
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
              pointerEvents: 'all',
            }}
            className="bg-white px-2 py-1 rounded text-xs border border-newyorker-gray-200 shadow-sm"
          >
            {label}
          </div>
        </EdgeLabelRenderer>
      )}
    </>
  );
};

export default CustomEdge;

// frontend/src/components/Common/Accordion.jsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronDown, ChevronRight } from 'lucide-react';

const Accordion = ({ 
  title, 
  children, 
  defaultOpen = false, 
  className = '',
  titleClassName = '',
  contentClassName = '' 
}) => {
  const [isOpen, setIsOpen] = useState(defaultOpen);

  return (
    <div className={`border border-newyorker-gray-200 rounded-lg overflow-hidden ${className}`}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`w-full flex items-center justify-between p-4 text-left hover:bg-newyorker-gray-50 transition-colors ${titleClassName}`}
      >
        <h4 className="font-medium text-newyorker-black">{title}</h4>
        <motion.div
          animate={{ rotate: isOpen ? 90 : 0 }}
          transition={{ duration: 0.2 }}
        >
          <ChevronRight size={20} className="text-newyorker-muted" />
        </motion.div>
      </button>
      
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3, ease: 'easeInOut' }}
            className="overflow-hidden"
          >
            <div className={`p-4 pt-0 border-t border-newyorker-gray-200 ${contentClassName}`}>
              {children}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default Accordion;

// frontend/src/components/Common/LoadingSpinner.jsx
import React from 'react';
import { motion } from 'framer-motion';

const LoadingSpinner = ({ size = 'md', className = '' }) => {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
    xl: 'w-16 h-16',
  };

  return (
    <motion.div
      className={`${sizeClasses[size]} ${className}`}
      animate={{ rotate: 360 }}
      transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
    >
      <div className="w-full h-full border-2 border-newyorker-gray-300 border-t-newyorker-accent rounded-full"></div>
    </motion.div>
  );
};

export default LoadingSpinner;

// frontend/src/components/Common/Button.jsx
import React from 'react';
import { motion } from 'framer-motion';
import { Loader2 } from 'lucide-react';

const Button = ({
  children,
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled = false,
  className = '',
  onClick,
  ...props
}) => {
  const baseClasses = 'inline-flex items-center justify-center font-medium transition-all focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variants = {
    primary: 'bg-newyorker-black text-newyorker-cream hover:bg-newyorker-charcoal focus:ring-newyorker-accent',
    secondary: 'bg-newyorker-gray-200 text-newyorker-black hover:bg-newyorker-gray-300 focus:ring-newyorker-accent',
    accent: 'bg-newyorker-accent text-white hover:bg-red-700 focus:ring-newyorker-accent',
    outline: 'border border-newyorker-gray-300 text-newyorker-black hover:bg-newyorker-gray-50 focus:ring-newyorker-accent',
    ghost: 'text-newyorker-black hover:bg-newyorker-gray-100 focus:ring-newyorker-accent',
  };

  const sizes = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg',
  };

  const isDisabled = disabled || loading;

  return (
    <motion.button
      whileHover={!isDisabled ? { scale: 1.02 } : {}}
      whileTap={!isDisabled ? { scale: 0.98 } : {}}
      className={`
        ${baseClasses}
        ${variants[variant]}
        ${sizes[size]}
        ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}
        ${className}
      `}
      disabled={isDisabled}
      onClick={onClick}
      {...props}
    >
      {loading && (
        <Loader2 size={16} className="animate-spin mr-2" />
      )}
      {children}
    </motion.button>
  );
};

export default Button;
