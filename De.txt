"""
ReAct Agent Workflow for ODRL to Rego Conversion
FIXED: Uses enhanced tools that extract actual values from ODRL JSON
"""
import json
import os
import sys
from typing import Dict, Any, List
from datetime import datetime
from pathlib import Path

from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, SystemMessage

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from src.config import OPENAI_MODEL

# Import ENHANCED tools that extract actual values
from .react_tools import (
    extract_policy_metadata,
    extract_permissions_with_values,
    extract_prohibitions_with_values,
    extract_all_constraint_values,
    generate_rego_pattern_from_constraint,
    generate_complete_rego_rule,
    analyze_rdfs_comments,
    analyze_operator,
    analyze_rightOperand,
    check_rego_syntax,
    fix_missing_if
)

from ..prompting.odrl_rego_strategies import (
    ODRL_PARSER_REACT_PROMPT,
    TYPE_INFERENCE_REACT_PROMPT,
    LOGIC_ANALYZER_REACT_PROMPT,
    REGO_GENERATOR_REACT_PROMPT,
    REFLECTION_REACT_PROMPT,
    CORRECTION_REACT_PROMPT
)


# ============================================================================
# Configuration
# ============================================================================

def get_llm_for_agent():
    """Get LLM instance using existing config.py settings"""
    return ChatOpenAI(model=OPENAI_MODEL)


# ============================================================================
# ReAct Agent Creators (Using ENHANCED tools)
# ============================================================================

def create_odrl_parser_agent():
    """
    Create ReAct agent for ODRL parsing that extracts ACTUAL values.
    """
    llm = get_llm_for_agent()
    
    tools = [
        extract_policy_metadata,
        extract_permissions_with_values,  # Enhanced version
        extract_prohibitions_with_values,  # Enhanced version
        extract_all_constraint_values,  # NEW: Gets all actual values
        analyze_rdfs_comments
    ]
    
    checkpointer = MemorySaver()
    
    agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=ODRL_PARSER_REACT_PROMPT,
        checkpointer=checkpointer
    )
    
    return agent


def create_type_inference_agent():
    """
    Create ReAct agent for type inference using actual constraint values.
    """
    llm = get_llm_for_agent()
    
    tools = [
        analyze_operator,
        analyze_rightOperand,
        generate_rego_pattern_from_constraint,  # Enhanced: uses actual values
        extract_all_constraint_values,
        analyze_rdfs_comments
    ]
    
    checkpointer = MemorySaver()
    
    agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=TYPE_INFERENCE_REACT_PROMPT,
        checkpointer=checkpointer
    )
    
    return agent


def create_rego_generator_agent():
    """
    Create ReAct agent for generating Rego v1 code with actual values.
    """
    llm = get_llm_for_agent()
    
    tools = [
        generate_rego_pattern_from_constraint,  # Generates patterns with actual values
        generate_complete_rego_rule,  # NEW: Generates complete rules
        analyze_operator,
        check_rego_syntax
    ]
    
    checkpointer = MemorySaver()
    
    agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=REGO_GENERATOR_REACT_PROMPT,
        checkpointer=checkpointer
    )
    
    return agent


def create_reflection_agent():
    """
    Create ReAct agent for validating generated Rego code.
    """
    llm = get_llm_for_agent()
    
    tools = [
        check_rego_syntax
    ]
    
    checkpointer = MemorySaver()
    
    agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=REFLECTION_REACT_PROMPT,
        checkpointer=checkpointer
    )
    
    return agent


def create_correction_agent():
    """
    Create ReAct agent for fixing issues in Rego code.
    """
    llm = get_llm_for_agent()
    
    tools = [
        generate_rego_pattern_from_constraint,  # Regenerate with actual values
        check_rego_syntax,
        fix_missing_if
    ]
    
    checkpointer = MemorySaver()
    
    agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=CORRECTION_REACT_PROMPT,
        checkpointer=checkpointer
    )
    
    return agent


# ============================================================================
# Orchestrated Workflow
# ============================================================================

def convert_odrl_to_rego_react(
    odrl_json: Dict[str, Any],
    existing_rego: str = None,
    max_corrections: int = 3
) -> Dict[str, Any]:
    """
    Complete ODRL to Rego conversion using ReAct agents that extract actual values.
    
    This orchestrates multiple ReAct agents in sequence:
    1. Parser agent extracts ACTUAL values from ODRL JSON
    2. Type inference agent generates patterns with ACTUAL values
    3. Generator agent creates Rego code with ACTUAL values
    4. Reflection agent validates code
    5. Correction agent fixes issues (if needed)
    
    Args:
        odrl_json: ODRL policy in JSON-LD format
        existing_rego: Existing Rego code to append to (optional)
        max_corrections: Maximum correction attempts
        
    Returns:
        Dictionary with conversion results
    """
    
    results = {
        "success": False,
        "generated_rego": "",
        "policy_id": "",
        "messages": [],
        "reasoning_chain": [],
        "logical_issues": [],
        "correction_attempts": 0,
        "error_message": None,
        "stage_reached": "initialization"
    }
    
    try:
        odrl_str = json.dumps(odrl_json, indent=2)
        
        # ========================================================================
        # STAGE 1: Parse ODRL and Extract ACTUAL Values
        # ========================================================================
        results["messages"].append("Stage 1: Extracting actual values from ODRL...")
        results["stage_reached"] = "parsing"
        
        parser_agent = create_odrl_parser_agent()
        
        parser_config = {"configurable": {"thread_id": "odrl-parser"}}
        parser_input = {
            "messages": [
                HumanMessage(content=f"""
Analyze this ODRL policy and extract ALL actual values:

{odrl_str}

CRITICAL: Use your tools to extract the REAL values from the JSON:
1. Use extract_policy_metadata to get policy ID
2. Use extract_permissions_with_values to get permissions with ACTUAL constraint values
3. Use extract_prohibitions_with_values to get prohibitions with ACTUAL constraint values
4. Use extract_all_constraint_values to get a complete map of all actual values
5. Use analyze_rdfs_comments for context

Report the ACTUAL values you find, not placeholders!

Example: If you see rightOperand: ["data_controller", "dpo"], 
report: "Found actual values: data_controller, dpo"
NOT: "Found actual values: [actual_values_from_constraint]"
                """)
            ]
        }
        
        parser_response = parser_agent.invoke(parser_input, parser_config)
        parser_result = parser_response["messages"][-1].content
        
        results["reasoning_chain"].append({
            "stage": "parsing",
            "reasoning": parser_result
        })
        
        # Extract policy ID
        metadata_result = extract_policy_metadata(odrl_str)
        results["policy_id"] = metadata_result.get("policy_id", "unknown")
        results["messages"].append(f"Parsed policy: {results['policy_id']}")
        
        # ========================================================================
        # STAGE 2: Generate Rego Patterns with ACTUAL Values
        # ========================================================================
        results["messages"].append("Stage 2: Generating Rego patterns with actual values...")
        results["stage_reached"] = "type_inference"
        
        type_agent = create_type_inference_agent()
        
        type_config = {"configurable": {"thread_id": "type-inference"}}
        type_input = {
            "messages": [
                HumanMessage(content=f"""
Generate Rego patterns using the ACTUAL constraint values from this ODRL policy:

{odrl_str}

Parser found these actual values:
{parser_result}

CRITICAL: For EACH constraint, use generate_rego_pattern_from_constraint tool to create
the Rego pattern with the ACTUAL rightOperand value from the JSON.

For example, if constraint is:
{{"leftOperand": "role", "operator": "isAnyOf", "rightOperand": ["data_controller", "dpo"]}}

Generate pattern:
input.role in {{"data_controller", "dpo"}}  # Using ACTUAL values

NOT:
input.role in {{actual_values}}  # WRONG - this is a placeholder!

Use your tools to process each constraint and generate patterns with actual values.
                """)
            ]
        }
        
        type_response = type_agent.invoke(type_input, type_config)
        type_result = type_response["messages"][-1].content
        
        results["reasoning_chain"].append({
            "stage": "type_inference",
            "reasoning": type_result
        })
        results["messages"].append("Generated Rego patterns with actual values")
        
        # ========================================================================
        # STAGE 3: Generate Complete Rego Code with ACTUAL Values
        # ========================================================================
        results["messages"].append("Stage 3: Generating complete Rego code...")
        results["stage_reached"] = "generation"
        
        generator_agent = create_rego_generator_agent()
        
        existing_rego_prompt = ""
        if existing_rego:
            existing_rego_prompt = f"""
            
EXISTING REGO TO APPEND TO:
```rego
{existing_rego}
```
            """
        
        gen_config = {"configurable": {"thread_id": "rego-generator"}}
        gen_input = {
            "messages": [
                HumanMessage(content=f"""
Generate complete OPA Rego v1 code using the ACTUAL values from the ODRL policy:

ODRL Policy:
{odrl_str}

Extracted Actual Values:
{parser_result}

Rego Patterns with Actual Values:
{type_result}

{existing_rego_prompt}

CRITICAL INSTRUCTIONS:
1. Use generate_rego_pattern_from_constraint for EACH constraint to get patterns with actual values
2. Use generate_complete_rego_rule to create complete rules with all actual values
3. DO NOT use placeholder text like "actual_values" or "[value_from_constraint]"
4. Include 'import rego.v1' at the top
5. Use 'if' keyword before rule bodies
6. Validate with check_rego_syntax before finalizing

Generate complete, working Rego code with ACTUAL values from the ODRL JSON.
Return ONLY the Rego code, no markdown formatting.
                """)
            ]
        }
        
        gen_response = generator_agent.invoke(gen_input, gen_config)
        rego_code = gen_response["messages"][-1].content
        
        # Clean markdown fences if present
        if "```" in rego_code:
            lines = rego_code.split('\n')
            rego_code = '\n'.join(
                line for line in lines 
                if not line.strip().startswith('```')
            )
        
        results["generated_rego"] = rego_code.strip()
        results["messages"].append(f"Generated Rego code ({len(rego_code)} characters)")
        
        # ========================================================================
        # STAGE 4: Validate Generated Code
        # ========================================================================
        results["messages"].append("Stage 4: Validating Rego code...")
        results["stage_reached"] = "validation"
        
        reflection_agent = create_reflection_agent()
        
        refl_config = {"configurable": {"thread_id": "reflection"}}
        refl_input = {
            "messages": [
                HumanMessage(content=f"""
Validate this generated Rego code:

```rego
{results['generated_rego']}
```

Original ODRL Policy:
{odrl_str}

Check for:
1. Syntax errors (use check_rego_syntax tool)
2. Placeholder text (like "actual_values_from_constraint", "[value]", etc.)
3. Logic errors
4. Missing constraints

The code should use ACTUAL values from the ODRL JSON, not placeholders!
                """)
            ]
        }
        
        refl_response = reflection_agent.invoke(refl_input, refl_config)
        validation_result = refl_response["messages"][-1].content
        
        results["reasoning_chain"].append({
            "stage": "validation",
            "reasoning": validation_result
        })
        
        # Check if valid
        try:
            if "```json" in validation_result:
                json_start = validation_result.find("```json") + 7
                json_end = validation_result.find("```", json_start)
                validation_json = json.loads(validation_result[json_start:json_end])
            else:
                start = validation_result.find("{")
                end = validation_result.rfind("}") + 1
                validation_json = json.loads(validation_result[start:end])
            
            is_valid = validation_json.get("is_valid", False)
        except:
            is_valid = "valid" in validation_result.lower() and "invalid" not in validation_result.lower()
        
        # ========================================================================
        # STAGE 5: Correction (if needed)
        # ========================================================================
        if not is_valid and max_corrections > 0:
            results["messages"].append(f"Stage 5: Attempting corrections (max {max_corrections})...")
            results["stage_reached"] = "correction"
            
            correction_agent = create_correction_agent()
            
            for attempt in range(max_corrections):
                results["correction_attempts"] += 1
                
                corr_config = {"configurable": {"thread_id": f"correction-{attempt}"}}
                corr_input = {
                    "messages": [
                        HumanMessage(content=f"""
Fix all issues in this Rego code:

```rego
{results['generated_rego']}
```

Validation Issues:
{validation_result}

Original ODRL Policy (for reference):
{odrl_str}

CRITICAL:
1. Remove ALL placeholder text
2. Use generate_rego_pattern_from_constraint to regenerate patterns with actual values from ODRL
3. Fix syntax errors with fix_missing_if if needed
4. Validate with check_rego_syntax

Return corrected Rego code with ACTUAL values, not placeholders!
                        """)
                    ]
                }
                
                corr_response = correction_agent.invoke(corr_input, corr_config)
                corrected_code = corr_response["messages"][-1].content
                
                # Clean markdown fences
                if "```" in corrected_code:
                    lines = corrected_code.split('\n')
                    corrected_code = '\n'.join(
                        line for line in lines 
                        if not line.strip().startswith('```')
                    )
                
                results["generated_rego"] = corrected_code.strip()
                results["messages"].append(f"Correction attempt {attempt + 1}/{max_corrections}")
                
                # Re-validate
                refl_input["messages"][0] = HumanMessage(content=f"""
Validate this corrected Rego code:

```rego
{results['generated_rego']}
```

Original ODRL Policy:
{odrl_str}
                """)
                
                refl_response = reflection_agent.invoke(refl_input, refl_config)
                validation_result = refl_response["messages"][-1].content
                
                try:
                    if "```json" in validation_result:
                        json_start = validation_result.find("```json") + 7
                        json_end = validation_result.find("```", json_start)
                        validation_json = json.loads(validation_result[json_start:json_end])
                    else:
                        start = validation_result.find("{")
                        end = validation_result.rfind("}") + 1
                        validation_json = json.loads(validation_result[start:end])
                    
                    is_valid = validation_json.get("is_valid", False)
                except:
                    is_valid = "valid" in validation_result.lower() and "invalid" not in validation_result.lower()
                
                if is_valid:
                    results["messages"].append("✓ Validation passed after correction")
                    break
        
        # ========================================================================
        # Final Status
        # ========================================================================
        results["success"] = is_valid
        if is_valid:
            results["stage_reached"] = "completed"
            results["messages"].append("✓ ODRL to Rego conversion successful!")
        else:
            results["stage_reached"] = "validation_failed"
            results["error_message"] = f"Validation failed after {max_corrections} correction attempts"
            results["messages"].append(f"✗ Conversion failed: {results['error_message']}")
        
    except Exception as e:
        results["error_message"] = f"Conversion error: {str(e)}"
        results["messages"].append(f"ERROR: {str(e)}")
        results["stage_reached"] = "failed"
        import traceback
        results["messages"].append(traceback.format_exc())
    
    return results


# ============================================================================
# Convenience Functions
# ============================================================================

def convert_odrl_file_to_rego(
    input_file: str,
    output_file: str = None,
    existing_rego_file: str = None,
    max_corrections: int = 3
) -> Dict[str, Any]:
    """
    Convert ODRL file to Rego file using ReAct agents.
    
    Args:
        input_file: Path to ODRL JSON file
        output_file: Path for output Rego file (optional)
        existing_rego_file: Path to existing Rego to append to (optional)
        max_corrections: Maximum correction attempts
        
    Returns:
        Conversion results
    """
    # Load ODRL
    with open(input_file, 'r') as f:
        odrl_json = json.load(f)
    
    # Load existing Rego if provided
    existing_rego = None
    if existing_rego_file and os.path.exists(existing_rego_file):
        with open(existing_rego_file, 'r') as f:
            existing_rego = f.read()
    
    # Convert
    result = convert_odrl_to_rego_react(odrl_json, existing_rego, max_corrections)
    
    # Save if successful
    if result["success"] and output_file:
        with open(output_file, 'w') as f:
            f.write(result["generated_rego"])
        result["output_file"] = output_file
    
    return result
