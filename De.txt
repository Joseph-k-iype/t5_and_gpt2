"""
HSBC Token Service for JWT authentication
FIXED: Better token expiration tracking and automatic refresh
Handles token fetching and automatic refresh using httpx + truststore
"""
import logging
import ssl
import httpx
import truststore
from typing import Optional
from datetime import datetime, timedelta
import threading
import time

logger = logging.getLogger(__name__)


class HSBCTokenService:
    """Service for managing HSBC JWT tokens with automatic refresh and expiration tracking."""
    
    def __init__(
        self,
        token_endpoint: str,
        username: str,
        password: str,
        token_buffer_seconds: int = 300,  # Refresh 5 minutes before expiry
        token_lifetime_seconds: int = 3600  # Assume 1 hour token lifetime
    ):
        """
        Initialize HSBC Token Service with dynamic token refresh
        
        Args:
            token_endpoint: URL for token translation endpoint
            username: HSBC username for authentication
            password: HSBC password for authentication
            token_buffer_seconds: Seconds before expiry to refresh token (default: 5 minutes)
            token_lifetime_seconds: Expected token lifetime in seconds (default: 1 hour)
        """
        self.token_endpoint = token_endpoint
        self.username = username
        self.password = password
        self.token_buffer_seconds = token_buffer_seconds
        self.token_lifetime_seconds = token_lifetime_seconds
        
        self._current_token: Optional[str] = None
        self._token_expiry: Optional[datetime] = None
        self._token_fetched_at: Optional[datetime] = None
        self._lock = threading.Lock()
        
        # Create httpx client with truststore SSL context
        ctx = truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        self.httpx_client = httpx.Client(http2=True, verify=ctx)
        
        logger.info("HSBC Token Service initialized with httpx + truststore")
        logger.info(f"  Token refresh buffer: {token_buffer_seconds} seconds")
        logger.info(f"  Expected token lifetime: {token_lifetime_seconds} seconds")
    
    def _fetch_new_token(self) -> str:
        """
        Fetch a new JWT token from HSBC token service.
        
        Returns:
            str: JWT token
            
        Raises:
            Exception: If token fetch fails
        """
        try:
            payload = {
                "input_token_state": {
                    "token_type": "CREDENTIAL",
                    "username": self.username,
                    "password": self.password
                },
                "output_token_state": {
                    "token_type": "JWT"
                }
            }
            
            logger.info(f"Fetching new token from {self.token_endpoint}")
            start_time = time.time()
            
            response = self.httpx_client.post(
                self.token_endpoint,
                json=payload,
                timeout=30.0  # Add timeout
            )
            
            response.raise_for_status()
            
            data = response.json()
            token = data.get("issued_token")
            
            if not token:
                raise ValueError(f"No issued_token in response: {data}")
            
            elapsed_time = time.time() - start_time
            logger.info(f"âœ“ Successfully fetched new JWT token (took {elapsed_time:.2f}s)")
            
            return token
            
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error fetching token: {e}")
            logger.error(f"Status code: {e.response.status_code}")
            logger.error(f"Response: {e.response.text if hasattr(e, 'response') else 'N/A'}")
            raise Exception(f"Failed to fetch HSBC token (HTTP {e.response.status_code}): {e}")
        except httpx.TimeoutException as e:
            logger.error(f"Timeout fetching token: {e}")
            raise Exception(f"Token fetch timeout: {e}")
        except Exception as e:
            logger.error(f"Error fetching token: {e}")
            raise Exception(f"Failed to fetch HSBC token: {e}")
    
    def _is_token_valid(self) -> bool:
        """
        Check if current token is valid and not near expiry.
        
        Returns:
            bool: True if token is valid and not expiring soon
        """
        if not self._current_token or not self._token_expiry:
            logger.debug("Token check: No current token")
            return False
        
        now = datetime.now()
        time_until_expiry = (self._token_expiry - now).total_seconds()
        
        if time_until_expiry <= 0:
            logger.warning(f"Token expired {abs(time_until_expiry):.0f} seconds ago")
            return False
        
        if time_until_expiry <= self.token_buffer_seconds:
            logger.info(f"Token expiring soon (in {time_until_expiry:.0f} seconds, buffer is {self.token_buffer_seconds})")
            return False
        
        logger.debug(f"Token valid for {time_until_expiry:.0f} more seconds")
        return True
    
    def _is_token_expired(self) -> bool:
        """
        Check if token is completely expired (past expiry time).
        
        Returns:
            bool: True if token is expired
        """
        if not self._current_token or not self._token_expiry:
            return True
        
        return datetime.now() >= self._token_expiry
    
    def get_token(self, force_refresh: bool = False) -> str:
        """
        Get current valid token, refreshing if necessary.
        Thread-safe with automatic refresh on expiration.
        
        Args:
            force_refresh: Force token refresh even if current token is valid
            
        Returns:
            str: Valid JWT token
        """
        with self._lock:
            # Check if we need to fetch/refresh token
            needs_refresh = force_refresh or not self._is_token_valid()
            
            if needs_refresh:
                if force_refresh:
                    logger.info("Token refresh forced by caller")
                elif self._is_token_expired():
                    logger.warning("Token has EXPIRED - fetching new token immediately")
                else:
                    logger.info("Token expiring soon - proactive refresh")
                
                try:
                    # Fetch new token
                    self._current_token = self._fetch_new_token()
                    self._token_fetched_at = datetime.now()
                    
                    # Calculate expiry time
                    self._token_expiry = self._token_fetched_at + timedelta(
                        seconds=self.token_lifetime_seconds
                    )
                    
                    time_until_expiry = (self._token_expiry - datetime.now()).total_seconds()
                    refresh_at = self._token_expiry - timedelta(seconds=self.token_buffer_seconds)
                    
                    logger.info(f"Token fetched successfully:")
                    logger.info(f"  Fetched at: {self._token_fetched_at.strftime('%Y-%m-%d %H:%M:%S')}")
                    logger.info(f"  Expires at: {self._token_expiry.strftime('%Y-%m-%d %H:%M:%S')}")
                    logger.info(f"  Valid for: {time_until_expiry:.0f} seconds")
                    logger.info(f"  Will refresh at: {refresh_at.strftime('%Y-%m-%d %H:%M:%S')}")
                    
                except Exception as e:
                    logger.error(f"Failed to refresh token: {e}")
                    # If we have a current token (even if expiring), return it as fallback
                    if self._current_token:
                        logger.warning("Using potentially expired token as fallback")
                        return self._current_token
                    raise
            else:
                time_remaining = (self._token_expiry - datetime.now()).total_seconds()
                logger.debug(f"Using existing token (valid for {time_remaining:.0f} more seconds)")
            
            return self._current_token
    
    def invalidate_token(self):
        """
        Invalidate current token to force refresh on next request.
        Thread-safe.
        """
        with self._lock:
            logger.info("Invalidating current token - will fetch fresh token on next request")
            self._current_token = None
            self._token_expiry = None
            self._token_fetched_at = None
    
    def get_token_info(self) -> dict:
        """
        Get information about current token status.
        
        Returns:
            dict: Token status information
        """
        with self._lock:
            if not self._current_token:
                return {
                    "has_token": False,
                    "status": "no_token"
                }
            
            now = datetime.now()
            time_until_expiry = (self._token_expiry - now).total_seconds() if self._token_expiry else 0
            
            if time_until_expiry <= 0:
                status = "expired"
            elif time_until_expiry <= self.token_buffer_seconds:
                status = "expiring_soon"
            else:
                status = "valid"
            
            return {
                "has_token": True,
                "status": status,
                "fetched_at": self._token_fetched_at.isoformat() if self._token_fetched_at else None,
                "expires_at": self._token_expiry.isoformat() if self._token_expiry else None,
                "seconds_until_expiry": max(0, time_until_expiry),
                "is_valid": status == "valid"
            }
    
    def get_httpx_client(self) -> httpx.Client:
        """Get the httpx client for making requests."""
        return self.httpx_client
