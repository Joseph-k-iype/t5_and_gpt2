import logging
import uuid
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query

from app.core.models import PBTTaggingRequest, PBTTaggingResponse, MatchedPBT
from app.core.business_terms import BusinessTermManager
from app.config.settings import get_llm

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1/pbt", tags=["PBT Tagging"])

# Dependency to get BusinessTermManager instance
def get_business_term_manager() -> BusinessTermManager:
    """Dependency to provide a BusinessTermManager instance."""
    return BusinessTermManager()

@router.post("/tag", response_model=PBTTaggingResponse)
async def find_preferred_business_terms(
    request: PBTTaggingRequest,
    bt_manager: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Find and suggest Preferred Business Terms (PBTs) for a given item name and description.

    This endpoint uses vector similarity search (via ChromaDB and text-embedding-3-large)
    and a RAG (Retrieval Augmented Generation) pattern to provide relevant PBT suggestions.
    Optional context like examples, process name, and process description can be provided
    to improve the accuracy of the suggestions.
    """
    try:
        logger.info(f"Received PBT tagging request for name: '{request.name}'")
        logger.info(f"Description: '{request.description}'")
        
        # Log database term count for debugging
        term_count = bt_manager.get_term_count()
        logger.info(f"Terms in database: {term_count}")

        # The BusinessTermManager.tag_element method is designed for enhancing DataElements
        # and tagging them. We can leverage its underlying search and RAG capabilities.
        # We'll pass the PBT request details as if it were a DataElement to be tagged.
        # A unique ID is needed for the internal `tag_element` call.
        temp_element_id = f"pbt_query_{uuid.uuid4()}"

        # Combine examples into a single string if provided
        example_context = ""
        if request.examples:
            example_context = " ".join(request.examples)
            logger.debug(f"Using example context: {example_context[:200]}...")

        # Initial tagging attempt with default threshold
        logger.info(f"Performing initial tagging attempt")
        tagging_result = await bt_manager.tag_element(
            element_id=temp_element_id,
            name=request.name, # Corresponds to element_name in TaggingRequest
            description=request.description, # Corresponds to element_description
            top_k=request.top_n,
            cdm=None, # CDM filtering can be implemented within tag_element or its agent if needed
            example=example_context,
            process_name=request.process_name,
            process_description=request.process_description,
            threshold=0.2  # Start with lower threshold (0.2 instead of default 0.3)
        )

        # Transform the results from TaggingResult to PBTTaggingResponse format
        matched_pbts_response: List[MatchedPBT] = []
        if tagging_result and tagging_result.matching_terms:
            for term_data in tagging_result.matching_terms:
                # term_data is expected to be a dict with 'id', 'name', 'description', 'similarity', 'metadata'
                pbt_id = term_data.get("id", "")
                pbt_name = term_data.get("name", "Unknown PBT Name")
                pbt_description = term_data.get("description", "No description available.")
                similarity_score = term_data.get("similarity", 0.0)
                metadata = term_data.get("metadata", {})
                cdm = metadata.get("cdm") # Assuming 'cdm' is stored in metadata

                matched_pbts_response.append(
                    MatchedPBT(
                        id=pbt_id,
                        pbt_name=pbt_name,
                        pbt_description=pbt_description,
                        cdm=cdm,
                        similarity_score=similarity_score,
                        metadata=metadata # Include other metadata if useful
                    )
                )
        
        # If no matches found, try again with a much lower threshold
        if not matched_pbts_response:
            logger.info(f"No matches found initially, trying with lower threshold")
            
            # Try again with much lower threshold
            fallback_result = await bt_manager.tag_element(
                element_id=temp_element_id,
                name=request.name,
                description=request.description,
                top_k=max(10, request.top_n * 2),  # Increase candidates
                cdm=None,
                example=example_context,
                process_name=request.process_name,
                process_description=request.process_description,
                threshold=0.05  # Very low threshold
            )
            
            # Process fallback results
            if fallback_result and fallback_result.matching_terms:
                for term_data in fallback_result.matching_terms:
                    pbt_id = term_data.get("id", "")
                    pbt_name = term_data.get("name", "Unknown PBT Name")
                    pbt_description = term_data.get("description", "No description available.")
                    similarity_score = term_data.get("similarity", 0.0)
                    metadata = term_data.get("metadata", {})
                    cdm = metadata.get("cdm")
                    
                    # Add fallback annotation to metadata
                    metadata["fallback_search"] = True
                    
                    matched_pbts_response.append(
                        MatchedPBT(
                            id=pbt_id,
                            pbt_name=pbt_name,
                            pbt_description=pbt_description,
                            cdm=cdm,
                            similarity_score=similarity_score,
                            metadata=metadata
                        )
                    )
                
                logger.info(f"Fallback search found {len(matched_pbts_response)} potential matches")
        
        response_message = tagging_result.message if tagging_result else "PBT tagging process completed."
        if tagging_result and tagging_result.modeling_required and not matched_pbts_response:
            response_message = "No suitable PBTs found. Consider modeling a new term."
        elif not matched_pbts_response:
             response_message = "No PBTs found matching the criteria."
        elif len(matched_pbts_response) > 0 and any(p.metadata.get("fallback_search", False) for p in matched_pbts_response):
             response_message = f"Found {len(matched_pbts_response)} potential PBTs using extended search."

        # If we have matches, use LLM to enhance the response with insights
        if matched_pbts_response and len(matched_pbts_response) > 0:
            try:
                llm = get_llm()
                if llm:
                    # Format matches for LLM
                    matches_text = "\n".join([
                        f"Match {i+1}:\nName: {m.pbt_name}\nDescription: {m.pbt_description}\nScore: {m.similarity_score:.3f}"
                        for i, m in enumerate(matched_pbts_response[:5])
                    ])
                    
                    insight_prompt = f"""
You are a data governance expert. Explain how these business terms might be relevant to the data element:

Data Element:
Name: {request.name}
Description: {request.description}

Matched Business Terms:
{matches_text}

Provide an insightful 1-2 sentence explanation of the match quality and applicability.
"""
                    
                    # Get LLM insight
                    insight = await llm.ainvoke(insight_prompt)
                    if insight and len(insight.strip()) > 0:
                        response_message = insight.strip()
                        logger.info("Added LLM insight to response")
            except Exception as e:
                logger.warning(f"Error getting LLM insight: {e}")
                # Continue with default message

        return PBTTaggingResponse(
            input_name=request.name,
            input_description=request.description,
            matched_pbts=matched_pbts_response,
            message=response_message
        )

    except HTTPException:
        # Re-raise HTTPException directly
        raise
    except Exception as e:
        logger.error(f"Error during PBT tagging for name '{request.name}': {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during PBT tagging: {str(e)}")
