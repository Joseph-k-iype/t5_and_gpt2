"""
PostgreSQL Vector Store - Vector database implementation using PostgreSQL with pgvector.

This module provides a PostgreSQL implementation of the vector store interface,
with functionality for storing, retrieving, and searching vectors using the pgvector extension.
"""

import logging
import numpy as np
from typing import List, Dict, Any, Optional
from app.core.vector_store import VectorStore
from app.core.db_manager import DBManager
from psycopg2.extras import Json

logger = logging.getLogger(__name__)

class PostgreSQLVectorStore(VectorStore):
    """Vector store implementation using PostgreSQL with pgvector."""
    
    def __init__(self):
        """Initialize PostgreSQL vector store."""
        self.db_manager = DBManager()
        self.schema_name = self.db_manager.schema_name
        
        logger.info(f"PostgreSQL vector store initialized with schema {self.schema_name}")
    
    def store_vector(self, id: str, name: str, description: str, embedding: List[float], metadata: Dict = None) -> bool:
        """
        Store a vector in PostgreSQL.
        
        Args:
            id: Unique identifier
            name: Name of the term
            description: Description of the term
            embedding: Vector embedding
            metadata: Additional metadata
            
        Returns:
            True if successful
        """
        return self.db_manager.store_vector(id, name, description, embedding, metadata)
    
    def batch_store_vectors(self, items: List[Dict[str, Any]]) -> int:
        """
        Store multiple vectors in PostgreSQL.
        
        Args:
            items: List of dictionaries with id, name, description, embedding, and metadata
            
        Returns:
            Number of successfully stored items
        """
        return self.db_manager.batch_store_vectors(items)
    
    def update_term_metadata(self, term_id: str, name: str, description: str, metadata: Dict) -> bool:
        """
        Update a term's metadata while preserving its embedding.
        
        Args:
            term_id: ID of the term to update
            name: Name of the term
            description: Description of the term
            metadata: Updated metadata
            
        Returns:
            True if successful
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    # Update the term with new metadata but keep the existing embedding
                    cursor.execute(f"""
                    UPDATE {self.schema_name}.business_terms
                    SET name = %s, description = %s, metadata = %s, updated_at = CURRENT_TIMESTAMP
                    WHERE id = %s
                    """, (name, description, Json(metadata or {}), term_id))
                    
                    conn.commit()
                    return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"Error updating term metadata in PostgreSQL: {e}")
            return False
    
    def find_similar_vectors(self, query_vector: List[float], top_k: int = 5, threshold: float = 0.5) -> List[Dict[str, Any]]:
        """
        Find similar vectors in PostgreSQL.
        
        Args:
            query_vector: Query vector
            top_k: Number of results to return
            threshold: Minimum similarity threshold
            
        Returns:
            List of dictionaries with id, name, description, similarity, and metadata
        """
        return self.db_manager.find_similar_vectors(query_vector, top_k, threshold)
    
    def get_term_by_id(self, term_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a term by ID.
        
        Args:
            term_id: ID of the term
            
        Returns:
            Dictionary with term details or None if not found
        """
        return self.db_manager.get_term_by_id(term_id)
    
    def get_all_terms(self) -> List[Dict[str, Any]]:
        """
        Get all terms from PostgreSQL.
        
        Returns:
            List of dictionaries with term details
        """
        return self.db_manager.get_all_terms()
    
    def delete_term(self, term_id: str) -> bool:
        """
        Delete a term from PostgreSQL.
        
        Args:
            term_id: ID of the term to delete
            
        Returns:
            True if successful
        """
        return self.db_manager.delete_term(term_id)
    
    def delete_all_terms(self) -> int:
        """
        Delete all terms from PostgreSQL.
        
        Returns:
            Number of deleted terms
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    # Count before deletion
                    cursor.execute(f"SELECT COUNT(*) FROM {self.schema_name}.business_terms")
                    count = cursor.fetchone()[0]
                    
                    # Delete all terms
                    cursor.execute(f"DELETE FROM {self.schema_name}.business_terms")
                    
                    conn.commit()
                    return count
        except Exception as e:
            logger.error(f"Error deleting all terms from PostgreSQL: {e}")
            return 0
    
    def search_terms(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Search for terms by text query.
        
        Args:
            query: Text query
            limit: Maximum number of results
            
        Returns:
            List of dictionaries with term details
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    # Search using full-text search
                    cursor.execute(f"""
                    SELECT id, name, description, metadata
                    FROM {self.schema_name}.business_terms
                    WHERE 
                        name ILIKE %s OR 
                        description ILIKE %s
                    LIMIT %s
                    """, (f"%{query}%", f"%{query}%", limit))
                    
                    results = []
                    for row in cursor.fetchall():
                        results.append({
                            "id": row[0],
                            "name": row[1],
                            "description": row[2],
                            "metadata": row[3]
                        })
                    
                    return results
        except Exception as e:
            logger.error(f"Error searching terms in PostgreSQL: {e}")
            return []
    
    def compute_cosine_similarity(self, vector1: List[float], vector2: List[float]) -> float:
        """
        Compute cosine similarity between two vectors.
        
        Args:
            vector1: First vector
            vector2: Second vector
            
        Returns:
            Cosine similarity between 0 and 1
        """
        return self.db_manager.compute_cosine_similarity(vector1, vector2)
    
    def health_check(self) -> Dict[str, Any]:
        """
        Check the health of the PostgreSQL connection.
        
        Returns:
            Dictionary with health status
        """
        try:
            db_health = self.db_manager.health_check()
            vector_enabled = db_health.get("vector_enabled", False)
            
            if db_health["status"] == "healthy" and vector_enabled:
                return {
                    "status": "healthy",
                    "type": "postgresql",
                    "term_count": db_health.get("terms_count", 0),
                    "vector_enabled": vector_enabled,
                    "db_size_mb": db_health.get("db_size_mb", 0),
                    "details": {
                        "version": db_health.get("version", "unknown"),
                        "connections": db_health.get("active_connections", 0)
                    }
                }
            else:
                return {
                    "status": "unhealthy",
                    "type": "postgresql",
                    "error": "PostgreSQL database is not healthy or pgvector extension is not enabled",
                    "details": db_health
                }
        except Exception as e:
            logger.error(f"PostgreSQL health check failed: {e}")
            return {
                "status": "unhealthy",
                "type": "postgresql",
                "error": str(e)
            }
