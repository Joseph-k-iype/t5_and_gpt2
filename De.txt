"""
ChromaDB Vector Store - Vector database implementation using ChromaDB.

This module provides a ChromaDB implementation of the vector store interface,
with functionality for storing, retrieving, and searching vectors.
"""

import logging
import os
import time
import numpy as np
from typing import List, Dict, Any, Optional
import chromadb
from chromadb.config import Settings
from app.core.vector_store import VectorStore

logger = logging.getLogger(__name__)

class ChromaDBVectorStore(VectorStore):
    """Vector store implementation using ChromaDB."""
    
    def __init__(self, collection_name: str = "business_terms", persist_dir: str = "./data/chroma_db"):
        """
        Initialize ChromaDB vector store.
        
        Args:
            collection_name: Name of the collection in ChromaDB
            persist_dir: Directory for persistent storage
        """
        # Create directory if it doesn't exist
        os.makedirs(persist_dir, exist_ok=True)
        
        # Initialize ChromaDB client with telemetry disabled
        self.settings = Settings(
            anonymized_telemetry=False,
            allow_reset=True,
            is_persistent=True
        )
        
        self.client = chromadb.PersistentClient(
            path=persist_dir,
            settings=self.settings
        )
        
        self.collection_name = collection_name
        self.persist_dir = persist_dir
        
        # Get or create collection
        self.collection = self.client.get_or_create_collection(
            name=collection_name,
            metadata={"hnsw:space": "cosine"}  # Use cosine similarity
        )
        
        logger.info(f"ChromaDB vector store initialized with collection {collection_name}")
    
    def store_vector(self, id: str, name: str, description: str, embedding: List[float], metadata: Dict = None) -> bool:
        """
        Store a vector in ChromaDB.
        
        Args:
            id: Unique identifier
            name: Name of the term
            description: Description of the term
            embedding: Vector embedding
            metadata: Additional metadata
            
        Returns:
            True if successful
        """
        try:
            # Convert embedding to float32 - required by Chroma
            embedding_float32 = np.array(embedding, dtype=np.float32).tolist()
            
            # Prepare metadata
            if metadata is None:
                metadata = {}
            
            # Ensure metadata contains name and description
            metadata["name"] = name
            metadata["description"] = description
            
            # Add or update the embedding
            self.collection.upsert(
                ids=[id],
                embeddings=[embedding_float32],
                metadatas=[metadata],
                documents=[f"{name} - {description}"]
            )
            
            return True
        except Exception as e:
            logger.error(f"Error storing vector in ChromaDB: {e}")
            return False
    
    def batch_store_vectors(self, items: List[Dict[str, Any]]) -> int:
        """
        Store multiple vectors in ChromaDB.
        
        Args:
            items: List of dictionaries with id, name, description, embedding, and metadata
            
        Returns:
            Number of successfully stored items
        """
        try:
            if not items:
                return 0
                
            # Prepare batch data
            ids = []
            embeddings = []
            metadatas = []
            documents = []
            
            for item in items:
                # Extract data
                id = item.get("id", "")
                name = item.get("name", "")
                description = item.get("description", "")
                embedding = item.get("embedding", [])
                metadata = item.get("metadata", {})
                
                if not id or not embedding:
                    logger.warning(f"Skipping item with missing ID or embedding: {name}")
                    continue
                
                # Convert embedding to float32
                embedding_float32 = np.array(embedding, dtype=np.float32).tolist()
                
                # Ensure metadata contains name and description
                metadata["name"] = name
                metadata["description"] = description
                
                # Add to batch
                ids.append(id)
                embeddings.append(embedding_float32)
                metadatas.append(metadata)
                documents.append(f"{name} - {description}")
            
            # Store batch
            if ids:
                self.collection.upsert(
                    ids=ids,
                    embeddings=embeddings,
                    metadatas=metadatas,
                    documents=documents
                )
            
            return len(ids)
        except Exception as e:
            logger.error(f"Error batch storing vectors in ChromaDB: {e}")
            return 0
    
    def update_term_metadata(self, term_id: str, name: str, description: str, metadata: Dict) -> bool:
        """
        Update a term's metadata while preserving its embedding.
        
        Args:
            term_id: ID of the term to update
            name: Name of the term
            description: Description of the term
            metadata: Updated metadata
            
        Returns:
            True if successful
        """
        try:
            # Get the existing item to preserve its embedding
            results = self.collection.get(
                ids=[term_id],
                include=["embeddings", "metadatas", "documents"]
            )
            
            if not results["ids"] or len(results["ids"]) == 0:
                logger.warning(f"Term not found for update: {term_id}")
                return False
            
            # Extract existing embedding
            embedding = results["embeddings"][0]
            
            # Ensure metadata contains name and description
            metadata["name"] = name
            metadata["description"] = description
            
            # Update the item with its existing embedding and new metadata
            self.collection.upsert(
                ids=[term_id],
                embeddings=[embedding],
                metadatas=[metadata],
                documents=[f"{name} - {description}"]
            )
            
            return True
        except Exception as e:
            logger.error(f"Error updating term metadata in ChromaDB: {e}")
            return False
    
    def find_similar_vectors(self, query_vector: List[float], top_k: int = 5, threshold: float = 0.5) -> List[Dict[str, Any]]:
        """
        Find similar vectors in ChromaDB.
        
        Args:
            query_vector: Query vector
            top_k: Number of results to return
            threshold: Minimum similarity threshold
            
        Returns:
            List of dictionaries with id, name, description, similarity, and metadata
        """
        try:
            # Convert query vector to float32
            query_vector_float32 = np.array(query_vector, dtype=np.float32).tolist()
            
            # Query ChromaDB
            results = self.collection.query(
                query_embeddings=[query_vector_float32],
                n_results=top_k * 2,  # Get more results than needed for filtering
                include=["metadatas", "distances"]
            )
            
            # Process results
            similar_vectors = []
            
            if results["ids"] and len(results["ids"][0]) > 0:
                for i, id in enumerate(results["ids"][0]):
                    # Get distance (convert to similarity)
                    distance = results["distances"][0][i]
                    similarity = 1.0 - distance  # Convert distance to similarity
                    
                    # Skip if below threshold
                    if similarity < threshold:
                        continue
                    
                    # Get metadata
                    metadata = results["metadatas"][0][i]
                    
                    # Extract name and description from metadata
                    name = metadata.get("name", "")
                    description = metadata.get("description", "")
                    
                    # Add to results
                    similar_vectors.append({
                        "id": id,
                        "name": name,
                        "description": description,
                        "similarity": similarity,
                        "metadata": metadata
                    })
            
            # Sort by similarity (highest first)
            similar_vectors.sort(key=lambda x: x["similarity"], reverse=True)
            
            # Limit to top_k
            return similar_vectors[:top_k]
        except Exception as e:
            logger.error(f"Error finding similar vectors in ChromaDB: {e}")
            return []
    
    def get_term_by_id(self, term_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a term by ID.
        
        Args:
            term_id: ID of the term
            
        Returns:
            Dictionary with term details or None if not found
        """
        try:
            results = self.collection.get(
                ids=[term_id],
                include=["metadatas"]
            )
            
            if not results["ids"] or len(results["ids"]) == 0:
                return None
            
            # Get metadata
            metadata = results["metadatas"][0]
            
            # Extract name and description from metadata
            name = metadata.get("name", "")
            description = metadata.get("description", "")
            
            return {
                "id": term_id,
                "name": name,
                "description": description,
                "metadata": metadata
            }
        except Exception as e:
            logger.error(f"Error getting term by ID from ChromaDB: {e}")
            return None
    
    def get_all_terms(self) -> List[Dict[str, Any]]:
        """
        Get all terms from ChromaDB.
        
        Returns:
            List of dictionaries with term details
        """
        try:
            # Get all items with maximum limit
            results = self.collection.get(
                limit=10000,  # Large enough to get all items
                include=["metadatas"]
            )
            
            terms = []
            
            for i, id in enumerate(results["ids"]):
                # Get metadata
                metadata = results["metadatas"][i]
                
                # Extract name and description from metadata
                name = metadata.get("name", "")
                description = metadata.get("description", "")
                
                terms.append({
                    "id": id,
                    "name": name,
                    "description": description,
                    "metadata": metadata
                })
            
            return terms
        except Exception as e:
            logger.error(f"Error getting all terms from ChromaDB: {e}")
            return []
    
    def delete_term(self, term_id: str) -> bool:
        """
        Delete a term from ChromaDB.
        
        Args:
            term_id: ID of the term to delete
            
        Returns:
            True if successful
        """
        try:
            self.collection.delete(ids=[term_id])
            return True
        except Exception as e:
            logger.error(f"Error deleting term from ChromaDB: {e}")
            return False
    
    def delete_all_terms(self) -> int:
        """
        Delete all terms from ChromaDB.
        
        Returns:
            Number of deleted terms
        """
        try:
            # Get count before deletion
            count = self.collection.count()
            
            # Delete all items
            self.collection.delete(where={})
            
            return count
        except Exception as e:
            logger.error(f"Error deleting all terms from ChromaDB: {e}")
            return 0
    
    def search_terms(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Search for terms by text query.
        
        Args:
            query: Text query
            limit: Maximum number of results
            
        Returns:
            List of dictionaries with term details
        """
        try:
            # Search by keyword using the 'where' filter
            results = self.collection.get(
                where={"$or": [
                    {"name": {"$contains": query}},
                    {"description": {"$contains": query}}
                ]},
                limit=limit,
                include=["metadatas"]
            )
            
            terms = []
            
            for i, id in enumerate(results["ids"]):
                # Get metadata
                metadata = results["metadatas"][i]
                
                # Extract name and description from metadata
                name = metadata.get("name", "")
                description = metadata.get("description", "")
                
                terms.append({
                    "id": id,
                    "name": name,
                    "description": description,
                    "metadata": metadata
                })
            
            return terms
        except Exception as e:
            logger.error(f"Error searching terms in ChromaDB: {e}")
            return []
    
    def compute_cosine_similarity(self, vector1: List[float], vector2: List[float]) -> float:
        """
        Compute cosine similarity between two vectors.
        
        Args:
            vector1: First vector
            vector2: Second vector
            
        Returns:
            Cosine similarity between 0 and 1
        """
        try:
            # Convert vectors to numpy arrays
            v1 = np.array(vector1)
            v2 = np.array(vector2)
            
            # Check if vectors have same dimension
            if len(v1) != len(v2):
                # Use the smaller dimension
                min_dim = min(len(v1), len(v2))
                v1 = v1[:min_dim]
                v2 = v2[:min_dim]
            
            # Compute cosine similarity
            dot_product = np.dot(v1, v2)
            norm_v1 = np.linalg.norm(v1)
            norm_v2 = np.linalg.norm(v2)
            
            if norm_v1 == 0 or norm_v2 == 0:
                return 0.0
            
            similarity = dot_product / (norm_v1 * norm_v2)
            
            # Ensure in range [0, 1]
            return max(0.0, min(similarity, 1.0))
        except Exception as e:
            logger.error(f"Error computing cosine similarity: {e}")
            return 0.0
    
    def health_check(self) -> Dict[str, Any]:
        """
        Check the health of the ChromaDB connection.
        
        Returns:
            Dictionary with health status
        """
        try:
            # Check if collection is accessible
            count = self.collection.count()
            
            return {
                "status": "healthy",
                "type": "chroma",
                "term_count": count,
                "collection": self.collection_name,
                "persist_dir": self.persist_dir,
                "details": {
                    "client_version": chromadb.__version__
                }
            }
        except Exception as e:
            logger.error(f"ChromaDB health check failed: {e}")
            return {
                "status": "unhealthy",
                "type": "chroma",
                "error": str(e)
            }
