"""
API endpoints for business term classification.
"""

import logging
from typing import List, Dict, Any, Optional, Set

from fastapi import APIRouter, Depends, HTTPException, status, Query, Body
from starlette.concurrency import run_in_threadpool

from app.config.settings import get_settings
from app.api.deps import (
    get_api_key, 
    get_request_id, 
    get_classification_service_dep,
    get_pbt_manager_dep,
    check_rate_limit
)
from app.core.services.classification import ClassificationService
from app.core.services.pbt_manager import PBTManager
from app.core.models.pbt import (
    PBT, PBTClassificationRequest, PBTClassificationResponse,
    BatchPBTClassificationRequest, BatchPBTClassificationResponse,
    PBTLoadRequest, PBTLoadResponse, PBTStatistics
)

logger = logging.getLogger(__name__)
settings = get_settings()

router = APIRouter(
    prefix="/classification",
    tags=["classification"]
    # No API key dependency required
)

@router.post(
    "/classify",
    response_model=PBTClassificationResponse,
    summary="Classify a business term",
    description="Classify a business term against the Preferred Business Terms (PBT) database."
)
async def classify_term(
    request: PBTClassificationRequest,
    request_id: str = Depends(get_request_id),
    classification_service: ClassificationService = Depends(get_classification_service_dep)
):
    """
    Classify a business term against the PBT database.
    
    Args:
        request: Classification request with name and description
        request_id: Request ID
        classification_service: Classification service
        
    Returns:
        Classification response with best match and confidence
    """
    logger.info(f"Classification request: {request.name} (method={request.method}, request_id={request_id})")
    
    try:
        # Validate method
        if request.method not in settings.classification.available_methods:
            logger.warning(f"Invalid classification method: {request.method}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid classification method. Available methods: {settings.classification.available_methods}"
            )
        
        # Validate input
        if not request.name or not request.name.strip():
            logger.warning(f"Empty name provided in request")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Name cannot be empty"
            )
        
        if not request.description or not request.description.strip():
            logger.warning(f"Empty description provided in request")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Description cannot be empty"
            )
        
        # Classify
        result = await classification_service.classify(
            name=request.name,
            description=request.description,
            method=request.method,
            include_broader_terms=request.include_broader_terms,
            top_n=request.top_n
        )
        
        # Add request ID
        result.request_id = request_id
        
        # Check for empty results
        if result.status == "error":
            logger.warning(f"Classification failed for {request.name}: {result.agent_response}")
            if "No similar items found" in result.agent_response:
                return PBTClassificationResponse(
                    status="no_match",
                    request_id=request_id,
                    agent_response="No matching terms found in the PBT database. Consider trying different terminology or adding this term to the database."
                )
            else:
                # Return the error but with 200 status code to allow client handling
                return result
        
        return result
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Unexpected error in classify_term: {e}", exc_info=True)
        return PBTClassificationResponse(
            status="error",
            request_id=request_id,
            agent_response=f"An unexpected error occurred: {str(e)}"
        )

@router.post(
    "/batch",
    response_model=BatchPBTClassificationResponse,
    summary="Classify multiple business terms",
    description="Classify multiple business terms in a single request."
)
async def batch_classify(
    request: BatchPBTClassificationRequest,
    request_id: str = Depends(get_request_id),
    classification_service: ClassificationService = Depends(get_classification_service_dep)
):
    """
    Batch classify multiple business terms.
    
    Args:
        request: Batch classification request with multiple items
        request_id: Request ID
        classification_service: Classification service
        
    Returns:
        Batch classification response with results for each item
    """
    try:
        # Check batch size limit
        if len(request.items) > settings.rate_limit.batch_size_limit:
            logger.warning(f"Batch size {len(request.items)} exceeds limit of {settings.rate_limit.batch_size_limit}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Batch size exceeds limit of {settings.rate_limit.batch_size_limit} items"
            )
        
        # Check for empty batch
        if not request.items:
            logger.warning("Empty batch request received")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Batch request cannot be empty"
            )
        
        logger.info(f"Batch classification request with {len(request.items)} items (method={request.method}, request_id={request_id})")
        
        # Validate method
        if request.method not in settings.classification.available_methods:
            logger.warning(f"Invalid classification method: {request.method}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid classification method. Available methods: {settings.classification.available_methods}"
            )
        
        # Validate all items have required fields
        for i, item in enumerate(request.items):
            if not item.name or not item.name.strip():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Item at index {i} has empty name"
                )
            
            if not item.description or not item.description.strip():
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Item at index {i} has empty description"
                )
        
        # Batch classify with error handling
        try:
            results = await classification_service.batch_classify(
                items=[item.dict() for item in request.items],
                method=request.method
            )
        except Exception as batch_error:
            logger.error(f"Error in batch classification: {batch_error}", exc_info=True)
            # Create error response for each item
            results = [
                PBTClassificationResponse(
                    status="error",
                    agent_response=f"Batch processing error: {str(batch_error)}"
                ) for _ in request.items
            ]
        
        # Count successes and failures
        success_count = sum(1 for result in results if result.status == "success")
        no_match_count = sum(1 for result in results if result.status == "no_match")
        error_count = len(results) - success_count - no_match_count
        
        # Create response
        response = BatchPBTClassificationResponse(
            status="success" if success_count > 0 else "error",
            items=results,
            request_id=request_id,
            total_processed=len(results),
            total_success=success_count,
            total_failure=error_count
        )
        
        return response
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Unexpected error in batch_classify: {e}", exc_info=True)
        # Return error response with empty results
        return BatchPBTClassificationResponse(
            status="error",
            items=[],
            request_id=request_id,
            total_processed=0,
            total_success=0,
            total_failure=len(request.items) if request.items else 0
        )

@router.post(
    "/load-pbt",
    response_model=PBTLoadResponse,
    summary="Load PBT data",
    description="Load Preferred Business Terms (PBT) data from a CSV file."
)
async def load_pbt_data(
    request: PBTLoadRequest,
    request_id: str = Depends(get_request_id),
    pbt_manager: PBTManager = Depends(get_pbt_manager_dep)
):
    """
    Load PBT data from a CSV file.
    
    Args:
        request: Load request with CSV path
        request_id: Request ID
        pbt_manager: PBT manager
        
    Returns:
        Load response with status and count
    """
    try:
        logger.info(f"Loading PBT data from {request.csv_path} (reload={request.reload}, request_id={request_id})")
        
        # Validate CSV path
        if not request.csv_path or not request.csv_path.strip():
            logger.warning("Empty CSV path provided")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="CSV path cannot be empty"
            )
        
        # Load the data
        result = await pbt_manager.load_csv(request.csv_path, request.reload)
        
        # Check for load errors
        if result["status"] == "error":
            logger.error(f"Error loading PBT data: {result['message']}")
            # Return error but with 200 status code to allow client handling
            response = PBTLoadResponse(
                status=result["status"],
                message=result["message"],
                total_loaded=result["total_loaded"],
                request_id=request_id
            )
            return response
        
        # Add request ID
        response = PBTLoadResponse(
            status=result["status"],
            message=result["message"],
            total_loaded=result["total_loaded"],
            request_id=request_id
        )
        
        return response
    except Exception as e:
        logger.error(f"Unexpected error in load_pbt_data: {e}", exc_info=True)
        return PBTLoadResponse(
            status="error",
            message=f"An unexpected error occurred: {str(e)}",
            total_loaded=0,
            request_id=request_id
        )

@router.get(
    "/pbt/{pbt_id}",
    response_model=PBT,
    summary="Get PBT by ID",
    description="Get a Preferred Business Term (PBT) by its ID."
)
async def get_pbt_by_id(
    pbt_id: str,
    request_id: str = Depends(get_request_id),
    pbt_manager: PBTManager = Depends(get_pbt_manager_dep)
):
    """
    Get a PBT by its ID.
    
    Args:
        pbt_id: PBT ID
        request_id: Request ID
        pbt_manager: PBT manager
        
    Returns:
        PBT object
    """
    try:
        logger.info(f"Getting PBT by ID: {pbt_id} (request_id={request_id})")
        
        # Validate PBT ID
        if not pbt_id or not pbt_id.strip():
            logger.warning("Empty PBT ID provided")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="PBT ID cannot be empty"
            )
        
        # Get the PBT
        pbt = await pbt_manager.get_pbt_by_id(pbt_id)
        
        if not pbt:
            logger.warning(f"PBT with ID {pbt_id} not found")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"PBT with ID {pbt_id} not found"
            )
        
        return pbt
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Unexpected error in get_pbt_by_id: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )

@router.get(
    "/statistics",
    response_model=PBTStatistics,
    summary="Get PBT statistics",
    description="Get statistics about the loaded PBT data."
)
async def get_pbt_statistics(
    request_id: str = Depends(get_request_id),
    pbt_manager: PBTManager = Depends(get_pbt_manager_dep)
):
    """
    Get statistics about the loaded PBT data.
    
    Args:
        request_id: Request ID
        pbt_manager: PBT manager
        
    Returns:
        PBT statistics
    """
    try:
        logger.info(f"Getting PBT statistics (request_id={request_id})")
        
        # Get statistics with error handling
        try:
            stats = await pbt_manager.get_statistics()
        except Exception as stats_error:
            logger.error(f"Error getting PBT statistics: {stats_error}", exc_info=True)
            # Return default statistics on error
            stats = PBTStatistics(
                total_pbt_count=0,
                indexed_count=0,
                cdm_categories={},
                has_synonyms_count=0,
                average_synonyms_per_pbt=0,
                top_cdm_categories=[]
            )
        
        return stats
    except Exception as e:
        logger.error(f"Unexpected error in get_pbt_statistics: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred: {str(e)}"
        )

# New endpoint for testing the system
@router.post(
    "/test-classification",
    response_model=PBTClassificationResponse,
    summary="Test classification system",
    description="Test the classification system with a simple example."
)
async def test_classification(
    request_id: str = Depends(get_request_id),
    classification_service: ClassificationService = Depends(get_classification_service_dep)
):
    """
    Test the classification system with a simple example.
    
    Args:
        request_id: Request ID
        classification_service: Classification service
        
    Returns:
        Classification response
    """
    try:
        logger.info(f"Test classification request (request_id={request_id})")
        
        # Define a test term
        test_name = "Customer Account"
        test_description = "A unique identifier for a customer in the system"
        
        # Try all classification methods
        methods = list(settings.classification.available_methods)
        
        # Start with embeddings (simplest method)
        method = "embeddings"
        if "embeddings" in methods:
            method = "embeddings"
        
        # Classify using the chosen method
        result = await classification_service.classify(
            name=test_name,
            description=test_description,
            method=method,
            include_broader_terms=True,
            top_n=5
        )
        
        # Add request ID and test info
        result.request_id = request_id
        
        if result.status == "success":
            # Add test info to agent response
            if result.agent_response:
                result.agent_response = f"TEST CLASSIFICATION SUCCEEDED USING METHOD: {method}\n\n" + result.agent_response
            else:
                result.agent_response = f"TEST CLASSIFICATION SUCCEEDED USING METHOD: {method}"
        else:
            # Try other methods if first one failed
            for backup_method in methods:
                if backup_method != method:
                    logger.info(f"First method failed, trying method: {backup_method}")
                    backup_result = await classification_service.classify(
                        name=test_name,
                        description=test_description,
                        method=backup_method,
                        include_broader_terms=True,
                        top_n=5
                    )
                    
                    if backup_result.status == "success":
                        logger.info(f"Backup method {backup_method} succeeded")
                        backup_result.request_id = request_id
                        backup_result.agent_response = f"TEST CLASSIFICATION SUCCEEDED USING BACKUP METHOD: {backup_method}\n\n" + (backup_result.agent_response or "")
                        return backup_result
            
            # All methods failed
            logger.warning("All classification methods failed in test")
            result.agent_response = f"TEST CLASSIFICATION FAILED FOR ALL METHODS\n\n" + (result.agent_response or "")
        
        return result
    except Exception as e:
        logger.error(f"Unexpected error in test_classification: {e}", exc_info=True)
        return PBTClassificationResponse(
            status="error",
            request_id=request_id,
            agent_response=f"Test failed with error: {str(e)}"
        )
