#!/usr/bin/env python3
"""
Complete JSON-LD Ontology Extractor with TTL Export

This script extracts comprehensive ontology information from JSON-LD files including:
- Classes, Subclasses, Individuals
- Object Properties, Data Properties, Annotation Properties
- Property characteristics (functional, symmetric, transitive, etc.)
- Restrictions, Equivalent/Disjoint relationships
- Annotations and comments
- Export to TTL, JSON, or console summary

Supports two methods:
1. Using rdflib for proper RDF/OWL handling (recommended)
2. Basic JSON parsing for simple structures
"""

import json
import sys
import os
from typing import Dict, List, Set, Any, Tuple, Optional
from collections import defaultdict
from datetime import datetime

# Method 1: Using rdflib (install with: pip install rdflib)
try:
    from rdflib import Graph, Namespace, RDF, RDFS, OWL, URIRef, Literal, XSD
    from rdflib.namespace import FOAF, DC, DCTERMS, SKOS
    RDFLIB_AVAILABLE = True
except ImportError:
    RDFLIB_AVAILABLE = False
    print("Warning: rdflib not available. Install with 'pip install rdflib' for full RDF support.")


class ComprehensiveOntologyExtractor:
    def __init__(self):
        # Core ontology elements
        self.classes = set()
        self.individuals = set()
        self.object_properties = set()
        self.data_properties = set()
        self.annotation_properties = set()
        
        # Relationships
        self.subclass_relationships = []
        self.subproperty_relationships = []
        self.equivalent_classes = []
        self.equivalent_properties = []
        self.disjoint_classes = []
        self.inverse_properties = []
        
        # Property characteristics
        self.functional_properties = set()
        self.inverse_functional_properties = set()
        self.transitive_properties = set()
        self.symmetric_properties = set()
        self.asymmetric_properties = set()
        self.reflexive_properties = set()
        self.irreflexive_properties = set()
        
        # Domains and ranges
        self.property_domains = defaultdict(set)
        self.property_ranges = defaultdict(set)
        
        # Restrictions and constraints
        self.restrictions = []
        self.cardinality_restrictions = []
        
        # Annotations
        self.annotations = defaultdict(dict)
        self.comments = {}
        self.labels = {}
        
        # Instance relationships
        self.instance_types = defaultdict(set)
        self.property_assertions = []
        
        # Namespaces
        self.namespaces = {}
        
        # Original graph for TTL export
        self.graph = None
        
    def extract_with_rdflib(self, file_path: str):
        """Extract comprehensive ontology using rdflib for proper RDF handling"""
        if not RDFLIB_AVAILABLE:
            raise ImportError("rdflib is required for this method")
            
        self.graph = Graph()
        self.graph.parse(file_path, format='json-ld')
        
        # Extract namespaces
        for prefix, namespace in self.graph.namespaces():
            self.namespaces[prefix] = str(namespace)
        
        # Extract classes
        for s in self.graph.subjects(RDF.type, RDFS.Class):
            self.classes.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.Class):
            self.classes.add(str(s))
            
        # Extract individuals
        for s, p, o in self.graph:
            if p == RDF.type and o != RDFS.Class and o != OWL.Class and o != OWL.ObjectProperty and o != OWL.DatatypeProperty:
                if str(o) in self.classes:  # If the type is a defined class
                    self.individuals.add(str(s))
                    self.instance_types[str(s)].add(str(o))
                    
        # Extract properties
        for s in self.graph.subjects(RDF.type, OWL.ObjectProperty):
            self.object_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.DatatypeProperty):
            self.data_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.AnnotationProperty):
            self.annotation_properties.add(str(s))
            
        # Extract subclass relationships
        for s, o in self.graph.subject_objects(RDFS.subClassOf):
            if str(s) != str(o):  # Avoid self-references
                self.subclass_relationships.append((str(s), str(o)))
                
        # Extract subproperty relationships
        for s, o in self.graph.subject_objects(RDFS.subPropertyOf):
            if str(s) != str(o):
                self.subproperty_relationships.append((str(s), str(o)))
                
        # Extract equivalent relationships
        for s, o in self.graph.subject_objects(OWL.equivalentClass):
            self.equivalent_classes.append((str(s), str(o)))
        for s, o in self.graph.subject_objects(OWL.equivalentProperty):
            self.equivalent_properties.append((str(s), str(o)))
            
        # Extract disjoint relationships
        for s, o in self.graph.subject_objects(OWL.disjointWith):
            self.disjoint_classes.append((str(s), str(o)))
            
        # Extract inverse properties
        for s, o in self.graph.subject_objects(OWL.inverseOf):
            self.inverse_properties.append((str(s), str(o)))
            
        # Extract property characteristics
        for s in self.graph.subjects(RDF.type, OWL.FunctionalProperty):
            self.functional_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.InverseFunctionalProperty):
            self.inverse_functional_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.TransitiveProperty):
            self.transitive_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.SymmetricProperty):
            self.symmetric_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.AsymmetricProperty):
            self.asymmetric_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.ReflexiveProperty):
            self.reflexive_properties.add(str(s))
        for s in self.graph.subjects(RDF.type, OWL.IrreflexiveProperty):
            self.irreflexive_properties.add(str(s))
            
        # Extract domains and ranges
        all_properties = self.object_properties.union(self.data_properties).union(self.annotation_properties)
        for prop_str in all_properties:
            prop_uri = URIRef(prop_str)
            for domain in self.graph.objects(prop_uri, RDFS.domain):
                self.property_domains[prop_str].add(str(domain))
            for range_val in self.graph.objects(prop_uri, RDFS.range):
                self.property_ranges[prop_str].add(str(range_val))
                
        # Extract annotations (labels, comments, etc.)
        for s, p, o in self.graph:
            s_str, p_str = str(s), str(p)
            if p == RDFS.label:
                self.labels[s_str] = str(o)
            elif p == RDFS.comment:
                self.comments[s_str] = str(o)
            elif p_str in self.annotation_properties:
                if s_str not in self.annotations:
                    self.annotations[s_str] = {}
                self.annotations[s_str][p_str] = str(o)
                
        # Extract property assertions for individuals
        for individual in self.individuals:
            individual_uri = URIRef(individual)
            for p, o in self.graph.predicate_objects(individual_uri):
                if str(p) in all_properties:
                    self.property_assertions.append((individual, str(p), str(o)))
    
    def extract_with_json_parsing(self, file_path: str):
        """Extract comprehensive ontology using basic JSON parsing"""
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            
        # Extract context for namespaces
        if isinstance(data, dict) and '@context' in data:
            context = data['@context']
            if isinstance(context, dict):
                self.namespaces.update(context)
            
        # Handle both single objects and arrays
        if isinstance(data, dict):
            items = [data]
        elif isinstance(data, list):
            items = data
        else:
            items = []
            
        # If there's a @graph, use that
        if isinstance(data, dict) and '@graph' in data:
            items = data['@graph']
            
        for item in items:
            if not isinstance(item, dict):
                continue
                
            self._process_json_item(item)
    
    def _process_json_item(self, item: Dict[str, Any]):
        """Process a single JSON item for ontology extraction"""
        item_type = item.get('@type', [])
        if isinstance(item_type, str):
            item_type = [item_type]
            
        item_id = item.get('@id', '')
        
        # Extract classes
        class_types = ['rdfs:Class', 'owl:Class', 'Class']
        if any(t in class_types for t in item_type):
            self.classes.add(item_id)
            
        # Extract properties
        if any(t in ['owl:ObjectProperty', 'ObjectProperty'] for t in item_type):
            self.object_properties.add(item_id)
        if any(t in ['owl:DatatypeProperty', 'DatatypeProperty'] for t in item_type):
            self.data_properties.add(item_id)
        if any(t in ['owl:AnnotationProperty', 'AnnotationProperty'] for t in item_type):
            self.annotation_properties.add(item_id)
            
        # Extract property characteristics
        if any(t in ['owl:FunctionalProperty', 'FunctionalProperty'] for t in item_type):
            self.functional_properties.add(item_id)
        if any(t in ['owl:TransitiveProperty', 'TransitiveProperty'] for t in item_type):
            self.transitive_properties.add(item_id)
        if any(t in ['owl:SymmetricProperty', 'SymmetricProperty'] for t in item_type):
            self.symmetric_properties.add(item_id)
            
        # Extract relationships
        self._extract_json_relationships(item, item_id)
        
        # Extract annotations
        self._extract_json_annotations(item, item_id)
        
        # Check if it's an individual (has type that's not a meta-class)
        if item_type and not any(t in class_types + ['owl:ObjectProperty', 'ObjectProperty', 
                                                    'owl:DatatypeProperty', 'DatatypeProperty'] 
                                for t in item_type):
            self.individuals.add(item_id)
            for t in item_type:
                self.instance_types[item_id].add(t)
    
    def _extract_json_relationships(self, item: Dict[str, Any], item_id: str):
        """Extract relationships from JSON item"""
        # Subclass relationships
        if 'rdfs:subClassOf' in item:
            self._add_relationship(item['rdfs:subClassOf'], item_id, self.subclass_relationships)
            
        # Subproperty relationships
        if 'rdfs:subPropertyOf' in item:
            self._add_relationship(item['rdfs:subPropertyOf'], item_id, self.subproperty_relationships)
            
        # Equivalent relationships
        if 'owl:equivalentClass' in item:
            self._add_relationship(item['owl:equivalentClass'], item_id, self.equivalent_classes)
        if 'owl:equivalentProperty' in item:
            self._add_relationship(item['owl:equivalentProperty'], item_id, self.equivalent_properties)
            
        # Domains and ranges
        if 'rdfs:domain' in item:
            self._add_to_set_dict(item['rdfs:domain'], item_id, self.property_domains)
        if 'rdfs:range' in item:
            self._add_to_set_dict(item['rdfs:range'], item_id, self.property_ranges)
    
    def _extract_json_annotations(self, item: Dict[str, Any], item_id: str):
        """Extract annotations from JSON item"""
        if 'rdfs:label' in item:
            label_val = item['rdfs:label']
            if isinstance(label_val, dict) and '@value' in label_val:
                self.labels[item_id] = label_val['@value']
            elif isinstance(label_val, str):
                self.labels[item_id] = label_val
                
        if 'rdfs:comment' in item:
            comment_val = item['rdfs:comment']
            if isinstance(comment_val, dict) and '@value' in comment_val:
                self.comments[item_id] = comment_val['@value']
            elif isinstance(comment_val, str):
                self.comments[item_id] = comment_val
    
    def _add_relationship(self, value: Any, subject: str, relationship_list: List[Tuple[str, str]]):
        """Helper to add relationships to list"""
        if isinstance(value, dict) and '@id' in value:
            relationship_list.append((subject, value['@id']))
        elif isinstance(value, str):
            relationship_list.append((subject, value))
        elif isinstance(value, list):
            for item in value:
                self._add_relationship(item, subject, relationship_list)
    
    def _add_to_set_dict(self, value: Any, key: str, target_dict: Dict[str, Set[str]]):
        """Helper to add values to set dictionary"""
        if isinstance(value, dict) and '@id' in value:
            target_dict[key].add(value['@id'])
        elif isinstance(value, str):
            target_dict[key].add(value)
        elif isinstance(value, list):
            for item in value:
                self._add_to_set_dict(item, key, target_dict)
    
    def print_comprehensive_summary(self):
        """Print a comprehensive summary of the extracted ontology"""
        print("=" * 60)
        print("üéØ COMPREHENSIVE ONTOLOGY EXTRACTION SUMMARY")
        print("=" * 60)
        print(f"üìÖ Extracted on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        
        # Namespaces
        if self.namespaces:
            print(f"üåê NAMESPACES ({len(self.namespaces)}):")
            for prefix, uri in sorted(self.namespaces.items()):
                print(f"  @prefix {prefix}: <{uri}>")
            print()
        
        # Classes
        print(f"üìÅ CLASSES ({len(self.classes)}):")
        for cls in sorted(self.classes):
            print(f"  ‚Ä¢ {cls}")
            if cls in self.labels:
                print(f"    üìù Label: {self.labels[cls]}")
            if cls in self.comments:
                print(f"    üí≠ Comment: {self.comments[cls]}")
        print()
        
        # Individuals
        if self.individuals:
            print(f"üë§ INDIVIDUALS ({len(self.individuals)}):")
            for individual in sorted(self.individuals):
                print(f"  ‚Ä¢ {individual}")
                if individual in self.instance_types:
                    types = ", ".join(sorted(self.instance_types[individual]))
                    print(f"    üè∑Ô∏è  Type(s): {types}")
            print()
        
        # Subclass relationships
        if self.subclass_relationships:
            print(f"üîó SUBCLASS RELATIONSHIPS ({len(self.subclass_relationships)}):")
            for child, parent in sorted(self.subclass_relationships):
                print(f"  ‚Ä¢ {child} ‚äÜ {parent}")
            print()
        
        # Object Properties
        print(f"üîß OBJECT PROPERTIES ({len(self.object_properties)}):")
        for prop in sorted(self.object_properties):
            print(f"  ‚Ä¢ {prop}")
            self._print_property_details(prop)
        print()
        
        # Data Properties
        print(f"üìä DATA PROPERTIES ({len(self.data_properties)}):")
        for prop in sorted(self.data_properties):
            print(f"  ‚Ä¢ {prop}")
            self._print_property_details(prop)
        print()
        
        # Annotation Properties
        if self.annotation_properties:
            print(f"üìù ANNOTATION PROPERTIES ({len(self.annotation_properties)}):")
            for prop in sorted(self.annotation_properties):
                print(f"  ‚Ä¢ {prop}")
                self._print_property_details(prop)
            print()
        
        # Property characteristics
        self._print_property_characteristics()
        
        # Equivalent relationships
        if self.equivalent_classes:
            print(f"‚â° EQUIVALENT CLASSES ({len(self.equivalent_classes)}):")
            for cls1, cls2 in sorted(self.equivalent_classes):
                print(f"  ‚Ä¢ {cls1} ‚â° {cls2}")
            print()
        
        # Statistics
        print("üìà STATISTICS:")
        total_entities = len(self.classes) + len(self.individuals) + len(self.object_properties) + len(self.data_properties)
        print(f"  ‚Ä¢ Total entities: {total_entities}")
        print(f"  ‚Ä¢ Total relationships: {len(self.subclass_relationships) + len(self.subproperty_relationships)}")
        print(f"  ‚Ä¢ Total annotations: {len(self.labels) + len(self.comments)}")
        print()
    
    def _print_property_details(self, prop: str):
        """Print detailed information about a property"""
        if prop in self.labels:
            print(f"    üìù Label: {self.labels[prop]}")
        if prop in self.comments:
            print(f"    üí≠ Comment: {self.comments[prop]}")
        if prop in self.property_domains:
            domains = ", ".join(sorted(self.property_domains[prop]))
            print(f"    üéØ Domain: {domains}")
        if prop in self.property_ranges:
            ranges = ", ".join(sorted(self.property_ranges[prop]))
            print(f"    üéØ Range: {ranges}")
            
        # Property characteristics
        characteristics = []
        if prop in self.functional_properties:
            characteristics.append("Functional")
        if prop in self.inverse_functional_properties:
            characteristics.append("InverseFunctional")
        if prop in self.transitive_properties:
            characteristics.append("Transitive")
        if prop in self.symmetric_properties:
            characteristics.append("Symmetric")
        if prop in self.asymmetric_properties:
            characteristics.append("Asymmetric")
        if prop in self.reflexive_properties:
            characteristics.append("Reflexive")
        if prop in self.irreflexive_properties:
            characteristics.append("Irreflexive")
        
        if characteristics:
            print(f"    ‚ö° Characteristics: {', '.join(characteristics)}")
    
    def _print_property_characteristics(self):
        """Print property characteristics summary"""
        if any([self.functional_properties, self.transitive_properties, 
                self.symmetric_properties, self.asymmetric_properties]):
            print("‚ö° PROPERTY CHARACTERISTICS:")
            if self.functional_properties:
                print(f"  üî® Functional: {len(self.functional_properties)} properties")
            if self.transitive_properties:
                print(f"  üîÑ Transitive: {len(self.transitive_properties)} properties")
            if self.symmetric_properties:
                print(f"  ‚ÜîÔ∏è  Symmetric: {len(self.symmetric_properties)} properties")
            if self.asymmetric_properties:
                print(f"  ‚ÜïÔ∏è  Asymmetric: {len(self.asymmetric_properties)} properties")
            print()
    
    def export_to_ttl(self, output_file: str):
        """Export the ontology to TTL (Turtle) format"""
        if self.graph and RDFLIB_AVAILABLE:
            # If we have the original graph, use it for high fidelity export
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(self.graph.serialize(format='turtle'))
            print(f"‚úÖ High-fidelity TTL exported to {output_file}")
        else:
            # Create TTL manually from extracted data
            self._create_ttl_manually(output_file)
            print(f"‚úÖ TTL exported to {output_file}")
    
    def _create_ttl_manually(self, output_file: str):
        """Create TTL file manually from extracted ontology data"""
        with open(output_file, 'w', encoding='utf-8') as f:
            # Write prefixes
            f.write("# Ontology extracted from JSON-LD\n")
            f.write(f"# Generated on: {datetime.now().isoformat()}\n\n")
            
            # Default prefixes
            f.write("@prefix owl: <http://www.w3.org/2002/07/owl#> .\n")
            f.write("@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n")
            f.write("@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n")
            f.write("@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n")
            
            # Custom prefixes
            for prefix, uri in self.namespaces.items():
                if prefix not in ['owl', 'rdf', 'rdfs', 'xsd']:
                    f.write(f"@prefix {prefix}: <{uri}> .\n")
            f.write("\n")
            
            # Classes
            f.write("# Classes\n")
            for cls in sorted(self.classes):
                f.write(f"<{cls}> rdf:type owl:Class .\n")
                if cls in self.labels:
                    f.write(f"<{cls}> rdfs:label \"{self.labels[cls]}\" .\n")
                if cls in self.comments:
                    f.write(f"<{cls}> rdfs:comment \"{self.comments[cls]}\" .\n")
            f.write("\n")
            
            # Subclass relationships
            if self.subclass_relationships:
                f.write("# Subclass relationships\n")
                for child, parent in sorted(self.subclass_relationships):
                    f.write(f"<{child}> rdfs:subClassOf <{parent}> .\n")
                f.write("\n")
            
            # Object properties
            f.write("# Object Properties\n")
            for prop in sorted(self.object_properties):
                f.write(f"<{prop}> rdf:type owl:ObjectProperty .\n")
                self._write_property_ttl(f, prop)
            f.write("\n")
            
            # Data properties
            f.write("# Data Properties\n")
            for prop in sorted(self.data_properties):
                f.write(f"<{prop}> rdf:type owl:DatatypeProperty .\n")
                self._write_property_ttl(f, prop)
            f.write("\n")
            
            # Individuals
            if self.individuals:
                f.write("# Individuals\n")
                for individual in sorted(self.individuals):
                    if individual in self.instance_types:
                        for class_type in sorted(self.instance_types[individual]):
                            f.write(f"<{individual}> rdf:type <{class_type}> .\n")
                f.write("\n")
    
    def _write_property_ttl(self, f, prop: str):
        """Write property details to TTL file"""
        if prop in self.labels:
            f.write(f"<{prop}> rdfs:label \"{self.labels[prop]}\" .\n")
        if prop in self.comments:
            f.write(f"<{prop}> rdfs:comment \"{self.comments[prop]}\" .\n")
        if prop in self.property_domains:
            for domain in sorted(self.property_domains[prop]):
                f.write(f"<{prop}> rdfs:domain <{domain}> .\n")
        if prop in self.property_ranges:
            for range_val in sorted(self.property_ranges[prop]):
                f.write(f"<{prop}> rdfs:range <{range_val}> .\n")
        
        # Property characteristics
        if prop in self.functional_properties:
            f.write(f"<{prop}> rdf:type owl:FunctionalProperty .\n")
        if prop in self.transitive_properties:
            f.write(f"<{prop}> rdf:type owl:TransitiveProperty .\n")
        if prop in self.symmetric_properties:
            f.write(f"<{prop}> rdf:type owl:SymmetricProperty .\n")
    
    def export_to_json(self, output_file: str):
        """Export extracted ontology to comprehensive JSON file"""
        ontology_data = {
            'metadata': {
                'extraction_date': datetime.now().isoformat(),
                'namespaces': self.namespaces,
                'statistics': {
                    'classes': len(self.classes),
                    'individuals': len(self.individuals),
                    'object_properties': len(self.object_properties),
                    'data_properties': len(self.data_properties),
                    'annotation_properties': len(self.annotation_properties)
                }
            },
            'classes': list(self.classes),
            'individuals': list(self.individuals),
            'properties': {
                'object_properties': list(self.object_properties),
                'data_properties': list(self.data_properties),
                'annotation_properties': list(self.annotation_properties)
            },
            'relationships': {
                'subclass_relationships': self.subclass_relationships,
                'subproperty_relationships': self.subproperty_relationships,
                'equivalent_classes': self.equivalent_classes,
                'equivalent_properties': self.equivalent_properties,
                'disjoint_classes': self.disjoint_classes,
                'inverse_properties': self.inverse_properties
            },
            'property_characteristics': {
                'functional': list(self.functional_properties),
                'inverse_functional': list(self.inverse_functional_properties),
                'transitive': list(self.transitive_properties),
                'symmetric': list(self.symmetric_properties),
                'asymmetric': list(self.asymmetric_properties),
                'reflexive': list(self.reflexive_properties),
                'irreflexive': list(self.irreflexive_properties)
            },
            'domains_and_ranges': {
                'property_domains': {k: list(v) for k, v in self.property_domains.items()},
                'property_ranges': {k: list(v) for k, v in self.property_ranges.items()}
            },
            'annotations': {
                'labels': self.labels,
                'comments': self.comments,
                'other_annotations': {k: dict(v) for k, v in self.annotations.items()}
            },
            'individuals': {
                'instance_types': {k: list(v) for k, v in self.instance_types.items()},
                'property_assertions': self.property_assertions
            }
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(ontology_data, f, indent=2, ensure_ascii=False)
        print(f"‚úÖ Comprehensive JSON exported to {output_file}")


def main():
    if len(sys.argv) < 2:
        print("Usage: python comprehensive_extractor.py <jsonld_file> [options]")
        print("\nOptions:")
        print("  --method [rdflib|json]     Extraction method (default: auto)")
        print("  --output-json <file>       Export to JSON file")
        print("  --output-ttl <file>        Export to TTL file")
        print("  --summary                  Print detailed summary (default)")
        print("  --quiet                    Suppress summary output")
        sys.exit(1)
    
    file_path = sys.argv[1]
    method = "auto"
    json_output = None
    ttl_output = None
    show_summary = True
    
    # Parse command line arguments
    i = 2
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg == '--method' and i + 1 < len(sys.argv):
            method = sys.argv[i + 1]
            i += 2
        elif arg == '--output-json' and i + 1 < len(sys.argv):
            json_output = sys.argv[i + 1]
            i += 2
        elif arg == '--output-ttl' and i + 1 < len(sys.argv):
            ttl_output = sys.argv[i + 1]
            i += 2
        elif arg == '--summary':
            show_summary = True
            i += 1
        elif arg == '--quiet':
            show_summary = False
            i += 1
        else:
            i += 1
    
    if not os.path.exists(file_path):
        print(f"‚ùå Error: File '{file_path}' not found")
        sys.exit(1)
    
    extractor = ComprehensiveOntologyExtractor()
    
    try:
        # Determine extraction method
        if method == "auto":
            method = "rdflib" if RDFLIB_AVAILABLE else "json"
        
        print(f"üîç Extracting ontology from: {file_path}")
        print(f"üõ†Ô∏è  Using method: {method}")
        
        if method == "rdflib" and RDFLIB_AVAILABLE:
            extractor.extract_with_rdflib(file_path)
        else:
            if method == "rdflib" and not RDFLIB_AVAILABLE:
                print("‚ö†Ô∏è  Warning: rdflib not available, falling back to JSON parsing")
            extractor.extract_with_json_parsing(file_path)
        
        # Show summary
        if show_summary:
            extractor.print_comprehensive_summary()
        
        # Export files
        if json_output:
            extractor.export_to_json(json_output)
        
        if ttl_output:
            extractor.export_to_ttl(ttl_output)
        
        if not json_output and not ttl_output and not show_summary:
            print("No output specified. Use --summary, --output-json, or --output-ttl")
            
    except Exception as e:
        print(f"‚ùå Error processing file: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


# Convenience functions
def extract_comprehensive_ontology(file_path: str, method: str = "auto") -> Dict[str, Any]:
    """Extract comprehensive ontology from JSON-LD file"""
    extractor = ComprehensiveOntologyExtractor()
    
    if method == "auto":
        method = "rdflib" if RDFLIB_AVAILABLE else "json"
    
    if method == "rdflib" and RDFLIB_AVAILABLE:
        extractor.extract_with_rdflib(file_path)
    else:
        extractor.extract_with_json_parsing(file_path)
    
    return extractor.export_to_json("temp_output.json")  # Returns the data structure


if __name__ == "__main__":
    main()
