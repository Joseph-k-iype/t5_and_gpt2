from enum import Enum
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, field_validator

class DataQualityStatus(str, Enum):
    """Quality status of a data element."""
    GOOD = "good"
    NEEDS_IMPROVEMENT = "needs_improvement"
    POOR = "poor"

class EnhancementStatus(str, Enum):
    """Status of an enhancement request."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

class DataElement(BaseModel):
    """Model representing a data element with name and description."""
    id: str = Field(..., description="Unique identifier for the data element")
    existing_name: str = Field(..., description="Current name of the data element")
    existing_description: str = Field(..., description="Current description of the data element")
    example: Optional[str] = Field(None, description="Example of the data element")
    process_name: Optional[str] = Field(None, description="Name of the related process")
    process_description: Optional[str] = Field(None, description="Description of the related process")
    cdm: Optional[str] = Field(None, description="Common Data Model category for the data element")
    
    @field_validator('id')
    def id_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('ID must not be empty')
        return v.strip()
    
    @field_validator('existing_name')
    def name_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Name must not be empty')
        return v.strip()
    
    @field_validator('existing_description')
    def description_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Description must not be empty')
        return v.strip()

class EnhancedDataElement(DataElement):
    """Model representing an enhanced data element."""
    enhanced_name: str = Field(..., description="Enhanced name of the data element")
    enhanced_description: str = Field(..., description="Enhanced description of the data element")
    quality_status: DataQualityStatus = Field(DataQualityStatus.NEEDS_IMPROVEMENT, 
                                             description="Quality status of the data element")
    enhancement_iterations: int = Field(0, description="Number of enhancement iterations performed")
    validation_feedback: List[str] = Field(default_factory=list, 
                                          description="Feedback from validation iterations")
    enhancement_feedback: List[str] = Field(default_factory=list, 
                                           description="Feedback from enhancement iterations")
    confidence_score: float = Field(0.0, ge=0.0, le=1.0, 
                                    description="Confidence score for the enhancement")

class ValidationResult(BaseModel):
    """Model representing the result of data validation."""
    is_valid: bool = Field(..., description="Whether the data element is valid")
    quality_status: DataQualityStatus = Field(..., description="Quality status of the data element")
    feedback: str = Field(..., description="Feedback on the quality of the data element")
    suggested_improvements: Optional[List[str]] = Field(default_factory=list, 
                                                       description="Suggested improvements")

class EnhancementResult(BaseModel):
    """Model representing the result of data enhancement."""
    enhanced_name: str = Field(..., description="Enhanced name of the data element")
    enhanced_description: str = Field(..., description="Enhanced description of the data element")
    feedback: str = Field(..., description="Feedback on the enhancement process")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence score")
    
    @field_validator('confidence')
    def confidence_must_be_positive(cls, v):
        if v < 0.0:
            return 0.0
        if v > 1.0:
            return 1.0
        return v

class EnhancementRequest(BaseModel):
    """Model representing a request for data enhancement."""
    data_element: DataElement = Field(..., description="Data element to enhance")
    max_iterations: Optional[int] = Field(5, description="Maximum number of enhancement iterations")
    
class EnhancementResponse(BaseModel):
    """Model representing a response to an enhancement request."""
    request_id: str = Field(..., description="ID of the enhancement request")
    status: EnhancementStatus = Field(..., description="Status of the enhancement request")
    enhanced_data: Optional[EnhancedDataElement] = Field(None, 
                                                        description="Enhanced data element")
    error_message: Optional[str] = Field(None, description="Error message if enhancement failed")
    
class TaggingResult(BaseModel):
    """Model representing the result of tagging a data element with business terms."""
    element_id: str
    element_name: str
    element_description: str
    matching_terms: List[Dict[str, Any]]
    confidence_scores: List[float]
    modeling_required: bool = False
    message: str = ""
    
class TaggingRequest(BaseModel):
    """Request model for tagging an enhanced data element."""
    element_id: str
    element_name: str
    element_description: str
    top_k: int = 3
    cdm: Optional[str] = Field(None, description="Optional CDM to prioritize in matching")
    example: Optional[str] = Field(None, description="Optional example for context")
    process_name: Optional[str] = Field(None, description="Optional process name for context")
    process_description: Optional[str] = Field(None, description="Optional process description for context")
    
class TaggingResponse(BaseModel):
    """Response model for a tagging request."""
    request_id: str
    element_name: str
    matching_terms: List[Dict[str, Any]]
    confidence_scores: List[float]
    validation_result: Optional[Dict[str, Any]] = None
    modeling_required: bool = False
    message: str = ""
    
class TaggingValidationResult(BaseModel):
    """Model representing the result of validating tagged business terms."""
    is_valid: bool = Field(..., description="Whether the tagging is valid")
    feedback: str = Field(..., description="Feedback on the tagging")
    suggested_alternatives: List[Dict[str, Any]] = Field(default_factory=list, 
                                                        description="Suggested alternative terms")

# Models for PBT Tagging Feature
class PBTTaggingRequest(BaseModel):
    """Request model for finding Preferred Business Terms (PBTs)."""
    name: str = Field(..., description="Name of the item to find PBTs for (e.g., a data field name)")
    description: str = Field(..., description="Description of the item to find PBTs for (e.g., a data field description)")
    top_n: int = Field(default=5, ge=1, le=50, description="Number of top PBTs to return")
    examples: Optional[List[str]] = Field(None, description="Optional list of example values or contexts for the item")
    process_name: Optional[str] = Field(None, description="Optional name of the business process related to the item")
    process_description: Optional[str] = Field(None, description="Optional description of the business process related to the item")
    # cdm_filter: Optional[str] = Field(None, description="Optional CDM to filter PBTs by. If provided, results will be biased towards this CDM.")

    @field_validator('name', 'description')
    def field_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Name and Description must not be empty')
        return v.strip()

class MatchedPBT(BaseModel):
    """Model representing a single matched Preferred Business Term."""
    id: str = Field(..., description="Unique identifier of the PBT")
    pbt_name: str = Field(..., description="Name of the PBT")
    pbt_description: str = Field(..., description="Description of the PBT")
    cdm: Optional[str] = Field(None, description="Common Data Model (CDM) category of the PBT, if available")
    similarity_score: float = Field(..., ge=0.0, le=1.0, description="Similarity score between the input item and the PBT")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Other metadata associated with the PBT")


class PBTTaggingResponse(BaseModel):
    """Response model for a PBT tagging request."""
    input_name: str = Field(..., description="The input name provided in the request")
    input_description: str = Field(..., description="The input description provided in the request")
    matched_pbts: List[MatchedPBT] = Field(..., description="List of matched PBTs, sorted by relevance")
    message: Optional[str] = Field(None, description="Additional information or summary about the tagging process")
    # request_id: str # Consider adding a unique ID for tracking the API request itself.

class PBTQueryContext(BaseModel):
    """Internal model to pass context for PBT querying, similar to DataElement but for PBTs."""
    id: str # A unique ID for this query, can be generated
    name: str
    description: str
    example: Optional[str] = None # Combined examples
    process_name: Optional[str] = None
    process_description: Optional[str] = None
    cdm: Optional[str] = None # For potential filtering or biasing
