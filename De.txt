"""
HSBC Token Service for JWT authentication
Handles token fetching and automatic refresh using httpx + truststore
"""
import logging
import ssl
import httpx
import truststore
from typing import Optional
from datetime import datetime, timedelta
import threading

logger = logging.getLogger(__name__)


class HSBCTokenService:
    """Service for managing HSBC JWT tokens with automatic refresh."""
    
    def __init__(
        self,
        token_endpoint: str,
        username: str,
        password: str,
        token_buffer_seconds: int = 300
    ):
        """
        Initialize HSBC Token Service
        
        Args:
            token_endpoint: URL for token translation endpoint
            username: HSBC username for authentication
            password: HSBC password for authentication
            token_buffer_seconds: Seconds before expiry to refresh token
        """
        self.token_endpoint = token_endpoint
        self.username = username
        self.password = password
        self.token_buffer_seconds = token_buffer_seconds
        
        self._current_token: Optional[str] = None
        self._token_expiry: Optional[datetime] = None
        self._lock = threading.Lock()
        
        # Create httpx client with truststore SSL context
        ctx = truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        self.httpx_client = httpx.Client(http2=True, verify=ctx)
        
        logger.info("HSBC Token Service initialized with httpx + truststore")
    
    def _fetch_new_token(self) -> str:
        """
        Fetch a new JWT token from HSBC token service.
        
        Returns:
            str: JWT token
            
        Raises:
            Exception: If token fetch fails
        """
        try:
            payload = {
                "input_token_state": {
                    "token_type": "CREDENTIAL",
                    "username": self.username,
                    "password": self.password
                },
                "output_token_state": {
                    "token_type": "JWT"
                }
            }
            
            logger.info(f"Fetching new token from {self.token_endpoint}")
            
            response = self.httpx_client.post(
                self.token_endpoint,
                json=payload
            )
            
            response.raise_for_status()
            
            data = response.json()
            token = data.get("issued_token")
            
            if not token:
                raise ValueError(f"No issued_token in response: {data}")
            
            logger.info("âœ“ Successfully fetched new JWT token")
            return token
            
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error fetching token: {e}")
            logger.error(f"Response: {e.response.text if hasattr(e, 'response') else 'N/A'}")
            raise Exception(f"Failed to fetch HSBC token: {e}")
        except Exception as e:
            logger.error(f"Error fetching token: {e}")
            raise Exception(f"Failed to fetch HSBC token: {e}")
    
    def _is_token_valid(self) -> bool:
        """
        Check if current token is valid and not near expiry.
        
        Returns:
            bool: True if token is valid and not expiring soon
        """
        if not self._current_token or not self._token_expiry:
            return False
        
        time_until_expiry = (self._token_expiry - datetime.now()).total_seconds()
        return time_until_expiry > self.token_buffer_seconds
    
    def get_token(self, force_refresh: bool = False) -> str:
        """
        Get current valid token, refreshing if necessary.
        
        Args:
            force_refresh: Force token refresh even if current token is valid
            
        Returns:
            str: Valid JWT token
        """
        with self._lock:
            if force_refresh or not self._is_token_valid():
                logger.info("Token refresh required")
                self._current_token = self._fetch_new_token()
                self._token_expiry = datetime.now() + timedelta(hours=1)
                logger.info(f"Token will expire at: {self._token_expiry}")
            
            return self._current_token
    
    def invalidate_token(self):
        """Invalidate current token to force refresh on next request."""
        with self._lock:
            logger.info("Invalidating current token")
            self._current_token = None
            self._token_expiry = None
    
    def get_httpx_client(self) -> httpx.Client:
        """Get the httpx client for making requests."""
        return self.httpx_client
