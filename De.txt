from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logging
import sys
import os
from typing import Dict

# Import our API routers
from app.api import chat, research, knowledge_graph
from app.core.config import get_settings
from app.core.session_manager import SessionManager
from app.core.research_engine import ResearchEngineWrapper

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Global instances
session_manager = SessionManager()
research_engine_wrapper = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifespan events"""
    # Startup
    logger.info("üöÄ Initializing Deep Research Chatbot API")
    
    global research_engine_wrapper
    try:
        # Initialize the research engine wrapper
        research_engine_wrapper = ResearchEngineWrapper()
        await research_engine_wrapper.initialize()
        logger.info("‚úÖ Research engine initialized successfully")
        
        # Start session manager cleanup task
        session_manager.start_cleanup_task()
        logger.info("‚úÖ Session manager started")
        
        # Set global reference for dependency injection
        app.state.research_engine = research_engine_wrapper
        app.state.session_manager = session_manager
        
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize application: {e}")
        sys.exit(1)
    
    yield
    
    # Shutdown
    logger.info("üîÑ Shutting down Deep Research Chatbot API")
    if research_engine_wrapper:
        await research_engine_wrapper.cleanup()
    
    await session_manager.cleanup()
    logger.info("‚úÖ Shutdown complete")

# Create FastAPI app with lifespan management
app = FastAPI(
    title="Deep Research Chatbot API",
    description="Advanced AI-powered research assistant with knowledge graph generation",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    lifespan=lifespan
)

# Configure CORS
settings = get_settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Dependency injection functions
def get_session_manager_dependency():
    """Dependency to get session manager"""
    def _get_session_manager():
        return session_manager
    return _get_session_manager

def get_research_engine_dependency():
    """Dependency to get research engine"""
    def _get_research_engine():
        return research_engine_wrapper
    return _get_research_engine

# Include API routers with proper dependency injection
app.include_router(chat.router, prefix="/api/v1/chat", tags=["chat"])
app.include_router(research.router, prefix="/api/v1/research", tags=["research"])
app.include_router(knowledge_graph.router, prefix="/api/v1/knowledge-graph", tags=["knowledge-graph"])

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, websocket: WebSocket, session_id: str):
        await websocket.accept()
        self.active_connections[session_id] = websocket
        logger.info(f"WebSocket connected: {session_id}")
    
    def disconnect(self, session_id: str):
        if session_id in self.active_connections:
            del self.active_connections[session_id]
            logger.info(f"WebSocket disconnected: {session_id}")
    
    async def send_personal_message(self, message: dict, session_id: str):
        if session_id in self.active_connections:
            try:
                await self.active_connections[session_id].send_json(message)
            except Exception as e:
                logger.error(f"Error sending message to {session_id}: {e}")
                self.disconnect(session_id)

connection_manager = ConnectionManager()

# WebSocket endpoint for real-time communication
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await connection_manager.connect(websocket, session_id)
    try:
        while True:
            # Keep connection alive and handle any incoming messages
            data = await websocket.receive_text()
            # Echo back for now - can be extended for real-time features
            await connection_manager.send_personal_message(
                {"type": "echo", "data": data}, session_id
            )
    except WebSocketDisconnect:
        connection_manager.disconnect(session_id)
    except Exception as e:
        logger.error(f"WebSocket error for {session_id}: {e}")
        connection_manager.disconnect(session_id)

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    try:
        # Check if research engine is available
        engine_status = "healthy" if research_engine_wrapper else "unavailable"
        
        return {
            "status": "healthy",
            "research_engine": engine_status,
            "active_sessions": len(session_manager.sessions),
            "active_websockets": len(connection_manager.active_connections)
        }
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(status_code=503, detail="Service unavailable")

# Root endpoint
@app.get("/")
async def root():
    """Root endpoint with API information"""
    return {
        "message": "Deep Research Chatbot API",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health",
        "features": [
            "Quick Chat with AI Assistant",
            "Deep Multi-Agent Research",
            "Real-time Knowledge Graph Generation",
            "Session Management",
            "WebSocket Support"
        ]
    }

# Error handlers
@app.exception_handler(404)
async def not_found_handler(request, exc):
    return {"error": "Endpoint not found", "detail": str(exc)}

@app.exception_handler(500)
async def internal_error_handler(request, exc):
    logger.error(f"Internal server error: {exc}")
    return {"error": "Internal server error", "detail": "Please try again later"}

if __name__ == "__main__":
    import uvicorn
    
    # Development server
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
