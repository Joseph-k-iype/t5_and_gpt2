"""
Safe JSON parsing utilities for handling LLM responses.

ENHANCEMENTS:
- Better handling of preamble text before JSON
- Finds JSON even when LLM adds explanatory text
- More robust error recovery

Location: src/utils/json_parser.py
"""
import json
import logging
import re
from typing import Dict, Any

logger = logging.getLogger(__name__)


class SafeJsonParser:
    """Safe JSON parsing with error handling."""

    @staticmethod
    def parse_json_response(response: str) -> Dict[str, Any]:
        """
        Safely parse JSON response from LLM.
        
        Handles various cases:
        - Pure JSON
        - JSON in markdown code blocks
        - JSON with preamble text
        - Malformed JSON that can be fixed
        """
        try:
            cleaned = response.strip()

            # Case 1: Check for markdown code blocks first
            if "```json" in cleaned:
                start = cleaned.find("```json") + 7
                end = cleaned.find("```", start)
                if end != -1:
                    cleaned = cleaned[start:end].strip()
            elif "```" in cleaned:
                start = cleaned.find("```") + 3
                end = cleaned.find("```", start)
                if end != -1:
                    cleaned = cleaned[start:end].strip()
            else:
                # Case 2: Look for JSON starting with { or [
                # This handles cases where LLM adds preamble like:
                # "Below is the machine-readable extraction of ODRL policy components..."
                json_start = cleaned.find('{')
                if json_start == -1:
                    json_start = cleaned.find('[')
                
                if json_start > 0:
                    # Found JSON after some preamble text
                    logger.debug(f"Removing preamble text before JSON (first {json_start} characters)")
                    cleaned = cleaned[json_start:]
                
                # Also look for ending } or ] and trim anything after
                if cleaned.startswith('{'):
                    # Find matching closing brace
                    brace_count = 0
                    for i, char in enumerate(cleaned):
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                cleaned = cleaned[:i+1]
                                break
                elif cleaned.startswith('['):
                    # Find matching closing bracket
                    bracket_count = 0
                    for i, char in enumerate(cleaned):
                        if char == '[':
                            bracket_count += 1
                        elif char == ']':
                            bracket_count -= 1
                            if bracket_count == 0:
                                cleaned = cleaned[:i+1]
                                break

            # Try to parse
            parsed = json.loads(cleaned)
            return parsed

        except json.JSONDecodeError as e:
            logger.warning(f"JSON decode error: {e}. Attempting to fix...")

            try:
                # Try common fixes
                fixed = SafeJsonParser.fix_common_json_errors(cleaned)
                parsed = json.loads(fixed)
                logger.info("Successfully parsed JSON after fixing common errors")
                return parsed
            except Exception as fix_error:
                # Last resort: try to extract JSON more aggressively
                logger.error(f"Could not parse JSON response after fixes: {str(fix_error)}")
                logger.error(f"First 500 chars: {cleaned[:500]}...")
                logger.error(f"Last 200 chars: {cleaned[-200:]}")
                return {"error": "Failed to parse JSON", "raw_response": cleaned[:1000]}

    @staticmethod
    def extract_json_from_markdown(text: str) -> str:
        """Extract JSON from markdown code blocks."""
        if "```json" in text:
            start = text.find("```json") + 7
            end = text.find("```", start)
            if end != -1:
                return text[start:end].strip()
        elif "```" in text:
            start = text.find("```") + 3
            end = text.find("```", start)
            if end != -1:
                return text[start:end].strip()
        return text.strip()

    @staticmethod
    def fix_common_json_errors(text: str) -> str:
        """
        Fix common JSON formatting errors.
        
        Handles:
        - Trailing commas
        - Single quotes instead of double quotes
        - Unquoted keys
        - Extra whitespace
        """
        # Remove trailing commas before } or ]
        text = re.sub(r',(\s*[}\]])', r'\1', text)
        
        # Fix single quotes around string values (but be careful with nested quotes)
        # This is a simple fix - may need refinement for complex cases
        text = re.sub(r"'([^']*)'(\s*:)", r'"\1"\2', text)  # Keys
        text = re.sub(r":\s*'([^']*)'", r': "\1"', text)    # Values
        
        # Try to fix unquoted keys (simple case - word characters only)
        text = re.sub(r'(\{|,)\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'\1 "\2":', text)
        
        return text

    @staticmethod
    def validate_json_structure(data: Dict[str, Any], required_fields: list = None) -> bool:
        """Validate JSON structure against required fields."""
        if required_fields is None:
            return True
            
        if not isinstance(data, dict):
            return False
            
        for field in required_fields:
            if field not in data:
                logger.warning(f"Missing required field: {field}")
                return False
                
        return True

    @staticmethod
    def clean_and_parse(response: str, required_fields: list = None) -> Dict[str, Any]:
        """
        Complete JSON cleaning and parsing pipeline.
        
        This is the most robust method - use this when you need
        maximum reliability.
        """
        try:
            # Step 1: Extract from markdown if needed
            extracted = SafeJsonParser.extract_json_from_markdown(response)
            
            # Step 2: Remove preamble if present
            json_start = extracted.find('{')
            if json_start == -1:
                json_start = extracted.find('[')
            if json_start > 0:
                extracted = extracted[json_start:]
            
            # Step 3: Fix common errors
            fixed = SafeJsonParser.fix_common_json_errors(extracted)
            
            # Step 4: Parse
            parsed = json.loads(fixed)
            
            # Step 5: Validate structure if required
            if required_fields and not SafeJsonParser.validate_json_structure(parsed, required_fields):
                return {"error": "Invalid JSON structure", "raw_response": response[:1000]}
                
            return parsed
            
        except Exception as e:
            logger.error(f"Complete JSON parsing failed: {e}")
            logger.error(f"Response preview: {response[:500]}...")
            return {"error": f"Failed to parse JSON: {str(e)}", "raw_response": response[:1000]}
    
    @staticmethod
    def extract_json_object(text: str) -> str:
        """
        Extract the first complete JSON object from text.
        
        Useful when LLM adds explanatory text before or after JSON.
        """
        # Find first { or [
        start = text.find('{')
        if start == -1:
            start = text.find('[')
        if start == -1:
            return text
        
        # Find matching closing brace/bracket
        if text[start] == '{':
            count = 0
            for i in range(start, len(text)):
                if text[i] == '{':
                    count += 1
                elif text[i] == '}':
                    count -= 1
                    if count == 0:
                        return text[start:i+1]
        elif text[start] == '[':
            count = 0
            for i in range(start, len(text)):
                if text[i] == '[':
                    count += 1
                elif text[i] == ']':
                    count -= 1
                    if count == 0:
                        return text[start:i+1]
        
        return text[start:]
