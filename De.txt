"""
Unified Azure Token Provider for FastAPI and background workers.
This module ensures consistent token handling across synchronous and asynchronous contexts.
"""

import logging
import time
import threading
import traceback
import os
import random
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Callable
from fastapi import Depends, HTTPException, status
from pydantic import BaseModel
from dotenv import dotenv_values
import requests
from azure.identity import ClientSecretCredential

logger = logging.getLogger(__name__)

# Load credentials directly from file
credentials_path = os.path.join("env", "credentials.env")
credentials_values = {}

try:
    if os.path.isfile(credentials_path):
        logger.info(f"Auth helper loading credentials from {credentials_path}")
        credentials_values = dotenv_values(credentials_path)
        logger.info(f"Loaded {len(credentials_values)} values from {credentials_path}")
    else:
        logger.warning(f"Credentials file not found: {credentials_path}")
except Exception as e:
    logger.error(f"Error loading credentials file: {e}")

# Extract Azure AD credentials directly
AZURE_TENANT_ID = credentials_values.get("AZURE_TENANT_ID", "")
AZURE_CLIENT_ID = credentials_values.get("AZURE_CLIENT_ID", "")
AZURE_CLIENT_SECRET = credentials_values.get("AZURE_CLIENT_SECRET", "")

# Models for token handling
class Token(BaseModel):
    access_token: str
    token_type: str
    expires_at: datetime


class TokenCache:
    """Thread-safe token cache for storing and retrieving Azure tokens."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TokenCache, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the token cache."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._tokens = {}  # Format: {cache_key: (token, expiry_time)}
                self._initialized = True
                self._last_log_time = 0  # For limiting log frequency
                logger.info("Token cache initialized")
    
    def get(self, tenant_id: str, client_id: str, scope: str) -> Optional[str]:
        """
        Get a token from the cache if it exists and is not expired.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            
        Returns:
            Token if found and valid, None otherwise
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                token, expiry_time = self._tokens[cache_key]
                # Allow 5 minute buffer before expiration
                if time.time() < expiry_time - 300:
                    current_time = time.time()
                    # Limit log frequency to avoid spamming logs
                    if current_time - self._last_log_time > 60:  # Log no more than once per minute
                        logger.debug(f"Token cache hit for {client_id[:8]}...")
                        self._last_log_time = current_time
                    return token
                else:
                    logger.debug(f"Token expired for {client_id[:8]}...")
                    # Remove expired token
                    del self._tokens[cache_key]
        
        return None
    
    def set(self, tenant_id: str, client_id: str, scope: str, token: str, expires_in: int = 3600) -> None:
        """
        Store a token in the cache.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            token: The token to store
            expires_in: Token expiration time in seconds
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        expiry_time = time.time() + expires_in
        
        with self._lock:
            self._tokens[cache_key] = (token, expiry_time)
            
        logger.debug(f"Token cached for {client_id[:8]}... (expires in {expires_in}s)")
    
    def _get_cache_key(self, tenant_id: str, client_id: str, scope: str) -> str:
        """Generate a cache key."""
        return f"{tenant_id}:{client_id}:{scope}"
    
    def clear(self) -> None:
        """Clear all tokens from the cache."""
        with self._lock:
            self._tokens.clear()
        logger.info("Token cache cleared")
    
    def remove(self, tenant_id: str, client_id: str, scope: str) -> None:
        """Remove a specific token from the cache."""
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                del self._tokens[cache_key]
                logger.debug(f"Token removed from cache for {client_id[:8]}...")


# Initialize global token cache
token_cache = TokenCache()

def get_azure_token_cached(tenant_id: str = None, client_id: str = None, client_secret: str = None, 
                          scope: str = "https://cognitiveservices.azure.com/.default",
                          max_retries: int = 3,
                          retry_delay: int = 2) -> Optional[str]:
    """
    Get an Azure AD token with caching support and retry logic.
    This function first checks the cache before making a new token request.
    
    Args:
        tenant_id: Azure tenant ID (uses value from credentials.env if None)
        client_id: Azure client ID (uses value from credentials.env if None)
        client_secret: Azure client secret (uses value from credentials.env if None)
        scope: OAuth scope to request
        max_retries: Maximum number of retry attempts
        retry_delay: Base delay between retries in seconds
        
    Returns:
        Access token if successful, None otherwise
    """
    # Use provided values or fall back to values loaded from credentials.env
    tenant_id = tenant_id or AZURE_TENANT_ID
    client_id = client_id or AZURE_CLIENT_ID
    client_secret = client_secret or AZURE_CLIENT_SECRET
    
    # Validate input parameters
    if not tenant_id or tenant_id == "your-tenant-id-here":
        logger.error("Invalid tenant_id: empty or using default value")
        return None
        
    if not client_id or client_id == "your-client-id-here":
        logger.error("Invalid client_id: empty or using default value")
        return None
        
    if not client_secret or client_secret == "your-client-secret-here":
        logger.error("Invalid client_secret: empty or using default value")
        return None
    
    # Check cache first
    token = token_cache.get(tenant_id, client_id, scope)
    if token:
        return token
    
    # Cache miss - get new token with retries
    for retry in range(max_retries):
        try:
            # Mask credentials for logging
            masked_tenant = f"{tenant_id[:4]}...{tenant_id[-4:]}" if len(tenant_id) > 8 else "***"
            masked_client = f"{client_id[:4]}...{client_id[-4:]}" if len(client_id) > 8 else "***"
            
            if retry == 0:
                logger.info(f"Token cache miss for {masked_client} - fetching new token from Azure AD")
            else:
                logger.info(f"Retrying token acquisition (attempt {retry+1}/{max_retries})")
            
            # Try using Azure Identity SDK first (preferred method)
            try:
                logger.debug("Attempting token acquisition with Azure Identity SDK...")
                credential = ClientSecretCredential(
                    tenant_id=tenant_id,
                    client_id=client_id,
                    client_secret=client_secret
                )
                token_response = credential.get_token(scope)
                if token_response and token_response.token:
                    token = token_response.token
                    expires_in = 3600  # Default to 1 hour if not provided
                    
                    # Log the token (partially masked)
                    token_prefix = token[:10] if len(token) > 20 else token[:5]
                    token_suffix = token[-10:] if len(token) > 20 else token[-5:]
                    logger.info(f"Received token using Azure Identity SDK: {token_prefix}...{token_suffix}")
                    
                    # Cache the token
                    token_cache.set(tenant_id, client_id, scope, token, expires_in)
                    
                    logger.info(f"New token acquired and cached (expires in {expires_in}s)")
                    return token
                else:
                    logger.warning("Azure Identity SDK did not return a valid token, falling back to REST API")
            except Exception as sdk_error:
                logger.warning(f"Error using Azure Identity SDK: {sdk_error}, falling back to REST API")
            
            # Fallback to OAuth2 token endpoint
            token_url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
            
            # Request body
            data = {
                "client_id": client_id,
                "client_secret": client_secret,
                "scope": scope,
                "grant_type": "client_credentials"
            }
            
            # Make the request
            logger.debug(f"Requesting token from {token_url}")
            response = requests.post(
                token_url, 
                data=data,
                timeout=30
            )
            
            # Handle response
            if response.status_code == 200:
                token_data = response.json()
                if "access_token" in token_data:
                    token = token_data["access_token"]
                    expires_in = token_data.get("expires_in", 3600)  # Default to 1 hour
                    
                    # Log the token (partially masked)
                    token_prefix = token[:10] if len(token) > 20 else token[:5]
                    token_suffix = token[-10:] if len(token) > 20 else token[-5:]
                    logger.info(f"Received token: {token_prefix}...{token_suffix}")
                    
                    # Cache the token
                    token_cache.set(tenant_id, client_id, scope, token, expires_in)
                    
                    logger.info(f"New token acquired and cached (expires in {expires_in}s)")
                    return token
                else:
                    logger.error("Token response did not contain access_token")
                    logger.debug(f"Response body: {token_data}")
            else:
                logger.error(f"Token request failed with status {response.status_code}: {response.text}")
                
                # Log more detailed error information for troubleshooting
                if response.status_code == 400:
                    try:
                        error_data = response.json()
                        error = error_data.get("error", "unknown")
                        error_description = error_data.get("error_description", "No description provided")
                        logger.error(f"Token error: {error}")
                        logger.error(f"Error description: {error_description}")
                    except:
                        logger.error(f"Could not parse error response: {response.text}")
        
        except requests.exceptions.ConnectionError as e:
            logger.error(f"Connection error when getting Azure token: {e}")
            logger.error("Check network connectivity and proxy settings")
        except requests.exceptions.Timeout as e:
            logger.error(f"Timeout when getting Azure token: {e}")
            logger.error("The request to Azure AD timed out")
        except Exception as e:
            logger.error(f"Error getting Azure token: {e}")
            logger.error(traceback.format_exc())
        
        # If we get here, the attempt failed - add delay before retry
        if retry < max_retries - 1:  # Only sleep if we're going to retry
            sleep_time = (retry_delay * (2 ** retry)) + random.uniform(0, 1)  # Exponential backoff with jitter
            logger.info(f"Retrying token acquisition in {sleep_time:.2f} seconds...")
            time.sleep(sleep_time)
    
    # If we get here, all retries failed
    logger.error(f"Failed to get Azure token after {max_retries} attempts")
    return None


# Function to check and refresh token if needed (used by both async and sync code)
def refresh_token_if_needed(tenant_id: str = None, client_id: str = None, client_secret: str = None, 
                           scope: str = "https://cognitiveservices.azure.com/.default",
                           min_validity_seconds: int = 600) -> bool:
    """
    Check if a token is about to expire and refresh it if needed.
    
    Args:
        tenant_id: Azure tenant ID (uses value from credentials.env if None)
        client_id: Azure client ID (uses value from credentials.env if None) 
        client_secret: Azure client secret (uses value from credentials.env if None)
        scope: OAuth scope
        min_validity_seconds: Minimum seconds of validity required
        
    Returns:
        True if token was refreshed or is valid, False on error
    """
    # Use provided values or fall back to values loaded from credentials.env
    tenant_id = tenant_id or AZURE_TENANT_ID
    client_id = client_id or AZURE_CLIENT_ID
    client_secret = client_secret or AZURE_CLIENT_SECRET
    
    # Get token from cache to check expiry
    cache_key = token_cache._get_cache_key(tenant_id, client_id, scope)
    should_refresh = False
    
    with token_cache._lock:
        if cache_key in token_cache._tokens:
            _, expiry_time = token_cache._tokens[cache_key]
            time_left = expiry_time - time.time()
            
            # If token expires soon, refresh it
            if time_left < min_validity_seconds:
                logger.info(f"Token for {client_id[:8]}... expires in {time_left:.0f}s, refreshing")
                
                # Remove old token
                del token_cache._tokens[cache_key]
                should_refresh = True
        else:
            # No token in cache, need to refresh
            should_refresh = True
    
    if should_refresh:
        # Get a fresh token (will update cache)
        token = get_azure_token_cached(tenant_id, client_id, client_secret, scope)
        if token:
            logger.info(f"Successfully refreshed token for {client_id[:8]}...")
            return True
        else:
            logger.error(f"Failed to refresh token for {client_id[:8]}...")
            return False
    
    # Token is still valid
    return True


# Background refresh worker that handles both synchronous and asynchronous contexts
class TokenRefreshService:
    """Service for refreshing Azure AD tokens periodically in background."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TokenRefreshService, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the token refresh service."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._thread = None
                self._running = False
                self._initialized = True
                logger.info("Token refresh service initialized")
    
    def start(self, refresh_interval: int = 300):
        """
        Start the token refresh service.
        
        Args:
            refresh_interval: Interval between refresh checks in seconds
        """
        with self._lock:
            if self._thread is not None and self._thread.is_alive():
                logger.info("Token refresh service is already running")
                return self._thread
            
            self._running = True
            self._thread = threading.Thread(
                target=self._refresh_worker,
                args=(refresh_interval,),
                daemon=True,
                name="TokenRefreshThread"
            )
            self._thread.start()
            logger.info(f"Token refresh service started (interval: {refresh_interval}s)")
            
            return self._thread
    
    def stop(self):
        """Stop the token refresh service."""
        with self._lock:
            self._running = False
            logger.info("Token refresh service stopping (will complete current cycle)")
    
    def _refresh_worker(self, refresh_interval: int):
        """
        Worker function for refreshing tokens periodically.
        
        Args:
            refresh_interval: Interval between refresh checks in seconds
        """
        # Initial delay to let the application start up
        time.sleep(10)
        
        logger.info("Token refresh worker started")
        
        while self._running:
            try:
                # Refresh the token if it's going to expire soon
                refresh_token_if_needed(
                    tenant_id=AZURE_TENANT_ID,
                    client_id=AZURE_CLIENT_ID,
                    client_secret=AZURE_CLIENT_SECRET,
                    min_validity_seconds=refresh_interval * 2  # Refresh if less than 2 intervals remaining
                )
            except Exception as e:
                logger.error(f"Error in token refresh worker: {e}")
                logger.error(traceback.format_exc())
            
            # Sleep for the specified interval
            for _ in range(refresh_interval):
                if not self._running:
                    break
                time.sleep(1)  # Sleep in 1-second increments for faster stopping


# Global refresh service instance
token_refresh_service = TokenRefreshService()

def start_token_refresh_service(refresh_interval: int = 300) -> threading.Thread:
    """
    Start the token refresh service.
    
    Args:
        refresh_interval: Interval between refresh checks in seconds
        
    Returns:
        The background thread
    """
    return token_refresh_service.start(refresh_interval)


# Simplified auth functions for FastAPI dependency injection
async def verify_api_key(api_key: str = None):
    """
    No API key verification required.
    This function always returns True.
    """
    return True


async def get_current_user(token: str = None):
    """
    Simplified user authentication.
    For direct connection without auth, this just returns a default user.
    """
    # Create a simple user object
    user = {"username": "default_user"}
    return user
