import { CustomNode, CustomEdge, NodeData, EdgeData } from '@/types/lineage';

/**
 * Convert API node data to React Flow nodes
 */
export const convertToFlowNodes = (
  apiNodes: NodeData[],
  highlightedIds: Set<string> = new Set()
): CustomNode[] => {
  return apiNodes.map((node) => ({
    id: node.id,
    type: 'customNode',
    data: {
      label: node.label,
      nodeType: node.type,
      country: node.country,
      database: node.database,
      parent_id: node.parent_id,
      data_category: node.data_category,
      is_collapsed: node.is_collapsed,
      isHighlighted: highlightedIds.has(node.id),
    },
    position: { x: 0, y: 0 }, // Will be calculated by layout
  }));
};

/**
 * Convert API edge data to React Flow edges
 */
export const convertToFlowEdges = (
  apiEdges: EdgeData[],
  highlightedIds: Set<string> = new Set()
): CustomEdge[] => {
  return apiEdges.map((edge) => ({
    id: edge.id,
    source: edge.source,
    target: edge.target,
    type: 'default',
    animated: highlightedIds.has(edge.id),
    data: {
      transfer_type: edge.transfer_type,
      hop_number: edge.hop_number,
      isHighlighted: highlightedIds.has(edge.id),
    },
    style: {
      stroke: highlightedIds.has(edge.id) ? '#3b82f6' : '#94a3b8',
      strokeWidth: highlightedIds.has(edge.id) ? 3 : 1.5,
    },
  }));
};

/**
 * Toggle node collapse state
 */
export const toggleNodeCollapse = (
  nodes: CustomNode[],
  nodeId: string
): CustomNode[] => {
  return nodes.map((node) => {
    if (node.id === nodeId) {
      return {
        ...node,
        data: {
          ...node.data,
          is_collapsed: !node.data.is_collapsed,
        },
      };
    }
    return node;
  });
};

/**
 * Get all descendant nodes of a given node
 */
export const getDescendants = (
  nodeId: string,
  allNodes: CustomNode[]
): Set<string> => {
  const descendants = new Set<string>();
  const queue = [nodeId];

  while (queue.length > 0) {
    const currentId = queue.shift()!;
    const children = allNodes.filter((n) => n.data.parent_id === currentId);

    children.forEach((child) => {
      descendants.add(child.id);
      queue.push(child.id);
    });
  }

  return descendants;
};

/**
 * Get all ancestor nodes of a given node
 */
export const getAncestors = (
  nodeId: string,
  allNodes: CustomNode[]
): Set<string> => {
  const ancestors = new Set<string>();
  let currentNode = allNodes.find((n) => n.id === nodeId);

  while (currentNode?.data.parent_id) {
    ancestors.add(currentNode.data.parent_id);
    currentNode = allNodes.find((n) => n.id === currentNode!.data.parent_id);
  }

  return ancestors;
};

/**
 * Get node color based on type and state
 */
export const getNodeColor = (
  nodeType: 'country' | 'database' | 'attribute',
  isHighlighted: boolean
): string => {
  if (isHighlighted) {
    switch (nodeType) {
      case 'country':
        return '#3b82f6'; // blue-500
      case 'database':
        return '#8b5cf6'; // violet-500
      case 'attribute':
        return '#ec4899'; // pink-500
    }
  }

  switch (nodeType) {
    case 'country':
      return '#64748b'; // slate-500
    case 'database':
      return '#6b7280'; // gray-500
    case 'attribute':
      return '#78716c'; // stone-500
  }
};

/**
 * Get node icon based on type
 */
export const getNodeIcon = (
  nodeType: 'country' | 'database' | 'attribute'
): string => {
  switch (nodeType) {
    case 'country':
      return 'üåç';
    case 'database':
      return 'üóÑÔ∏è';
    case 'attribute':
      return 'üìä';
  }
};
