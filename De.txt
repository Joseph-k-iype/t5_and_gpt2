import { useState, useCallback, useRef } from 'react';
import { useWebSocket } from './useWebSocket';
import { apiClient } from '../utils/api';
import { Message, ChatSession, ThoughtProcess, ResearchState } from '../types';

interface UseChatReturn {
  // State
  session: ChatSession | null;
  messages: Message[];
  isProcessing: boolean;
  isConnected: boolean;
  currentThoughts: ThoughtProcess[];
  researchState: ResearchState | null;
  error: string | null;
  
  // Actions
  initializeSession: () => Promise<void>;
  sendMessage: (message: string) => Promise<void>;
  startDeepResearch: (topic: string, maxIterations?: number) => Promise<void>;
  clearMessages: () => void;
  resetSession: () => void;
}

export const useChat = (): UseChatReturn => {
  // Core state
  const [session, setSession] = useState<ChatSession | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [currentThoughts, setCurrentThoughts] = useState<ThoughtProcess[]>([]);
  const [researchState, setResearchState] = useState<ResearchState | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Refs for stable references
  const sessionRef = useRef<ChatSession | null>(null);
  const processingRef = useRef(false);

  // WebSocket event handlers
  const handleWebSocketMessage = useCallback((event: string, data: any) => {
    console.log('WebSocket event:', event, data);
    
    switch (event) {
      case 'message_response':
        if (data.session_id === sessionRef.current?.session_id) {
          setMessages(prev => {
            // Remove any duplicate messages
            const filteredPrev = prev.filter(msg => msg.id !== data.message.id);
            return [...filteredPrev, data.message];
          });
          setIsProcessing(false);
          processingRef.current = false;
          setCurrentThoughts([]);
        }
        break;
        
      case 'message_error':
        if (data.session_id === sessionRef.current?.session_id) {
          setMessages(prev => [...prev, data.error]);
          setIsProcessing(false);
          processingRef.current = false;
          setCurrentThoughts([]);
          setError(data.error.content);
        }
        break;
        
      case 'thinking_start':
        if (data.session_id === sessionRef.current?.session_id) {
          setCurrentThoughts([{
            timestamp: new Date().toISOString(),
            content: data.message,
            type: 'analysis'
          }]);
        }
        break;
        
      case 'thinking_update':
        if (data.session_id === sessionRef.current?.session_id) {
          setCurrentThoughts(prev => [...prev, {
            timestamp: new Date().toISOString(),
            content: data.thought,
            type: 'processing'
          }]);
        }
        break;
        
      case 'research_start':
        if (data.session_id === sessionRef.current?.session_id) {
          setResearchState({
            query: data.topic,
            iterations_completed: 0,
            confidence: 'unknown',
            accumulated_knowledge: {},
            final_report: '',
            is_processing: true
          });
          setCurrentThoughts([{
            timestamp: new Date().toISOString(),
            content: `Starting deep research on: ${data.topic}`,
            type: 'research'
          }]);
        }
        break;
        
      case 'research_complete':
        if (data.session_id === sessionRef.current?.session_id) {
          setResearchState(data.result);
          setIsProcessing(false);
          processingRef.current = false;
          setCurrentThoughts([]);
          
          // Add research result as a message
          const researchMessage: Message = {
            id: `research_${Date.now()}`,
            type: 'assistant',
            content: data.result.final_report || 'Research completed successfully.',
            timestamp: new Date().toISOString(),
            confidence: data.result.confidence || 'medium',
            intent: 'research',
            approach: 'deep_research',
            metadata: {
              research_result: data.result,
              iterations: data.result.iterations_completed
            }
          };
          
          setMessages(prev => [...prev, researchMessage]);
        }
        break;
        
      case 'research_error':
        if (data.session_id === sessionRef.current?.session_id) {
          setIsProcessing(false);
          processingRef.current = false;
          setCurrentThoughts([]);
          setError(`Research failed: ${data.error}`);
          
          const errorMessage: Message = {
            id: `error_${Date.now()}`,
            type: 'error',
            content: `Research failed: ${data.error}`,
            timestamp: new Date().toISOString()
          };
          
          setMessages(prev => [...prev, errorMessage]);
        }
        break;
        
      default:
        console.log('Unhandled WebSocket event:', event, data);
    }
  }, []);

  const handleWebSocketConnect = useCallback(() => {
    console.log('Connected to WebSocket');
    if (sessionRef.current) {
      // Join the session room
      socket?.emit('join_session', { 
        session_id: sessionRef.current.session_id 
      });
    }
  }, []);

  const handleWebSocketDisconnect = useCallback(() => {
    console.log('Disconnected from WebSocket');
  }, []);

  // Initialize WebSocket
  const { socket, isConnected } = useWebSocket({
    onMessage: handleWebSocketMessage,
    onConnect: handleWebSocketConnect,
    onDisconnect: handleWebSocketDisconnect
  });

  // Initialize chat session
  const initializeSession = useCallback(async () => {
    try {
      setError(null);
      const newSession = await apiClient.startChatSession();
      setSession(newSession);
      sessionRef.current = newSession;
      
      // Join WebSocket room if connected
      if (socket && isConnected) {
        socket.emit('join_session', { 
          session_id: newSession.session_id 
        });
      }
      
      console.log('Chat session initialized:', newSession.session_id);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to initialize session';
      setError(errorMessage);
      console.error('Failed to initialize session:', err);
    }
  }, [socket, isConnected]);

  // Send message
  const sendMessage = useCallback(async (message: string) => {
    if (!session || !message.trim() || processingRef.current) {
      return;
    }

    try {
      setError(null);
      setIsProcessing(true);
      processingRef.current = true;
      
      // Add user message immediately
      const userMessage: Message = {
        id: `user_${Date.now()}`,
        type: 'user',
        content: message,
        timestamp: new Date().toISOString()
      };
      
      setMessages(prev => [...prev, userMessage]);
      
      // Send to API
      const response = await apiClient.sendMessage({
        session_id: session.session_id,
        message
      });
      
      console.log('Message sent:', response);
      
      // The actual response will come via WebSocket
      
    } catch (err) {
      setIsProcessing(false);
      processingRef.current = false;
      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';
      setError(errorMessage);
      
      const errorMsg: Message = {
        id: `error_${Date.now()}`,
        type: 'error',
        content: `Error: ${errorMessage}`,
        timestamp: new Date().toISOString()
      };
      
      setMessages(prev => [...prev, errorMsg]);
      console.error('Failed to send message:', err);
    }
  }, [session]);

  // Start deep research
  const startDeepResearch = useCallback(async (topic: string, maxIterations = 3) => {
    if (!session || !topic.trim() || processingRef.current) {
      return;
    }

    try {
      setError(null);
      setIsProcessing(true);
      processingRef.current = true;
      
      // Add user research request message
      const userMessage: Message = {
        id: `research_request_${Date.now()}`,
        type: 'user',
        content: `ðŸ”¬ Deep Research Request: ${topic}`,
        timestamp: new Date().toISOString()
      };
      
      setMessages(prev => [...prev, userMessage]);
      
      // Send research request
      const response = await apiClient.startDeepResearch({
        session_id: session.session_id,
        topic,
        max_iterations: maxIterations
      });
      
      console.log('Deep research started:', response);
      
      // The research results will come via WebSocket
      
    } catch (err) {
      setIsProcessing(false);
      processingRef.current = false;
      const errorMessage = err instanceof Error ? err.message : 'Failed to start research';
      setError(errorMessage);
      
      const errorMsg: Message = {
        id: `research_error_${Date.now()}`,
        type: 'error',
        content: `Research Error: ${errorMessage}`,
        timestamp: new Date().toISOString()
      };
      
      setMessages(prev => [...prev, errorMsg]);
      console.error('Failed to start research:', err);
    }
  }, [session]);

  // Clear messages
  const clearMessages = useCallback(() => {
    setMessages([]);
    setCurrentThoughts([]);
    setError(null);
  }, []);

  // Reset session
  const resetSession = useCallback(async () => {
    setSession(null);
    setMessages([]);
    setCurrentThoughts([]);
    setResearchState(null);
    setIsProcessing(false);
    setError(null);
    sessionRef.current = null;
    processingRef.current = false;
    
    // Initialize new session
    await initializeSession();
  }, [initializeSession]);

  return {
    // State
    session,
    messages,
    isProcessing,
    isConnected,
    currentThoughts,
    researchState,
    error,
    
    // Actions
    initializeSession,
    sendMessage,
    startDeepResearch,
    clearMessages,
    resetSession
  };
};
