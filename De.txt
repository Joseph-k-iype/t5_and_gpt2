"""
Advanced Prompting Strategies for Legal Document Analysis
COMPLETE FULL VERSION - NO TRUNCATION
All methods fully implemented with watermark handling awareness
Location: src/prompting/advanced_strategies.py
"""
from typing import Optional, List, Dict, Any
from enum import Enum


class ExpertRole(str, Enum):
    """Expert roles for Mixture of Experts prompting"""
    LEGAL_EXPERT = "legal_expert"
    COMPLIANCE_OFFICER = "compliance_officer"
    DATA_PRIVACY_SPECIALIST = "data_privacy_specialist"
    REGULATORY_ANALYST = "regulatory_analyst"
    TECHNICAL_ARCHITECT = "technical_architect"
    BUSINESS_ANALYST = "business_analyst"


class ReasoningMode(str, Enum):
    """Reasoning modes for different analysis approaches"""
    CHAIN_OF_THOUGHT = "chain_of_thought"
    MIXTURE_OF_EXPERTS = "mixture_of_experts"
    TREE_OF_THOUGHT = "tree_of_thought"
    REFLECTION = "reflection"
    REACT = "react"


class AdvancedPromptingStrategies:
    """
    Advanced prompting strategies optimized for citation tracking,
    evidence collection, and simplified taxonomy.
    NOTE: Watermarks (INTERNAL, CONFIDENTIAL, etc.) are filtered out by document_chunker.py
    """
    
    def __init__(self, rule_name: str, jurisdiction: str):
        self.rule_name = rule_name
        self.jurisdiction = jurisdiction
    
    # ============================================================================
    # COMPLETE EXTRACTION PROMPT - FULL VERSION
    # ============================================================================
    
    def get_complete_extraction_prompt(
        self,
        chunk_text: str,
        chunk_id: int,
        level: int,
        enterprise_context: Optional[Dict[str, Any]]
    ) -> str:
        """
        COMPLETE extraction prompt with ALL requirements
        NOTE: chunk_text has already been cleaned of watermarks by DocumentChunker
        """
        
        level_desc = self._get_level_description(level)
        chunk_context = f"Chunk ID: {chunk_id}"
        
        enterprise_section = ""
        if enterprise_context:
            org = enterprise_context.get("organization", "")
            tools = enterprise_context.get("internal_tools", [])
            if org or tools:
                enterprise_section = f"\n\nENTERPRISE CONTEXT (Level 3 Enterprise Policies):\n- Organization: {org}\n- Internal Tools: {', '.join(tools)}\n- IMPORTANT: Look for organization-specific policies and internal tool requirements!"
        
        return f"""You are analyzing legal/regulatory text for: {self.rule_name} in {self.jurisdiction}

DOCUMENT LEVEL: {level_desc}
{chunk_context}{enterprise_section}

CRITICAL ANTI-HALLUCINATION RULES:
1. Extract ONLY what is explicitly stated in the text below
2. Every citation must be VERBATIM text from the chunk (word-for-word quote)
3. Every claim must have a corresponding citation
4. DO NOT infer, assume, or make up information
5. If something is not clearly stated, do not extract it
6. Use simple, clear English - NO references to "the document", "section 2", "the guidance", etc.

===== FULL CHUNK TEXT (NO TRUNCATION) =====
{chunk_text}
===== END OF CHUNK TEXT =====

MANDATORY REQUIREMENTS FOR EVERY EXTRACTION:

1. RULE DESCRIPTION (MANDATORY - CANNOT BE EMPTY):
   - Comprehensive summary in simple, clear English (minimum 100 characters)
   - Must explain WHO must do WHAT under WHICH conditions
   - NO document references like "section 2.3", "the document states", "as mentioned in"
   - Example: "Organizations must implement appropriate technical measures to ensure data security, including encryption and access controls, when processing personal data of EU residents"

2. CITATIONS (MANDATORY FOR EVERY ITEM - MINIMUM 3 TOTAL):
   - MUST be EXACT VERBATIM quotes from the text above (word-for-word)
   - Minimum 20 characters, maximum 200 characters
   - Include reasoning explaining HOW this citation supports your claim
   - Format: {{"text": "EXACT VERBATIM QUOTE FROM TEXT ABOVE", "reasoning": "This text directly states that [explain connection to claim]"}}
   - VERIFY the quote exists in the text before including it
   - Example: {{"text": "organizations shall implement appropriate technical and organizational measures", "reasoning": "This mandates the security implementation requirement"}}

3. DATA ACTIONS (extract ALL found):
   - Type: Use ONLY these three: "data_sharing_and_access" | "data_storage_and_hosting" | "data_usage"
   - Description: COMPLETE description in simple English (minimum 30 chars) - NO document references
   - Citations: AT LEAST ONE verbatim citation supporting this action
   - Thought process: DETAILED reasoning (minimum 50 chars): WHY this is classified as this action type, WHAT requirement it creates, WHO must perform it, WHEN it must be done
   - Example: {{
       "type": "data_sharing_and_access",
       "description": "Organizations must obtain explicit consent before sharing personal data with third parties",
       "citations": [{{"text": "explicit consent must be obtained before any disclosure to third parties", "reasoning": "This directly mandates the consent requirement for data sharing"}}],
       "thought_process": "This is data_sharing_and_access because it specifically regulates sharing of data with external parties. The requirement creates an obligation to implement a consent mechanism before any third-party data transfer occurs. Organizations must build consent workflows into their data sharing processes."
     }}

4. CONSTRAINTS (extract ALL found):
   - Type: Type of constraint (temporal, geographic, purpose, technical, procedural, etc.)
   - Description: COMPLETE constraint in simple English (minimum 40 chars) - NO document references
   - Left_operand: What is being constrained (e.g., "processing_location", "data_retention_period")
   - Operator: Comparison operator (eq, neq, lt, gt, lte, gte, in, contains, isPartOf)
   - Right_operand: Value or condition (string, number, array, etc.)
   - Scope: Scope of constraint (general, permission, prohibition, duty)
   - Citations: AT LEAST ONE verbatim citation
   - Thought process: DETAILED reasoning (minimum 50 chars): WHY this is a constraint, WHAT it limits, HOW it affects processing, WHAT happens if violated
   - Example: {{
       "type": "geographic",
       "description": "Data processing must occur within the European Economic Area",
       "left_operand": "processing_location",
       "operator": "isPartOf",
       "right_operand": ["EEA"],
       "scope": "general",
       "citations": [{{"text": "processing operations shall take place within the territory of the EEA", "reasoning": "This establishes the geographic boundary for processing"}}],
       "thought_process": "This is a geographic constraint that limits WHERE data processing can occur. It affects all processing activities by requiring infrastructure and operations within EEA territories. Violating this constraint means processing is unlawful and requires additional safeguards like Standard Contractual Clauses."
     }}

5. USER EVIDENCE (what users must/can/cannot do):
   - Description: COMPLETE requirement in simple English (minimum 40 chars) - NO document references
   - Citations: AT LEAST ONE verbatim citation
   - Thought process: DETAILED reasoning (minimum 50 chars): WHY this is a user action, WHAT users must do, HOW users can comply, WHAT evidence they need
   - Example: {{
       "description": "Users must review and approve their personal data before it is shared with third parties",
       "citations": [{{"text": "the data subject shall have the right to verify the accuracy before any disclosure", "reasoning": "This grants users control over third-party sharing"}}],
       "thought_process": "This is a user action because it requires individual data subjects to take specific steps. Users must: (1) access their data, (2) review it for accuracy, (3) explicitly approve or reject third-party sharing. This empowers users with direct control over data flows."
     }}

6. SYSTEM EVIDENCE (what systems must implement):
   - Description: COMPLETE requirement in simple English (minimum 40 chars) - NO document references
   - Citations: AT LEAST ONE verbatim citation
   - Thought process: DETAILED reasoning (minimum 50 chars): WHY this is a system requirement, WHAT technical implementation is needed, HOW the system should behave, WHAT happens if not implemented
   - Example: {{
       "description": "Systems must implement encryption for all personal data at rest using industry-standard algorithms with minimum 256-bit key length",
       "citations": [{{"text": "appropriate technical measures including encryption shall be implemented", "reasoning": "This mandates system-level security controls"}}],
       "thought_process": "This is a system requirement because it mandates technical infrastructure. Systems must: (1) detect when personal data is stored, (2) automatically apply encryption before writing to disk, (3) use AES-256 or equivalent, (4) manage encryption keys securely. Without this implementation, the organization cannot demonstrate appropriate security measures."
     }}

7. ENTERPRISE POLICIES (ONLY for Level 3 documents):
   - Policy_name: Name of the enterprise-specific policy (minimum 10 chars)
   - Description: COMPLETE policy description in simple English (minimum 50 chars) - NO document references
   - Organization: Organization name (e.g., "HSBC", "Acme Corp")
   - Applies_to: List of who/what it applies to (e.g., ["all employees", "vendors", "contractors"])
   - Internal_tools: List of internal tools mentioned (e.g., ["DataVisa", "PrivacyHub", "DataHub"])
   - Citations: AT LEAST ONE verbatim citation
   - Thought_process: DETAILED reasoning (minimum 50 chars): HOW this differs from legal requirements, WHY the organization added this, WHAT additional protection it provides, WHO must follow it
   - Example: {{
       "policy_name": "Third-Party Data Transfer Approval Policy",
       "description": "All third-party data transfers must be approved through the DataVisa system with documented business justification and executive sign-off before any data leaves the organization",
       "organization": "HSBC",
       "applies_to": ["all employees", "contractors", "vendors"],
       "internal_tools": ["DataVisa"],
       "citations": [{{"text": "transfer requests must be submitted via DataVisa with executive approval", "reasoning": "This establishes the organization's specific approval process"}}],
       "thought_process": "This is an enterprise policy because it goes beyond legal requirements by mandating a specific internal tool (DataVisa) and approval workflow. While law requires lawful basis for transfers, HSBC adds executive approval and documentation requirements. This applies to all HSBC employees and contractors. It operationalizes legal compliance through concrete organizational procedures."
     }}

8. CLASSIFICATION (MANDATORY):
   - Must be either "condition" (allowed under certain conditions) OR "restriction" (prohibited/restricted)
   - Classification_reasoning: DETAILED explanation (minimum 50 chars) of WHY you chose this classification, with reference to the actual text
   - Example: {{
       "classification": "condition",
       "classification_reasoning": "The text states data processing is 'permitted when consent is obtained', which indicates processing is ALLOWED but requires specific conditions to be met. This is not a prohibition but a conditional permission, therefore classified as 'condition'."
     }}

QUALITY REQUIREMENTS (ALL MANDATORY):
✓ NO single-character items or placeholders
✓ NO truncated descriptions or "..."
✓ EVERY item has at least one citation with VERBATIM text from above
✓ EVERY citation is checked to exist in the chunk text
✓ EVERY item has detailed thought_process (minimum 50 chars)
✓ Descriptions are COMPLETE sentences explaining the full requirement
✓ Rule description is comprehensive (minimum 100 chars)
✓ NO hallucination - only extract what you can see in the text
✓ NO document structure references - use plain language
✓ Use simple, clear English throughout

Return valid JSON with ALL mandatory fields fully populated. Missing any mandatory field will result in extraction failure.

JSON STRUCTURE:
{{
  "description": "Complete rule description in simple English (minimum 100 chars)",
  "citations": [
    {{"text": "exact verbatim quote (20-200 chars)", "reasoning": "how it supports the claim (minimum 30 chars)", "level": {level}}}
  ],
  "data_actions": [
    {{
      "type": "data_sharing_and_access | data_storage_and_hosting | data_usage",
      "description": "Complete action description (minimum 30 chars)",
      "citations": [{{"text": "exact quote", "reasoning": "..."}}],
      "thought_process": "Detailed reasoning (minimum 50 chars)"
    }}
  ],
  "constraints": [
    {{
      "type": "temporal|geographic|purpose|technical|procedural",
      "description": "Complete constraint description (minimum 40 chars)",
      "left_operand": "what_is_constrained",
      "operator": "eq|neq|lt|gt|lte|gte|in|contains|isPartOf",
      "right_operand": "value or array",
      "scope": "general|permission|prohibition|duty",
      "citations": [{{"text": "exact quote", "reasoning": "..."}}],
      "thought_process": "Detailed reasoning (minimum 50 chars)"
    }}
  ],
  "user_evidence": [
    {{
      "description": "Complete user requirement (minimum 40 chars)",
      "citations": [{{"text": "exact quote", "reasoning": "..."}}],
      "thought_process": "Detailed reasoning (minimum 50 chars)"
    }}
  ],
  "system_evidence": [
    {{
      "description": "Complete system requirement (minimum 40 chars)",
      "citations": [{{"text": "exact quote", "reasoning": "..."}}],
      "thought_process": "Detailed reasoning (minimum 50 chars)"
    }}
  ],
  "enterprise_policies": [
    {{
      "policy_name": "Policy name (minimum 10 chars)",
      "description": "Complete policy description (minimum 50 chars)",
      "organization": "Organization name",
      "applies_to": ["who it applies to"],
      "internal_tools": ["tool names"],
      "citations": [{{"text": "exact quote", "reasoning": "..."}}],
      "thought_process": "Detailed reasoning (minimum 50 chars)"
    }}
  ],
  "classification": "condition|restriction",
  "classification_reasoning": "Detailed explanation (minimum 50 chars)"
}}

REMEMBER:
- Extract ONLY from the text provided above
- ALL citations must be EXACT VERBATIM quotes
- Use simple, clear English without document references
- Provide detailed thought_process for everything
- Minimum lengths are MANDATORY
- NO hallucination - verify everything against the source text"""
    
    def _get_level_description(self, level: int) -> str:
        """Get description of document level"""
        descriptions = {
            1: "PRIMARY LEGISLATION - Base legal requirements from laws and regulations",
            2: "REGULATORY GUIDANCE - Detailed interpretation and implementation guidance",
            3: "ENTERPRISE POLICIES - Organization-specific implementation and internal requirements"
        }
        return descriptions.get(level, "Unknown level")
    
    # ============================================================================
    # REACT AGENT PROMPT
    # ============================================================================
    
    def get_react_agent_system_prompt(self) -> str:
        """ReAct agent system prompt with new requirements"""
        return f"""You are a legal document analyzer using ReAct methodology.

Rule: {self.rule_name}
Jurisdiction: {self.jurisdiction}

CRITICAL REQUIREMENTS:

1. CITATIONS: For every claim, provide exact text excerpts (max 200 chars) with reasoning
2. EVIDENCE: Separate user perspective (what users do) from system perspective (what systems implement)
3. ACTION TAXONOMY: Use ONLY these three categories:
   - data_sharing_and_access (sharing, transferring, disclosing, accessing)
   - data_storage_and_hosting (storing, hosting, retaining, archiving)
   - data_usage (using, processing, analyzing, collecting)
4. CLASSIFICATION: Classify as either:
   - "condition" = Allowed under certain conditions
   - "restriction" = Prohibited or restricted
5. ENTERPRISE POLICIES: Pay special attention to Level 3 documents for enterprise-specific policies
6. NO DOCUMENT REFERENCES: Never use phrases like "the document states", "section 2.3", "as mentioned in"

Extract:
- Rule description with citations
- Data actions (using simplified taxonomy)
- User evidence (what users must/can/cannot do)
- System evidence (what systems must implement)
- Constraints with citations
- Classification with reasoning
- Enterprise policies (if Level 3)

Return structured JSON with all citations and detailed reasoning."""
    
    # ============================================================================
    # CHAIN OF THOUGHT PROMPTS
    # ============================================================================
    
    def get_chain_of_thought_prompt(self, text: str) -> str:
        """Chain of Thought reasoning prompt"""
        text_truncated = text[:2000] + "..." if len(text) > 2000 else text
        
        return f"""Analyze this legal text step by step using Chain of Thought reasoning:

TEXT:
{text_truncated}

STEP-BY-STEP ANALYSIS:

1. IDENTIFY KEY REQUIREMENTS:
   What are the main obligations stated in this text?
   Who must comply? What must they do?

2. EXTRACT CONDITIONS:
   What conditions or constraints are mentioned?
   When do these requirements apply?

3. DETERMINE CLASSIFICATION:
   Is this a condition (allowed under conditions) or restriction (prohibited)?
   What evidence supports this classification?

4. IDENTIFY EVIDENCE TYPES:
   What must users do (user evidence)?
   What must systems implement (system evidence)?

5. MAP TO TAXONOMY:
   What actions are mentioned?
   How do they map to: sharing/access, storage/hosting, or usage?

6. EXTRACT CITATIONS:
   What exact text supports each finding?

Provide detailed reasoning at each step, then final JSON output."""
    
    # ============================================================================
    # MIXTURE OF EXPERTS PROMPTS
    # ============================================================================
    
    def get_mixture_of_experts_prompt(
        self,
        text: str,
        experts: List[ExpertRole]
    ) -> str:
        """Mixture of Experts prompt - multiple perspectives"""
        text_truncated = text[:1500] + "..." if len(text) > 1500 else text
        
        expert_instructions = []
        for expert in experts:
            if expert == ExpertRole.LEGAL_EXPERT:
                expert_instructions.append("LEGAL EXPERT: Identify legal obligations, requirements, and compliance mandates")
            elif expert == ExpertRole.COMPLIANCE_OFFICER:
                expert_instructions.append("COMPLIANCE OFFICER: Identify practical compliance steps and verification methods")
            elif expert == ExpertRole.DATA_PRIVACY_SPECIALIST:
                expert_instructions.append("DATA PRIVACY SPECIALIST: Identify data protection measures and privacy safeguards")
            elif expert == ExpertRole.TECHNICAL_ARCHITECT:
                expert_instructions.append("TECHNICAL ARCHITECT: Identify technical implementation requirements and system controls")
        
        expert_section = "\n".join(expert_instructions)
        
        return f"""Analyze from multiple expert perspectives:

TEXT:
{text_truncated}

EXPERT PERSPECTIVES:
{expert_section}

Each expert should:
1. Analyze from their specialized perspective
2. Provide citations for their findings
3. Explain their reasoning
4. Use simple, clear language

Then synthesize all perspectives into unified JSON output."""
    
    # ============================================================================
    # REFLECTION AND VALIDATION PROMPTS
    # ============================================================================
    
    def get_reflection_prompt(self, analysis: Dict[str, Any]) -> str:
        """Reflection prompt to validate and improve analysis"""
        # Create compact summary
        summary = f"""Current analysis:
Classification: {analysis.get('classification', 'N/A')}
Description: {analysis.get('description', '')[:200]}...
Actions: {len(analysis.get('data_actions', []))}
Constraints: {len(analysis.get('constraints', []))}
Citations: {len(analysis.get('citations', []))}"""
        
        return f"""Reflect on and validate this analysis:

{summary}

VALIDATION CHECKLIST:
1. Citations: Are all claims properly cited with exact text?
2. Taxonomy: Are actions mapped to the 3 categories (sharing/access, storage/hosting, usage)?
3. Evidence: Is user/system separation clear?
4. Classification: Is condition/restriction correct?
5. Completeness: Is anything missing from the source text?
6. Accuracy: Are citations accurate and verifiable?
7. No Hallucination: Is everything based on actual text?

Provide JSON:
{{
    "is_valid": true/false,
    "issues": ["issue1", "issue2", ...],
    "suggestions": ["suggestion1", "suggestion2", ...],
    "missing_citations": ["claim without citation"],
    "taxonomy_issues": ["action not properly mapped"],
    "hallucination_risks": ["potential hallucinated content"]
}}"""
    
    # ============================================================================
    # MERGE AND REFINEMENT PROMPTS
    # ============================================================================
    
    def get_merge_prompt(self, analyses: List[Dict[str, Any]]) -> str:
        """Merge multiple chunk analyses"""
        summaries = []
        total_citations = 0
        
        for i, analysis in enumerate(analyses[:3]):
            desc = analysis.get('description', '')[:100]
            num_cites = len(analysis.get('citations', []))
            total_citations += num_cites
            summaries.append(f"Analysis {i+1}: {desc}... [{num_cites} citations]")
        
        if len(analyses) > 3:
            remaining_cites = sum(len(a.get('citations', [])) for a in analyses[3:])
            total_citations += remaining_cites
            summaries.append(f"... and {len(analyses) - 3} more [{remaining_cites} citations]")
        
        summary_text = "\n".join(summaries)
        
        return f"""Merge these chunk analyses into one comprehensive analysis:

{summary_text}

Total citations available: {total_citations}

MERGE REQUIREMENTS:
1. Combined description covering all chunks
2. ALL citations preserved (deduplicate exact duplicates only)
3. All unique data actions (using taxonomy)
4. All user evidence items
5. All system evidence items
6. All constraints
7. All enterprise policies (if any)
8. Unified classification
9. Merged reasoning

Deduplicate while preserving all citations and source traceability.
Ensure minimum quality thresholds are maintained."""
    
    def get_refinement_prompt(self, analysis: Dict[str, Any], feedback: str) -> str:
        """Refinement prompt based on feedback"""
        summary = f"""Current analysis:
Classification: {analysis.get('classification', 'N/A')}
Description: {analysis.get('description', '')[:200]}...
Actions: {len(analysis.get('data_actions', []))}
Citations: {len(analysis.get('citations', []))}"""
        
        feedback_truncated = feedback[:300] + "..." if len(feedback) > 300 else feedback
        
        return f"""Refine this analysis based on feedback:

{summary}

FEEDBACK:
{feedback_truncated}

Apply improvements while:
1. Preserving all existing citations
2. Maintaining taxonomy compliance
3. Keeping user/system separation
4. Ensuring correct classification
5. Adding missing citations
6. Fixing any hallucinations

Provide improved JSON with all required fields and enhanced quality."""
    
    # ============================================================================
    # ENTERPRISE CONTEXT EXTRACTION
    # ============================================================================
    
    def get_enterprise_context_prompt(self, text: str, level: int) -> str:
        """Extract enterprise-specific context (especially from Level 3)"""
        text_truncated = text[:1000] + "..." if len(text) > 1000 else text
        
        level_note = ""
        if level == 3:
            level_note = "\n\nIMPORTANT: This is a Level 3 (Enterprise Policy) document. Look for organization-specific policies, internal tools, and company-specific requirements that go beyond legal mandates.\n"
        
        return f"""Identify enterprise-specific context:
{level_note}
TEXT:
{text_truncated}

Extract:
- Organization name (e.g., HSBC, Acme Corp)
- Internal tools/systems (e.g., DataVisa, PrivacyHub, DataHub)
- Company-specific processes
- Business units
- Enterprise-specific data handling policies

Provide JSON:
{{
    "organization": "Organization name or null",
    "internal_tools": ["tool1", "tool2"] or [],
    "processes": ["process1", "process2"] or [],
    "business_units": ["unit1", "unit2"] or [],
    "enterprise_policies": [
        {{"policy": "policy name", "applies_to": "scope", "citation": "exact text"}}
    ]
}}"""
    
    # ============================================================================
    # CLASSIFICATION HELPERS
    # ============================================================================
    
    def get_classification_prompt(self, analysis_summary: str) -> str:
        """Determine condition vs restriction classification"""
        return f"""Classify this rule as CONDITION or RESTRICTION:

ANALYSIS:
{analysis_summary}

DEFINITIONS:
- CONDITION: Actions ARE allowed but only under specific conditions
  Example: "Data transfer is allowed if adequacy decision exists"
  Keywords: "permitted when", "allowed if", "may be done provided that"
  
- RESTRICTION: Actions are NOT allowed or heavily prohibited
  Example: "Automated decision-making is prohibited without human oversight"
  Keywords: "prohibited", "shall not", "forbidden", "not permitted"

Provide JSON:
{{
    "classification": "condition" or "restriction",
    "reasoning": "Why this classification based on the analysis",
    "key_indicators": ["phrases that led to this classification"],
    "confidence": "high|medium|low"
}}"""
