import logging
import uuid
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query

from app.core.models import PBTTaggingRequest, PBTTaggingResponse, MatchedPBT
from app.core.business_terms import BusinessTermManager
# from app.core.embedding import EmbeddingClient # Only if direct embedding generation is needed outside BusinessTermManager

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1/pbt", tags=["PBT Tagging"])

# Dependency to get BusinessTermManager instance
def get_business_term_manager() -> BusinessTermManager:
    """Dependency to provide a BusinessTermManager instance."""
    return BusinessTermManager()

@router.post("/tag", response_model=PBTTaggingResponse)
async def find_preferred_business_terms(
    request: PBTTaggingRequest,
    bt_manager: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Find and suggest Preferred Business Terms (PBTs) for a given item name and description.

    This endpoint uses vector similarity search (via ChromaDB and text-embedding-3-large)
    and a RAG (Retrieval Augmented Generation) pattern to provide relevant PBT suggestions.
    Optional context like examples, process name, and process description can be provided
    to improve the accuracy of the suggestions.
    """
    try:
        logger.info(f"Received PBT tagging request for name: '{request.name}'")

        # The BusinessTermManager.tag_element method is designed for enhancing DataElements
        # and tagging them. We can leverage its underlying search and RAG capabilities.
        # We'll pass the PBT request details as if it were a DataElement to be tagged.
        # A unique ID is needed for the internal `tag_element` call.
        temp_element_id = f"pbt_query_{uuid.uuid4()}"

        # Combine examples into a single string if provided
        example_context = ""
        if request.examples:
            example_context = " ".join(request.examples)
            logger.debug(f"Using example context: {example_context[:200]}...")


        # Call the existing tag_element method in BusinessTermManager.
        # This method uses _term_matching_agent, which should handle the RAG logic.
        # The embedding model (text-embedding-3-large) is configured via environment variables
        # and used by the EmbeddingClient, which BusinessTermManager utilizes.
        tagging_result = await bt_manager.tag_element(
            element_id=temp_element_id,
            name=request.name, # Corresponds to element_name in TaggingRequest
            description=request.description, # Corresponds to element_description
            top_k=request.top_n,
            cdm=None, # CDM filtering can be implemented within tag_element or its agent if needed
            example=example_context,
            process_name=request.process_name,
            process_description=request.process_description
        )

        # Transform the results from TaggingResult to PBTTaggingResponse format
        matched_pbts_response: List[MatchedPBT] = []
        if tagging_result and tagging_result.matching_terms:
            for term_data in tagging_result.matching_terms:
                # term_data is expected to be a dict with 'id', 'name', 'description', 'similarity', 'metadata'
                pbt_id = term_data.get("id", "")
                pbt_name = term_data.get("name", "Unknown PBT Name")
                pbt_description = term_data.get("description", "No description available.")
                similarity_score = term_data.get("similarity", 0.0)
                metadata = term_data.get("metadata", {})
                cdm = metadata.get("cdm") # Assuming 'cdm' is stored in metadata

                matched_pbts_response.append(
                    MatchedPBT(
                        id=pbt_id,
                        pbt_name=pbt_name,
                        pbt_description=pbt_description,
                        cdm=cdm,
                        similarity_score=similarity_score,
                        metadata=metadata # Include other metadata if useful
                    )
                )
        
        response_message = tagging_result.message if tagging_result else "PBT tagging process completed."
        if tagging_result and tagging_result.modeling_required and not matched_pbts_response:
            response_message = "No suitable PBTs found. Consider modeling a new term."
        elif not matched_pbts_response:
             response_message = "No PBTs found matching the criteria."


        return PBTTaggingResponse(
            input_name=request.name,
            input_description=request.description,
            matched_pbts=matched_pbts_response,
            message=response_message
        )

    except HTTPException:
        # Re-raise HTTPException directly
        raise
    except Exception as e:
        logger.error(f"Error during PBT tagging for name '{request.name}': {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during PBT tagging: {str(e)}")

