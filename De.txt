import { RuleData } from '../types';

// Utility function to validate JSON Rules Engine format
export const validateRuleData = (data: unknown): data is RuleData => {
  if (typeof data !== 'object' || data === null) {
    return false;
  }

  const rule = data as Record<string, unknown>;
  
  return (
    typeof rule.rule_id === 'string' &&
    typeof rule.rule_text === 'string'
  );
};

// Utility function to validate array of rules
export const validateRulesArray = (data: unknown): data is RuleData[] => {
  if (!Array.isArray(data)) {
    return false;
  }
  
  return data.every(validateRuleData);
};

// Utility function to extract unique countries from rules
export const extractUniqueCountries = (rules: RuleData[]): string[] => {
  const countries = new Set<string>();
  
  rules.forEach(rule => {
    rule.applies_to_countries?.forEach(country => countries.add(country));
    rule.adequacy_countries?.forEach(country => countries.add(country));
  });
  
  return Array.from(countries).sort();
};

// Utility function to calculate priority distribution
export const calculatePriorityDistribution = (rules: RuleData[]) => {
  const distribution = {
    high: 0,
    medium: 0,
    low: 0,
  };
  
  rules.forEach(rule => {
    const priority = rule.priority || 50;
    if (priority >= 70) {
      distribution.high++;
    } else if (priority >= 30) {
      distribution.medium++;
    } else {
      distribution.low++;
    }
  });
  
  return distribution;
};

// Utility function to format file size
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

// Utility function to download JSON data
export const downloadJson = (data: unknown, filename: string): void => {
  try {
    const dataStr = JSON.stringify(data, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename.endsWith('.json') ? filename : `${filename}.json`;
    
    // Append to body, click, and remove
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Error downloading JSON:', error);
    throw new Error('Failed to download JSON file');
  }
};

// Utility function to generate unique ID
export const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Utility function to debounce function calls
export const debounce = <T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => func(...args), wait);
  };
};

// Utility function to calculate graph statistics
export const calculateGraphStats = (rules: RuleData[]) => {
  let totalConditions = 0;
  let totalEvents = 0;
  
  rules.forEach(rule => {
    if (rule.conditions) {
      Object.values(rule.conditions).forEach(conditionList => {
        if (Array.isArray(conditionList)) {
          totalConditions += conditionList.length;
        }
      });
    }
    
    if (rule.event) {
      totalEvents++;
    }
  });
  
  return {
    totalRules: rules.length,
    totalConditions,
    totalEvents,
    averageConditionsPerRule: rules.length > 0 ? totalConditions / rules.length : 0,
  };
};

// Utility function to safely parse JSON
export const safeJsonParse = <T = unknown>(jsonString: string): T | null => {
  try {
    return JSON.parse(jsonString) as T;
  } catch (error) {
    console.error('JSON parsing error:', error);
    return null;
  }
};

// Utility function to truncate text
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) {
    return text;
  }
  return text.substring(0, maxLength - 3) + '...';
};

// Utility function to check if a value is defined and not null
export const isDefined = <T>(value: T | null | undefined): value is T => {
  return value !== null && value !== undefined;
};

// Utility function to get safe array from potentially undefined array
export const getSafeArray = <T>(arr: T[] | undefined): T[] => {
  return Array.isArray(arr) ? arr : [];
};

// Utility function to capitalize first letter
export const capitalizeFirst = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

// Utility function to create a delay (for async operations)
export const delay = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

// Utility function to check if browser supports file API
export const supportsFileAPI = (): boolean => {
  return !!(window.File && window.FileReader && window.FileList && window.Blob);
};
