import pandas as pd
import requests
import json
import time
from typing import List, Dict, Any, Optional

def send_row_to_api(
    df: pd.DataFrame, 
    api_url: str,
    process_name_column: str = 'process_name',
    headers: Optional[Dict[str, str]] = None,
    max_iterations: int = 5,
    delay_between_requests: float = 0.1,
    default_process_id_prefix: str = "PROC"
) -> List[Dict[str, Any]]:
    """
    Send each row from DataFrame to API endpoint
    
    Args:
        df: DataFrame with process_name column (required) and optional other fields
        api_url: The API endpoint URL
        process_name_column: Column name containing the process name (required)
        headers: Optional headers for the API request (e.g., authentication)
        max_iterations: Default max_iterations for all requests
        delay_between_requests: Delay between API calls to avoid rate limiting
        default_process_id_prefix: Prefix for auto-generated process IDs
    
    Returns:
        List of dictionaries containing results from each API call
    """
    
    if headers is None:
        headers = {'Content-Type': 'application/json'}
    
    if process_name_column not in df.columns:
        raise ValueError(f"Required column '{process_name_column}' not found in DataFrame")
    
    results = []
    
    for index, row in df.iterrows():
        try:
            # Build basic payload - start with max_iterations
            row_max_iterations = max_iterations  # default
            if 'max_iterations' in row and pd.notna(row['max_iterations']):
                try:
                    row_max_iterations = int(row['max_iterations'])
                except (ValueError, TypeError):
                    row_max_iterations = max_iterations
            
            payload = {
                "max_iterations": row_max_iterations
            }
            
            # Add optional fields only if they exist and are not null
            if 'id' in row and pd.notna(row['id']):
                payload["id"] = str(row['id'])
            elif 'element_id' in row and pd.notna(row['element_id']):
                payload["id"] = str(row['element_id'])
            else:
                payload["id"] = f"element_{index + 1}"
                
            if 'existing_name' in row and pd.notna(row['existing_name']):
                payload["existing_name"] = str(row['existing_name'])
            elif 'element_name' in row and pd.notna(row['element_name']):
                payload["existing_name"] = str(row['element_name'])
            else:
                payload["existing_name"] = ""
                
            if 'existing_description' in row and pd.notna(row['existing_description']):
                payload["existing_description"] = str(row['existing_description'])
            elif 'element_description' in row and pd.notna(row['element_description']):
                payload["existing_description"] = str(row['element_description'])
            else:
                payload["existing_description"] = ""
                
            if 'example' in row and pd.notna(row['example']):
                payload["example"] = str(row['example'])
            elif 'optional_example' in row and pd.notna(row['optional_example']):
                payload["example"] = str(row['optional_example'])
            
            # Build processes array from the process_name in the current row
            process_name = str(row[process_name_column])
            process_id = row.get('process_id', f"{default_process_id_prefix}-{index + 1:03d}")
            process_description = row.get('process_description', f"Process: {process_name}")
            
            payload["processes"] = [
                {
                    "process_id": str(process_id),
                    "process_name": process_name,
                    "process_description": str(process_description)
                }
            ]
            
            # Remove None values from payload
            payload = {k: v for k, v in payload.items() if v is not None}
            
            print(f"Sending request {index + 1}/{len(df)} for ID: {payload['id']}")
            print(f"Payload: {json.dumps(payload, indent=2)}")  # Debug: show full payload
            
            # Make API request
            response = requests.post(
                api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            # Store result
            result = {
                'row_index': index,
                'element_id': payload['id'],
                'status_code': response.status_code,
                'success': response.status_code == 200,
                'response_data': None,
                'error': None
            }
            
            if response.status_code == 200:
                try:
                    result['response_data'] = response.json()
                except json.JSONDecodeError:
                    result['response_data'] = response.text
            else:
                result['error'] = f"HTTP {response.status_code}: {response.text}"
                print(f"Error for row {index}: {result['error']}")
            
            results.append(result)
            
            # Add delay to avoid rate limiting
            if delay_between_requests > 0:
                time.sleep(delay_between_requests)
                
        except requests.exceptions.RequestException as e:
            error_result = {
                'row_index': index,
                'element_id': str(row.get('element_id', row.get('id', f'element_{index}'))),
                'status_code': None,
                'success': False,
                'response_data': None,
                'error': f"Request exception: {str(e)}"
            }
            results.append(error_result)
            print(f"Request failed for row {index}: {str(e)}")
            
        except Exception as e:
            error_result = {
                'row_index': index,
                'element_id': str(row.get('element_id', row.get('id', f'element_{index}'))),
                'status_code': None,
                'success': False,
                'response_data': None,
                'error': f"Unexpected error: {str(e)}"
            }
            results.append(error_result)
            print(f"Unexpected error for row {index}: {str(e)}")
    
    return results

# Debug function to test payload generation without making API calls
def test_payload_generation(df: pd.DataFrame, process_name_column: str = 'process_name', max_iterations: int = 5):
    """
    Test function to see what payloads will be generated without making API calls
    """
    print("Testing payload generation...")
    print(f"DataFrame shape: {df.shape}")
    print(f"DataFrame columns: {list(df.columns)}")
    print("\n" + "="*50)
    
    for index, row in df.iterrows():
        print(f"\nRow {index + 1}:")
        print(f"Input row data: {dict(row)}")
        
        # Build the same payload as the main function
        row_max_iterations = max_iterations
        if 'max_iterations' in row and pd.notna(row['max_iterations']):
            try:
                row_max_iterations = int(row['max_iterations'])
            except (ValueError, TypeError):
                row_max_iterations = max_iterations
        
        # Build data_element object
        data_element = {}
        
        # Add optional fields to data_element
        if 'id' in row and pd.notna(row['id']):
            data_element["id"] = str(row['id'])
        elif 'element_id' in row and pd.notna(row['element_id']):
            data_element["id"] = str(row['element_id'])
        else:
            data_element["id"] = f"element_{index + 1}"
            
        if 'existing_name' in row and pd.notna(row['existing_name']):
            data_element["existing_name"] = str(row['existing_name'])
        elif 'element_name' in row and pd.notna(row['element_name']):
            data_element["existing_name"] = str(row['element_name'])
        else:
            data_element["existing_name"] = ""
            
        if 'existing_description' in row and pd.notna(row['existing_description']):
            data_element["existing_description"] = str(row['existing_description'])
        elif 'element_description' in row and pd.notna(row['element_description']):
            data_element["existing_description"] = str(row['element_description'])
        else:
            data_element["existing_description"] = ""
            
        if 'example' in row and pd.notna(row['example']):
            data_element["example"] = str(row['example'])
        elif 'optional_example' in row and pd.notna(row['optional_example']):
            data_element["example"] = str(row['optional_example'])
        
        # Build processes array for data_element
        process_name = str(row[process_name_column])
        process_id = row.get('process_id', f"PROC-{index + 1:03d}")
        process_description = row.get('process_description', f"Process: {process_name}")
        
        data_element["processes"] = [
            {
                "process_id": str(process_id),
                "process_name": process_name,
                "process_description": str(process_description)
            }
        ]
        
        # Build final payload
        payload = {
            "data_element": data_element,
            "max_iterations": row_max_iterations
        }
        
        print(f"Generated payload:")
        print(json.dumps(payload, indent=2))
        print("-" * 30)

# Example usage
if __name__ == "__main__":
    # Sample DataFrame - only process_name is required, rest is optional
    sample_data = {
        'process_name': ['Customer Onboarding', 'Order Processing', 'Quality Assurance'],
        'existing_name': ['Onboarding System', None, 'QA Process'],  # Optional
        'existing_description': ['Current onboarding flow', None, 'Quality checks'],  # Optional
        'example': ['New customer signup', None, 'Product testing'],  # Optional
        'max_iterations': [5, 3, 7]  # Optional, will use default if missing
    }
    
    df = pd.DataFrame(sample_data)
    
    # API configuration
    api_url = "https://your-api-endpoint.com/process"
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer your-api-token'  # Add your auth token
    }
    
    # Send requests
    results = send_row_to_api(
        df=df,
        api_url=api_url,
        headers=headers,
        process_name_column='process_name',  # Specify the column with process names
        delay_between_requests=0.5  # 500ms delay between requests
    )
    
    # Each request will have this structure:
    # {
    #   "data_element": {
    #     "id": "element_1",
    #     "existing_name": "Onboarding System", 
    #     "existing_description": "Current onboarding flow",
    #     "example": "New customer signup",
    #     "processes": [
    #       {
    #         "process_id": "PROC-001",
    #         "process_name": "Customer Onboarding",
    #         "process_description": "Process: Customer Onboarding"
    #       }
    #     ]
    #   },
    #   "max_iterations": 5
    # }
    
    # Process results
    successful_requests = [r for r in results if r['success']]
    failed_requests = [r for r in results if not r['success']]
    
    print(f"\nSummary:")
    print(f"Total requests: {len(results)}")
    print(f"Successful: {len(successful_requests)}")
    print(f"Failed: {len(failed_requests)}")
    
    if failed_requests:
        print("\nFailed requests:")
        for fail in failed_requests:
            print(f"Row {fail['row_index']} (ID: {fail['element_id']}): {fail['error']}")
    
    # Convert results to DataFrame for easy analysis
    results_df = pd.DataFrame(results)
    print(f"\nResults saved to DataFrame with shape: {results_df.shape}")

# Alternative: Simple approach for minimal DataFrame (only process names)
def send_simple_processes(
    df: pd.DataFrame, 
    api_url: str, 
    process_name_column: str = 'process_name',
    headers: Dict[str, str] = None,
    max_iterations: int = 5
) -> List[Dict]:
    """
    Simplified version for DataFrames that only contain process names
    """
    results = []
    
    if headers is None:
        headers = {'Content-Type': 'application/json'}
    
    for index, row in df.iterrows():
        try:
            payload = {
                "data_element": {
                    "id": f"element_{index + 1}",
                    "existing_name": "",
                    "existing_description": "",
                    "processes": [
                        {
                            "process_id": f"PROC-{index + 1:03d}",
                            "process_name": str(row[process_name_column]),
                            "process_description": f"Process: {row[process_name_column]}"
                        }
                    ]
                },
                "max_iterations": max_iterations
            }
            
            response = requests.post(api_url, headers=headers, json=payload, timeout=30)
            
            results.append({
                'row_index': index,
                'process_name': row[process_name_column],
                'success': response.status_code == 200,
                'status_code': response.status_code,
                'response': response.json() if response.status_code == 200 else response.text
            })
            
            print(f"Processed: {row[process_name_column]} - Status: {response.status_code}")
            
        except Exception as e:
            results.append({
                'row_index': index,
                'process_name': row[process_name_column],
                'success': False,
                'error': str(e)
            })
            print(f"Error processing {row[process_name_column]}: {str(e)}")
    
    return results

# Example for minimal DataFrame (just process names)
def example_minimal_usage():
    """Example with DataFrame containing only process names"""
    # DataFrame with just process names
    df_minimal = pd.DataFrame({
        'process_name': [
            'Customer Registration',
            'Payment Processing', 
            'Inventory Management',
            'Customer Support'
        ]
    })
    
    api_url = "https://your-api-endpoint.com/process"
    headers = {'Authorization': 'Bearer your-token'}
    
    # Send all processes
    results = send_simple_processes(
        df=df_minimal,
        api_url=api_url,
        headers=headers,
        max_iterations=5
    )
    
    # Check results
    for result in results:
        if result['success']:
            print(f"✅ {result['process_name']}: Success")
        else:
            print(f"❌ {result['process_name']}: {result.get('error', 'Failed')}")
    
    return results
