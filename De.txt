"""
Term Matching Agent - Agent for finding matching business terms using advanced strategies.

This module provides the TermMatchingAgent for finding matching business terms
for data elements, using vector similarity search enhanced with LLM evaluation.
"""

import logging
import uuid
from typing import List, Dict, Any, Optional, Tuple
import numpy as np
from app.core.embedding import MyDocument

logger = logging.getLogger(__name__)

class TermMatchingAgent:
    """
    Agent for matching terms using embedding similarity and LLM evaluation.
    """
    
    def __init__(self, term_manager):
        """
        Initialize the term matching agent.
        
        Args:
            term_manager: The business term manager
        """
        self.term_manager = term_manager
        logger.info("Term matching agent initialized")
    
    async def find_matching_terms(
        self, 
        element_id: str, 
        element_name: str, 
        element_description: str,
        top_k: int = 5, 
        cdm_context: Optional[str] = None,
        example_context: Optional[str] = None,
        process_name_context: Optional[str] = None,
        process_description_context: Optional[str] = None,
        initial_threshold: float = 0.2
    ) -> Tuple[List[Dict[str, Any]], List[float]]:
        """
        Find matching terms for a data element using vector similarity search.
        
        Args:
            element_id: ID of the element
            element_name: Name of the element
            element_description: Description of the element
            top_k: Number of top matches to return
            cdm_context: Optional CDM context
            example_context: Optional example context
            process_name_context: Optional process name context
            process_description_context: Optional process description context
            initial_threshold: Initial similarity threshold
            
        Returns:
            Tuple of (matching_terms, confidence_scores)
        """
        try:
            # Construct query with all context
            query_text = f"Name: {element_name}. Description: {element_description}."
            if example_context:
                query_text += f" Example: {example_context}."
            if process_name_context:
                query_text += f" Process Name: {process_name_context}."
            if process_description_context:
                query_text += f" Process Description: {process_description_context}."
            if cdm_context:
                query_text += f" CDM: {cdm_context}."
            
            # Create embedding for query
            doc = MyDocument(id=element_id, text=query_text)
            doc_with_embedding = self.term_manager.embedding_client.generate_embeddings(doc)
            
            if not doc_with_embedding.embedding:
                logger.error(f"Failed to generate embedding for element {element_id}")
                return [], []
            
            # Find similar vectors
            similar_terms = self.term_manager.vector_store.find_similar_vectors(
                query_vector=doc_with_embedding.embedding,
                top_k=top_k * 2,  # Get more to filter
                threshold=initial_threshold * 0.5  # Lower threshold for more results
            )
            
            # Filter and process results
            matching_terms = []
            confidence_scores = []
            
            for term in similar_terms:
                # Extract term data
                term_id = term.get("id", "")
                name = term.get("name", "")
                description = term.get("description", "")
                similarity = term.get("similarity", 0.0)
                metadata = term.get("metadata", {})
                
                # Apply CDM-based boost if CDM context matches
                if cdm_context and metadata.get("cdm") == cdm_context:
                    similarity *= 1.2  # 20% boost for matching CDM
                
                # Check for synonyms in metadata (if present)
                synonym_match = False
                if metadata.get("synonyms_str"):
                    synonyms = [s.strip() for s in metadata.get("synonyms_str", "").split(",")]
                    query_terms = set(query_text.lower().split())
                    
                    for synonym in synonyms:
                        if not synonym:
                            continue
                        synonym_terms = set(synonym.lower().split())
                        if query_terms.intersection(synonym_terms):
                            synonym_match = True
                            similarity *= 1.1  # 10% boost for synonym match
                            break
                
                # Add term to results
                matching_terms.append({
                    "id": term_id,
                    "name": name,
                    "description": description,
                    "metadata": metadata,
                    "synonym_match": synonym_match
                })
                confidence_scores.append(similarity)
            
            # Sort by confidence
            combined = list(zip(matching_terms, confidence_scores))
            combined.sort(key=lambda x: x[1], reverse=True)
            
            # Take top_k
            top_matches = combined[:top_k]
            
            if not top_matches:
                logger.warning(f"No matching terms found for element {element_id}")
                return [], []
            
            # Unzip
            matching_terms, confidence_scores = zip(*top_matches)
            
            return list(matching_terms), list(confidence_scores)
        
        except Exception as e:
            logger.error(f"Error finding matching terms: {e}")
            return [], []
    
    async def evaluate_match_confidence(
        self, 
        element_name: str, 
        element_description: str,
        term_name: str,
        term_description: str
    ) -> float:
        """
        Evaluate the confidence of a match between an element and a term.
        
        Args:
            element_name: Name of the element
            element_description: Description of the element
            term_name: Name of the term
            term_description: Description of the term
            
        Returns:
            Confidence score between 0 and 1
        """
        try:
            # Use vector similarity as a baseline
            element_embedding = self.term_manager.embedding_client.generate_embeddings(
                MyDocument(id="element", text=f"{element_name} - {element_description}")
            ).embedding
            
            term_embedding = self.term_manager.embedding_client.generate_embeddings(
                MyDocument(id="term", text=f"{term_name} - {term_description}")
            ).embedding
            
            if not element_embedding or not term_embedding:
                return 0.5  # Default confidence
            
            # Calculate cosine similarity
            similarity = self.term_manager.compute_similarity(
                element_embedding, term_embedding
            )
            
            # Add some noise to avoid exact same scores
            confidence = min(0.99, max(0.01, similarity * 0.8 + 0.1 + np.random.normal(0, 0.05)))
            
            return confidence
        
        except Exception as e:
            logger.error(f"Error evaluating match confidence: {e}")
            return 0.5  # Default confidence
