from fastapi import FastAPI, HTTPException, Body
import json
from pathlib import Path
import pandas as pd
import numpy as np
import httpx
from typing import Optional
from collections import defaultdict

# ============= Configuration =============
CSV_PATH = Path("Full TIA details.csv")
DATA_PATH = Path(__file__).parent / "countries.json"
OPA_QUERY_URL = "https://nginx.dvc-opa.hsbc-11974748-dvcloud.dev.dev.gcp.cloud.uk.hsbc/v1/query"

# ============= Global State =============
class DataCache:
    """Singleton to hold preloaded data with optimized dict structures"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialized = False
        return cls._instance
    
    def initialize(self):
        if self.initialized:
            return
        
        print("Loading CSV data into memory...")
        start_time = pd.Timestamp.now()
        
        # Load CSV once
        df = pd.read_csv(CSV_PATH)
        print(f"Loaded {len(df)} rows in {(pd.Timestamp.now() - start_time).total_seconds():.2f}s")
        
        # Convert to optimized dict structures
        self._build_indexes(df)
        
        # Load policies
        with DATA_PATH.open(encoding="utf-8") as f:
            self.policies = json.load(f)
        
        self.initialized = True
        total_time = (pd.Timestamp.now() - start_time).total_seconds()
        print(f"Indexing complete in {total_time:.2f}s")
        print(f"Memory structures ready for O(1) lookups")
    
    def _build_indexes(self, df: pd.DataFrame):
        """Convert pandas DataFrame to optimized dict/set structures"""
        
        # Replace NaN with None for cleaner comparisons
        df = df.replace({np.nan: None})
        
        # Convert entire DataFrame to list of dicts (much faster than iterrows)
        records = df.to_dict('records')
        
        # Initialize index structures with defaultdict for cleaner code
        self.by_app_id = defaultdict(list)
        self.by_dv_case_id = defaultdict(list)
        self.by_business_id = defaultdict(list)
        
        # Required columns for each lookup
        country_cols = {
            'ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE',
            'ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE',
            'ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME',
            'ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME'
        }
        
        module_cols = {
            'CASE_MODULE_NAME',
            'CASE_MODULE_STATUS_NAME'
        }
        
        all_cols = country_cols | module_cols
        
        # Build indexes using vectorized approach
        for record in records:
            # Extract only needed fields (reduces memory)
            compact_record = {
                k: v for k, v in record.items() 
                if k in all_cols and v is not None
            }
            
            # Index by APPLICATION_INSTANCE_ID
            if 'APPLICATION_INSTANCE_ID' in record and record['APPLICATION_INSTANCE_ID']:
                app_id = str(record['APPLICATION_INSTANCE_ID'])
                self.by_app_id[app_id].append(compact_record)
            
            # Index by ASSURANCE_DV_CASE_ID
            if 'ASSURANCE_DV_CASE_ID' in record and record['ASSURANCE_DV_CASE_ID']:
                dv_id = str(record['ASSURANCE_DV_CASE_ID'])
                self.by_dv_case_id[dv_id].append(compact_record)
            
            # Index by BUSINESS_APPLICATION_ID
            if 'BUSINESS_APPLICATION_ID' in record and record['BUSINESS_APPLICATION_ID']:
                bus_id = str(record['BUSINESS_APPLICATION_ID'])
                self.by_business_id[bus_id].append(compact_record)
        
        # Convert defaultdicts to regular dicts to save memory
        self.by_app_id = dict(self.by_app_id)
        self.by_dv_case_id = dict(self.by_dv_case_id)
        self.by_business_id = dict(self.by_business_id)
        
        # Create fast lookup sets for module checks (pre-computed for instant access)
        self._build_module_cache()
        
        print(f"Indexed: {len(self.by_app_id)} APP_IDs, "
              f"{len(self.by_dv_case_id)} DV_CASE_IDs, "
              f"{len(self.by_business_id)} BUSINESS_IDs")
    
    def _build_module_cache(self):
        """Pre-compute module completion status for O(1) lookups"""
        self.pia_completed = set()
        self.tia_completed = set()
        
        # Check all three index types
        for id_dict, id_type in [
            (self.by_app_id, 'app'),
            (self.by_dv_case_id, 'dv'),
            (self.by_business_id, 'ba')
        ]:
            for case_id, records in id_dict.items():
                for record in records:
                    module = record.get('CASE_MODULE_NAME')
                    status = record.get('CASE_MODULE_STATUS_NAME')
                    
                    if status == 'Completed':
                        full_id = f"{id_type}:{case_id}"
                        if module == 'PIA':
                            self.pia_completed.add(full_id)
                        elif module == 'TIA':
                            self.tia_completed.add(full_id)

# Initialize cache
cache = DataCache()

# HTTP client with optimized connection pooling
http_client = httpx.AsyncClient(
    verify=False,
    timeout=30.0,
    limits=httpx.Limits(
        max_keepalive_connections=20,
        max_connections=100,
        keepalive_expiry=30.0
    )
)

# ============= Helper Functions =============
def get_id_type_and_lookup(case_id: str) -> tuple[Optional[str], Optional[dict], Optional[str]]:
    """
    Determine ID type and return appropriate lookup dict + prefix
    Returns: (id_type, lookup_dict, cache_prefix)
    """
    case_str = str(case_id)
    
    if case_str.isdigit():
        return "APPLICATION_INSTANCE_ID", cache.by_app_id, "app"
    elif case_str.startswith("DVC"):
        return "ASSURANCE_DV_CASE_ID", cache.by_dv_case_id, "dv"
    elif case_str.startswith("BA"):
        return "BUSINESS_APPLICATION_ID", cache.by_business_id, "ba"
    else:
        return None, None, None

def check_countries(case_id: str, sending_country: str, receiving_country: str) -> str:
    """
    Ultra-fast country matching using in-memory dicts
    Returns: all_match | both_mismatch | sending_mismatch | receiving_mismatch | no_case
    """
    id_type, lookup_dict, _ = get_id_type_and_lookup(case_id)
    
    if not id_type or not lookup_dict:
        return "no_case"
    
    case_data = lookup_dict.get(str(case_id))
    
    if not case_data:
        return "no_case"
    
    # Use any() with generator expressions (faster than list comprehension)
    sending_match = any(
        record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE") == sending_country or
        record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME") == sending_country
        for record in case_data
    )
    
    receiving_match = any(
        record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE") == receiving_country or
        record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME") == receiving_country
        for record in case_data
    )
    
    # Simplified logic
    if sending_match and receiving_match:
        return "all_match"
    elif not sending_match and not receiving_match:
        return "both_mismatch"
    elif not sending_match:
        return "sending_mismatch"
    else:
        return "receiving_mismatch"

def check_module_status(case_id: str, module_name: str) -> bool:
    """
    O(1) module status check using pre-computed sets
    Returns: True if module is completed, False otherwise
    """
    _, _, cache_prefix = get_id_type_and_lookup(case_id)
    
    if not cache_prefix:
        return False
    
    full_id = f"{cache_prefix}:{case_id}"
    
    if module_name == "PIA":
        return full_id in cache.pia_completed
    elif module_name == "TIA":
        return full_id in cache.tia_completed
    else:
        return False

async def query_opa(query: str, input_data: Optional[dict] = None) -> dict:
    """
    Reusable OPA query function with connection pooling
    """
    payload = {"query": query}
    if input_data:
        payload["input"] = input_data
    
    try:
        response = await http_client.post(OPA_QUERY_URL, json=payload)
        response.raise_for_status()
        return response.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(
            status_code=502,
            detail=f"OPA query failed: {e.response.status_code}"
        )
    except httpx.RequestError as e:
        raise HTTPException(
            status_code=503,
            detail=f"OPA service unavailable: {str(e)}"
        )

# ============= FastAPI App =============
app = FastAPI(
    title="TIA Evaluation Service",
    description="Ultra-fast TIA/PIA compliance evaluation with O(1) lookups",
    version="2.0.0"
)

@app.on_event("startup")
async def startup_event():
    """Load and index data on startup"""
    cache.initialize()

@app.on_event("shutdown")
async def shutdown_event():
    """Close HTTP client on shutdown"""
    await http_client.aclose()

@app.post("/data/evaluate")
async def data_evaluate(
    body: dict = Body(
        ...,
        example={
            "caseId": "DVC123456",
            "sendingCountry": "GB",
            "receivingCountry": "US",
            "personalData": "Yes"
        }
    )
):
    """
    Evaluate TIA/PIA requirements for a data transfer case
    
    Ultra-optimized with:
    - O(1) case lookups via hash tables
    - O(1) module status checks via pre-computed sets
    - Connection pooling for OPA queries
    - Zero pandas operations during request handling
    """
    cid = body.get("caseId")
    sending_country = body.get("sendingCountry")
    receiving_country = body.get("receivingCountry")
    personal_data = body.get("personalData")
    
    # Validation
    if not sending_country or not receiving_country or personal_data is None:
        raise HTTPException(
            status_code=400,
            detail="Missing required fields: sendingCountry, receivingCountry, and personalData"
        )
    
    # Normalize personal_data to boolean
    is_personal = str(personal_data).lower() not in ["no", "0", "false"]
    
    # Case 1: No case ID provided and no personal data
    if not cid and not is_personal:
        opa_result = await query_opa(
            "result = data.Uk.no_id_given",
            {"sendingCountry": sending_country, "receivingCountry": receiving_country}
        )
        return {"opa_result": opa_result}
    
    # Case 2: Case ID not provided but personal data is Yes
    if not cid and is_personal:
        raise HTTPException(
            status_code=400,
            detail="caseId is required when personalData is Yes"
        )
    
    # Case 3: Case ID provided
    result = check_countries(cid, sending_country, receiving_country)
    
    # Handle no case found
    if result == "no_case":
        opa_result = await query_opa("result = data.Uk.no_case_found")
        return {"opa_result": opa_result}
    
    # Handle country mismatches
    if result in ["sending_mismatch", "receiving_mismatch", "both_mismatch"]:
        query_map = {
            "both_mismatch": "result = data.Uk.both_mismatch",
            "sending_mismatch": "result = data.Uk.sending_mismatch",
            "receiving_mismatch": "result = data.Uk.receiving_mismatch"
        }
        opa_result = await query_opa(query_map[result])
        return {"opa_result": opa_result}
    
    # Handle all_match with no personal data
    if result == "all_match" and not is_personal:
        opa_result = await query_opa("result = data.Uk.country_match_personal_no")
        return {"opa_result": opa_result}
    
    # Case 4: Check TIA/PIA status
    opa_result = await query_opa(
        "result = data.Uk.check_status",
        {"sendingCountry": sending_country, "receivingCountry": receiving_country}
    )
    
    # Parse OPA response for TIA/PIA requirements
    opa_message = None
    if isinstance(opa_result, dict) and "result" in opa_result:
        if isinstance(opa_result["result"], list):
            for item in opa_result["result"]:
                if isinstance(item, dict) and "result" in item:
                    opa_message = item["result"]
                    break
    
    # Handle NO TIA case (PIA only required)
    if opa_message == "NO TIA":
        pia_complete = check_module_status(cid, "PIA")
        
        if pia_complete:
            opa_result = await query_opa("result = data.Uk.PIA_satisfied")
        else:
            opa_result = await query_opa("result = data.Uk.PIA_not_satisfied")
        
        return {"opa_result": opa_result}
    
    # Handle Check TIA case (both TIA and PIA required)
    elif opa_message == "Check TIA":
        # O(1) lookups using pre-computed sets
        tia_complete = check_module_status(cid, "TIA")
        pia_complete = check_module_status(cid, "PIA")
        
        if tia_complete and pia_complete:
            opa_result = await query_opa("result = data.Uk.TIA_PIA_satisfied")
        else:
            opa_result = await query_opa("result = data.Uk.TIA_PIA_not_satisfied")
        
        return {"opa_result": opa_result}
    
    return {"opa_result": opa_result}

@app.get("/health")
async def health_check():
    """Health check endpoint with cache statistics"""
    if not cache.initialized:
        return {
            "status": "initializing",
            "cache_initialized": False
        }
    
    return {
        "status": "healthy",
        "cache_initialized": True,
        "indexes": {
            "application_ids": len(cache.by_app_id),
            "dv_case_ids": len(cache.by_dv_case_id),
            "business_ids": len(cache.by_business_id),
            "pia_completed_cases": len(cache.pia_completed),
            "tia_completed_cases": len(cache.tia_completed)
        }
    }

@app.get("/stats")
async def get_stats():
    """Detailed statistics about cached data"""
    if not cache.initialized:
        raise HTTPException(status_code=503, detail="Cache not initialized")
    
    return {
        "total_unique_cases": {
            "application_ids": len(cache.by_app_id),
            "dv_case_ids": len(cache.by_dv_case_id),
            "business_ids": len(cache.by_business_id)
        },
        "compliance_status": {
            "pia_completed": len(cache.pia_completed),
            "tia_completed": len(cache.tia_completed)
        },
        "performance": {
            "lookup_complexity": "O(1)",
            "module_check_complexity": "O(1)"
        }
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        workers=1  # Use 1 worker to share cache, or use Redis for multi-worker
    )
