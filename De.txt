"""
Enhanced mapping endpoints with asynchronous processing support.
"""

import logging
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks, Query, Path
from typing import List, Dict, Any, Optional
from app.models.mapping import MappingRequest, MappingResponse
from app.models.job import MappingJob, JobStatus, MappingJobResponse, MappingJobsResponse
from app.models.base import BaseResponse
from app.services.mapping_service import MappingService
from app.core.auth_helper import verify_api_key
from app.core.environment import get_os_env

logger = logging.getLogger(__name__)
router = APIRouter()

# In-memory mapping service cache
_mapping_service_instance = None

async def get_mapping_service() -> MappingService:
    """
    Get or create a mapping service instance.
    
    Returns:
        MappingService: The mapping service instance
    """
    global _mapping_service_instance
    
    if _mapping_service_instance is None:
        # Import here to avoid circular imports
        from app.services.azure_openai import AzureOpenAIService
        from app.services.elasticsearch_service import ElasticsearchService
        from app.services.vector_service import VectorService
        
        # Create service instances
        azure_service = AzureOpenAIService()
        es_service = ElasticsearchService()
        
        # Connect to Elasticsearch
        await es_service.connect()
        
        # Create mapping service
        vector_service = VectorService(azure_service, es_service)
        _mapping_service_instance = MappingService(azure_service, es_service, vector_service)
    
    return _mapping_service_instance

@router.post("/term", response_model=MappingResponse)
async def map_business_term(
    request: MappingRequest,
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Map a business term to existing terms (synchronous).
    
    Args:
        request: Mapping request
        mapping_service: Mapping service instance
        
    Returns:
        Mapping results
    """
    try:
        logger.info(f"Processing synchronous mapping request: {request.name}")
        response = await mapping_service.map_business_term(request)
        return response
    except Exception as e:
        logger.error(f"Error processing synchronous mapping request: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing mapping request: {str(e)}"
        )

@router.post("/term/async", response_model=MappingJobResponse)
async def map_business_term_async(
    request: MappingRequest,
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Map a business term to existing terms asynchronously.
    
    Creates a background job for mapping and returns a job ID that can be used
    to check on the status and results.
    
    Args:
        request: Mapping request
        mapping_service: Mapping service instance
        
    Returns:
        Job ID and status
    """
    try:
        logger.info(f"Creating asynchronous mapping job for: {request.name}")
        job = await mapping_service.create_mapping_job(request)
        
        return MappingJobResponse(
            success=True,
            message="Mapping job created successfully",
            job=job
        )
    except Exception as e:
        logger.error(f"Error creating asynchronous mapping job: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating mapping job: {str(e)}"
        )

@router.get("/jobs/{job_id}", response_model=MappingJobResponse)
async def get_mapping_job(
    job_id: str = Path(..., description="ID of the mapping job"),
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Get a mapping job by ID.
    
    Args:
        job_id: ID of the job to get
        mapping_service: Mapping service instance
        
    Returns:
        Job details
    """
    try:
        logger.info(f"Getting mapping job: {job_id}")
        job = await mapping_service.get_mapping_job(job_id)
        
        if not job:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Mapping job {job_id} not found"
            )
        
        return MappingJobResponse(
            success=True,
            message="Mapping job retrieved successfully",
            job=job
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting mapping job: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting mapping job: {str(e)}"
        )

@router.get("/jobs", response_model=MappingJobsResponse)
async def get_mapping_jobs(
    status: Optional[JobStatus] = Query(None, description="Filter by job status"),
    page: int = Query(1, description="Page number (starting from 1)"),
    page_size: int = Query(10, description="Number of items per page"),
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Get mapping jobs with optional filtering.
    
    Args:
        status: Filter by job status (optional)
        page: Page number (1-based)
        page_size: Number of results per page
        mapping_service: Mapping service instance
        
    Returns:
        List of jobs
    """
    try:
        logger.info(f"Getting mapping jobs (status={status}, page={page}, page_size={page_size})")
        jobs, total = await mapping_service.get_mapping_jobs(status, page, page_size)
        
        return MappingJobsResponse(
            success=True,
            message=f"Retrieved {len(jobs)} mapping jobs",
            jobs=jobs,
            total=total,
            page=page,
            page_size=page_size
        )
    except Exception as e:
        logger.error(f"Error getting mapping jobs: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error getting mapping jobs: {str(e)}"
        )

@router.get("/terms", response_model=BaseResponse)
async def get_all_terms(
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Get all business terms.
    
    Args:
        mapping_service: Mapping service instance
        
    Returns:
        List of business terms
    """
    try:
        logger.info("Retrieving all business terms")
        terms = await mapping_service.get_all_business_terms()
        return BaseResponse(
            success=True,
            message=f"Retrieved {len(terms)} business terms",
            data=terms
        )
    except Exception as e:
        logger.error(f"Error retrieving business terms: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving business terms: {str(e)}"
        )

@router.delete("/jobs/{job_id}", response_model=BaseResponse)
async def delete_mapping_job(
    job_id: str = Path(..., description="ID of the mapping job to delete"),
    mapping_service: MappingService = Depends(get_mapping_service)
):
    """
    Delete a mapping job.
    
    Args:
        job_id: ID of the job to delete
        mapping_service: Mapping service instance
        
    Returns:
        Success message
    """
    try:
        logger.info(f"Deleting mapping job: {job_id}")
        # Use the job tracking service to delete the job
        await mapping_service.job_tracking_service.connect(mapping_service.es_service.client)
        deleted = await mapping_service.job_tracking_service.delete_job(job_id)
        
        if not deleted:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Mapping job {job_id} not found"
            )
        
        return BaseResponse(
            success=True,
            message=f"Mapping job {job_id} deleted successfully",
            data=None
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting mapping job: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error deleting mapping job: {str(e)}"
        )
