import React, { useRef, useEffect } from 'react';
import type { ContextMenuOption } from '../../types/node.types';

interface ContextMenuProps {
  x: number;
  y: number;
  onExpand: (type: string) => void;
  onClose: () => void;
  options: ContextMenuOption[];
}

const ContextMenu: React.FC<ContextMenuProps> = ({ x, y, onExpand, onClose, options }) => {
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        onClose();
      }
    };

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    // Add event listeners
    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('keydown', handleEscape);

    // Focus the menu for keyboard navigation
    if (menuRef.current) {
      menuRef.current.focus();
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [onClose]);

  // Adjust position to prevent menu from going off-screen
  const adjustedPosition = React.useMemo(() => {
    const menuWidth = 220; // Approximate menu width
    const menuHeight = options.length * 44 + 16; // Approximate menu height
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let adjustedX = x;
    let adjustedY = y;

    // Adjust horizontal position
    if (x + menuWidth > viewportWidth) {
      adjustedX = x - menuWidth;
    }

    // Adjust vertical position
    if (y + menuHeight > viewportHeight) {
      adjustedY = y - menuHeight;
    }

    // Ensure menu doesn't go off the left or top edge
    adjustedX = Math.max(8, adjustedX);
    adjustedY = Math.max(8, adjustedY);

    return { x: adjustedX, y: adjustedY };
  }, [x, y, options.length]);

  const handleOptionClick = (optionKey: string, available: boolean) => {
    if (available) {
      onExpand(optionKey);
      onClose();
    }
  };

  const handleKeyDown = (event: React.KeyboardEvent, optionKey: string, available: boolean) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleOptionClick(optionKey, available);
    }
  };

  return (
    <div
      ref={menuRef}
      className="
        fixed bg-white border border-gray-300 rounded-lg shadow-xl py-2 z-50 
        min-w-[220px] max-w-[280px] animate-fade-in backdrop-blur-sm
        bg-white/95 border-gray-200
      "
      style={{ 
        left: adjustedPosition.x, 
        top: adjustedPosition.y 
      }}
      role="menu"
      tabIndex={-1}
      aria-label="Node actions menu"
    >
      {/* Menu Header */}
      <div className="px-4 py-2 border-b border-gray-100">
        <span className="text-xs font-semibold text-gray-600 uppercase tracking-wide">
          Expand Node Details
        </span>
      </div>

      {/* Menu Options */}
      {options.map((option) => (
        <button
          key={option.key}
          disabled={!option.available}
          className={`
            w-full px-4 py-2 text-left text-sm flex items-center gap-3 
            transition-all duration-150 focus:outline-none
            ${option.available 
              ? 'hover:bg-blue-50 text-gray-700 cursor-pointer focus:bg-blue-50 hover:translate-x-1' 
              : 'text-gray-400 cursor-not-allowed'
            }
          `}
          onClick={() => handleOptionClick(option.key, option.available)}
          onKeyDown={(e) => handleKeyDown(e, option.key, option.available)}
          role="menuitem"
          tabIndex={option.available ? 0 : -1}
          aria-disabled={!option.available}
        >
          {/* Icon */}
          <span className={`
            text-base flex-shrink-0 transition-transform duration-150
            ${option.available ? 'group-hover:scale-110' : 'grayscale'}
          `}>
            {option.icon}
          </span>
          
          {/* Label and description */}
          <div className="flex-1 min-w-0">
            <div className={`
              font-medium
              ${option.available ? 'text-gray-800' : 'text-gray-400'}
            `}>
              {option.label}
            </div>
            
            {/* Optional description based on option type */}
            <div className="text-xs text-gray-500 mt-0.5">
              {getOptionDescription(option.key)}
            </div>
          </div>
          
          {/* Availability indicator */}
          <div className="flex-shrink-0">
            {option.available ? (
              <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
            ) : (
              <div className="w-2 h-2 bg-gray-300 rounded-full" />
            )}
          </div>
        </button>
      ))}

      {/* Menu Footer */}
      <div className="px-4 py-2 border-t border-gray-100 mt-1">
        <div className="text-xs text-gray-500 flex items-center gap-1">
          <span>ðŸ’¡</span>
          <span>Click to expand, ESC to close</span>
        </div>
      </div>
    </div>
  );
};

// Helper function to get option descriptions
const getOptionDescription = (optionKey: string): string => {
  const descriptions: Record<string, string> = {
    'countries': 'Show applicable jurisdictions',
    'adequacy': 'Show adequacy decision countries',
    'conditions': 'Show processing conditions',
    'roles': 'Show involved stakeholders',
    'action': 'Show required actions',
    'consequence': 'Show violation consequences'
  };
  
  return descriptions[optionKey] || '';
};

export default ContextMenu;
