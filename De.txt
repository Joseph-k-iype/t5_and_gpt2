"""
Enhanced ReAct Tools for ODRL to Rego Conversion
Tools that extract ACTUAL values from ODRL JSON and prepare them for Rego generation
"""
import json
import re
from typing import Dict, Any, List
from langchain_core.tools import tool


# ============================================================================
# ODRL Extraction Tools (Extract ACTUAL values from JSON)
# ============================================================================

@tool
def extract_policy_metadata(odrl_json: str) -> Dict[str, Any]:
    """
    Extract policy metadata from ODRL policy.
    
    Args:
        odrl_json: JSON string of the ODRL policy
        
    Returns:
        Policy ID, type, and structure information
    """
    try:
        policy = json.loads(odrl_json) if isinstance(odrl_json, str) else odrl_json
        
        return {
            "policy_id": policy.get("uid") or policy.get("@id") or policy.get("policyid", "unknown"),
            "policy_type": policy.get("@type") or policy.get("policytype", "Set"),
            "permission_count": len(policy.get("permission", [])),
            "prohibition_count": len(policy.get("prohibition", [])),
            "has_context": "@context" in policy
        }
    except Exception as e:
        return {"error": f"Failed to extract metadata: {str(e)}"}


@tool
def extract_permissions_with_values(odrl_json: str) -> Dict[str, Any]:
    """
    Extract ALL permissions with their ACTUAL constraint values from ODRL policy.
    This extracts the real values that should be used in Rego generation.
    
    Args:
        odrl_json: JSON string of the ODRL policy
        
    Returns:
        Structured list of permissions with actual values extracted
    """
    try:
        policy = json.loads(odrl_json) if isinstance(odrl_json, str) else odrl_json
        permissions = policy.get("permission", [])
        
        extracted = []
        for idx, perm in enumerate(permissions):
            # Extract actual values from constraints
            constraints_with_values = []
            for constraint in perm.get("constraint", []):
                constraint_data = {
                    "leftOperand": constraint.get("leftOperand"),
                    "operator": constraint.get("operator"),
                    "rightOperand": constraint.get("rightOperand"),  # ACTUAL VALUE
                    "unit": constraint.get("unit"),
                    "dataType": constraint.get("dataType"),
                    "rdfs_comment": constraint.get("rdfs:comment", "")
                }
                constraints_with_values.append(constraint_data)
            
            extracted.append({
                "id": f"permission_{idx}",
                "action": perm.get("action"),  # ACTUAL ACTION
                "target": perm.get("target"),
                "assignee": perm.get("assignee"),
                "assigner": perm.get("assigner"),
                "constraints": constraints_with_values,
                "duties": perm.get("duty", []),
                "rdfs_comment": perm.get("rdfs:comment", "")
            })
        
        return {
            "permissions": extracted,
            "count": len(extracted),
            "analysis": f"Extracted {len(extracted)} permission(s) with actual constraint values"
        }
    except Exception as e:
        return {"error": f"Failed to extract permissions: {str(e)}"}


@tool
def extract_prohibitions_with_values(odrl_json: str) -> Dict[str, Any]:
    """
    Extract ALL prohibitions with their ACTUAL constraint values from ODRL policy.
    
    Args:
        odrl_json: JSON string of the ODRL policy
        
    Returns:
        Structured list of prohibitions with actual values
    """
    try:
        policy = json.loads(odrl_json) if isinstance(odrl_json, str) else odrl_json
        prohibitions = policy.get("prohibition", [])
        
        extracted = []
        for idx, prohib in enumerate(prohibitions):
            # Extract actual values from constraints
            constraints_with_values = []
            for constraint in prohib.get("constraint", []):
                constraint_data = {
                    "leftOperand": constraint.get("leftOperand"),
                    "operator": constraint.get("operator"),
                    "rightOperand": constraint.get("rightOperand"),  # ACTUAL VALUE
                    "unit": constraint.get("unit"),
                    "dataType": constraint.get("dataType"),
                    "rdfs_comment": constraint.get("rdfs:comment", "")
                }
                constraints_with_values.append(constraint_data)
            
            extracted.append({
                "id": f"prohibition_{idx}",
                "action": prohib.get("action"),  # ACTUAL ACTION
                "target": prohib.get("target"),
                "assignee": prohib.get("assignee"),
                "assigner": prohib.get("assigner"),
                "constraints": constraints_with_values,
                "remedy": prohib.get("remedy"),
                "rdfs_comment": prohib.get("rdfs:comment", "")
            })
        
        return {
            "prohibitions": extracted,
            "count": len(extracted),
            "analysis": f"Extracted {len(extracted)} prohibition(s) with actual constraint values"
        }
    except Exception as e:
        return {"error": f"Failed to extract prohibitions: {str(e)}"}


@tool
def extract_all_constraint_values(odrl_json: str) -> Dict[str, Any]:
    """
    Extract ALL constraint values from the entire ODRL policy.
    Returns a comprehensive map of actual values to use in Rego generation.
    
    Args:
        odrl_json: JSON string of the ODRL policy
        
    Returns:
        Complete mapping of all constraint values found in the policy
    """
    try:
        policy = json.loads(odrl_json) if isinstance(odrl_json, str) else odrl_json
        
        all_constraints = []
        
        # Extract from permissions
        for perm in policy.get("permission", []):
            for constraint in perm.get("constraint", []):
                all_constraints.append({
                    "source": "permission",
                    "leftOperand": constraint.get("leftOperand"),
                    "operator": constraint.get("operator"),
                    "rightOperand": constraint.get("rightOperand"),
                    "rightOperand_type": type(constraint.get("rightOperand")).__name__,
                    "unit": constraint.get("unit"),
                    "dataType": constraint.get("dataType")
                })
        
        # Extract from prohibitions
        for prohib in policy.get("prohibition", []):
            for constraint in prohib.get("constraint", []):
                all_constraints.append({
                    "source": "prohibition",
                    "leftOperand": constraint.get("leftOperand"),
                    "operator": constraint.get("operator"),
                    "rightOperand": constraint.get("rightOperand"),
                    "rightOperand_type": type(constraint.get("rightOperand")).__name__,
                    "unit": constraint.get("unit"),
                    "dataType": constraint.get("dataType")
                })
        
        # Create value summary
        unique_left_operands = list(set(c["leftOperand"] for c in all_constraints if c["leftOperand"]))
        unique_operators = list(set(c["operator"] for c in all_constraints if c["operator"]))
        
        return {
            "all_constraints": all_constraints,
            "total_count": len(all_constraints),
            "unique_left_operands": unique_left_operands,
            "unique_operators": unique_operators,
            "analysis": f"Found {len(all_constraints)} constraints with actual values"
        }
    except Exception as e:
        return {"error": f"Failed to extract constraint values: {str(e)}"}


# ============================================================================
# Type Inference and Pattern Generation (Use ACTUAL values)
# ============================================================================

@tool
def generate_rego_pattern_from_constraint(constraint_json: str) -> Dict[str, Any]:
    """
    Generate complete Rego code pattern using ACTUAL values from constraint.
    This is the key function that creates Rego code with real values, not placeholders.
    
    Args:
        constraint_json: JSON string of a single constraint with actual values
        
    Returns:
        Complete Rego pattern ready to use in code generation
    """
    try:
        constraint = json.loads(constraint_json) if isinstance(constraint_json, str) else constraint_json
        
        left_op = constraint.get("leftOperand", "")
        operator = constraint.get("operator", "eq")
        right_op = constraint.get("rightOperand")
        
        if not left_op or right_op is None:
            return {"error": "Missing leftOperand or rightOperand"}
        
        # Generate input reference
        input_ref = f"input.{left_op}"
        
        # Analyze the ACTUAL right operand value
        right_op_analysis = _analyze_actual_value(right_op)
        
        # Map operator to Rego
        operator_map = {
            "eq": "==",
            "neq": "!=",
            "lt": "<",
            "gt": ">",
            "lteq": "<=",
            "gteq": ">=",
            "isAnyOf": "in",
            "isA": "==",
            "isPartOf": "in"
        }
        
        rego_op = operator_map.get(operator, "==")
        
        # Generate pattern based on actual value type
        if right_op_analysis["type"] == "list" and operator == "isAnyOf":
            # Convert list to Rego set with ACTUAL values
            values_str = ", ".join([f'"{v}"' if isinstance(v, str) else str(v) for v in right_op])
            pattern = f'{input_ref} in {{{values_str}}}'
            comment = f"# ODRL: {left_op} {operator} {right_op}"
            
        elif right_op_analysis["type"] == "temporal":
            # Use actual datetime value
            pattern = f'time.parse_rfc3339_ns("{right_op}") {rego_op} time.now_ns()'
            comment = f"# ODRL: {left_op} {operator} {right_op}"
            
        elif right_op_analysis["type"] == "numeric":
            # Use actual number
            pattern = f'{input_ref} {rego_op} {right_op}'
            comment = f"# ODRL: {left_op} {operator} {right_op}"
            
        else:
            # String comparison with actual value
            pattern = f'{input_ref} {rego_op} "{right_op}"'
            comment = f"# ODRL: {left_op} {operator} {right_op}"
        
        return {
            "rego_pattern": pattern,
            "comment": comment,
            "left_operand": left_op,
            "operator": operator,
            "right_operand": right_op,
            "actual_value_used": True,
            "input_field": input_ref
        }
    
    except Exception as e:
        return {"error": f"Failed to generate pattern: {str(e)}"}


def _analyze_actual_value(value: Any) -> Dict[str, str]:
    """
    Analyze the actual rightOperand value to determine its type.
    """
    if isinstance(value, list):
        return {"type": "list", "element_type": type(value[0]).__name__ if value else "unknown"}
    
    if isinstance(value, (int, float)):
        return {"type": "numeric"}
    
    if isinstance(value, bool):
        return {"type": "boolean"}
    
    if isinstance(value, str):
        # Check for temporal patterns
        if re.match(r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}', value):
            return {"type": "temporal"}
        if value.startswith("http://") or value.startswith("https://"):
            return {"type": "uri"}
        return {"type": "string"}
    
    return {"type": "unknown"}


@tool
def generate_complete_rego_rule(rule_json: str) -> Dict[str, Any]:
    """
    Generate a complete Rego rule (allow/deny) with ALL actual constraint values.
    This creates production-ready Rego code using real values from the policy.
    
    Args:
        rule_json: JSON string of a permission or prohibition with constraints
        
    Returns:
        Complete Rego rule code
    """
    try:
        rule = json.loads(rule_json) if isinstance(rule_json, str) else rule_json
        
        rule_type = rule.get("type", "allow")  # allow or deny
        action = rule.get("action", "")
        constraints = rule.get("constraints", [])
        
        # Generate rule header
        if rule_type == "allow":
            rule_header = "allow if {"
        else:
            rule_header = "deny if {"
        
        # Generate constraint patterns
        constraint_patterns = []
        for constraint in constraints:
            pattern_result = generate_rego_pattern_from_constraint(json.dumps(constraint))
            if "error" not in pattern_result:
                constraint_patterns.append({
                    "pattern": pattern_result["rego_pattern"],
                    "comment": pattern_result["comment"]
                })
        
        # Build complete rule
        lines = [f"# Permission/Prohibition for action: {action}"]
        for cp in constraint_patterns:
            lines.append(cp["comment"])
        lines.append(rule_header)
        
        # Add action check if present
        if action:
            action_value = action.split("/")[-1] if "/" in action else action
            lines.append(f'    input.action == "{action_value}"')
        
        # Add constraint patterns
        for cp in constraint_patterns:
            lines.append(f'    {cp["pattern"]}')
        
        lines.append("}")
        
        return {
            "rego_code": "\n".join(lines),
            "constraint_count": len(constraint_patterns),
            "uses_actual_values": True
        }
    
    except Exception as e:
        return {"error": f"Failed to generate rule: {str(e)}"}


# ============================================================================
# Legacy Tools (for compatibility)
# ============================================================================

@tool
def extract_permissions(odrl_json: str) -> Dict[str, Any]:
    """Legacy tool - redirects to enhanced version"""
    return extract_permissions_with_values(odrl_json)


@tool
def extract_prohibitions(odrl_json: str) -> Dict[str, Any]:
    """Legacy tool - redirects to enhanced version"""
    return extract_prohibitions_with_values(odrl_json)


@tool
def extract_constraints(constraint_data: str) -> Dict[str, Any]:
    """Legacy tool - kept for compatibility"""
    try:
        if isinstance(constraint_data, str):
            constraints = json.loads(constraint_data)
        else:
            constraints = constraint_data
        
        if not isinstance(constraints, list):
            constraints = [constraints]
        
        analyzed = []
        for idx, constraint in enumerate(constraints):
            analyzed.append({
                "id": f"constraint_{idx}",
                "leftOperand": constraint.get("leftOperand"),
                "operator": constraint.get("operator"),
                "rightOperand": constraint.get("rightOperand"),
                "unit": constraint.get("unit"),
                "dataType": constraint.get("dataType")
            })
        
        return {
            "constraints": analyzed,
            "count": len(analyzed)
        }
    except Exception as e:
        return {"error": f"Failed to extract constraints: {str(e)}"}


@tool
def analyze_rdfs_comments(odrl_json: str) -> Dict[str, Any]:
    """Extract RDFS comments for semantic context."""
    try:
        policy = json.loads(odrl_json) if isinstance(odrl_json, str) else odrl_json
        comments = {}
        
        def extract_comments(obj, path=""):
            if isinstance(obj, dict):
                if "rdfs:comment" in obj:
                    uri = obj.get("@id", path)
                    comments[uri] = obj["rdfs:comment"]
                for key, value in obj.items():
                    extract_comments(value, f"{path}.{key}" if path else key)
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    extract_comments(item, f"{path}[{i}]")
        
        extract_comments(policy)
        
        return {
            "comments": comments,
            "count": len(comments)
        }
    except Exception as e:
        return {"error": f"Failed to analyze RDFS comments: {str(e)}"}


@tool
def analyze_operator(operator: str) -> Dict[str, Any]:
    """Analyze ODRL operator and suggest Rego equivalent."""
    operator_map = {
        "eq": {"rego": "==", "type_hint": "any"},
        "neq": {"rego": "!=", "type_hint": "any"},
        "lt": {"rego": "<", "type_hint": "numeric/temporal"},
        "gt": {"rego": ">", "type_hint": "numeric/temporal"},
        "lteq": {"rego": "<=", "type_hint": "numeric/temporal"},
        "gteq": {"rego": ">=", "type_hint": "numeric/temporal"},
        "isAnyOf": {"rego": "in", "type_hint": "set"},
        "isA": {"rego": "==", "type_hint": "type/class"},
        "hasPart": {"rego": "in", "type_hint": "array/set"},
        "isPartOf": {"rego": "in", "type_hint": "array/set"}
    }
    
    analysis = operator_map.get(operator, {"rego": "==", "type_hint": "unknown"})
    
    return {
        "operator": operator,
        "rego": analysis["rego"],
        "type_hint": analysis["type_hint"]
    }


@tool
def analyze_rightOperand(right_operand: str) -> Dict[str, Any]:
    """Infer data type from rightOperand value."""
    result = _analyze_actual_value(right_operand)
    return result


@tool
def suggest_rego_pattern(constraint: str) -> Dict[str, Any]:
    """Legacy tool - redirects to enhanced version"""
    return generate_rego_pattern_from_constraint(constraint)


@tool
def check_rego_syntax(rego_code: str) -> Dict[str, Any]:
    """Check Rego code for syntax compliance with Rego v1."""
    issues = []
    
    if "import rego.v1" not in rego_code:
        issues.append("Missing 'import rego.v1' statement")
    
    lines = rego_code.split('\n')
    for idx, line in enumerate(lines, 1):
        stripped = line.strip()
        if ':=' in stripped or ('=' in stripped and not stripped.startswith('default')):
            if '{' in stripped and 'if' not in stripped:
                if not any(x in stripped for x in ['package ', 'import ', 'default ']):
                    issues.append(f"Line {idx}: Missing 'if' keyword before rule body")
    
    return {
        "is_valid": len(issues) == 0,
        "issues": issues,
        "issue_count": len(issues)
    }


@tool
def fix_missing_if(rego_code: str) -> Dict[str, Any]:
    """Add missing 'if' keywords to Rego code."""
    lines = rego_code.split('\n')
    fixed_lines = []
    changes = []
    
    for idx, line in enumerate(lines, 1):
        stripped = line.strip()
        
        if ((':=' in stripped or '=' in stripped) and 
            '{' in stripped and 
            'if' not in stripped and
            not stripped.startswith('default ') and
            not stripped.startswith('package ') and
            not stripped.startswith('import ')):
            
            fixed_line = line.replace('{', 'if {')
            fixed_lines.append(fixed_line)
            changes.append(f"Line {idx}: Added 'if' keyword")
        else:
            fixed_lines.append(line)
    
    return {
        "corrected_code": '\n'.join(fixed_lines),
        "changes": changes,
        "change_count": len(changes)
    }


# Export all tools
__all__ = [
    "extract_policy_metadata",
    "extract_permissions",
    "extract_prohibitions",
    "extract_permissions_with_values",
    "extract_prohibitions_with_values",
    "extract_all_constraint_values",
    "generate_rego_pattern_from_constraint",
    "generate_complete_rego_rule",
    "extract_constraints",
    "analyze_rdfs_comments",
    "analyze_operator",
    "analyze_rightOperand",
    "suggest_rego_pattern",
    "check_rego_syntax",
    "fix_missing_if"
]
