import { Node, Edge, Position } from 'reactflow';
import { CustomNode, CustomEdge } from '@/types/lineage';

interface LayoutConfig {
  countrySpacing: number;
  databaseSpacing: number;
  attributeSpacing: number;
  levelSpacing: number;
}

const defaultLayout: LayoutConfig = {
  countrySpacing: 400,
  databaseSpacing: 250,
  attributeSpacing: 180,
  levelSpacing: 200,
};

/**
 * Calculate hierarchical layout for lineage graph
 */
export const calculateHierarchicalLayout = (
  nodes: CustomNode[],
  edges: CustomEdge[],
  config: LayoutConfig = defaultLayout
): CustomNode[] => {
  const { countrySpacing, databaseSpacing, attributeSpacing, levelSpacing } = config;

  // Group nodes by type and hierarchy
  const countries = nodes.filter((n) => n.data.nodeType === 'country');
  const databases = nodes.filter((n) => n.data.nodeType === 'database');
  const attributes = nodes.filter((n) => n.data.nodeType === 'attribute');

  // Position countries horizontally at top level
  const positionedCountries = countries.map((country, index) => ({
    ...country,
    position: { x: index * countrySpacing, y: 0 },
    sourcePosition: Position.Bottom,
    targetPosition: Position.Top,
  }));

  // Create a map for quick lookup
  const nodeMap = new Map<string, CustomNode>();
  positionedCountries.forEach((n) => nodeMap.set(n.id, n));

  // Position databases under their parent countries
  databases.forEach((db) => {
    const parentCountry = positionedCountries.find((c) => c.id === db.data.parent_id);
    if (parentCountry) {
      const siblingDbs = databases.filter((d) => d.data.parent_id === db.data.parent_id);
      const dbIndex = siblingDbs.findIndex((d) => d.id === db.id);
      const totalSiblings = siblingDbs.length;
      const offsetX = (dbIndex - (totalSiblings - 1) / 2) * databaseSpacing;

      const positionedDb = {
        ...db,
        position: {
          x: parentCountry.position.x + offsetX,
          y: levelSpacing,
        },
        sourcePosition: Position.Bottom,
        targetPosition: Position.Top,
        hidden: db.data.is_collapsed,
      };
      nodeMap.set(db.id, positionedDb);
    }
  });

  // Position attributes under their parent databases
  attributes.forEach((attr) => {
    const parentDb = Array.from(nodeMap.values()).find((n) => n.id === attr.data.parent_id);
    if (parentDb) {
      const siblingAttrs = attributes.filter((a) => a.data.parent_id === attr.data.parent_id);
      const attrIndex = siblingAttrs.findIndex((a) => a.id === attr.id);
      const totalSiblings = siblingAttrs.length;
      const offsetX = (attrIndex - (totalSiblings - 1) / 2) * attributeSpacing;

      const positionedAttr = {
        ...attr,
        position: {
          x: parentDb.position.x + offsetX,
          y: levelSpacing * 2,
        },
        sourcePosition: Position.Bottom,
        targetPosition: Position.Top,
        hidden: attr.data.is_collapsed || parentDb.hidden,
      };
      nodeMap.set(attr.id, positionedAttr);
    }
  });

  return Array.from(nodeMap.values());
};

/**
 * Filter edges based on visible nodes
 */
export const filterVisibleEdges = (
  edges: CustomEdge[],
  nodes: CustomNode[]
): CustomEdge[] => {
  const visibleNodeIds = new Set(
    nodes.filter((n) => !n.hidden).map((n) => n.id)
  );

  return edges.map((edge) => ({
    ...edge,
    hidden: !visibleNodeIds.has(edge.source) || !visibleNodeIds.has(edge.target),
  }));
};

/**
 * Get node dimensions based on type
 */
export const getNodeDimensions = (
  nodeType: 'country' | 'database' | 'attribute'
): { width: number; height: number } => {
  switch (nodeType) {
    case 'country':
      return { width: 200, height: 80 };
    case 'database':
      return { width: 180, height: 70 };
    case 'attribute':
      return { width: 160, height: 60 };
    default:
      return { width: 150, height: 50 };
  }
};
