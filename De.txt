"""
Enhanced Legal Summary Generator - COMPLETE VERSION
Generates grammatically correct documents with proper sentences
"""

from typing import Dict, List, Any, Optional
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.style import WD_STYLE_TYPE
from datetime import datetime
import os
import re


class LegalSummaryGenerator:
    """Generates Word documents with grammatically correct content"""
    
    def __init__(self, output_dir: str = "output/legal_summaries"):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    def _ensure_proper_sentence(self, text: str) -> str:
        """Ensure text is a proper sentence"""
        if not text or len(text) < 3:
            return text
        
        # Remove any trailing/leading whitespace
        text = text.strip()
        
        # Capitalize first letter
        if text and text[0].islower():
            text = text[0].upper() + text[1:]
        
        # Ensure ends with period if not ending with punctuation
        if text and text[-1] not in '.!?':
            text += '.'
        
        return text
    
    def _format_as_paragraph(self, text: str) -> str:
        """Format text as grammatically correct paragraph"""
        if not text:
            return ""
        
        # Split into sentences
        sentences = re.split(r'(?<=[.!?])\s+', text)
        
        # Clean each sentence
        clean_sentences = []
        for sentence in sentences:
            sentence = sentence.strip()
            if sentence:
                sentence = self._ensure_proper_sentence(sentence)
                clean_sentences.append(sentence)
        
        # Join with proper spacing
        return " ".join(clean_sentences)
    
    def create_document(self, analysis: Dict[str, Any]) -> Document:
        """Create formatted Word document"""
        doc = Document()
        self._setup_styles(doc)
        
        self._add_title(doc, analysis)
        self._add_metadata(doc, analysis)
        self._add_classification(doc, analysis)
        self._add_description(doc, analysis)
        self._add_knowledge_graph_insights(doc, analysis)
        self._add_reasoning_summary(doc, analysis)
        self._add_citations_section(doc, analysis)
        self._add_data_actions_section(doc, analysis)
        self._add_evidence_section(doc, analysis)
        self._add_constraints_section(doc, analysis)
        self._add_enterprise_policies_section(doc, analysis)
        self._add_footer(doc, analysis)
        
        return doc
    
    def _setup_styles(self, doc: Document):
        """Setup document styles"""
        styles = doc.styles
        
        if 'CustomTitle' not in styles:
            title_style = styles.add_style('CustomTitle', WD_STYLE_TYPE.PARAGRAPH)
            title_style.font.name = 'Calibri'
            title_style.font.size = Pt(24)
            title_style.font.bold = True
            title_style.font.color.rgb = RGBColor(0, 51, 102)
        
        for level, size, color in [
            (1, 16, RGBColor(0, 51, 102)),
            (2, 14, RGBColor(0, 102, 204)),
            (3, 12, RGBColor(0, 102, 204))
        ]:
            heading = styles[f'Heading {level}']
            heading.font.name = 'Calibri'
            heading.font.size = Pt(size)
            heading.font.color.rgb = color
        
        normal = styles['Normal']
        normal.font.name = 'Calibri'
        normal.font.size = Pt(11)
    
    def _add_title(self, doc: Document, analysis: Dict[str, Any]):
        """Add title"""
        metadata = analysis.get("metadata", {})
        rule_name = metadata.get("rule_name", "Legal Rule Analysis")
        
        title = doc.add_paragraph(rule_name, style='CustomTitle')
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        jurisdiction = metadata.get("jurisdiction", "General")
        subtitle = doc.add_paragraph(f"Jurisdiction: {jurisdiction}")
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle.runs[0].font.size = Pt(12)
        subtitle.runs[0].font.italic = True
        subtitle.runs[0].font.color.rgb = RGBColor(80, 80, 80)
        
        doc.add_paragraph()
    
    def _add_metadata(self, doc: Document, analysis: Dict[str, Any]):
        """Add metadata table"""
        metadata = analysis.get("metadata", {})
        
        table = doc.add_table(rows=0, cols=2)
        table.style = 'Light Grid Accent 1'
        
        def add_row(label: str, value: str):
            row = table.add_row()
            row.cells[0].text = label
            row.cells[1].text = value
            row.cells[0].paragraphs[0].runs[0].font.bold = True
        
        add_row("Rule Name", metadata.get("rule_name", "N/A"))
        add_row("Jurisdiction", metadata.get("jurisdiction", "N/A"))
        add_row("Analysis Date", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        add_row("Analysis Method", "FalkorDB Graph RAG + LangGraph Workflows + Advanced Embeddings")
        
        total_chunks = (metadata.get("level_1_chunks", 0) +
                       metadata.get("level_2_chunks", 0) +
                       metadata.get("level_3_chunks", 0))
        add_row("Chunks Processed", str(total_chunks))
        
        add_row("Total Citations", str(metadata.get("total_citations", 0)))
        add_row("Total Actions", str(metadata.get("total_actions", 0)))
        
        kg_stats = metadata.get("kg_stats", {})
        if kg_stats:
            if isinstance(kg_stats, dict):
                total_nodes = sum(v for v in kg_stats.values() if isinstance(v, int))
                add_row("Knowledge Graph Nodes", str(total_nodes))
        
        enterprise_context = metadata.get("enterprise_context", {})
        if enterprise_context:
            if enterprise_context.get("organization"):
                add_row("Organization", enterprise_context["organization"])
            if enterprise_context.get("internal_tools"):
                tools = enterprise_context["internal_tools"]
                tools_str = ", ".join(tools)
                add_row("Internal Tools", tools_str)
                
                # Special note for DataVisa
                if "DataVisa" in tools:
                    add_row("DataVisa", "Data Governance Tool")
        
        doc.add_paragraph()
    
    def _add_classification(self, doc: Document, analysis: Dict[str, Any]):
        """Add classification section"""
        doc.add_heading("Rule Classification", level=1)
        
        classification = analysis.get("classification", "condition")
        
        para = doc.add_paragraph()
        para.add_run("Classification: ").bold = True
        
        class_run = para.add_run(classification.upper())
        class_run.bold = True
        class_run.font.size = Pt(14)
        
        if classification == "condition":
            class_run.font.color.rgb = RGBColor(0, 128, 0)
            explanation = doc.add_paragraph()
            explanation.add_run("This rule describes actions that are permitted under specific conditions. ")
            explanation.add_run("Compliance requires meeting the stated conditions.")
        else:
            class_run.font.color.rgb = RGBColor(178, 34, 34)
            explanation = doc.add_paragraph()
            explanation.add_run("This rule describes actions that are prohibited or heavily restricted. ")
            explanation.add_run("Compliance requires avoiding these actions or seeking explicit permission.")
        
        reasoning = analysis.get("classification_reasoning", "")
        if reasoning:
            doc.add_paragraph()
            reasoning_formatted = self._format_as_paragraph(reasoning)
            para = doc.add_paragraph()
            para.add_run("Reasoning: ").bold = True
            para.add_run(reasoning_formatted).italic = True
        
        doc.add_paragraph()
    
    def _add_description(self, doc: Document, analysis: Dict[str, Any]):
        """Add description with proper grammar"""
        doc.add_heading("Description of the Rule", level=1)
        
        description = analysis.get("description", "")
        
        if not description:
            doc.add_paragraph("No description was extracted from the source documents.")
            doc.add_paragraph()
            return
        
        # Format as proper paragraph
        description_formatted = self._format_as_paragraph(description)
        
        # Split into multiple paragraphs for readability (every 3-4 sentences)
        sentences = re.split(r'(?<=[.!?])\s+', description_formatted)
        
        current_para = []
        for i, sentence in enumerate(sentences):
            current_para.append(sentence)
            
            # Start new paragraph every 3 sentences or at end
            if (i + 1) % 3 == 0 or i == len(sentences) - 1:
                para_text = " ".join(current_para)
                doc.add_paragraph(para_text, style='Normal')
                current_para = []
        
        doc.add_paragraph()
    
    def _add_knowledge_graph_insights(self, doc: Document, analysis: Dict[str, Any]):
        """Add knowledge graph section"""
        kg_stats = analysis.get("metadata", {}).get("kg_stats", {})
        
        if not kg_stats or not isinstance(kg_stats, dict):
            return
        
        doc.add_heading("Knowledge Graph Analysis", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("This analysis utilized a semantic knowledge graph to capture and reason about ")
        intro.add_run("the relationships between requirements, actions, evidence, and constraints. ")
        intro.add_run("The knowledge graph enables sophisticated reasoning about legal compliance requirements ")
        intro.add_run("and their interconnections.")
        intro.italic = True
        
        doc.add_paragraph()
        
        table = doc.add_table(rows=0, cols=2)
        table.style = 'Light Grid Accent 1'
        
        def add_row(label: str, value: str):
            row = table.add_row()
            row.cells[0].text = label
            row.cells[1].text = value
            row.cells[0].paragraphs[0].runs[0].font.bold = True
        
        # Add statistics
        for key, value in kg_stats.items():
            if isinstance(value, int):
                label = key.replace('_', ' ').title()
                add_row(label, str(value))
        
        doc.add_paragraph()
    
    def _add_reasoning_summary(self, doc: Document, analysis: Dict[str, Any]):
        """Add reasoning methodology"""
        doc.add_heading("Analysis Methodology", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("This analysis employed multiple advanced artificial intelligence reasoning techniques ")
        intro.add_run("to ensure comprehensive extraction and accurate interpretation of legal requirements. ")
        intro.add_run("The following methodologies were applied:")
        intro.bold = True
        
        doc.add_paragraph()
        
        techniques = [
            ("Chain of Thought Reasoning", 
             "The system analyzed the legal text through systematic step-by-step logical reasoning, "
             "explicitly articulating each inference and ensuring traceability from text to conclusion."),
            
            ("Mixture of Experts Analysis",
             "Multiple specialized analytical perspectives were applied, including legal expert analysis, "
             "data privacy specialist review, technical architecture assessment, and compliance officer evaluation. "
             "This multi-faceted approach ensures comprehensive coverage of all relevant aspects."),
            
            ("Tree of Thought Exploration",
             "Alternative interpretations were systematically explored, considering conservative, balanced, "
             "and expansive readings of the requirements. The most appropriate interpretation was selected "
             "based on legal principles and practical considerations."),
            
            ("Knowledge Graph Integration",
             "All extracted information was integrated into a semantic knowledge graph using FalkorDB, "
             "enabling sophisticated reasoning about relationships between requirements, identification of "
             "dependencies, and detection of potential conflicts or gaps."),
            
            ("Semantic Embeddings",
             "Advanced text embeddings using OpenAI's text-embedding-3-large model enabled semantic similarity "
             "matching and retrieval of related requirements across the document corpus.")
        ]
        
        for technique, description in techniques:
            para = doc.add_paragraph(style='List Bullet')
            para.add_run(f"{technique}: ").bold = True
            para.add_run(self._format_as_paragraph(description))
        
        doc.add_paragraph()
    
    def _add_citations_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add citations with proper sentences"""
        doc.add_heading("Citations and References", level=1)
        
        citations = analysis.get("citations", [])
        
        if not citations:
            doc.add_paragraph("No specific citations were extracted from the source documents.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run(f"This analysis is supported by {len(citations)} citations ")
        intro.add_run("extracted from the source documents. ")
        intro.add_run("Each citation provides the exact text from the source and explains ")
        intro.add_run("how it supports the analysis.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by level
        by_level = {1: [], 2: [], 3: []}
        for cite in citations:
            level = cite.get("level", 1)
            by_level[level].append(cite)
        
        level_names = {
            1: "Primary Legislation",
            2: "Regulatory Guidance and Interpretation",
            3: "Enterprise-Specific Policies and Implementation"
        }
        
        for level in [1, 2, 3]:
            level_cites = by_level[level]
            if not level_cites:
                continue
            
            doc.add_heading(f"Level {level}: {level_names[level]}", level=2)
            
            for i, cite in enumerate(level_cites, 1):
                para = doc.add_paragraph()
                
                # Citation number
                para.add_run(f"[{i}] ").bold = True
                
                # Text excerpt
                text = cite.get("text", "")[:400]
                if len(cite.get("text", "")) > 400:
                    text += "..."
                para.add_run(f'"{text}"')
                
                # Reasoning
                reasoning = cite.get("reasoning", "")
                if reasoning:
                    reasoning_formatted = self._format_as_paragraph(reasoning)
                    sub_para = doc.add_paragraph(style='List Bullet 2')
                    sub_para.add_run("Relevance: ").italic = True
                    sub_para.add_run(reasoning_formatted)
                    sub_para.runs[-1].font.size = Pt(10)
                
                # Method
                method = cite.get("method", "")
                if method:
                    method_para = doc.add_paragraph(style='List Bullet 2')
                    method_para.add_run(f"Extracted via: {method.replace('_', ' ').title()}")
                    method_para.runs[0].font.size = Pt(9)
                    method_para.runs[0].font.color.rgb = RGBColor(100, 100, 100)
        
        doc.add_paragraph()
    
    def _add_data_actions_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add data actions with proper sentences"""
        doc.add_heading("Data Actions Required", level=1)
        
        data_actions = analysis.get("data_actions", [])
        
        if not data_actions:
            doc.add_paragraph("No specific data actions were identified in this analysis.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("The following data operations are regulated by this rule. ")
        intro.add_run("Each action describes a specific operation that must be controlled ")
        intro.add_run("or managed according to the requirements.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by type
        by_type = {
            "data_sharing_and_access": [],
            "data_storage_and_hosting": [],
            "data_usage": []
        }
        
        for action in data_actions:
            action_type = action.get("type", "data_usage")
            by_type[action_type].append(action)
        
        categories = {
            "data_sharing_and_access": ("Data Sharing and Access Operations", "ðŸ“¤"),
            "data_storage_and_hosting": ("Data Storage and Hosting Operations", "ðŸ’¾"),
            "data_usage": ("Data Usage and Processing Operations", "âš™ï¸")
        }
        
        for action_type, (category_name, emoji) in categories.items():
            actions = by_type[action_type]
            if not actions:
                continue
            
            doc.add_heading(f"{emoji} {category_name}", level=2)
            
            category_intro = doc.add_paragraph()
            if action_type == "data_sharing_and_access":
                category_intro.add_run("These actions involve sharing data with third parties, ")
                category_intro.add_run("transferring data across boundaries, or providing access to data.")
            elif action_type == "data_storage_and_hosting":
                category_intro.add_run("These actions involve storing data in repositories, ")
                category_intro.add_run("hosting data on systems, or maintaining data over time.")
            else:
                category_intro.add_run("These actions involve using data for specific purposes, ")
                category_intro.add_run("processing data, or collecting data from sources.")
            category_intro.italic = True
            category_intro.runs[0].font.size = Pt(10)
            
            doc.add_paragraph()
            
            for i, action in enumerate(actions, 1):
                # Description as proper sentence
                desc = action.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                # Actor
                actor = action.get("actor", "")
                if actor:
                    actor_para = doc.add_paragraph(style='List Bullet 2')
                    if actor == "user":
                        actor_para.add_run("This action must be performed by individual users.")
                    else:
                        actor_para.add_run("This action must be implemented by the system.")
                    actor_para.runs[0].font.size = Pt(10)
                    actor_para.runs[0].font.italic = True
                
                # Citations
                citations = action.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Supporting evidence: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:150]
                    cite_para.add_run(f'"{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        
        doc.add_paragraph()
    
    def _add_evidence_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add evidence with proper sentences"""
        doc.add_heading("Evidence and Requirements", level=1)
        
        user_evidence = analysis.get("user_evidence", [])
        system_evidence = analysis.get("system_evidence", [])
        
        if not user_evidence and not system_evidence:
            doc.add_paragraph("No specific evidence requirements were identified.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("This section describes the requirements from two perspectives: ")
        intro.add_run("what individual users must do to comply, ")
        intro.add_run("and what technical systems must implement.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # User perspective
        doc.add_heading("ðŸ‘¤ User Perspective", level=2)
        
        user_intro = doc.add_paragraph()
        user_intro.add_run("The following requirements describe actions that individual users ")
        user_intro.add_run("must take, permissions they must obtain, or restrictions they must observe.")
        user_intro.italic = True
        user_intro.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
        
        if user_evidence:
            for i, evidence in enumerate(user_evidence, 1):
                desc = evidence.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                citations = evidence.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Basis in source: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:200]
                    cite_para.add_run(f'"{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        else:
            doc.add_paragraph("No user-specific requirements were identified.")
        
        doc.add_paragraph()
        
        # System perspective
        doc.add_heading("ðŸ–¥ï¸ System Perspective", level=2)
        
        system_intro = doc.add_paragraph()
        system_intro.add_run("The following requirements describe technical controls, ")
        system_intro.add_run("system configurations, or automated processes that must be implemented.")
        system_intro.italic = True
        system_intro.runs[0].font.size = Pt(10)
        
        doc.add_paragraph()
        
        if system_evidence:
            for i, evidence in enumerate(system_evidence, 1):
                desc = evidence.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                citations = evidence.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Basis in source: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:200]
                    cite_para.add_run(f'"{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        else:
            doc.add_paragraph("No system-specific requirements were identified.")
        
        doc.add_paragraph()
    
    def _add_constraints_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add constraints with proper sentences"""
        doc.add_heading("Constraints and Conditions", level=1)
        
        constraints = analysis.get("constraints", [])
        
        if not constraints:
            doc.add_paragraph("No specific constraints or conditions were identified.")
            doc.add_paragraph()
            return
        
        intro = doc.add_paragraph()
        intro.add_run("The following constraints and conditions apply to this rule. ")
        intro.add_run("These define the boundaries within which the rule operates ")
        intro.add_run("and the specific conditions that must be met.")
        intro.italic = True
        
        doc.add_paragraph()
        
        # Group by type
        by_type = {}
        for constraint in constraints:
            ctype = constraint.get("type", "general")
            if ctype not in by_type:
                by_type[ctype] = []
            by_type[ctype].append(constraint)
        
        type_info = {
            "temporal": ("â°", "Temporal Constraints", "These constraints relate to time periods, deadlines, or durations."),
            "spatial": ("ðŸŒ", "Spatial Constraints", "These constraints relate to geographic locations or jurisdictions."),
            "technical": ("ðŸ”§", "Technical Constraints", "These constraints relate to technical specifications or system requirements."),
            "procedural": ("ðŸ“‹", "Procedural Constraints", "These constraints relate to processes or procedures that must be followed."),
            "purpose": ("ðŸŽ¯", "Purpose Constraints", "These constraints relate to the purposes for which actions may be taken."),
            "general": ("ðŸ“Œ", "General Constraints", "These are general constraints that apply to the rule.")
        }
        
        for ctype, constraints_list in by_type.items():
            emoji, title, description = type_info.get(ctype, ("ðŸ“Œ", ctype.title(), ""))
            
            doc.add_heading(f"{emoji} {title}", level=2)
            
            if description:
                type_intro = doc.add_paragraph(description)
                type_intro.italic = True
                type_intro.runs[0].font.size = Pt(10)
                doc.add_paragraph()
            
            for i, constraint in enumerate(constraints_list, 1):
                desc = constraint.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. ").bold = True
                para.add_run(desc_formatted)
                
                # Operator details
                operator = constraint.get("operator", "")
                value = constraint.get("right_operand", "")
                if operator and value:
                    op_para = doc.add_paragraph(style='List Bullet 2')
                    op_para.add_run(f"Constraint operator: {operator}, value: {value}")
                    op_para.runs[0].font.size = Pt(9)
                    op_para.runs[0].font.color.rgb = RGBColor(100, 100, 100)
                
                # Citations
                citations = constraint.get("citations", [])
                if citations and len(citations) > 0:
                    cite_para = doc.add_paragraph(style='List Bullet 2')
                    cite_para.add_run("Source reference: ").italic = True
                    cite_para.runs[0].font.size = Pt(9)
                    
                    cite_text = citations[0].get("text", "")[:150]
                    cite_para.add_run(f'"{cite_text}..."')
                    cite_para.runs[-1].font.size = Pt(9)
        
        doc.add_paragraph()
    
    def _add_enterprise_policies_section(self, doc: Document, analysis: Dict[str, Any]):
        """Add enterprise policies"""
        enterprise_policies = analysis.get("enterprise_policies", [])
        metadata = analysis.get("metadata", {})
        enterprise_context = metadata.get("enterprise_context", {})
        
        if not enterprise_context and not enterprise_policies:
            return
        
        doc.add_heading("ðŸ¢ Enterprise-Specific Policies", level=1)
        
        intro = doc.add_paragraph()
        intro.add_run("The following information represents enterprise-specific implementation ")
        intro.add_run("of the legal requirements described above. ")
        intro.add_run("These policies show how the organization has operationalized ")
        intro.add_run("the legal obligations into concrete procedures and systems.")
        intro.italic = True
        
        doc.add_paragraph()
        
        if enterprise_context:
            if enterprise_context.get("organization"):
                para = doc.add_paragraph()
                para.add_run("Organization: ").bold = True
                para.add_run(enterprise_context["organization"])
            
            if enterprise_context.get("internal_tools"):
                tools = enterprise_context["internal_tools"]
                para = doc.add_paragraph()
                para.add_run("Internal Tools Referenced: ").bold = True
                para.add_run(", ".join(tools))
                
                # Special note for DataVisa
                if "DataVisa" in tools:
                    datavisa_para = doc.add_paragraph(style='List Bullet 2')
                    datavisa_para.add_run("DataVisa is the organization's internal data governance tool, ")
                    datavisa_para.add_run("used for managing data handling requests, approvals, and compliance tracking.")
                    datavisa_para.runs[0].font.size = Pt(10)
                    datavisa_para.runs[0].font.italic = True
            
            if enterprise_context.get("business_units"):
                para = doc.add_paragraph()
                para.add_run("Relevant Business Units: ").bold = True
                para.add_run(", ".join(enterprise_context["business_units"]))
            
            doc.add_paragraph()
        
        if enterprise_policies:
            doc.add_heading("Specific Enterprise Policies", level=2)
            
            for i, policy in enumerate(enterprise_policies, 1):
                policy_name = policy.get("policy_name", "")
                desc = policy.get("description", "")
                desc_formatted = self._ensure_proper_sentence(desc)
                
                para = doc.add_paragraph()
                para.add_run(f"{i}. {policy_name}: ").bold = True
                para.add_run(desc_formatted)
                
                applies_to = policy.get("applies_to", [])
                if applies_to:
                    applies_para = doc.add_paragraph(style='List Bullet 2')
                    applies_para.add_run("Applies to: ")
                    applies_para.add_run(", ".join(applies_to))
                    applies_para.runs[0].font.size = Pt(10)
                    applies_para.runs[0].font.italic = True
        
        doc.add_paragraph()
    
    def _add_footer(self, doc: Document, analysis: Dict[str, Any]):
        """Add footer"""
        doc.add_paragraph()
        doc.add_paragraph()
        
        disclaimer = doc.add_paragraph()
        disclaimer.add_run("âš ï¸ Disclaimer: ").bold = True
        disclaimer.add_run("This analysis was generated automatically using advanced artificial intelligence ")
        disclaimer.add_run("techniques including FalkorDB graph reasoning, LangGraph workflows, ")
        disclaimer.add_run("and semantic embeddings. ")
        disclaimer.add_run("While comprehensive measures were taken to ensure accuracy, ")
        disclaimer.add_run("this analysis should be reviewed by qualified legal professionals ")
        disclaimer.add_run("before being used for compliance purposes. ")
        disclaimer.add_run("The analysis is based on the documents provided ")
        disclaimer.add_run("and may require updates as regulations evolve.")
        disclaimer.runs[1].font.italic = True
        disclaimer.runs[1].font.size = Pt(9)
        disclaimer.runs[1].font.color.rgb = RGBColor(100, 100, 100)
        
        doc.add_paragraph()
        
        timestamp = doc.add_paragraph()
        timestamp.add_run(f"Document generated on {datetime.now().strftime('%Y-%m-%d at %H:%M:%S')} ")
        timestamp.add_run(f"using Enhanced Legal Analysis Pipeline v2.0 with FalkorDB")
        timestamp.alignment = WD_ALIGN_PARAGRAPH.CENTER
        timestamp.runs[0].font.size = Pt(9)
        timestamp.runs[0].font.color.rgb = RGBColor(150, 150, 150)
    
    def save_document(self, doc: Document, rule_name: str, 
                     jurisdiction: str, filename: Optional[str] = None) -> str:
        """Save document"""
        if filename is None:
            safe_rule_name = "".join(
                c if c.isalnum() or c in (' ', '_') else '_' 
                for c in rule_name
            ).replace(' ', '_')
            safe_jurisdiction = jurisdiction.replace(' ', '_')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_rule_name}_{safe_jurisdiction}_{timestamp}.docx"
        
        filepath = os.path.join(self.output_dir, filename)
        doc.save(filepath)
        return filepath
    
    def generate_legal_summary(self, analysis: Dict[str, Any],
                              filename: Optional[str] = None) -> str:
        """Generate complete legal summary"""
        doc = self.create_document(analysis)
        
        metadata = analysis.get("metadata", {})
        rule_name = metadata.get("rule_name", "Legal_Rule")
        jurisdiction = metadata.get("jurisdiction", "General")
        
        return self.save_document(doc, rule_name, jurisdiction, filename)
    
    def create_index_document(self, analyses: Dict[str, Dict[str, Any]],
                             output_filename: str = "Legal_Summaries_Index.docx") -> str:
        """Create index document"""
        doc = Document()
        self._setup_styles(doc)
        
        title = doc.add_paragraph("Legal Rules Summary Index", style='CustomTitle')
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        subtitle = doc.add_paragraph(
            f"Generated on {datetime.now().strftime('%Y-%m-%d')} using FalkorDB Enhanced Analysis"
        )
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        subtitle.runs[0].font.size = Pt(12)
        subtitle.runs[0].font.italic = True
        
        doc.add_paragraph()
        
        doc.add_heading("Summary Statistics", level=1)
        
        total_rules = len(analyses)
        para = doc.add_paragraph()
        para.add_run(f"This index covers {total_rules} legal rules that were analyzed ")
        para.add_run("using advanced artificial intelligence techniques including ")
        para.add_run("FalkorDB graph reasoning, semantic embeddings, and LangGraph workflows.")
        
        doc.add_paragraph()
        
        # Classification counts
        classification_counts = {}
        for analysis in analyses.values():
            classification = analysis.get("classification", "unknown")
            classification_counts[classification] = classification_counts.get(classification, 0) + 1
        
        if classification_counts:
            doc.add_paragraph("Rules by Classification:")
            for classification, count in classification_counts.items():
                para = doc.add_paragraph(style='List Bullet')
                para.add_run(f"{classification.title()}: {count} rules")
        
        doc.add_paragraph()
        
        doc.add_heading("Rules Analyzed", level=1)
        
        table = doc.add_table(rows=1, cols=5)
        table.style = 'Light Grid Accent 1'
        
        headers = table.rows[0].cells
        headers[0].text = "Rule Name"
        headers[1].text = "Jurisdiction"
        headers[2].text = "Classification"
        headers[3].text = "Actions"
        headers[4].text = "Evidence"
        
        for cell in headers:
            cell.paragraphs[0].runs[0].font.bold = True
        
        for rule_name, analysis in analyses.items():
            metadata = analysis.get("metadata", {})
            row = table.add_row()
            
            row.cells[0].text = rule_name
            row.cells[1].text = metadata.get("jurisdiction", "N/A")
            row.cells[2].text = analysis.get("classification", "N/A").title()
            row.cells[3].text = str(len(analysis.get("data_actions", [])))
            
            evidence_count = (len(analysis.get("user_evidence", [])) +
                            len(analysis.get("system_evidence", [])))
            row.cells[4].text = str(evidence_count)
        
        filepath = os.path.join(self.output_dir, output_filename)
        doc.save(filepath)
        return filepath
