import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from typing import List, Dict
import io

def load_excel_file(uploaded_file) -> pd.DataFrame:
    """Load an Excel file and return as DataFrame."""
    try:
        # Display file details for debugging
        st.write(f"Loading file: {uploaded_file.name}")
        st.write(f"File type: {uploaded_file.type}")
        st.write(f"File size: {uploaded_file.size} bytes")
        
        # Read the Excel file
        df = pd.read_excel(uploaded_file)
        
        # Display basic DataFrame info
        st.write(f"Columns found: {list(df.columns)}")
        st.write(f"Number of rows: {len(df)}")
        
        return df
    except Exception as e:
        st.error(f"Error in load_excel_file: {str(e)}")
        return None

def get_common_columns(dataframes: List[pd.DataFrame]) -> List[str]:
    """Find common columns across all DataFrames."""
    try:
        if not dataframes:
            return []
        common_cols = set(dataframes[0].columns)
        for df in dataframes[1:]:
            common_cols = common_cols.intersection(df.columns)
        return list(common_cols)
    except Exception as e:
        st.error(f"Error in get_common_columns: {str(e)}")
        return []

def merge_dataframes(dataframes: List[pd.DataFrame], keys: List[str], how: str = 'left') -> pd.DataFrame:
    """Merge multiple DataFrames based on selected keys."""
    try:
        if not dataframes:
            return pd.DataFrame()
        
        # Display merge operation details
        st.write("Merging DataFrames:")
        for i, df in enumerate(dataframes):
            st.write(f"DataFrame {i+1} shape: {df.shape}")
        
        result = dataframes[0]
        for i, df in enumerate(dataframes[1:], 1):
            result = result.merge(df, on=keys, how=how, suffixes=(f'_{i-1}', f'_{i}'))
            st.write(f"Merged result shape after step {i}: {result.shape}")
        
        return result
    except Exception as e:
        st.error(f"Error in merge_dataframes: {str(e)}")
        return pd.DataFrame()

def create_pivot_table(df: pd.DataFrame, index: List[str], values: List[str], 
                      aggfuncs: List[str], filters: Dict = None) -> pd.DataFrame:
    """Create a pivot table based on selected columns and aggregation functions."""
    try:
        # Validate input DataFrame
        if df is None or df.empty:
            st.error("No data available for pivot table creation")
            return pd.DataFrame()

        # Validate that all required columns exist
        missing_cols = []
        for col in index + values:
            if col not in df.columns:
                missing_cols.append(col)
        
        if missing_cols:
            st.error(f"Missing columns in data: {', '.join(missing_cols)}")
            return pd.DataFrame()

        # Apply filters if any
        filtered_df = df.copy()
        if filters:
            for col, val in filters.items():
                if val and col in filtered_df.columns:
                    filtered_df = filtered_df[filtered_df[col].isin(val)]

        # Validate filtered data
        if filtered_df.empty:
            st.warning("No data matches the selected filters")
            return pd.DataFrame()

        # Create pivot table with error handling for each parameter
        st.write("Creating pivot table with:")
        st.write(f"- Index columns: {index}")
        st.write(f"- Value columns: {values}")
        st.write(f"- Selected aggregation functions: {aggfuncs}")
        
        # Add import for numpy if not already present
        import numpy as np
        
        # Dynamically determine available aggregations based on column type
        def get_available_aggregations(column_series, selected_aggs):
            dtype = column_series.dtype
            is_numeric = np.issubdtype(dtype, np.number)
            
            available_aggs = []
            for agg in selected_aggs:
                # These aggregations work for all data types
                if agg == 'distinct_count':
                    available_aggs.append(('unique_count', lambda x: len(x.unique())))
                elif agg == 'count':
                    available_aggs.append(('count', 'count'))
                # These aggregations only work for numeric data
                elif is_numeric and agg in ['sum', 'mean', 'max', 'min']:
                    available_aggs.append((agg, agg))
            return available_aggs
        
        # Create aggregation dictionary based on column types
        agg_dict = {}
        for value in values:
            available_aggs = get_available_aggregations(filtered_df[value], aggfuncs)
            if available_aggs:
                agg_dict[value] = [agg[1] for agg in available_aggs]
                st.write(f"Column '{value}' will use aggregations: {[agg[0] for agg in available_aggs]}")
        
        # Prepare aggregation functions based on column data types
        agg_dict = {}
        for value in values:
            col_dtype = filtered_df[value].dtype
            is_numeric = np.issubdtype(col_dtype, np.number)
            
            # Get available aggregation functions for this column
            available_aggs = []
            for agg in aggfuncs:
                if agg == 'distinct_count':
                    available_aggs.append(('unique_count', lambda x: len(x.unique())))
                elif agg == 'count':
                    available_aggs.append(('count', 'count'))
                elif is_numeric:  # Only add numeric aggregations for numeric columns
                    if agg in ['sum', 'mean', 'max', 'min']:
                        available_aggs.append((agg, agg))
                
            if available_aggs:
                agg_dict[value] = [agg[1] for agg in available_aggs]
                
            # Log the aggregations being applied
            st.write(f"Column '{value}' ({col_dtype}) will use aggregations: {[agg[0] for agg in available_aggs]}")

        # Create pivot table with proper column handling
        pivot = pd.pivot_table(
            filtered_df,
            index=index,
            values=values,
            aggfunc=agg_dict,
            fill_value=0,
            margins=True,  # Add totals
            margins_name='Total'
        ).round(2)  # Round numeric values to 2 decimal places
        
        # Fix column names to prevent duplicates
        if isinstance(pivot.columns, pd.MultiIndex):
            # For multi-level columns, create meaningful names
            pivot.columns = [f"{col[0]} ({col[1].capitalize()})" for col in pivot.columns]
        else:
            # For single-level columns, add aggregation type
            pivot.columns = [f"{col} ({list(agg_dict[col])[0].capitalize()})" for col in pivot.columns]
        
        return pivot
        
        return pivot
    except Exception as e:
        st.error(f"Error in create_pivot_table: {str(e)}")
        st.write("Debugging information:")
        st.write(f"DataFrame shape: {df.shape if df is not None else 'None'}")
        st.write(f"DataFrame columns: {df.columns.tolist() if df is not None else 'None'}")
        return pd.DataFrame()

def main():
    st.set_page_config(layout="wide")  # Use wide layout for better visibility
    
    st.title("Excel File Merger and Analysis Dashboard")
    st.write("Upload multiple Excel files, merge them, and create dynamic pivot tables")

    # Add a sidebar for file upload and basic settings
    with st.sidebar:
        st.header("File Upload")
        uploaded_files = st.file_uploader("Upload Excel files", 
                                        type=['xlsx', 'xls'], 
                                        accept_multiple_files=True)

    # Main content area
    if not uploaded_files:
        st.warning("Please upload at least one Excel file to begin.")
        st.stop()

    # Initialize session state if not already done
    if 'dataframes' not in st.session_state:
        st.session_state.dataframes = []

    # Load DataFrames
    st.header("Uploaded Files")
    dataframes = []
    
    # Create columns for file information
    cols = st.columns(len(uploaded_files))
    
    for idx, file in enumerate(uploaded_files):
        with cols[idx]:
            st.subheader(f"File {idx + 1}")
            df = load_excel_file(file)
            if df is not None:
                dataframes.append(df)
                st.success(f"✓ {file.name} loaded")
                st.write("Preview:")
                st.dataframe(df.head(), height=150)
            else:
                st.error(f"× Failed to load {file.name}")

    if not dataframes:
        st.error("No valid DataFrames loaded. Please check your files.")
        st.stop()

    # Store dataframes in session state
    st.session_state.dataframes = dataframes

    # Get common columns
    common_columns = get_common_columns(dataframes)
    
    if not common_columns:
        st.error("No common columns found between the uploaded files!")
        st.write("Columns in each file:")
        for idx, df in enumerate(dataframes):
            st.write(f"File {idx + 1}: {list(df.columns)}")
        st.stop()

    # Merge settings
    st.header("Merge Settings")
    col1, col2 = st.columns(2)
    
    with col1:
        merge_keys = st.multiselect("Select columns to merge on:", 
                                   common_columns,
                                   help="Select one or more columns to use as merge keys")
    
    with col2:
        merge_type = st.selectbox("Select merge type:", 
                                 ['left', 'right', 'inner', 'outer'])

    if not merge_keys:
        st.warning("Please select at least one column to merge on.")
        st.stop()

    try:
        merged_df = merge_dataframes(dataframes, merge_keys, merge_type)
        
        if merged_df.empty:
            st.error("Merge resulted in an empty DataFrame. Please check your merge keys.")
            st.stop()
        
        st.success("Files merged successfully!")
        
        # Show merged data preview
        st.subheader("Merged Data Preview")
        st.dataframe(merged_df.head(), height=150)
        
        # Analysis section
        st.header("Create Pivot Tables")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            pivot_indices = st.multiselect("Select Index Columns:", 
                                         merged_df.columns)
        
        with col2:
            # Allow selection of all columns for aggregation
            pivot_values = st.multiselect("Select Values to Aggregate:", 
                                        merged_df.columns,
                                        help="Select any columns to aggregate - numeric columns support all operations, text columns support count and distinct count")
        
        with col3:
            # Allow multiple aggregation functions
            agg_functions = st.multiselect("Select Aggregation Functions:",
                                         ['sum', 'mean', 'count', 'distinct_count', 'max', 'min'],
                                         help="You can select multiple aggregation functions")

        # Filters
        if pivot_indices:
            st.subheader("Filters")
            filter_cols = st.columns(len(pivot_indices))
            filters = {}
            
            for idx, col in enumerate(pivot_indices):
                with filter_cols[idx]:
                    unique_values = merged_df[col].unique()
                    selected_values = st.multiselect(f"Filter {col}:",
                                                   unique_values)
                    if selected_values:
                        filters[col] = selected_values

            if pivot_values and pivot_indices:
                # Validate selections before creating pivot table
                st.write("Validating selected columns...")
                
                # Check if selected columns exist in merged data
                all_selected_cols = set(pivot_indices + pivot_values)
                available_cols = set(merged_df.columns)
                missing_cols = all_selected_cols - available_cols
                
                if missing_cols:
                    st.error(f"Selected columns not found in merged data: {missing_cols}")
                else:
                    # Create pivot table
                    st.info("Creating pivot table with selected columns...")
                    if not agg_functions:
                        st.warning("Please select at least one aggregation function")
                    else:
                        pivot_table = create_pivot_table(merged_df,
                                                       pivot_indices,
                                                       pivot_values,
                                                       agg_functions,
                                                       filters)
                    
                    if not pivot_table.empty:
                    # Display pivot table
                    st.subheader("Pivot Table Results")
                    st.dataframe(pivot_table)
                    
                    # Create visualizations
                    st.subheader("Visualizations")
                    viz_col1, viz_col2 = st.columns(2)
                    
                    with viz_col1:
                        chart_type = st.selectbox("Select Chart Type:",
                                                ['Bar', 'Line', 'Scatter'])
                    
                    fig = None
                    if chart_type == 'Bar':
                        fig = px.bar(pivot_table.reset_index(),
                                   x=pivot_indices[0],
                                   y=pivot_values[0])
                    elif chart_type == 'Line':
                        fig = px.line(pivot_table.reset_index(),
                                    x=pivot_indices[0],
                                    y=pivot_values[0])
                    elif chart_type == 'Scatter':
                        fig = px.scatter(pivot_table.reset_index(),
                                       x=pivot_indices[0],
                                       y=pivot_values[0])
                    
                    if fig:
                        st.plotly_chart(fig, use_container_width=True)

                    # Download results
                    st.subheader("Download Results")
                    
                    output = io.BytesIO()
                    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                        pivot_table.to_excel(writer, sheet_name='Pivot Table')
                        merged_df.to_excel(writer, sheet_name='Merged Data')
                    
                    st.download_button(
                        label="Download Excel file",
                        data=output.getvalue(),
                        file_name="analysis_results.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    )

    except Exception as e:
        st.error(f"An error occurred during analysis: {str(e)}")
        st.write("Please check your data and try again.")

if __name__ == "__main__":
    main()
