# backend/app/core/research_engine.py
import asyncio
import logging
import sys
import os
from typing import Dict, Any, Optional
from datetime import datetime

# Add the parent directory to path to import the original chatbot
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from enhanced_chatbot import EnhancedChatbotInterface

logger = logging.getLogger(__name__)

class ResearchEngineWrapper:
    """
    Wrapper for the enhanced chatbot research engine
    Provides async interface and session management
    """
    
    def __init__(self):
        self.chatbot_interface = None
        self.is_initialized = False
        self._initialization_lock = asyncio.Lock()
    
    async def initialize(self):
        """Initialize the research engine"""
        async with self._initialization_lock:
            if self.is_initialized:
                return True
            
            try:
                logger.info("Initializing Enhanced Chatbot Research Engine...")
                self.chatbot_interface = EnhancedChatbotInterface()
                
                # Check if initialize method exists and call it
                if hasattr(self.chatbot_interface, 'initialize'):
                    success = await self.chatbot_interface.initialize()
                    if not success:
                        logger.error("❌ Research engine initialization returned False")
                        return False
                else:
                    logger.info("No initialize method found, assuming ready")
                
                self.is_initialized = True
                logger.info("✅ Research engine initialized successfully")
                return True
                    
            except Exception as e:
                logger.error(f"❌ Failed to initialize research engine: {e}")
                return False
    
    async def quick_chat(self, question: str, user_id: str, session_id: str) -> Dict[str, Any]:
        """
        Handle quick chat queries
        """
        if not self.is_initialized:
            await self.initialize()
        
        if self.chatbot_interface is None:
            logger.error("Chatbot interface is None")
            return {
                "answer": "Research engine not available",
                "confidence": "low",
                "approach": "error",
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "error": "Research engine not initialized"
            }
        
        try:
            logger.info(f"Processing quick chat: {question[:100]}...")
            
            # Check what method exists - try different possible method names
            result = None
            if hasattr(self.chatbot_interface, 'ask_question'):
                result = await self.chatbot_interface.ask_question(
                    question, 
                    user_id=user_id, 
                    thread_id=session_id
                )
            elif hasattr(self.chatbot_interface, 'chat'):
                result = await self.chatbot_interface.chat(question)
            elif hasattr(self.chatbot_interface, 'query'):
                result = await self.chatbot_interface.query(question)
            else:
                # Try the most basic approach
                logger.warning("No known chat method found, using fallback")
                result = {
                    "answer": "Chat method not available in current interface",
                    "confidence": "low",
                    "approach": "fallback"
                }
            
            # Ensure result is a dict
            if not isinstance(result, dict):
                result = {"answer": str(result), "confidence": "unknown", "approach": "basic"}
            
            # Enhance result with metadata
            enhanced_result = {
                **result,
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "query_type": "quick_chat",
                "processing_time": "fast"
            }
            
            logger.info(f"Quick chat completed with confidence: {result.get('confidence', 'unknown')}")
            return enhanced_result
            
        except Exception as e:
            logger.error(f"Error in quick chat: {e}")
            return {
                "answer": f"I encountered an error processing your question: {str(e)}",
                "confidence": "low",
                "approach": "error",
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e)
            }
    
    async def deep_research(self, topic: str, user_id: str, session_id: str, 
                          progress_callback=None) -> Dict[str, Any]:
        """
        Handle deep research queries with progress updates
        """
        if not self.is_initialized:
            await self.initialize()
        
        if self.chatbot_interface is None:
            logger.error("Chatbot interface is None")
            return {
                "final_synthesis": "Research engine not available",
                "overall_confidence": 0.0,
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "error": "Research engine not initialized"
            }
        
        try:
            logger.info(f"Starting deep research: {topic[:100]}...")
            
            if progress_callback:
                await progress_callback({
                    "stage": "initialization",
                    "message": "Initializing multi-agent research system...",
                    "progress": 0
                })
            
            # Progress tracking wrapper
            async def research_with_progress():
                if progress_callback:
                    await progress_callback({
                        "stage": "planning",
                        "message": "Creating research plan and assigning agents...",
                        "progress": 20
                    })
                
                # Check what research method exists
                result = None
                if hasattr(self.chatbot_interface, 'conduct_deep_research'):
                    result = await self.chatbot_interface.conduct_deep_research(
                        topic, 
                        user_id=user_id
                    )
                elif hasattr(self.chatbot_interface, 'research'):
                    result = await self.chatbot_interface.research(topic)
                elif hasattr(self.chatbot_interface, 'deep_research'):
                    result = await self.chatbot_interface.deep_research(topic)
                elif hasattr(self.chatbot_interface, 'ask_question'):
                    # Fallback to regular question with research prompt
                    research_prompt = f"Please conduct comprehensive research on: {topic}"
                    result = await self.chatbot_interface.ask_question(
                        research_prompt,
                        user_id=user_id,
                        thread_id=session_id
                    )
                    # Convert to expected format
                    if isinstance(result, dict) and 'answer' in result:
                        result = {
                            "final_synthesis": result['answer'],
                            "overall_confidence": 0.7,
                            "agents_used": ["general"],
                            "iterations_completed": 1
                        }
                else:
                    logger.warning("No research method found, using basic response")
                    result = {
                        "final_synthesis": f"Deep research capability not available. Topic: {topic}",
                        "overall_confidence": 0.1,
                        "agents_used": [],
                        "iterations_completed": 0
                    }
                
                if progress_callback:
                    await progress_callback({
                        "stage": "research",
                        "message": "Agents conducting specialized research...",
                        "progress": 60
                    })
                
                await asyncio.sleep(1)
                
                if progress_callback:
                    await progress_callback({
                        "stage": "synthesis",
                        "message": "Synthesizing findings and generating report...",
                        "progress": 80
                    })
                
                await asyncio.sleep(1)
                
                if progress_callback:
                    await progress_callback({
                        "stage": "completion",
                        "message": "Research completed successfully!",
                        "progress": 100
                    })
                
                return result
            
            result = await research_with_progress()
            
            # Ensure result is in expected format
            if not isinstance(result, dict):
                result = {"final_synthesis": str(result), "overall_confidence": 0.5}
            
            # Enhance result with metadata
            enhanced_result = {
                "final_synthesis": result.get("final_synthesis", "No synthesis available"),
                "overall_confidence": result.get("overall_confidence", 0.0),
                "agents_used": result.get("agents_used", []),
                "iterations_completed": result.get("iterations_completed", 0),
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "query_type": "deep_research",
                "processing_time": "extended",
                "metadata": result.get("metadata", {})
            }
            
            logger.info(f"Deep research completed with confidence: {enhanced_result['overall_confidence']}")
            return enhanced_result
            
        except Exception as e:
            logger.error(f"Error in deep research: {e}")
            if progress_callback:
                await progress_callback({
                    "stage": "error",
                    "message": f"Research failed: {str(e)}",
                    "progress": 0,
                    "error": True
                })
            
            return {
                "final_synthesis": f"Research failed due to error: {str(e)}",
                "overall_confidence": 0.0,
                "agents_used": [],
                "iterations_completed": 0,
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e)
            }
    
    async def get_engine_status(self) -> Dict[str, Any]:
        """Get the status of the research engine"""
        available_methods = []
        if self.chatbot_interface:
            for method in ['ask_question', 'conduct_deep_research', 'chat', 'research', 'query']:
                if hasattr(self.chatbot_interface, method):
                    available_methods.append(method)
        
        return {
            "initialized": self.is_initialized,
            "interface_available": self.chatbot_interface is not None,
            "available_methods": available_methods,
            "engine_type": "EnhancedChatbotInterface",
            "capabilities": [
                "Quick Chat",
                "Deep Multi-Agent Research",
                "Knowledge Synthesis",
                "Domain Filtering",
                "Session Management"
            ],
            "timestamp": datetime.utcnow().isoformat()
        }
    
    async def cleanup(self):
        """Clean up resources"""
        try:
            # Only call cleanup if it exists
            if self.chatbot_interface and hasattr(self.chatbot_interface, 'cleanup'):
                if asyncio.iscoroutinefunction(self.chatbot_interface.cleanup):
                    await self.chatbot_interface.cleanup()
                else:
                    self.chatbot_interface.cleanup()
            
            self.chatbot_interface = None
            self.is_initialized = False
            logger.info("Research engine cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during research engine cleanup: {e}")
