import React, { useState, useCallback, useEffect, useMemo } from 'react';
import {
  ReactFlow,
  Node,
  Edge,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  Connection,
  ConnectionMode,
  Panel,
  MiniMap,
  NodeTypes,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { Upload, Search, Filter, Download } from 'lucide-react';
import { RuleData, RuleNodeData, ConditionNodeData, EventNodeData, LogicNodeData, FilterState } from '../types';
import { RuleNode, ConditionNode, EventNode, LogicNode } from './nodes';

const nodeTypes: NodeTypes = {
  rule: RuleNode,
  condition: ConditionNode,
  event: EventNode,
  logic: LogicNode,
};

export default function LegislationRulesVisualizer() {
  const [nodes, setNodes, onNodesChange] = useNodesState<Node[]>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge[]>([]);
  const [rulesData, setRulesData] = useState<RuleData[]>([]);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState<FilterState>({
    searchTerm: '',
    selectedCountry: '',
    selectedPriority: '',
  });

  // File upload handler
  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setLoading(true);
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const result = e.target?.result;
          if (typeof result === 'string') {
            const jsonData = JSON.parse(result);
            setRulesData(Array.isArray(jsonData) ? jsonData : [jsonData]);
          }
        } catch (error) {
          console.error('Error parsing JSON:', error);
          alert('Error parsing JSON file. Please check the file format.');
        } finally {
          setLoading(false);
        }
      };
      reader.readAsText(file);
    }
  }, []);

  // Fetch JSON from URL
  const fetchJsonData = useCallback(async () => {
    setLoading(true);
    try {
      // Try to fetch from the default output path
      const response = await fetch('/json_rules_engine_format.json');
      if (response.ok) {
        const jsonData = await response.json();
        setRulesData(Array.isArray(jsonData) ? jsonData : [jsonData]);
      } else {
        throw new Error('File not found');
      }
    } catch (error) {
      console.error('Error fetching JSON:', error);
      alert('Could not fetch json_rules_engine_format.json. Please upload the file manually.');
    } finally {
      setLoading(false);
    }
  }, []);

  // Generate graph nodes and edges
  const generateGraph = useCallback((data: RuleData[]) => {
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];
    let nodeId = 0;
    
    const getNextId = () => `node-${nodeId++}`;
    
    // Calculate layout positions
    const getPosition = (index: number, total: number, type: 'rule' | 'condition' | 'event' | 'logic') => {
      const baseY = type === 'rule' ? 100 : type === 'condition' ? 300 : type === 'logic' ? 500 : 700;
      const spacing = Math.max(400, Math.min(800, (typeof window !== 'undefined' ? window.innerWidth - 200 : 1200) / Math.max(total, 1)));
      const startX = Math.max(50, (typeof window !== 'undefined' ? (window.innerWidth - (total * spacing)) / 2 : 100));
      
      return {
        x: startX + (index * spacing),
        y: baseY + (Math.random() - 0.5) * 50, // Add slight randomization
      };
    };

    data.forEach((rule, ruleIndex) => {
      // Create rule node
      const ruleNodeId = getNextId();
      newNodes.push({
        id: ruleNodeId,
        type: 'rule',
        position: getPosition(ruleIndex, data.length, 'rule'),
        data: {
          rule_id: rule.rule_id,
          rule_text: rule.rule_text,
          applies_to_countries: rule.applies_to_countries,
          adequacy_countries: rule.adequacy_countries,
          priority: rule.priority,
        } as RuleNodeData,
      });

      // Process conditions
      if (rule.conditions) {
        const processConditions = (conditions: any, parentNodeId: string, level = 0) => {
          Object.entries(conditions).forEach(([logicType, conditionList], logicIndex) => {
            if (Array.isArray(conditionList)) {
              // Create logic node
              const logicNodeId = getNextId();
              newNodes.push({
                id: logicNodeId,
                type: 'logic',
                position: {
                  x: getPosition(ruleIndex, data.length, 'logic').x + (logicIndex * 100),
                  y: 400 + (level * 150),
                },
                data: { logic: logicType as 'all' | 'any' | 'not' } as LogicNodeData,
              });

              // Connect parent to logic node
              newEdges.push({
                id: `edge-${parentNodeId}-${logicNodeId}`,
                source: parentNodeId,
                target: logicNodeId,
                animated: true,
              });

              // Create condition nodes
              conditionList.forEach((condition: any, condIndex: number) => {
                if (typeof condition === 'object' && condition.fact) {
                  const conditionNodeId = getNextId();
                  newNodes.push({
                    id: conditionNodeId,
                    type: 'condition',
                    position: {
                      x: getPosition(ruleIndex, data.length, 'condition').x + (condIndex * 250) - (conditionList.length * 125),
                      y: 550 + (level * 150),
                    },
                    data: condition as ConditionNodeData,
                  });

                  // Connect logic to condition
                  newEdges.push({
                    id: `edge-${logicNodeId}-${conditionNodeId}`,
                    source: logicNodeId,
                    target: conditionNodeId,
                  });
                } else if (typeof condition === 'object') {
                  // Nested conditions
                  processConditions(condition, logicNodeId, level + 1);
                }
              });
            }
          });
        };

        processConditions(rule.conditions, ruleNodeId);
      }

      // Create event node
      if (rule.event) {
        const eventNodeId = getNextId();
        newNodes.push({
          id: eventNodeId,
          type: 'event',
          position: getPosition(ruleIndex, data.length, 'event'),
          data: rule.event as EventNodeData,
        });

        // Connect rule to event
        newEdges.push({
          id: `edge-${ruleNodeId}-${eventNodeId}`,
          source: ruleNodeId,
          target: eventNodeId,
          style: { stroke: '#10b981', strokeWidth: 3 },
          animated: true,
        });
      }
    });

    setNodes(newNodes);
    setEdges(newEdges);
  }, [setNodes, setEdges]);

  // Filter rules based on search and filters
  const filteredRules = useMemo(() => {
    return rulesData.filter(rule => {
      const matchesSearch = !filters.searchTerm || 
        rule.rule_text?.toLowerCase().includes(filters.searchTerm.toLowerCase()) ||
        rule.rule_id?.toLowerCase().includes(filters.searchTerm.toLowerCase());
      
      const matchesCountry = !filters.selectedCountry || 
        rule.applies_to_countries?.includes(filters.selectedCountry) ||
        rule.adequacy_countries?.includes(filters.selectedCountry);
      
      const matchesPriority = !filters.selectedPriority || 
        (filters.selectedPriority === 'high' && (rule.priority || 50) >= 70) ||
        (filters.selectedPriority === 'medium' && (rule.priority || 50) >= 30 && (rule.priority || 50) < 70) ||
        (filters.selectedPriority === 'low' && (rule.priority || 50) < 30);
      
      return matchesSearch && matchesCountry && matchesPriority;
    });
  }, [rulesData, filters]);

  // Update graph when filtered rules change
  useEffect(() => {
    if (filteredRules.length > 0) {
      generateGraph(filteredRules);
    }
  }, [filteredRules, generateGraph]);

  // Get unique countries for filter
  const uniqueCountries = useMemo(() => {
    const countries = new Set<string>();
    rulesData.forEach(rule => {
      rule.applies_to_countries?.forEach(country => countries.add(country));
      rule.adequacy_countries?.forEach(country => countries.add(country));
    });
    return Array.from(countries).sort();
  }, [rulesData]);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // Export functionality
  const exportData = useCallback(() => {
    const dataStr = JSON.stringify({ nodes, edges, rulesData: filteredRules }, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'legislation-rules-graph.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [nodes, edges, filteredRules]);

  // Update filter state
  const updateFilter = useCallback((key: keyof FilterState, value: string) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);

  // Load sample data on mount
  useEffect(() => {
    fetchJsonData();
  }, [fetchJsonData]);

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow-sm border-b border-gray-200 p-4">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Legislation Rules Visualizer</h1>
            <p className="text-sm text-gray-600">Interactive graph visualization of JSON Rules Engine format</p>
          </div>
          
          <div className="flex items-center gap-3">
            <button
              onClick={fetchJsonData}
              disabled={loading}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors"
            >
              <Download className="w-4 h-4" />
              {loading ? 'Loading...' : 'Fetch JSON'}
            </button>
            
            <label className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 cursor-pointer transition-colors">
              <Upload className="w-4 h-4" />
              Upload JSON
              <input
                type="file"
                accept=".json"
                onChange={handleFileUpload}
                className="hidden"
              />
            </label>
            
            <button
              onClick={exportData}
              className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors"
            >
              <Download className="w-4 h-4" />
              Export
            </button>
          </div>
        </div>
        
        {/* Filters */}
        <div className="mt-4 flex items-center gap-4 flex-wrap">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
            <input
              type="text"
              placeholder="Search rules..."
              value={filters.searchTerm}
              onChange={(e) => updateFilter('searchTerm', e.target.value)}
              className="pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
          
          <select
            value={filters.selectedCountry}
            onChange={(e) => updateFilter('selectedCountry', e.target.value)}
            className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            <option value="">All Countries</option>
            {uniqueCountries.map(country => (
              <option key={country} value={country}>{country}</option>
            ))}
          </select>
          
          <select
            value={filters.selectedPriority}
            onChange={(e) => updateFilter('selectedPriority', e.target.value)}
            className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          >
            <option value="">All Priorities</option>
            <option value="high">High Priority (70+)</option>
            <option value="medium">Medium Priority (30-69)</option>
            <option value="low">Low Priority (&lt;30)</option>
          </select>
          
          <div className="flex items-center gap-2 text-sm text-gray-600">
            <Filter className="w-4 h-4" />
            Showing {filteredRules.length} of {rulesData.length} rules
          </div>
        </div>
      </div>

      {/* Graph */}
      <div className="flex-1 relative">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          connectionMode={ConnectionMode.Loose}
          fitView
          fitViewOptions={{
            padding: 50,
            includeHiddenNodes: false,
          }}
          className="bg-gray-50"
        >
          <Background color="#e5e7eb" gap={20} />
          <Controls className="bg-white shadow-lg rounded-lg" />
          <MiniMap 
            className="bg-white shadow-lg rounded-lg"
            nodeColor={(node) => {
              switch (node.type) {
                case 'rule': return '#3b82f6';
                case 'condition': return '#10b981';
                case 'event': return '#f59e0b';
                case 'logic': return '#8b5cf6';
                default: return '#6b7280';
              }
            }}
          />
          
          <Panel position="top-right" className="bg-white p-4 rounded-lg shadow-lg">
            <div className="space-y-2 text-sm">
              <div className="font-semibold text-gray-700 mb-3">Legend</div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-blue-500 rounded"></div>
                <span>Rules</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-gray-400 rounded"></div>
                <span>Conditions</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-purple-500 rounded-full"></div>
                <span>Logic (AND/OR)</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-gradient-to-r from-red-500 to-red-600 rounded"></div>
                <span>Actions</span>
              </div>
            </div>
          </Panel>
        </ReactFlow>
      </div>
      
      {/* Status Bar */}
      <div className="bg-white border-t border-gray-200 px-4 py-2 text-sm text-gray-600">
        <div className="flex items-center justify-between">
          <div>
            Graph: {nodes.length} nodes, {edges.length} edges
          </div>
          <div>
            JSON Rules Engine Compatible ✓
          </div>
        </div>
      </div>
    </div>
  );
}
