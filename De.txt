"""
OpenAI API service for the legislation rules converter.
Updated to support HSBC authentication with httpx + truststore
"""
import logging
from typing import List, Union, Dict, Optional, Any
from openai import OpenAI
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

from ..config import Config

logger = logging.getLogger(__name__)


class OpenAIService:
    """Service for OpenAI API interactions with HSBC auth support."""

    def __init__(self, api_key: str = None, base_url: str = None, use_hsbc_auth: bool = None):
        """
        Initialize OpenAI service
        
        Args:
            api_key: OpenAI API key (defaults to Config.API_KEY, ignored if using HSBC)
            base_url: OpenAI API base URL (defaults to Config.BASE_URL)
            use_hsbc_auth: Whether to use HSBC authentication (defaults to Config.USE_HSBC_AUTH)
        """
        self.use_hsbc_auth = use_hsbc_auth if use_hsbc_auth is not None else Config.USE_HSBC_AUTH
        self.base_url = base_url or Config.BASE_URL
        
        logger.info(f"Initializing OpenAI Service:")
        logger.info(f"  Base URL: {self.base_url}")
        logger.info(f"  HSBC Auth: {self.use_hsbc_auth}")
        logger.info(f"  Embedding Model: {Config.EMBEDDING_MODEL}")
        logger.info(f"  Chat Model: {Config.CHAT_MODEL}")
        
        if self.use_hsbc_auth:
            from .hsbc_openai_client import create_hsbc_client
            
            logger.info("  Using HSBC authentication (httpx + truststore)")
            self.client = create_hsbc_client()
            self.api_key = "HSBC_MANAGED"
            
        else:
            self.api_key = api_key or Config.API_KEY
            
            if not self.api_key:
                raise ValueError("API key is required. Set OPENAI_API_KEY environment variable.")
            
            logger.info(f"  API Key: ***{self.api_key[-4:] if self.api_key else 'NOT SET'}")
            
            self.client = OpenAI(
                api_key=self.api_key,
                base_url=self.base_url
            )
        
        logger.info("âœ“ OpenAI client initialized")

    async def get_embeddings(self, texts: List[str]) -> List[List[float]]:
        """
        Generate embeddings using configured connection.
        
        Args:
            texts: List of text strings to embed
            
        Returns:
            List of embedding vectors
        """
        max_retries = 2
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                logger.debug(f"Requesting embeddings for {len(texts)} texts (attempt {retry_count + 1}/{max_retries})")
                logger.debug(f"  Model: {Config.EMBEDDING_MODEL}")
                logger.debug(f"  Base URL: {self.client.base_url}")
                
                # Build request parameters
                request_params = {
                    "model": Config.EMBEDDING_MODEL,
                    "input": texts,
                }
                
                # Add HSBC-specific parameters
                if self.use_hsbc_auth:
                    request_params["user"] = Config.HSBC_USER_ID
                    logger.debug(f"  User ID: {Config.HSBC_USER_ID}")
                
                # Note: encoding_format may not be supported by HSBC gateway
                # Only add it for standard OpenAI
                if not self.use_hsbc_auth:
                    request_params["encoding_format"] = "float"
                
                logger.debug(f"Request params: {list(request_params.keys())}")
                
                response = self.client.embeddings.create(**request_params)
                
                embeddings = [data.embedding for data in response.data]
                logger.info(f"âœ“ Generated {len(embeddings)} embeddings")
                logger.debug(f"  First embedding dimension: {len(embeddings[0]) if embeddings else 0}")
                
                return embeddings
                
            except Exception as e:
                error_code = None
                if hasattr(e, 'status_code'):
                    error_code = e.status_code
                elif hasattr(e, 'code'):
                    error_code = e.code
                
                logger.error(f"Error generating embeddings (attempt {retry_count + 1}/{max_retries}): {e}")
                logger.error(f"  Error type: {type(e).__name__}")
                logger.error(f"  Error code: {error_code}")
                logger.error(f"  Base URL: {self.client.base_url}")
                logger.error(f"  Model: {Config.EMBEDDING_MODEL}")
                
                if hasattr(e, 'response'):
                    logger.error(f"  Response: {e.response}")
                if hasattr(e, 'body'):
                    logger.error(f"  Body: {e.body}")
                
                # Retry with token refresh for HSBC on 400/401 errors or any error on first attempt
                if self.use_hsbc_auth and retry_count < max_retries - 1:
                    if error_code in [400, 401] or retry_count == 0:
                        logger.info("ðŸ”„ Refreshing HSBC token and retrying...")
                        
                        # Force token refresh
                        if hasattr(self.client, 'token_service'):
                            self.client.token_service.invalidate_token()
                            fresh_token = self.client.token_service.get_token(force_refresh=True)
                            self.client.api_key = fresh_token
                            logger.info("âœ“ Token refreshed, retrying request...")
                        elif hasattr(self.client, '_refresh_token_and_headers'):
                            self.client._refresh_token_and_headers()
                            logger.info("âœ“ Token refreshed, retrying request...")
                        
                        retry_count += 1
                        continue
                
                # No more retries or not HSBC auth
                raise
        
        raise Exception(f"Failed to generate embeddings after {max_retries} attempts")

    async def chat_completion(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]],
        **kwargs
    ) -> str:
        """
        Generate chat completion with default settings.
        
        Args:
            messages: List of messages in the conversation
            **kwargs: Additional arguments for chat completion
            
        Returns:
            String response from the model
        """
        max_retries = 2
        retry_count = 0
        formatted_messages = self._format_messages(messages)
        
        while retry_count < max_retries:
            try:
                logger.debug(f"Chat completion request (attempt {retry_count + 1}/{max_retries}):")
                logger.debug(f"  Model: {Config.CHAT_MODEL}")
                logger.debug(f"  Messages: {len(formatted_messages)}")
                logger.debug(f"  Base URL: {self.client.base_url}")
                
                if self.use_hsbc_auth and 'user' not in kwargs:
                    kwargs['user'] = Config.HSBC_USER_ID
                    logger.debug(f"  User ID: {Config.HSBC_USER_ID}")
                
                response = self.client.chat.completions.create(
                    model=Config.CHAT_MODEL,
                    messages=formatted_messages,
                    **kwargs
                )
                return response.choices[0].message.content
                
            except Exception as e:
                error_code = None
                if hasattr(e, 'status_code'):
                    error_code = e.status_code
                elif hasattr(e, 'code'):
                    error_code = e.code
                
                logger.error(f"Error in chat completion (attempt {retry_count + 1}/{max_retries}): {e}")
                logger.error(f"  Error type: {type(e).__name__}")
                logger.error(f"  Error code: {error_code}")
                
                if hasattr(e, 'response'):
                    logger.error(f"  Response: {e.response}")
                if hasattr(e, 'body'):
                    logger.error(f"  Body: {e.body}")
                
                # Retry with token refresh for HSBC on 400/401 errors or any error on first attempt
                if self.use_hsbc_auth and retry_count < max_retries - 1:
                    if error_code in [400, 401] or retry_count == 0:
                        logger.info("ðŸ”„ Refreshing HSBC token and retrying...")
                        
                        # Force token refresh
                        if hasattr(self.client, 'token_service'):
                            self.client.token_service.invalidate_token()
                            fresh_token = self.client.token_service.get_token(force_refresh=True)
                            self.client.api_key = fresh_token
                            logger.info("âœ“ Token refreshed, retrying request...")
                        elif hasattr(self.client, '_refresh_token_and_headers'):
                            self.client._refresh_token_and_headers()
                            logger.info("âœ“ Token refreshed, retrying request...")
                        
                        retry_count += 1
                        continue
                
                raise
        
        raise Exception(f"Failed chat completion after {max_retries} attempts")

    async def get_completion(
        self,
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]],
        **kwargs
    ) -> Any:
        """
        Generate chat completion with default settings.
        
        Args:
            messages: List of messages in the conversation
            **kwargs: Additional arguments for chat completion
            
        Returns:
            Response object with content attribute
        """
        max_retries = 2
        retry_count = 0
        formatted_messages = self._format_messages(messages)
        
        while retry_count < max_retries:
            try:
                if self.use_hsbc_auth and 'user' not in kwargs:
                    kwargs['user'] = Config.HSBC_USER_ID

                response = self.client.chat.completions.create(
                    model=Config.CHAT_MODEL,
                    messages=formatted_messages,
                    **kwargs
                )
                
                class CompletionResponse:
                    def __init__(self, content):
                        self.content = content
                
                return CompletionResponse(response.choices[0].message.content)
                
            except Exception as e:
                error_code = None
                if hasattr(e, 'status_code'):
                    error_code = e.status_code
                elif hasattr(e, 'code'):
                    error_code = e.code
                
                logger.error(f"Error in get_completion (attempt {retry_count + 1}/{max_retries}): {e}")
                
                # Retry with token refresh for HSBC on 400/401 errors or any error on first attempt
                if self.use_hsbc_auth and retry_count < max_retries - 1:
                    if error_code in [400, 401] or retry_count == 0:
                        logger.info("ðŸ”„ Refreshing HSBC token and retrying...")
                        
                        # Force token refresh
                        if hasattr(self.client, 'token_service'):
                            self.client.token_service.invalidate_token()
                            fresh_token = self.client.token_service.get_token(force_refresh=True)
                            self.client.api_key = fresh_token
                            logger.info("âœ“ Token refreshed, retrying request...")
                        elif hasattr(self.client, '_refresh_token_and_headers'):
                            self.client._refresh_token_and_headers()
                            logger.info("âœ“ Token refreshed, retrying request...")
                        
                        retry_count += 1
                        continue
                
                raise
        
        raise Exception(f"Failed get_completion after {max_retries} attempts")
    
    def _format_messages(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> List[Dict[str, str]]:
        """
        Format messages to OpenAI API format.
        
        Args:
            messages: List of messages in various formats
            
        Returns:
            List of formatted message dicts
        """
        formatted_messages = []
        
        for msg in messages:
            if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                if isinstance(msg, SystemMessage):
                    formatted_messages.append({"role": "system", "content": msg.content})
                elif isinstance(msg, HumanMessage):
                    formatted_messages.append({"role": "user", "content": msg.content})
                elif isinstance(msg, AIMessage):
                    formatted_messages.append({"role": "assistant", "content": msg.content})
            elif isinstance(msg, dict):
                if msg.get("role") == "developer":
                    formatted_messages.append({"role": "system", "content": msg.get("content", "")})
                else:
                    formatted_messages.append(msg)
            else:
                formatted_messages.append({"role": "user", "content": str(msg)})
        
        return formatted_messages
    
    def get_client(self) -> OpenAI:
        """
        Get the underlying OpenAI client.
        
        Returns:
            OpenAI client instance (standard or HSBC)
        """
        return self.client
    
    def create_langchain_client(self):
        """
        Create a LangChain ChatOpenAI client with HSBC authentication.
        Only works when HSBC auth is enabled.
        
        Returns:
            ChatOpenAI instance configured for HSBC
        """
        if not self.use_hsbc_auth:
            raise ValueError("create_langchain_client only works with HSBC authentication enabled")
        
        from .hsbc_openai_client import create_langchain_client
        return create_langchain_client()
