"""
OpenAI API service for the legislation rules converter.
FIXED VERSION - Works with corrected HSBC client structure
Automatic token refresh handled by custom HTTP transport
"""
import logging
from typing import List, Union, Dict, Optional, Any
from openai import OpenAI
from openai._exceptions import APIStatusError
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

from ..config import Config

logger = logging.getLogger(__name__)


class OpenAIService:
    """Service for OpenAI API interactions with HSBC auth and automatic token refresh."""

    def __init__(self, api_key: str = None, base_url: str = None, use_hsbc_auth: bool = None):
        """
        Initialize OpenAI service with automatic token management
        
        Args:
            api_key: OpenAI API key (defaults to Config.API_KEY, ignored if using HSBC)
            base_url: OpenAI API base URL (defaults to Config.BASE_URL)
            use_hsbc_auth: Whether to use HSBC authentication (defaults to Config.USE_HSBC_AUTH)
        """
        self.use_hsbc_auth = use_hsbc_auth if use_hsbc_auth is not None else Config.USE_HSBC_AUTH
        self.base_url = base_url or Config.BASE_URL
        
        logger.info(f"Initializing OpenAI Service:")
        logger.info(f"  Base URL: {self.base_url}")
        logger.info(f"  HSBC Auth: {self.use_hsbc_auth}")
        logger.info(f"  Embedding Model: {Config.EMBEDDING_MODEL}")
        logger.info(f"  Chat Model: {Config.CHAT_MODEL}")
        
        if self.use_hsbc_auth:
            from .hsbc_openai_client import create_hsbc_client
            
            logger.info("  Using HSBC authentication with automatic token refresh")
            self.client = create_hsbc_client()
            self.api_key = "HSBC_MANAGED"
            logger.info("  ✓ Custom HTTP transport will auto-refresh tokens on 401")
            
        else:
            self.api_key = api_key or Config.API_KEY
            
            if not self.api_key:
                raise ValueError("API key is required. Set OPENAI_API_KEY environment variable.")
            
            logger.info(f"  API Key: ***{self.api_key[-4:] if self.api_key else 'NOT SET'}")
            
            self.client = OpenAI(
                api_key=self.api_key,
                base_url=self.base_url
            )
        
        logger.info("✓ OpenAI client initialized")

    async def get_embeddings(self, texts: List[str]) -> List[List[float]]:
        """
        Generate embeddings using configured connection.
        For HSBC auth, token refresh is handled automatically by custom HTTP transport.
        
        Args:
            texts: List of text strings to embed
            
        Returns:
            List of embedding vectors
        """
        try:
            logger.debug(f"Requesting embeddings for {len(texts)} texts")
            logger.debug(f"  Model: {Config.EMBEDDING_MODEL}")
            logger.debug(f"  Base URL: {self.client.base_url}")
            
            # Build request parameters
            request_params = {
                "model": Config.EMBEDDING_MODEL,
                "input": texts,
            }
            
            # Add HSBC-specific parameters
            if self.use_hsbc_auth:
                request_params["user"] = Config.HSBC_USER_ID
                logger.debug(f"  User ID: {Config.HSBC_USER_ID}")
            
            # Note: encoding_format may not be supported by HSBC gateway
            # Only add it for standard OpenAI
            if not self.use_hsbc_auth:
                request_params["encoding_format"] = "float"
            
            logger.debug(f"Request params: {list(request_params.keys())}")
            
            # Make request - custom transport will handle 401 retries automatically
            response = self.client.embeddings.create(**request_params)
            
            embeddings = [data.embedding for data in response.data]
            logger.info(f"✓ Generated {len(embeddings)} embeddings")
            logger.debug(f"  First embedding dimension: {len(embeddings[0]) if embeddings else 0}")
            
            return embeddings
            
        except APIStatusError as e:
            # For HSBC, 401 errors are handled by custom transport retry logic
            # If we get here, all retries have been exhausted
            logger.error(f"API Status Error generating embeddings: {e}")
            logger.error(f"  Status code: {e.status_code}")
            logger.error(f"  Message: {e.message}")
            logger.error(f"  Base URL: {self.client.base_url}")
            logger.error(f"  Model: {Config.EMBEDDING_MODEL}")
            
            if self.use_hsbc_auth and e.status_code == 401:
                logger.error("  Token refresh failed after multiple attempts")
            
            raise
            
        except Exception as e:
            logger.error(f"Error generating embeddings: {e}")
            logger.error(f"  Error type: {type(e).__name__}")
            logger.error(f"  Base URL: {self.client.base_url}")
            logger.error(f"  Model: {Config.EMBEDDING_MODEL}")
            
            if hasattr(e, 'response'):
                logger.error(f"  Response: {e.response}")
            if hasattr(e, 'body'):
                logger.error(f"  Body: {e.body}")
            
            raise

    async def chat_completion(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]],
        **kwargs
    ) -> str:
        """
        Generate chat completion with default settings.
        For HSBC auth, token refresh is handled automatically by custom HTTP transport.
        
        Args:
            messages: List of messages in the conversation
            **kwargs: Additional arguments for chat completion (can include 'model')
            
        Returns:
            String response from the model
        """
        try:
            formatted_messages = self._format_messages(messages)
            
            # Allow model override via kwargs, otherwise use default
            model = kwargs.pop('model', Config.CHAT_MODEL)
            
            logger.debug(f"Chat completion request:")
            logger.debug(f"  Model: {model}")
            logger.debug(f"  Messages: {len(formatted_messages)}")
            logger.debug(f"  Base URL: {self.client.base_url}")
            
            if self.use_hsbc_auth and 'user' not in kwargs:
                kwargs['user'] = Config.HSBC_USER_ID
                logger.debug(f"  User ID: {Config.HSBC_USER_ID}")
            
            # Make request - custom transport will handle 401 retries automatically
            response = self.client.chat.completions.create(
                model=model,
                messages=formatted_messages,
                **kwargs
            )
            
            return response.choices[0].message.content
            
        except APIStatusError as e:
            logger.error(f"API Status Error in chat completion: {e}")
            logger.error(f"  Status code: {e.status_code}")
            logger.error(f"  Message: {e.message}")
            
            if self.use_hsbc_auth and e.status_code == 401:
                logger.error("  Token refresh failed after multiple attempts")
            
            raise
            
        except Exception as e:
            logger.error(f"Error in chat completion: {e}")
            logger.error(f"  Error type: {type(e).__name__}")
            
            if hasattr(e, 'response'):
                logger.error(f"  Response: {e.response}")
            if hasattr(e, 'body'):
                logger.error(f"  Body: {e.body}")
            
            raise

    async def get_completion(
        self,
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]],
        **kwargs
    ) -> Any:
        """
        Generate chat completion with default settings.
        For HSBC auth, token refresh is handled automatically by custom HTTP transport.
        
        Args:
            messages: List of messages in the conversation
            **kwargs: Additional arguments for chat completion (can include 'model')
            
        Returns:
            Response object with content attribute
        """
        try:
            formatted_messages = self._format_messages(messages)
            
            # Allow model override via kwargs, otherwise use default
            model = kwargs.pop('model', Config.CHAT_MODEL)
            
            if self.use_hsbc_auth and 'user' not in kwargs:
                kwargs['user'] = Config.HSBC_USER_ID

            # Make request - custom transport will handle 401 retries automatically
            response = self.client.chat.completions.create(
                model=model,
                messages=formatted_messages,
                **kwargs
            )
            
            class CompletionResponse:
                def __init__(self, content):
                    self.content = content
            
            return CompletionResponse(response.choices[0].message.content)
            
        except APIStatusError as e:
            logger.error(f"API Status Error in get_completion: {e}")
            logger.error(f"  Status code: {e.status_code}")
            
            if self.use_hsbc_auth and e.status_code == 401:
                logger.error("  Token refresh failed after multiple attempts")
            
            raise
            
        except Exception as e:
            logger.error(f"Error in get_completion: {e}")
            raise
    
    def _format_messages(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> List[Dict[str, str]]:
        """
        Format messages to OpenAI API format.
        
        Args:
            messages: List of messages in various formats
            
        Returns:
            List of formatted message dicts
        """
        formatted_messages = []
        
        for msg in messages:
            if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                if isinstance(msg, SystemMessage):
                    formatted_messages.append({"role": "system", "content": msg.content})
                elif isinstance(msg, HumanMessage):
                    formatted_messages.append({"role": "user", "content": msg.content})
                elif isinstance(msg, AIMessage):
                    formatted_messages.append({"role": "assistant", "content": msg.content})
            elif isinstance(msg, dict):
                if msg.get("role") == "developer":
                    formatted_messages.append({"role": "system", "content": msg.get("content", "")})
                else:
                    formatted_messages.append(msg)
            else:
                formatted_messages.append({"role": "user", "content": str(msg)})
        
        return formatted_messages
    
    def get_client(self) -> OpenAI:
        """
        Get the underlying OpenAI client.
        
        Returns:
            OpenAI client instance (standard or HSBC with custom transport)
        """
        return self.client
    
    def get_token_status(self) -> Optional[dict]:
        """
        Get current token status (HSBC auth only).
        
        Returns:
            dict: Token status information or None if not using HSBC auth
        """
        if not self.use_hsbc_auth:
            return None
        
        if hasattr(self.client, '_hsbc_token_service'):
            return self.client._hsbc_token_service.get_token_info()
        
        return None
    
    def create_langchain_client(self):
        """
        Create a LangChain ChatOpenAI client with HSBC authentication.
        Only works when HSBC auth is enabled.
        
        Returns:
            ChatOpenAI instance configured for HSBC with automatic token refresh
        """
        if not self.use_hsbc_auth:
            raise ValueError("create_langchain_client only works with HSBC authentication enabled")
        
        from .hsbc_openai_client import create_langchain_client
        return create_langchain_client()
