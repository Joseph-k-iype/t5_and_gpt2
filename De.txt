"""
Fix for Azure AD tokens with direct credential loading.
"""

import logging
import time
import threading
import requests
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from fastapi import Depends, HTTPException, status
from jose import JWTError, jwt
from pydantic import BaseModel
import os
from dotenv import dotenv_values

logger = logging.getLogger(__name__)

# Load credentials directly from file
credentials_path = os.path.join("env", "credentials.env")
credentials_values = {}

try:
    if os.path.isfile(credentials_path):
        logger.info(f"Auth helper loading credentials from {credentials_path}")
        credentials_values = dotenv_values(credentials_path)
        logger.info(f"Loaded {len(credentials_values)} values from {credentials_path}")
    else:
        logger.warning(f"Credentials file not found: {credentials_path}")
except Exception as e:
    logger.error(f"Error loading credentials file: {e}")

# Extract Azure AD credentials directly
AZURE_TENANT_ID = credentials_values.get("AZURE_TENANT_ID", "")
AZURE_CLIENT_ID = credentials_values.get("AZURE_CLIENT_ID", "")
AZURE_CLIENT_SECRET = credentials_values.get("AZURE_CLIENT_SECRET", "")

# Validate credentials
if not AZURE_TENANT_ID or AZURE_TENANT_ID == "your-tenant-id-here":
    logger.error("AZURE_TENANT_ID is missing or invalid in credentials.env")

if not AZURE_CLIENT_ID or AZURE_CLIENT_ID == "your-client-id-here":
    logger.error("AZURE_CLIENT_ID is missing or invalid in credentials.env")

if not AZURE_CLIENT_SECRET or AZURE_CLIENT_SECRET == "your-client-secret-here":
    logger.error("AZURE_CLIENT_SECRET is missing or invalid in credentials.env")

# Log credential status (masked for security)
if AZURE_TENANT_ID and AZURE_CLIENT_ID and AZURE_CLIENT_SECRET:
    masked_tenant = f"{AZURE_TENANT_ID[:4]}...{AZURE_TENANT_ID[-4:]}" if len(AZURE_TENANT_ID) > 8 else "***"
    masked_client = f"{AZURE_CLIENT_ID[:4]}...{AZURE_CLIENT_ID[-4:]}" if len(AZURE_CLIENT_ID) > 8 else "***"
    logger.info(f"Using Azure credentials - tenant_id: {masked_tenant}, client_id: {masked_client}")
else:
    logger.warning("One or more Azure credentials are missing or invalid")

# Models for token handling
class Token(BaseModel):
    access_token: str
    token_type: str
    expires_at: datetime


class TokenCache:
    """Thread-safe token cache for storing and retrieving Azure tokens."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TokenCache, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the token cache."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._tokens = {}  # Format: {cache_key: (token, expiry_time)}
                self._initialized = True
                logger.info("Token cache initialized")
    
    def get(self, tenant_id: str, client_id: str, scope: str) -> Optional[str]:
        """
        Get a token from the cache if it exists and is not expired.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            
        Returns:
            Token if found and valid, None otherwise
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                token, expiry_time = self._tokens[cache_key]
                # Allow 5 minute buffer before expiration
                if time.time() < expiry_time - 300:
                    logger.debug(f"Token cache hit for {client_id[:8]}...")
                    return token
                else:
                    logger.debug(f"Token expired for {client_id[:8]}...")
                    # Remove expired token
                    del self._tokens[cache_key]
        
        return None
    
    def set(self, tenant_id: str, client_id: str, scope: str, token: str, expires_in: int = 3600) -> None:
        """
        Store a token in the cache.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            token: The token to store
            expires_in: Token expiration time in seconds
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        expiry_time = time.time() + expires_in
        
        with self._lock:
            self._tokens[cache_key] = (token, expiry_time)
            
        logger.debug(f"Token cached for {client_id[:8]}... (expires in {expires_in}s)")
    
    def _get_cache_key(self, tenant_id: str, client_id: str, scope: str) -> str:
        """Generate a cache key."""
        return f"{tenant_id}:{client_id}:{scope}"
    
    def clear(self) -> None:
        """Clear all tokens from the cache."""
        with self._lock:
            self._tokens.clear()
        logger.info("Token cache cleared")
    
    def remove(self, tenant_id: str, client_id: str, scope: str) -> None:
        """Remove a specific token from the cache."""
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                del self._tokens[cache_key]
                logger.debug(f"Token removed from cache for {client_id[:8]}...")


# Initialize global token cache
token_cache = TokenCache()

def get_azure_token_cached(tenant_id: str = None, client_id: str = None, client_secret: str = None, 
                          scope: str = "https://cognitiveservices.azure.com/.default") -> Optional[str]:
    """
    Get an Azure AD token with caching support.
    This function first checks the cache before making a new token request.
    
    Args:
        tenant_id: Azure tenant ID (uses value from credentials.env if None)
        client_id: Azure client ID (uses value from credentials.env if None)
        client_secret: Azure client secret (uses value from credentials.env if None)
        scope: OAuth scope to request
        
    Returns:
        Access token if successful, None otherwise
    """
    # Use provided values or fall back to values loaded from credentials.env
    tenant_id = tenant_id or AZURE_TENANT_ID
    client_id = client_id or AZURE_CLIENT_ID
    client_secret = client_secret or AZURE_CLIENT_SECRET
    
    # Validate input parameters
    if not tenant_id or tenant_id == "your-tenant-id-here":
        logger.error("Invalid tenant_id: empty or using default value")
        return None
        
    if not client_id or client_id == "your-client-id-here":
        logger.error("Invalid client_id: empty or using default value")
        return None
        
    if not client_secret or client_secret == "your-client-secret-here":
        logger.error("Invalid client_secret: empty or using default value")
        return None
    
    # Check cache first
    token = token_cache.get(tenant_id, client_id, scope)
    if token:
        return token
    
    # Cache miss - get new token
    try:
        # Mask credentials for logging
        masked_tenant = f"{tenant_id[:4]}...{tenant_id[-4:]}" if len(tenant_id) > 8 else "***"
        masked_client = f"{client_id[:4]}...{client_id[-4:]}" if len(client_id) > 8 else "***"
        logger.info(f"Token cache miss for {masked_client} - fetching new token from Azure AD")
        
        # OAuth2 token endpoint
        token_url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
        
        # Request body
        data = {
            "client_id": client_id,
            "client_secret": client_secret,
            "scope": scope,
            "grant_type": "client_credentials"
        }
        
        # Make the request
        logger.debug(f"Requesting token from {token_url}")
        response = requests.post(
            token_url, 
            data=data,
            timeout=30
        )
        
        # Handle response
        if response.status_code == 200:
            token_data = response.json()
            if "access_token" in token_data:
                token = token_data["access_token"]
                expires_in = token_data.get("expires_in", 3600)  # Default to 1 hour
                
                # Log the token (partially masked)
                token_prefix = token[:10] if len(token) > 20 else token[:5]
                token_suffix = token[-10:] if len(token) > 20 else token[-5:]
                logger.info(f"Received token: {token_prefix}...{token_suffix}")
                
                # Cache the token
                token_cache.set(tenant_id, client_id, scope, token, expires_in)
                
                logger.info(f"New token acquired and cached (expires in {expires_in}s)")
                return token
            else:
                logger.error("Token response did not contain access_token")
                logger.debug(f"Response body: {token_data}")
                return None
        else:
            logger.error(f"Token request failed with status {response.status_code}: {response.text}")
            
            # Log more detailed error information
            if response.status_code == 400:
                try:
                    error_data = response.json()
                    error = error_data.get("error", "unknown")
                    error_description = error_data.get("error_description", "No description provided")
                    logger.error(f"Token error: {error}")
                    logger.error(f"Error description: {error_description}")
                    
                    if "invalid_request" in error:
                        logger.error("Invalid request - check your Azure AD credentials")
                        logger.error(f"Tenant ID: {tenant_id}")
                        logger.error(f"Client ID: {client_id}")
                        logger.error(f"Client Secret length: {len(client_secret)} characters")
                    elif "invalid_client" in error:
                        logger.error("Invalid client - check your client ID and client secret")
                    elif "invalid_grant" in error:
                        logger.error("Invalid grant - check your tenant ID and scope")
                except:
                    logger.error(f"Could not parse error response: {response.text}")
            
            return None
            
    except requests.exceptions.ConnectionError as e:
        logger.error(f"Connection error when getting Azure token: {e}")
        logger.error("Check network connectivity and proxy settings")
        return None
    except requests.exceptions.Timeout as e:
        logger.error(f"Timeout when getting Azure token: {e}")
        logger.error("The request to Azure AD timed out")
        return None
    except Exception as e:
        logger.error(f"Error getting Azure token: {e}")
        return None


def refresh_token_if_needed(tenant_id: str = None, client_id: str = None, client_secret: str = None, 
                           scope: str = "https://cognitiveservices.azure.com/.default",
                           min_validity_seconds: int = 600) -> bool:
    """
    Check if a token is about to expire and refresh it if needed.
    
    Args:
        tenant_id: Azure tenant ID (uses value from credentials.env if None)
        client_id: Azure client ID (uses value from credentials.env if None) 
        client_secret: Azure client secret (uses value from credentials.env if None)
        scope: OAuth scope
        min_validity_seconds: Minimum seconds of validity required
        
    Returns:
        True if token was refreshed or is valid, False on error
    """
    # Use provided values or fall back to values loaded from credentials.env
    tenant_id = tenant_id or AZURE_TENANT_ID
    client_id = client_id or AZURE_CLIENT_ID
    client_secret = client_secret or AZURE_CLIENT_SECRET
    
    # Get token from cache to check expiry
    cache_key = token_cache._get_cache_key(tenant_id, client_id, scope)
    should_refresh = False
    
    with token_cache._lock:
        if cache_key in token_cache._tokens:
            _, expiry_time = token_cache._tokens[cache_key]
            time_left = expiry_time - time.time()
            
            # If token expires soon, refresh it
            if time_left < min_validity_seconds:
                logger.info(f"Token for {client_id[:8]}... expires in {time_left:.0f}s, refreshing")
                
                # Remove old token
                del token_cache._tokens[cache_key]
                should_refresh = True
        else:
            # No token in cache, need to refresh
            should_refresh = True
    
    if should_refresh:
        # Get a fresh token (will update cache)
        token = get_azure_token_cached(tenant_id, client_id, client_secret, scope)
        if token:
            logger.info(f"Successfully refreshed token for {client_id[:8]}...")
            return True
        else:
            logger.error(f"Failed to refresh token for {client_id[:8]}...")
            return False
    
    # Token is still valid
    return True


# Global refresh thread reference
_token_refresh_thread = None

def start_token_refresh_service(refresh_interval: int = 300) -> threading.Thread:
    """
    Start a background thread that refreshes tokens periodically.
    
    Args:
        refresh_interval: Interval between refresh checks in seconds
        
    Returns:
        The background thread
    """
    def _token_refresh_worker():
        # Initial delay to let the application start up
        time.sleep(10)
        
        while True:
            try:
                # Refresh the token if it's going to expire soon using values from credentials.env
                refresh_token_if_needed(
                    tenant_id=AZURE_TENANT_ID,
                    client_id=AZURE_CLIENT_ID,
                    client_secret=AZURE_CLIENT_SECRET
                )
            except Exception as e:
                logger.error(f"Error in token refresh worker: {e}")
            
            # Sleep for the specified interval
            time.sleep(refresh_interval)
    
    # Create and start the thread
    refresh_thread = threading.Thread(
        target=_token_refresh_worker,
        daemon=True,
        name="TokenRefreshThread"
    )
    refresh_thread.start()
    logger.info(f"Token refresh service started (interval: {refresh_interval}s)")
    
    return refresh_thread


# Simplified auth functions - No API key verification
async def verify_api_key(api_key: str = None):
    """
    No API key verification required.
    This function always returns True.
    """
    return True


async def get_current_user(token: str = None):
    """
    Simplified user authentication.
    For direct connection without auth, this just returns a default user.
    """
    # Create a simple user object
    user = {"username": "default_user"}
    return user
