from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel, Field
import requests
import json
from urllib.parse import urlparse, unquote
from typing import Dict, List, Optional, Any
import uvicorn
import typer # For creating the command-line interface

# --- Application Configuration ---
# A simple class to hold the configuration that will be set at startup.
class AppConfig:
    ENDPOINT_URL: str = ""
    BEARER_TOKEN: Optional[str] = None

# Global config object that will be populated by the CLI command.
config = AppConfig()

# --- Constants ---
RDFS_LABEL_URI = "http://www.w3.org/2000/01/rdf-schema#label" # Standard URI for labels

# --- Helper Functions ---
def _get_label_from_uri(uri_str: str) -> str:
    """Extracts a human-readable label from a URI."""
    if not isinstance(uri_str, str): return str(uri_str)
    try:
        parsed_uri = urlparse(uri_str)
        if parsed_uri.fragment: return unquote(parsed_uri.fragment)
        path_segments = [seg for seg in parsed_uri.path.split('/') if seg]
        if path_segments: return unquote(path_segments[-1])
        if parsed_uri.scheme and parsed_uri.opaque:
            opaque_parts = parsed_uri.opaque.split(':')
            return unquote(opaque_parts[-1]) if len(opaque_parts) > 1 else unquote(parsed_uri.opaque)
        return uri_str
    except Exception: return uri_str

def _add_value_to_json_ld_object(obj: Dict[str, Any], key: str, value_to_add: Any):
    """Helper to add potentially multi-valued properties to a JSON-LD object."""
    if key not in obj:
        obj[key] = value_to_add
    else:
        if not isinstance(obj[key], list): obj[key] = [obj[key]]
        if value_to_add not in obj[key]: obj[key].append(value_to_add)

def _execute_sparql_query(query: str, query_type_label: str) -> Dict[str, Any]:
    """Executes a SPARQL query using the globally configured endpoint and token."""
    headers = {'Accept': 'application/sparql-results+json', 'Content-Type': 'application/x-www-form-urlencoded'}
    if config.BEARER_TOKEN:
        headers['Authorization'] = f'Bearer {config.BEARER_TOKEN}'
    
    payload = {'query': query}
    try:
        response = requests.post(config.ENDPOINT_URL, data=payload, headers=headers, timeout=60)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        details = e.response.text
        try: details = e.response.json()
        except json.JSONDecodeError: pass
        return {"error": f"HTTP error for {query_type_label}: {e.response.status_code} {e.response.reason}", "details": details}
    except requests.exceptions.RequestException as e:
        return {"error": f"Request failed for {query_type_label}: {e}"}
    except json.JSONDecodeError as e_json:
        return {"error": f"Failed to decode JSON response for {query_type_label}: {e_json}", "details": response.text if 'response' in locals() else "No response text available"}

def _create_minimal_jsonld_entry(node_id: str, json_ld_objects: Dict[str, Any]):
    """Creates a minimal entry for a node in the JSON-LD graph if it doesn't exist."""
    if node_id not in json_ld_objects:
        json_ld_objects[node_id] = {"@id": node_id}


# --- Core Logic Function ---
def generate_jsonld_from_queries(
    node_query: str,
    node_id_var: str,
    edge_query: str,
    edge_source_var: str,
    edge_target_var: str,
    edge_predicate_var: str,
    node_label_var: Optional[str] = None,
    node_attributes_map: Optional[Dict[str, str]] = None,
    node_group_id_var: Optional[str] = None,
    group_query: Optional[str] = None,
    group_id_var: Optional[str] = None,
    group_label_var: Optional[str] = None,
    json_ld_group_predicate_uri: Optional[str] = None 
) -> Dict[str, Any]:
    """
    Processes user-defined queries to build and return a JSON-LD graph.
    Uses the globally configured endpoint and token for SPARQL connections.
    """
    json_ld_objects: Dict[str, Any] = {}
    json_ld_context: Dict[str, Any] = {
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
    }
    if json_ld_group_predicate_uri:
        json_ld_context['group'] = json_ld_group_predicate_uri

    # 1. Process Node Query
    node_results_json = _execute_sparql_query(node_query, "Node Query")
    if "error" in node_results_json: return node_results_json
    node_query_vars = node_results_json.get('head', {}).get('vars', [])
    if node_id_var not in node_query_vars:
        return {"error": f"Node ID variable '{node_id_var}' not found in Node Query results."}

    for binding in node_results_json.get('results', {}).get('bindings', []):
        if node_id_var not in binding: continue
        node_id = binding[node_id_var]['value']
        json_ld_node = json_ld_objects.setdefault(node_id, {"@id": node_id})
        
        if node_label_var and node_label_var in binding:
            label_binding = binding[node_label_var]
            label_obj = {"@value": label_binding['value']}
            if 'xml:lang' in label_binding: label_obj["@language"] = label_binding['xml:lang']
            _add_value_to_json_ld_object(json_ld_node, RDFS_LABEL_URI, label_obj)

        if node_attributes_map:
            for attr_var, pred_uri in node_attributes_map.items():
                if attr_var in binding:
                    attr_binding = binding[attr_var]
                    ld_literal = {"@value": attr_binding['value']}
                    if 'datatype' in attr_binding: ld_literal["@type"] = attr_binding['datatype']
                    if 'xml:lang' in attr_binding: ld_literal["@language"] = attr_binding['xml:lang']
                    _add_value_to_json_ld_object(json_ld_node, pred_uri, ld_literal)

        if node_group_id_var and json_ld_group_predicate_uri and node_group_id_var in binding:
            group_id = binding[node_group_id_var]['value']
            _create_minimal_jsonld_entry(group_id, json_ld_objects)
            _add_value_to_json_ld_object(json_ld_node, json_ld_group_predicate_uri, {"@id": group_id})

    # 2. Process Group Query
    if group_query and group_id_var and group_label_var:
        group_results_json = _execute_sparql_query(group_query, "Group Query")
        if "error" in group_results_json: return group_results_json
        for binding in group_results_json.get('results', {}).get('bindings', []):
            if group_id_var in binding and group_label_var in binding:
                gid = binding[group_id_var]['value']
                glabel_binding = binding[group_label_var]
                json_ld_group = json_ld_objects.setdefault(gid, {"@id": gid})
                label_obj = {"@value": glabel_binding['value']}
                if 'xml:lang' in glabel_binding: label_obj["@language"] = glabel_binding['xml:lang']
                _add_value_to_json_ld_object(json_ld_group, RDFS_LABEL_URI, label_obj)

    # 3. Process Edge Query
    edge_results_json = _execute_sparql_query(edge_query, "Edge Query")
    if "error" in edge_results_json: return edge_results_json
    for binding in edge_results_json.get('results', {}).get('bindings', []):
        if not (edge_source_var in binding and edge_target_var in binding and edge_predicate_var in binding): continue
        source_id = binding[edge_source_var]['value']
        target_id = binding[edge_target_var]['value']
        predicate_uri = binding[edge_predicate_var]['value']
        _create_minimal_jsonld_entry(source_id, json_ld_objects)
        _create_minimal_jsonld_entry(target_id, json_ld_objects)
        json_ld_source_node = json_ld_objects.get(source__id)
        if json_ld_source_node:
            _add_value_to_json_ld_object(json_ld_source_node, predicate_uri, {"@id": target_id})

    return {"@context": json_ld_context, "@graph": list(json_ld_objects.values())}

# --- FastAPI Pydantic Model for API Request Body ---
class SparqlQueries(BaseModel):
    # Core required fields
    node_query: str = Field(..., description="User-provided SPARQL query to define nodes and their literal attributes.")
    node_id_var: str = Field(..., description="Variable in node_query for node ID.")
    
    edge_query: str = Field(..., description="User-provided SPARQL query to define edges (relationships).")
    edge_source_var: str = Field(..., description="Variable in edge_query for the source node of an edge.")
    edge_target_var: str = Field(..., description="Variable in edge_query for the target node of an edge.")
    edge_predicate_var: str = Field(..., description="Variable in edge_query for the edge's predicate URI.")

    # Optional fields for enhancing the output
    node_label_var: Optional[str] = Field(None, description="Optional: Variable in node_query for the node's rdfs:label.")
    node_attributes_map: Optional[Dict[str, str]] = Field(None, description="Optional: Map of query variables to predicate URIs for node attributes.")
    node_group_id_var: Optional[str] = Field(None, description="Optional: Variable in node_query that identifies the node's group.")
    
    group_query: Optional[str] = Field(None, description="Optional: SPARQL query to define group labels explicitly.")
    group_id_var: Optional[str] = Field(None, description="Variable in group_query for the group's ID.")
    group_label_var: Optional[str] = Field(None, description="Variable in group_query for the group's rdfs:label.")
    
    json_ld_group_predicate_uri: Optional[str] = Field(None, description="Optional: The predicate URI to link a node to its group in JSON-LD.")

# --- FastAPI App & Endpoint ---
# The FastAPI app object
app = FastAPI(
    title="SPARQL to JSON-LD Service",
    description="A simple API that connects to a pre-configured SPARQL endpoint and transforms query results into JSON-LD.",
    version="2.0.0"
)

@app.post("/query-to-jsonld", summary="Transform SPARQL Queries to JSON-LD")
async def convert_sparql_to_jsonld(queries: SparqlQueries = Body(...)):
    """
    Accepts SPARQL queries for nodes, edges, and groups. It uses the
    endpoint and token configured at startup to execute these queries and returns a
    single, unified JSON-LD graph.
    """
    if not config.ENDPOINT_URL:
        raise HTTPException(status_code=503, detail="SPARQL endpoint not configured. The service was not started correctly with the --endpoint option.")
    
    result = generate_jsonld_from_queries(**queries.model_dump())

    if "error" in result:
        # Determine appropriate status code for errors
        status_code = 400 # Bad Request for user query errors
        if "HTTP error" in result.get("error", ""):
            status_code = 502 # Bad Gateway for upstream endpoint errors
        elif "Request failed" in result.get("error", ""):
            status_code = 504 # Gateway Timeout for connection issues
        raise HTTPException(status_code=status_code, detail=result)

    return result

# --- Command-Line Interface to run the App ---
# Use Typer to create a CLI command that configures and starts the server
cli = typer.Typer()

@cli.command()
def start(
    endpoint: str = typer.Option(..., "--endpoint", "-e", help="The full URL of the SPARQL endpoint to connect to."),
    token: Optional[str] = typer.Option(None, "--token", "-t", help="Optional Bearer token for endpoint authentication."),
    host: str = typer.Option("127.0.0.1", help="The host to bind the server to."),
    port: int = typer.Option(8000, help="The port to run the server on.")
):
    """
    Starts the FastAPI server, configured for a specific SPARQL endpoint.
    """
    # Store the endpoint and token from the command line into the global config object
    config.ENDPOINT_URL = endpoint
    config.BEARER_TOKEN = token
    typer.echo(f"🚀 Starting server for SPARQL endpoint: {config.ENDPOINT_URL}")
    typer.echo(f"API will be available at http://{host}:{port}")
    
    # Run the Uvicorn server with the FastAPI app
    uvicorn.run(app, host=host, port=port)

# --- Main Entry Point ---
if __name__ == "__main__":
    # This makes the script runnable.
    # To use, run the following command in your terminal:
    # python main.py start --endpoint "YOUR_SPARQL_ENDPOINT_URL" --token "YOUR_OPTIONAL_TOKEN"
    cli()
