"""
Azure AD token management aligned with existing codebase patterns.
This module ensures consistent token handling across synchronous and asynchronous contexts
using the get_bearer_token_provider pattern from your existing code.
"""

import logging
import time
import threading
import os
import traceback
from typing import Optional, Dict, Any
from dotenv import dotenv_values
from azure.identity import (
    DefaultAzureCredential, 
    ClientSecretCredential,
    get_bearer_token_provider
)

logger = logging.getLogger(__name__)

# Load credentials directly from file
credentials_path = os.path.join("env", "credentials.env")
config_path = os.path.join("env", "config.env")
credentials_values = {}
config_values = {}

try:
    if os.path.isfile(credentials_path):
        logger.info(f"Auth helper loading credentials from {credentials_path}")
        credentials_values = dotenv_values(credentials_path)
        logger.info(f"Loaded {len(credentials_values)} values from {credentials_path}")
    else:
        logger.warning(f"Credentials file not found: {credentials_path}")
        
    if os.path.isfile(config_path):
        logger.info(f"Auth helper loading config from {config_path}")
        config_values = dotenv_values(config_path)
        logger.info(f"Loaded {len(config_values)} values from {config_path}")
    else:
        logger.warning(f"Config file not found: {config_path}")
except Exception as e:
    logger.error(f"Error loading env files: {e}")

# Combine both sets of values, with credentials taking precedence
all_values = {**config_values, **credentials_values}

# Extract Azure AD credentials directly
AZURE_TENANT_ID = all_values.get("AZURE_TENANT_ID", "")
AZURE_CLIENT_ID = all_values.get("AZURE_CLIENT_ID", "")
AZURE_CLIENT_SECRET = all_values.get("AZURE_CLIENT_SECRET", "")
AZURE_OPENAI_ENDPOINT = all_values.get("AZURE_OPENAI_ENDPOINT", "")
USE_MANAGED_IDENTITY = all_values.get("USE_MANAGED_IDENTITY", "False").lower() in ("true", "1", "yes", "y")

# Log credential status (masked for security)
if AZURE_TENANT_ID and AZURE_CLIENT_ID and AZURE_CLIENT_SECRET:
    masked_tenant = f"{AZURE_TENANT_ID[:4]}...{AZURE_TENANT_ID[-4:]}" if len(AZURE_TENANT_ID) > 8 else "***"
    masked_client = f"{AZURE_CLIENT_ID[:4]}...{AZURE_CLIENT_ID[-4:]}" if len(AZURE_CLIENT_ID) > 8 else "***"
    logger.info(f"Using Azure credentials - tenant_id: {masked_tenant}, client_id: {masked_client}")
else:
    logger.warning("One or more Azure credentials are missing or invalid")

class AzureCredentialManager:
    """Singleton manager for Azure credentials and token providers."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(AzureCredentialManager, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the credential manager."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._credential = None
                self._token_provider = None
                self._last_init_time = 0
                self._refresh_interval = 55 * 60  # 55 minutes (tokens typically last 60 min)
                self._initialize_credential()
                self._initialized = True
                logger.info("Azure credential manager initialized")
    
    def _initialize_credential(self):
        """Initialize Azure credential."""
        try:
            if USE_MANAGED_IDENTITY:
                logger.info("Using DefaultAzureCredential (managed identity)")
                self._credential = DefaultAzureCredential()
            else:
                # Validate credentials
                if not AZURE_TENANT_ID or AZURE_TENANT_ID == "your-tenant-id-here":
                    logger.error("Invalid tenant_id: empty or using default value")
                    raise ValueError("Invalid AZURE_TENANT_ID")
                    
                if not AZURE_CLIENT_ID or AZURE_CLIENT_ID == "your-client-id-here":
                    logger.error("Invalid client_id: empty or using default value")
                    raise ValueError("Invalid AZURE_CLIENT_ID")
                    
                if not AZURE_CLIENT_SECRET or AZURE_CLIENT_SECRET == "your-client-secret-here":
                    logger.error("Invalid client_secret: empty or using default value")
                    raise ValueError("Invalid AZURE_CLIENT_SECRET")
                
                logger.info("Using ClientSecretCredential")
                self._credential = ClientSecretCredential(
                    tenant_id=AZURE_TENANT_ID,
                    client_id=AZURE_CLIENT_ID,
                    client_secret=AZURE_CLIENT_SECRET
                )
            
            # Create token provider
            self._token_provider = get_bearer_token_provider(
                self._credential,
                "https://cognitiveservices.azure.com/.default"
            )
            
            self._last_init_time = time.time()
            logger.info("Azure credential and token provider initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing Azure credential: {e}")
            logger.error(traceback.format_exc())
            raise
    
    def get_credential(self, force_refresh: bool = False):
        """
        Get the Azure credential, refreshing if needed.
        
        Args:
            force_refresh: Force refresh the credential
            
        Returns:
            Azure credential
        """
        with self._lock:
            current_time = time.time()
            # Refresh credential if it's time or forced
            if force_refresh or (current_time - self._last_init_time) > self._refresh_interval:
                logger.info("Refreshing Azure credential")
                self._initialize_credential()
            
            return self._credential
    
    def get_token_provider(self, force_refresh: bool = False):
        """
        Get the Azure token provider, refreshing if needed.
        
        Args:
            force_refresh: Force refresh the token provider
            
        Returns:
            Azure token provider
        """
        with self._lock:
            # Refresh credential and token provider if needed
            self.get_credential(force_refresh)
            return self._token_provider
    
    def get_token(self, scope: str = "https://cognitiveservices.azure.com/.default", force_refresh: bool = False):
        """
        Get an Azure AD token directly.
        
        Args:
            scope: OAuth scope to request
            force_refresh: Force refresh the credential
            
        Returns:
            Access token if successful, None otherwise
        """
        try:
            credential = self.get_credential(force_refresh)
            token = credential.get_token(scope)
            
            if token and token.token:
                # Log the token (partially masked)
                token_prefix = token.token[:10] if len(token.token) > 20 else token.token[:5]
                token_suffix = token.token[-10:] if len(token.token) > 20 else token.token[-5:]
                logger.info(f"Received token: {token_prefix}...{token_suffix}")
                
                return token.token
            else:
                logger.error("No token received from Azure AD")
                return None
        except Exception as e:
            logger.error(f"Error getting Azure token: {e}")
            logger.error(traceback.format_exc())
            return None


# Global credential manager instance
credential_manager = AzureCredentialManager()

def get_azure_credential(force_refresh: bool = False):
    """
    Get the Azure credential, refreshing if needed.
    
    Args:
        force_refresh: Force refresh the credential
        
    Returns:
        Azure credential
    """
    return credential_manager.get_credential(force_refresh)

def get_azure_token_provider(force_refresh: bool = False):
    """
    Get the Azure token provider, refreshing if needed.
    
    Args:
        force_refresh: Force refresh the token provider
        
    Returns:
        Azure token provider
    """
    return credential_manager.get_token_provider(force_refresh)

def get_azure_token(scope: str = "https://cognitiveservices.azure.com/.default", force_refresh: bool = False):
    """
    Get an Azure AD token directly.
    
    Args:
        scope: OAuth scope to request
        force_refresh: Force refresh the credential
        
    Returns:
        Access token if successful, None otherwise
    """
    return credential_manager.get_token(scope, force_refresh)


# Token refresh background service
class TokenRefreshService:
    """Service for refreshing Azure credentials periodically."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TokenRefreshService, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the token refresh service."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._thread = None
                self._running = False
                self._initialized = True
                logger.info("Token refresh service initialized")
    
    def start(self, refresh_interval: int = 1800):  # Default 30 minutes
        """
        Start the token refresh service.
        
        Args:
            refresh_interval: Interval between refresh checks in seconds
        """
        with self._lock:
            if self._thread is not None and self._thread.is_alive():
                logger.info("Token refresh service is already running")
                return self._thread
            
            self._running = True
            self._thread = threading.Thread(
                target=self._refresh_worker,
                args=(refresh_interval,),
                daemon=True,
                name="TokenRefreshThread"
            )
            self._thread.start()
            logger.info(f"Token refresh service started (interval: {refresh_interval}s)")
            
            return self._thread
    
    def stop(self):
        """Stop the token refresh service."""
        with self._lock:
            self._running = False
            logger.info("Token refresh service stopping (will complete current cycle)")
    
    def _refresh_worker(self, refresh_interval: int):
        """
        Worker function for refreshing credentials periodically.
        
        Args:
            refresh_interval: Interval between refresh checks in seconds
        """
        # Initial delay to let the application start up
        time.sleep(10)
        
        logger.info("Token refresh worker started")
        
        while self._running:
            try:
                # Force refresh the credential which will recreate the token provider
                credential_manager.get_credential(force_refresh=True)
                logger.info("Azure credentials refreshed successfully")
            except Exception as e:
                logger.error(f"Error in token refresh worker: {e}")
                logger.error(traceback.format_exc())
            
            # Sleep for the specified interval
            sleep_counter = 0
            while sleep_counter < refresh_interval and self._running:
                time.sleep(1)  # Sleep in 1-second increments for faster stopping
                sleep_counter += 1


# Global refresh service instance
token_refresh_service = TokenRefreshService()

def start_token_refresh_service(refresh_interval: int = 1800) -> threading.Thread:
    """
    Start the token refresh service.
    
    Args:
        refresh_interval: Interval between refresh checks in seconds
        
    Returns:
        The background thread
    """
    return token_refresh_service.start(refresh_interval)


# Simplified auth functions for FastAPI dependency injection
async def verify_api_key(api_key: str = None):
    """
    No API key verification required.
    This function always returns True.
    """
    return True


async def get_current_user(token: str = None):
    """
    Simplified user authentication.
    For direct connection without auth, this just returns a default user.
    """
    # Create a simple user object
    user = {"username": "default_user"}
    return user
