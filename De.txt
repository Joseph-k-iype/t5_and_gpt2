import type {
  ChatSession,
  SendMessageRequest,
  SendMessageResponse,
  StartResearchRequest,
  StartResearchResponse,
  HealthCheckResponse,
  DiagnosticsResponse,
} from '../types';

// Configuration
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000';
const API_TIMEOUT = 30000; // 30 seconds

// Custom error class for API errors
export class ApiError extends Error {
  constructor(
    message: string,
    public status?: number,
    public code?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// HTTP client configuration
class HttpClient {
  private baseURL: string;
  private timeout: number;
  private defaultHeaders: Record<string, string>;

  constructor(baseURL: string, timeout: number = API_TIMEOUT) {
    this.baseURL = baseURL.replace(/\/$/, ''); // Remove trailing slash
    this.timeout = timeout;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
  }

  private async request<T = unknown>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...this.defaultHeaders,
          ...options.headers
        },
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      // Handle non-JSON responses
      const contentType = response.headers.get('content-type');
      const isJson = contentType?.includes('application/json');

      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        let errorDetails: unknown = null;

        if (isJson) {
          try {
            const errorData = await response.json();
            errorMessage = (errorData as { error?: string; message?: string }).error || 
                          (errorData as { error?: string; message?: string }).message || 
                          errorMessage;
            errorDetails = errorData;
          } catch {
            // Ignore JSON parsing errors for error responses
          }
        } else {
          try {
            errorMessage = await response.text() || errorMessage;
          } catch {
            // Ignore text parsing errors
          }
        }

        throw new ApiError(
          errorMessage,
          response.status,
          response.status.toString(),
          errorDetails
        );
      }

      if (!isJson) {
        throw new ApiError(
          'Expected JSON response but received: ' + (contentType || 'unknown'),
          response.status
        );
      }

      const data = await response.json();
      return data as T;

    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof ApiError) {
        throw error;
      }

      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          throw new ApiError('Request timeout', 408, 'TIMEOUT');
        }
        
        if (error.message.includes('fetch')) {
          throw new ApiError(
            'Network error - please check your connection',
            0,
            'NETWORK_ERROR'
          );
        }
      }

      throw new ApiError(
        error instanceof Error ? error.message : 'Unknown error occurred',
        0,
        'UNKNOWN_ERROR',
        error
      );
    }
  }

  async get<T = unknown>(endpoint: string, headers?: Record<string, string>): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'GET',
      headers
    });
  }

  async post<T = unknown>(
    endpoint: string,
    data?: unknown,
    headers?: Record<string, string>
  ): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      headers,
      body: data ? JSON.stringify(data) : undefined
    });
  }

  async put<T = unknown>(
    endpoint: string,
    data?: unknown,
    headers?: Record<string, string>
  ): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      headers,
      body: data ? JSON.stringify(data) : undefined
    });
  }

  async delete<T = unknown>(
    endpoint: string,
    headers?: Record<string, string>
  ): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'DELETE',
      headers
    });
  }
}

// Create HTTP client instance
const httpClient = new HttpClient(API_BASE_URL);

// API Client class
export class PrivacyChatbotApiClient {
  private client: HttpClient;

  constructor(client: HttpClient) {
    this.client = client;
  }

  // Health check
  async checkHealth(): Promise<HealthCheckResponse> {
    try {
      const response = await this.client.get<HealthCheckResponse>('/api/health');
      return response;
    } catch (error) {
      console.error('Health check failed:', error);
      throw error;
    }
  }

  // Start chat session
  async startChatSession(): Promise<ChatSession> {
    try {
      const response = await this.client.post<ChatSession>('/api/chat/start');
      return response;
    } catch (error) {
      console.error('Failed to start chat session:', error);
      throw error;
    }
  }

  // Send message
  async sendMessage(request: SendMessageRequest): Promise<SendMessageResponse> {
    try {
      if (!request.session_id || !request.message?.trim()) {
        throw new ApiError('Session ID and message are required', 400, 'INVALID_REQUEST');
      }

      const response = await this.client.post<SendMessageResponse>(
        '/api/chat/message',
        request
      );
      return response;
    } catch (error) {
      console.error('Failed to send message:', error);
      throw error;
    }
  }

  // Start deep research
  async startDeepResearch(request: StartResearchRequest): Promise<StartResearchResponse> {
    try {
      if (!request.session_id || !request.topic?.trim()) {
        throw new ApiError('Session ID and topic are required', 400, 'INVALID_REQUEST');
      }

      const response = await this.client.post<StartResearchResponse>(
        '/api/chat/deep-research',
        request
      );
      return response;
    } catch (error) {
      console.error('Failed to start deep research:', error);
      throw error;
    }
  }

  // Get chat history
  async getChatHistory(sessionId: string): Promise<{
    session_id: string;
    messages: unknown[];
    is_processing: boolean;
    research_state: unknown;
  }> {
    try {
      if (!sessionId) {
        throw new ApiError('Session ID is required', 400, 'INVALID_REQUEST');
      }

      const response = await this.client.get(`/api/chat/history/${sessionId}`);
      return response as {
        session_id: string;
        messages: unknown[];
        is_processing: boolean;
        research_state: unknown;
      };
    } catch (error) {
      console.error('Failed to get chat history:', error);
      throw error;
    }
  }

  // Get diagnostics
  async getDiagnostics(): Promise<DiagnosticsResponse> {
    try {
      const response = await this.client.get<DiagnosticsResponse>('/api/diagnostics');
      return response;
    } catch (error) {
      console.error('Failed to get diagnostics:', error);
      throw error;
    }
  }

  // Test connection
  async testConnection(): Promise<boolean> {
    try {
      await this.checkHealth();
      return true;
    } catch {
      return false;
    }
  }

  // Retry mechanism for failed requests
  async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error');
        
        // Don't retry on client errors (4xx)
        if (error instanceof ApiError && error.status && error.status >= 400 && error.status < 500) {
          throw error;
        }

        if (attempt < maxRetries) {
          console.log(`Request failed (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }

    throw lastError!;
  }
}

// Create and export API client instance
export const apiClient = new PrivacyChatbotApiClient(httpClient);

// Utility functions
export const isApiError = (error: unknown): error is ApiError => {
  return error instanceof ApiError;
};

export const getErrorMessage = (error: unknown): string => {
  if (isApiError(error)) {
    return error.message;
  }
  
  if (error instanceof Error) {
    return error.message;
  }
  
  if (typeof error === 'string') {
    return error;
  }
  
  return 'An unknown error occurred';
};

export const isNetworkError = (error: unknown): boolean => {
  return isApiError(error) && error.code === 'NETWORK_ERROR';
};

export const isTimeoutError = (error: unknown): boolean => {
  return isApiError(error) && error.code === 'TIMEOUT';
};

export const isServerError = (error: unknown): boolean => {
  return isApiError(error) && error.status !== undefined && error.status >= 500;
};

export const isClientError = (error: unknown): boolean => {
  return isApiError(error) && error.status !== undefined && error.status >= 400 && error.status < 500;
};

// Default export
export default apiClient;
