"""
PBT Client - Client library for interacting with the PBT Tagging API.

This module provides a client library for interacting with the PBT Tagging API,
making it easy to tag data elements with Preferred Business Terms (PBTs).
"""

import time
import json
import requests
from typing import Dict, Any, List, Optional
from pydantic import BaseModel

class PBTTaggingClient:
    """Client for interacting with the PBT Tagging API."""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        """
        Initialize the PBT Tagging client.
        
        Args:
            base_url: Base URL of the API
        """
        self.base_url = base_url
        self.api_path = "/api/v1/pbt"
    
    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:
        """
        Handle the API response.
        
        Args:
            response: Response from the API
            
        Returns:
            Response data as dictionary
            
        Raises:
            Exception: If the response status code is not 200
        """
        if response.status_code != 200:
            try:
                error_data = response.json()
                error_message = error_data.get("detail", "Unknown error")
            except ValueError:
                error_message = response.text
            
            raise Exception(f"API error: {response.status_code} - {error_message}")
        
        return response.json()
    
    def tag(self, name: str, description: str, top_n: int = 5, 
            examples: Optional[List[str]] = None,
            process_name: Optional[str] = None,
            process_description: Optional[str] = None) -> Dict[str, Any]:
        """
        Tag an item with PBTs synchronously.
        
        Args:
            name: Name of the item to tag
            description: Description of the item to tag
            top_n: Number of top PBTs to return
            examples: Optional list of example values or contexts
            process_name: Optional name of the business process
            process_description: Optional description of the business process
            
        Returns:
            Dictionary with tagging results
        """
        url = f"{self.base_url}{self.api_path}/tag"
        
        data = {
            "name": name,
            "description": description,
            "top_n": top_n
        }
        
        if examples:
            data["examples"] = examples
        if process_name:
            data["process_name"] = process_name
        if process_description:
            data["process_description"] = process_description
        
        response = requests.post(url, json=data)
        return self._handle_response(response)
    
    def tag_async(self, name: str, description: str, top_n: int = 5,
                examples: Optional[List[str]] = None,
                process_name: Optional[str] = None,
                process_description: Optional[str] = None) -> str:
        """
        Tag an item with PBTs asynchronously.
        
        Args:
            name: Name of the item to tag
            description: Description of the item to tag
            top_n: Number of top PBTs to return
            examples: Optional list of example values or contexts
            process_name: Optional name of the business process
            process_description: Optional description of the business process
            
        Returns:
            Job ID for checking status later
        """
        url = f"{self.base_url}{self.api_path}/tag-async"
        
        data = {
            "name": name,
            "description": description,
            "top_n": top_n
        }
        
        if examples:
            data["examples"] = examples
        if process_name:
            data["process_name"] = process_name
        if process_description:
            data["process_description"] = process_description
        
        response = requests.post(url, json=data)
        result = self._handle_response(response)
        
        return result["job_id"]
    
    def get_status(self, job_id: str) -> Dict[str, Any]:
        """
        Get the status of an asynchronous tagging job.
        
        Args:
            job_id: ID of the job to check
            
        Returns:
            Dictionary with job status and results if available
        """
        url = f"{self.base_url}{self.api_path}/status/{job_id}"
        
        response = requests.get(url)
        return self._handle_response(response)
    
    def wait_for_completion(self, job_id: str, timeout: int = 300, poll_interval: int = 2) -> Dict[str, Any]:
        """
        Wait for an asynchronous tagging job to complete.
        
        Args:
            job_id: ID of the job to wait for
            timeout: Maximum time to wait in seconds
            poll_interval: Time between status checks in seconds
            
        Returns:
            Dictionary with job results
            
        Raises:
            TimeoutError: If the job doesn't complete within the timeout
            Exception: If the job fails
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            status = self.get_status(job_id)
            
            if status["status"] == "completed":
                return status["result"]
            elif status["status"] == "failed":
                raise Exception(f"Job failed: {status.get('error', 'Unknown error')}")
            
            time.sleep(poll_interval)
        
        raise TimeoutError(f"Job did not complete within {timeout} seconds")
    
    def batch_tag(self, items: List[Dict[str, Any]]) -> List[str]:
        """
        Tag multiple items with PBTs in batch mode.
        
        Args:
            items: List of dictionaries with name, description, and optional fields
            
        Returns:
            List of job IDs for checking status later
        """
        url = f"{self.base_url}{self.api_path}/batch"
        
        data = []
        for item in items:
            item_data = {
                "name": item["name"],
                "description": item["description"],
                "top_n": item.get("top_n", 5)
            }
            
            if "examples" in item:
                item_data["examples"] = item["examples"]
            if "process_name" in item:
                item_data["process_name"] = item["process_name"]
            if "process_description" in item:
                item_data["process_description"] = item["process_description"]
            
            data.append(item_data)
        
        response = requests.post(url, json=data)
        results = self._handle_response(response)
        
        return [result["job_id"] for result in results]
    
    def delete_job(self, job_id: str) -> Dict[str, Any]:
        """
        Delete a tagging job.
        
        Args:
            job_id: ID of the job to delete
            
        Returns:
            Dictionary with deletion status
        """
        url = f"{self.base_url}{self.api_path}/job/{job_id}"
        
        response = requests.delete(url)
        return self._handle_response(response)

# Example usage
if __name__ == "__main__":
    # Initialize client
    client = PBTTaggingClient()
    
    # Example 1: Synchronous tagging
    result = client.tag(
        name="Account Number",
        description="A unique identifier for a customer account"
    )
    print(json.dumps(result, indent=2))
    
    # Example 2: Asynchronous tagging
    job_id = client.tag_async(
        name="Customer ID",
        description="A unique identifier for a customer in the system",
        examples=["12345", "CID-789"],
        process_name="Customer Onboarding",
        process_description="Process for registering new customers"
    )
    print(f"Job ID: {job_id}")
    
    # Wait for completion
    try:
        result = client.wait_for_completion(job_id)
        print(json.dumps(result, indent=2))
    except Exception as e:
        print(f"Error: {e}")
    
    # Example 3: Batch tagging
    job_ids = client.batch_tag([
        {
            "name": "Email Address",
            "description": "Electronic mail address of a customer"
        },
        {
            "name": "Phone Number",
            "description": "Contact telephone number for a customer"
        }
    ])
    print(f"Batch job IDs: {job_ids}")
