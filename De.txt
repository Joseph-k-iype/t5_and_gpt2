import pandas as pd
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
import rdflib
from rdflib.plugins.stores.sparqlstore import SPARQLUpdateStore
import os
import sys

# Helper function to create a table with specified headers and rows
def create_table(slide, headers, num_rows, top_position, slide_width=Inches(10)):
    cols = len(headers)
    table = slide.shapes.add_table(num_rows, cols, Inches(0.5), top_position, slide_width, Inches(0.5)).table
    for col_idx, header in enumerate(headers):
        cell = table.cell(0, col_idx)
        cell.text = header
        cell.fill.solid()
        cell.fill.fore_color.rgb = RGBColor(0x48, 0x8F, 0x29)
        for paragraph in cell.text_frame.paragraphs:
            for run in paragraph.runs:
                run.font.size = Pt(10)
                run.font.bold = True
                run.font.color.rgb = RGBColor(255, 255, 255)
    return table

# Function to populate a table with data
def populate_table(table, data, start_row=1):
    for row_idx, row_data in enumerate(data, start=start_row):
        for col_idx, cell_data in enumerate(row_data):
            cell = table.cell(row_idx, col_idx)
            cell.text = str(cell_data)
            cell.fill.solid()
            cell.fill.fore_color.rgb = RGBColor(255, 255, 255)
            for paragraph in cell.text_frame.paragraphs:
                for run in paragraph.runs:
                    run.font.size = Pt(10)
                    run.font.color.rgb = RGBColor(0, 0, 0)

# Populate Slide 6
def populate_slide_6(slide, df):
    delete_existing_tables(slide)
    headers = ["Process", "Consumed or Produced", "Business", "Process Owner", "Total Metrics", "BDEs at Boundary Level", "Pass Through BDEs", "Pass Through Metrics"]
    table = create_table(slide, headers, num_rows=1 + 2 * df['Process'].nunique(), top_position=Inches(1))

    row_data = []
    for process in df['Process'].unique():
        process_data = df[df['Process'] == process]

        # Dictionary for consumed calculations
        consumed_calculations = {
            "total_metrics": process_data['Consumed Metric'].loc[process_data['Consumed Metric'] != ''].nunique(),
            "boundary_bdes": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Inbound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('In-bound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False))
            ]['Consumed BDE'].nunique(),
            "pass_through_bdes": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False))
            ]['Consumed BDE'].nunique(),
            "pass_through_metrics": process_data[
                (process_data['Consumed Metric'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False))
            ]['Consumed Metric'].nunique()
        }

        row_data.append([
            process, 'Consumed', process_data['Business'].iloc[0] if 'Business' in process_data.columns else '',
            process_data['Process Owner'].iloc[0] if 'Process Owner' in process_data.columns else '',
            consumed_calculations["total_metrics"], consumed_calculations["boundary_bdes"],
            consumed_calculations["pass_through_bdes"], consumed_calculations["pass_through_metrics"]
        ])

        # Dictionary for produced calculations
        produced_calculations = {
            "total_metrics": process_data['Produced Metric'].loc[process_data['Produced Metric'] != ''].nunique(),
            "boundary_bdes": process_data[
                (process_data['Produced BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Process Output', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Process-Output', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'to Intra[ -]?Process$', case=False, na=False))
            ]['Produced BDE'].nunique(),
            "pass_through_bdes": process_data[
                (process_data['Produced BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'to Intra[ -]?Process$', case=False, na=False))
            ]['Produced BDE'].nunique(),
            "pass_through_metrics": process_data[
                (process_data['Produced Metric'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'to Intra[ -]?Process$', case=False, na=False))
            ]['Produced Metric'].nunique()
        }

        row_data.append([
            process, 'Produced', process_data['Business'].iloc[0] if 'Business' in process_data.columns else '',
            process_data['Process Owner'].iloc[0] if 'Process Owner' in process_data.columns else '',
            produced_calculations["total_metrics"], produced_calculations["boundary_bdes"],
            produced_calculations["pass_through_bdes"], produced_calculations["pass_through_metrics"]
        ])

    populate_table(table, row_data)

# Populate Slide 8
def populate_slide_8(slide, df, csv_data):
    delete_existing_tables(slide)
    headers = [
        "Process", "Consumed or Produced", "Total BDEs", "Total BDEs Agreed to Monitor", "% BDE Monitored",
        "BDEs at Boundary Level", "Boundary BDEs Agreed to Monitor", "% Boundary BDE Monitored",
        "Pass Through BDEs", "Pass Through BDEs Agreed to Monitor", "% Pass Through BDE Monitored",
        "Total Metrics", "Total Metrics Agreed to Monitor", "% Metrics Monitored",
        "Pass Through Metrics", "Pass Through Metrics Agreed to Monitor", "% Pass Through Metrics Monitored"
    ]
    
    table = create_table(slide, headers, num_rows=1 + 2 * df['Process'].nunique(), top_position=Inches(1))

    row_data = []
    for process in df['Process'].unique():
        process_data = df[df['Process'] == process]

        # Consumed calculations in dictionary format
        consumed_calculations = {
            "total_bdes": process_data['Consumed BDE'].loc[process_data['Consumed BDE'] != ''].nunique(),
            "total_bdes_monitored": process_data[(process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique(),
            "boundary_bdes": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Inbound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('In-bound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False))
            ]['Consumed BDE'].nunique(),
            "boundary_bdes_monitored": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Inbound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('In-bound Element', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False)) &
                (process_data['Monitored'] != '')
            ]['Consumed BDE'].nunique(),
            "pass_through_bdes": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False))
            ]['Consumed BDE'].nunique(),
            "pass_through_bdes_monitored": process_data[
                (process_data['Consumed BDE'] != '') &
                (
                    process_data['Flow Type'].str.contains('Pass Through', case=False, na=False) |
                    process_data['Flow Type'].str.contains('Pass-Through', case=False, na=False)
                ) &
                (~process_data['Flow Type'].str.match(r'^Intra[ -]?Process$', case=False, na=False)) &
                (~process_data['Flow Type'].str.contains(r'^Intra[ -]?Process to', case=False, na=False)) &
                (process_data['Monitored'] != '')
            ]['Consumed BDE'].nunique()
        }

        row_data.append([
            process, 'Consumed', consumed_calculations["total_bdes"], consumed_calculations["total_bdes_monitored"],
            f"{(consumed_calculations['total_bdes_monitored'] / consumed_calculations['total_bdes'] * 100) if consumed_calculations['total_bdes'] else 0:.2f}%",
            consumed_calculations["boundary_bdes"], consumed_calculations["boundary_bdes_monitored"],
            f"{(consumed_calculations['boundary_bdes_monitored'] / consumed_calculations['boundary_bdes'] * 100) if consumed_calculations['boundary_bdes'] else 0:.2f}%",
            consumed_calculations["pass_through_bdes"], consumed_calculations["pass_through_bdes_monitored"],
            f"{(consumed_calculations['pass_through_bdes_monitored'] / consumed_calculations['pass_through_bdes'] * 100) if consumed_calculations['pass_through_bdes'] else 0:.2f}%"
        ])

    populate_table(table, row_data)
    csv_data.extend(row_data)
