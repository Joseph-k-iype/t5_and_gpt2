"""
LangGraph-based Legislation to Machine-Readable JSON Rules Converter
Using React Agent Pattern with o3-mini reasoning model and custom tools

This system converts legislation text into JSON rules compatible with json-rules-engine
"""

import json
import re
import asyncio
from typing import List, Dict, Any, Optional, Annotated, Sequence
from dataclasses import dataclass
from enum import Enum

from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, SystemMessage
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode, tools_condition
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel, Field


# State Management
class AgentState(BaseModel):
    """State for the legislation processing agent"""
    messages: Annotated[Sequence[BaseMessage], add_messages]
    legislation_text: str = ""
    extracted_rules: List[Dict[str, Any]] = []
    json_rules: List[Dict[str, Any]] = []
    processing_step: str = "initial"
    metadata: Dict[str, Any] = {}


class RuleType(Enum):
    """Types of rules that can be extracted from legislation"""
    CONDITIONAL = "conditional"
    REQUIREMENT = "requirement"
    PROHIBITION = "prohibition"
    DEFINITION = "definition"
    PROCEDURE = "procedure"
    PENALTY = "penalty"
    EXCEPTION = "exception"


@dataclass
class LegislationRule:
    """Structured representation of a rule extracted from legislation"""
    rule_id: str
    rule_type: RuleType
    title: str
    description: str
    conditions: List[str]
    actions: List[str]
    references: List[str]
    keywords: List[str]
    confidence: float


# Custom Tools for Legislation Processing

@tool
def parse_legislation_structure(legislation_text: str) -> Dict[str, Any]:
    """
    Parse the structure of legislation text to identify sections, subsections, and articles.
    
    Args:
        legislation_text: Raw legislation text
        
    Returns:
        Dictionary containing structured legislation with sections and subsections
    """
    # Pattern matching for common legislation structures
    patterns = {
        'section': r'(?:Section|Sec\.?)\s+(\d+(?:\.\d+)*)[:\.\s]+(.*?)(?=(?:Section|Sec\.?)\s+\d+|$)',
        'article': r'(?:Article|Art\.?)\s+(\d+(?:\.\d+)*)[:\.\s]+(.*?)(?=(?:Article|Art\.?)\s+\d+|$)',
        'subsection': r'(?:^|\n)\s*\(([a-z]|\d+)\)\s+(.*?)(?=\n\s*\([a-z]|\d+\)|$)',
        'paragraph': r'(?:^|\n)\s*(\d+)\.\s+(.*?)(?=\n\s*\d+\.|$)',
        'clause': r'(?:^|\n)\s*\(i+\)\s+(.*?)(?=\n\s*\(i+\)|$)'
    }
    
    structure = {
        'title': '',
        'sections': [],
        'articles': [],
        'definitions': [],
        'raw_text': legislation_text
    }
    
    # Extract title (usually first few lines)
    lines = legislation_text.split('\n')
    title_lines = []
    for line in lines[:5]:
        if line.strip() and not re.match(r'(?:Section|Article)', line):
            title_lines.append(line.strip())
    structure['title'] = ' '.join(title_lines)
    
    # Extract sections
    sections = re.findall(patterns['section'], legislation_text, re.DOTALL | re.MULTILINE)
    for section_num, section_text in sections:
        section_obj = {
            'number': section_num,
            'text': section_text.strip(),
            'subsections': []
        }
        
        # Extract subsections within this section
        subsections = re.findall(patterns['subsection'], section_text, re.DOTALL | re.MULTILINE)
        for subsec_id, subsec_text in subsections:
            section_obj['subsections'].append({
                'id': subsec_id,
                'text': subsec_text.strip()
            })
        
        structure['sections'].append(section_obj)
    
    # Extract articles if no sections found
    if not structure['sections']:
        articles = re.findall(patterns['article'], legislation_text, re.DOTALL | re.MULTILINE)
        for article_num, article_text in articles:
            structure['articles'].append({
                'number': article_num,
                'text': article_text.strip()
            })
    
    return structure


@tool
def extract_legal_entities(text: str) -> Dict[str, List[str]]:
    """
    Extract legal entities, definitions, and key terms from legislation text.
    
    Args:
        text: Legislation text to analyze
        
    Returns:
        Dictionary containing categorized legal entities
    """
    entities = {
        'definitions': [],
        'actors': [],
        'obligations': [],
        'rights': [],
        'penalties': [],
        'timeframes': [],
        'amounts': []
    }
    
    # Definition patterns
    definition_patterns = [
        r'"([^"]+)"\s+means\s+([^.]+)',
        r'([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+means\s+([^.]+)',
        r'(?:For the purposes of this|In this)\s+[^,]*,\s*"([^"]+)"\s+([^.]+)'
    ]
    
    for pattern in definition_patterns:
        matches = re.findall(pattern, text, re.MULTILINE)
        for match in matches:
            entities['definitions'].append({
                'term': match[0].strip(),
                'definition': match[1].strip()
            })
    
    # Extract actors (who/what the law applies to)
    actor_patterns = [
        r'\b(?:person|individual|entity|organization|company|corporation|agency|department|officer|employee|citizen|resident)\b',
        r'\b(?:applicant|licensee|registrant|holder|owner|operator|provider|contractor)\b'
    ]
    
    for pattern in actor_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        entities['actors'].extend(list(set(matches)))
    
    # Extract obligation keywords
    obligation_patterns = [
        r'\b(?:shall|must|required|mandatory|obligated|duty|responsible)\b',
        r'\b(?:ensure|provide|maintain|submit|comply|notify|report)\b'
    ]
    
    for pattern in obligation_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        entities['obligations'].extend(list(set(matches)))
    
    # Extract rights keywords
    rights_patterns = [
        r'\b(?:may|entitled|authorized|permitted|allowed|right|privilege)\b'
    ]
    
    for pattern in rights_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        entities['rights'].extend(list(set(matches)))
    
    # Extract penalties/sanctions
    penalty_patterns = [
        r'\b(?:fine|penalty|sanction|imprisonment|suspension|revocation|violation)\b',
        r'\$[\d,]+(?:\.\d{2})?',
        r'\b\d+\s+(?:days|months|years)\b'
    ]
    
    for pattern in penalty_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        entities['penalties'].extend(matches)
    
    # Extract timeframes
    timeframe_patterns = [
        r'\b(?:within|before|after|by|no later than)\s+\d+\s+(?:days|weeks|months|years)\b',
        r'\b\d+\s+(?:day|week|month|year)s?\b',
        r'\b(?:immediately|promptly|forthwith|annually|monthly|quarterly)\b'
    ]
    
    for pattern in timeframe_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        entities['timeframes'].extend(matches)
    
    # Clean up and deduplicate
    for key in entities:
        if isinstance(entities[key], list) and entities[key] and isinstance(entities[key][0], str):
            entities[key] = list(set([item.lower() for item in entities[key]]))
    
    return entities


@tool
def identify_rule_patterns(text: str) -> List[Dict[str, Any]]:
    """
    Identify common legal rule patterns in legislation text.
    
    Args:
        text: Legislation text to analyze
        
    Returns:
        List of identified rule patterns with metadata
    """
    patterns = []
    
    # If-then patterns (conditional rules)
    if_then_pattern = r'(?:If|When|Where)\s+([^,]+),\s*(?:then\s+)?([^.]+)'
    matches = re.findall(if_then_pattern, text, re.IGNORECASE | re.DOTALL)
    for condition, action in matches:
        patterns.append({
            'type': 'conditional',
            'pattern': 'if-then',
            'condition': condition.strip(),
            'action': action.strip(),
            'confidence': 0.8
        })
    
    # Shall/Must patterns (requirements)
    requirement_pattern = r'([^.]+?)\s+(?:shall|must)\s+([^.]+)'
    matches = re.findall(requirement_pattern, text, re.IGNORECASE)
    for subject, requirement in matches:
        patterns.append({
            'type': 'requirement',
            'pattern': 'shall-must',
            'subject': subject.strip(),
            'requirement': requirement.strip(),
            'confidence': 0.9
        })
    
    # Prohibition patterns
    prohibition_pattern = r'([^.]+?)\s+(?:shall not|must not|may not|prohibited from)\s+([^.]+)'
    matches = re.findall(prohibition_pattern, text, re.IGNORECASE)
    for subject, prohibition in matches:
        patterns.append({
            'type': 'prohibition',
            'pattern': 'shall-not',
            'subject': subject.strip(),
            'prohibition': prohibition.strip(),
            'confidence': 0.9
        })
    
    # Exception patterns
    exception_pattern = r'(?:except|unless|provided that|notwithstanding)\s+([^,]+),\s*([^.]+)'
    matches = re.findall(exception_pattern, text, re.IGNORECASE | re.DOTALL)
    for exception_condition, exception_action in matches:
        patterns.append({
            'type': 'exception',
            'pattern': 'except-unless',
            'condition': exception_condition.strip(),
            'action': exception_action.strip(),
            'confidence': 0.7
        })
    
    # Penalty patterns
    penalty_pattern = r'(?:violation|breach|failure to comply)[^.]*?(?:shall result in|subject to|punishable by)\s+([^.]+)'
    matches = re.findall(penalty_pattern, text, re.IGNORECASE | re.DOTALL)
    for penalty in matches:
        patterns.append({
            'type': 'penalty',
            'pattern': 'violation-penalty',
            'penalty': penalty.strip(),
            'confidence': 0.8
        })
    
    return patterns


@tool
def convert_to_json_rules(rules: List[Dict[str, Any]], entities: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Convert extracted legal rules into json-rules-engine compatible format.
    
    Args:
        rules: List of extracted legal rules
        entities: Dictionary of legal entities and definitions
        
    Returns:
        List of JSON rules compatible with json-rules-engine
    """
    json_rules = []
    
    for i, rule in enumerate(rules):
        rule_id = f"rule_{i+1}"
        
        if rule['type'] == 'conditional':
            # Convert if-then rules
            json_rule = {
                "conditions": {
                    "all": [
                        {
                            "fact": "legislation_context",
                            "operator": "contains",
                            "value": rule['condition'].lower(),
                            "path": "$.conditions"
                        }
                    ]
                },
                "event": {
                    "type": "conditional_rule",
                    "params": {
                        "rule_id": rule_id,
                        "action": rule['action'],
                        "condition": rule['condition'],
                        "confidence": rule.get('confidence', 0.5)
                    }
                }
            }
            
        elif rule['type'] == 'requirement':
            # Convert shall/must requirements
            json_rule = {
                "conditions": {
                    "all": [
                        {
                            "fact": "subject_context",
                            "operator": "equal",
                            "value": rule['subject'].lower(),
                            "path": "$.subject"
                        },
                        {
                            "fact": "action_required",
                            "operator": "equal",
                            "value": True
                        }
                    ]
                },
                "event": {
                    "type": "requirement_rule",
                    "params": {
                        "rule_id": rule_id,
                        "subject": rule['subject'],
                        "requirement": rule['requirement'],
                        "mandatory": True,
                        "confidence": rule.get('confidence', 0.9)
                    }
                }
            }
            
        elif rule['type'] == 'prohibition':
            # Convert prohibition rules
            json_rule = {
                "conditions": {
                    "all": [
                        {
                            "fact": "subject_context",
                            "operator": "equal",
                            "value": rule['subject'].lower(),
                            "path": "$.subject"
                        },
                        {
                            "fact": "action_prohibited",
                            "operator": "equal",
                            "value": True
                        }
                    ]
                },
                "event": {
                    "type": "prohibition_rule",
                    "params": {
                        "rule_id": rule_id,
                        "subject": rule['subject'],
                        "prohibition": rule['prohibition'],
                        "mandatory": True,
                        "confidence": rule.get('confidence', 0.9)
                    }
                }
            }
            
        elif rule['type'] == 'exception':
            # Convert exception rules
            json_rule = {
                "conditions": {
                    "any": [
                        {
                            "fact": "exception_context",
                            "operator": "contains",
                            "value": rule['condition'].lower(),
                            "path": "$.conditions"
                        }
                    ]
                },
                "event": {
                    "type": "exception_rule",
                    "params": {
                        "rule_id": rule_id,
                        "condition": rule['condition'],
                        "action": rule['action'],
                        "overrides": True,
                        "confidence": rule.get('confidence', 0.7)
                    }
                }
            }
            
        elif rule['type'] == 'penalty':
            # Convert penalty rules
            json_rule = {
                "conditions": {
                    "all": [
                        {
                            "fact": "violation_detected",
                            "operator": "equal",
                            "value": True
                        },
                        {
                            "fact": "compliance_status",
                            "operator": "equal",
                            "value": "non_compliant"
                        }
                    ]
                },
                "event": {
                    "type": "penalty_rule",
                    "params": {
                        "rule_id": rule_id,
                        "penalty": rule['penalty'],
                        "severity": "high",
                        "confidence": rule.get('confidence', 0.8)
                    }
                }
            }
        
        # Add metadata and priority
        json_rule["priority"] = rule.get('priority', 50)
        json_rule["metadata"] = {
            "source": "legislation",
            "rule_type": rule['type'],
            "extracted_by": "langgraph_agent",
            "entities": entities
        }
        
        json_rules.append(json_rule)
    
    return json_rules


@tool
def validate_json_rules(json_rules: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Validate the generated JSON rules for compatibility with json-rules-engine.
    
    Args:
        json_rules: List of JSON rules to validate
        
    Returns:
        Validation report with errors and warnings
    """
    validation_report = {
        "valid": True,
        "errors": [],
        "warnings": [],
        "rule_count": len(json_rules),
        "validated_rules": []
    }
    
    required_fields = ["conditions", "event"]
    valid_operators = [
        "equal", "notEqual", "lessThan", "lessThanInclusive", 
        "greaterThan", "greaterThanInclusive", "in", "notIn", 
        "contains", "doesNotContain", "regex"
    ]
    
    for i, rule in enumerate(json_rules):
        rule_errors = []
        rule_warnings = []
        
        # Check required fields
        for field in required_fields:
            if field not in rule:
                rule_errors.append(f"Missing required field: {field}")
        
        # Validate conditions structure
        if "conditions" in rule:
            conditions = rule["conditions"]
            if not isinstance(conditions, dict):
                rule_errors.append("Conditions must be an object")
            else:
                # Check for valid logical operators
                logical_ops = ["all", "any", "not"]
                if not any(op in conditions for op in logical_ops):
                    rule_errors.append("Conditions must contain 'all', 'any', or 'not' operator")
                
                # Validate individual conditions
                for logical_op in logical_ops:
                    if logical_op in conditions:
                        condition_list = conditions[logical_op]
                        if logical_op == "not":
                            # 'not' should contain a single condition
                            if not isinstance(condition_list, dict):
                                rule_errors.append("'not' operator must contain a single condition object")
                        else:
                            # 'all' and 'any' should contain arrays
                            if not isinstance(condition_list, list):
                                rule_errors.append(f"'{logical_op}' operator must contain an array of conditions")
                            else:
                                for j, condition in enumerate(condition_list):
                                    if not isinstance(condition, dict):
                                        rule_errors.append(f"Condition {j} must be an object")
                                        continue
                                    
                                    # Check required condition fields
                                    if "fact" not in condition:
                                        rule_errors.append(f"Condition {j} missing 'fact' field")
                                    if "operator" not in condition:
                                        rule_errors.append(f"Condition {j} missing 'operator' field")
                                    elif condition["operator"] not in valid_operators:
                                        rule_warnings.append(f"Condition {j} uses unknown operator: {condition['operator']}")
                                    if "value" not in condition:
                                        rule_warnings.append(f"Condition {j} missing 'value' field")
        
        # Validate event structure
        if "event" in rule:
            event = rule["event"]
            if not isinstance(event, dict):
                rule_errors.append("Event must be an object")
            elif "type" not in event:
                rule_warnings.append("Event missing 'type' field")
        
        # Validate priority
        if "priority" in rule:
            if not isinstance(rule["priority"], (int, float)):
                rule_errors.append("Priority must be a number")
            elif rule["priority"] < 0 or rule["priority"] > 100:
                rule_warnings.append("Priority should be between 0 and 100")
        
        # Add rule validation results
        rule_validation = {
            "rule_index": i,
            "valid": len(rule_errors) == 0,
            "errors": rule_errors,
            "warnings": rule_warnings
        }
        
        validation_report["validated_rules"].append(rule_validation)
        validation_report["errors"].extend(rule_errors)
        validation_report["warnings"].extend(rule_warnings)
        
        if rule_errors:
            validation_report["valid"] = False
    
    return validation_report


# Agent Setup with o3-mini

def create_legislation_agent():
    """Create a LangGraph agent for legislation processing with o3-mini reasoning model"""
    
    # Initialize o3-mini model with reasoning capabilities
    model = ChatOpenAI(
        model="o3-mini",  # Use o3-mini for enhanced reasoning
        temperature=0,
        model_kwargs={
            "reasoning_effort": "medium",  # Balance speed and accuracy
            "response_format": {"type": "text"}
        }
    )
    
    # Available tools for the agent
    tools = [
        parse_legislation_structure,
        extract_legal_entities,
        identify_rule_patterns,
        convert_to_json_rules,
        validate_json_rules
    ]
    
    # Bind tools to the model
    model_with_tools = model.bind_tools(tools)
    
    # Define system message for the agent
    system_message = """You are an expert legal analyst and rules engineer specializing in converting legislation into machine-readable JSON rules.

Your task is to:
1. Parse and understand the structure of legislation text
2. Extract legal entities, definitions, and key terms
3. Identify rule patterns (requirements, prohibitions, conditions, exceptions, penalties)
4. Convert these patterns into JSON rules compatible with json-rules-engine
5. Validate the generated rules for correctness and compliance

Use your reasoning capabilities to:
- Understand complex legal language and relationships
- Identify implicit rules and conditions
- Resolve ambiguities in legal text
- Ensure accurate translation to machine-readable format

Work step by step and use the provided tools to process the legislation systematically.
Output the final JSON rules in a structured format that can be directly used by json-rules-engine."""

    def call_model(state: AgentState):
        """Node that calls the model with reasoning capabilities"""
        messages = [SystemMessage(content=system_message)] + list(state.messages)
        response = model_with_tools.invoke(messages)
        return {"messages": [response]}

    def should_continue(state: AgentState):
        """Determine whether to continue or end the workflow"""
        messages = state.messages
        last_message = messages[-1]
        
        # If the last message has tool calls, continue to tools
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            return "tools"
        
        # If we have processed rules, check if validation is complete
        if state.json_rules and state.processing_step != "validation":
            return "tools"  # Continue to validation
        
        # Otherwise, end the workflow
        return END

    # Create the graph
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("agent", call_model)
    workflow.add_node("tools", ToolNode(tools))
    
    # Add edges
    workflow.set_entry_point("agent")
    workflow.add_conditional_edges(
        "agent",
        should_continue,
        {
            "tools": "tools",
            END: END
        }
    )
    workflow.add_edge("tools", "agent")
    
    # Add memory for conversation state
    memory = MemorySaver()
    
    # Compile the graph
    app = workflow.compile(checkpointer=memory)
    
    return app


# Main Processing Function

async def process_legislation_to_rules(
    legislation_text: str,
    config: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Main function to process legislation text and convert it to JSON rules.
    
    Args:
        legislation_text: The legislation text to process
        config: Optional configuration for the agent
        
    Returns:
        Dictionary containing the processed results
    """
    
    # Create the agent
    agent = create_legislation_agent()
    
    # Default config
    if config is None:
        config = {"configurable": {"thread_id": "legislation_processing_session"}}
    
    # Initial state
    initial_state = AgentState(
        messages=[],
        legislation_text=legislation_text,
        processing_step="initial"
    )
    
    # Create the processing prompt
    prompt = f"""Please process the following legislation text and convert it into JSON rules compatible with json-rules-engine:

LEGISLATION TEXT:
{legislation_text}

Please follow these steps:
1. Parse the legislation structure to identify sections, articles, and subsections
2. Extract legal entities, definitions, and key terms
3. Identify rule patterns (requirements, prohibitions, conditions, exceptions, penalties)
4. Convert the identified patterns into json-rules-engine compatible JSON format
5. Validate the generated JSON rules for correctness

Provide the final output as a structured JSON rules array that can be directly used with json-rules-engine."""

    # Process the legislation
    response = await agent.ainvoke(
        {"messages": [HumanMessage(content=prompt)]},
        config=config
    )
    
    return {
        "status": "completed",
        "original_text": legislation_text,
        "messages": response["messages"],
        "json_rules": response.get("json_rules", []),
        "metadata": response.get("metadata", {})
    }


# Example Usage and Testing

def run_example_sync():
    """Run example processing - handles both async and sync contexts"""
    # Example legislation text
    sample_legislation = """
    SECTION 1. DEFINITIONS
    
    For the purposes of this Act:
    (a) "Vehicle" means any motorized conveyance designed for transportation on public roads.
    (b) "Driver" means any person operating a vehicle on a public road.
    (c) "Speed limit" means the maximum lawful speed for vehicles on a particular road segment.
    
    SECTION 2. SPEED REGULATIONS
    
    (a) No person shall operate a vehicle at a speed greater than the posted speed limit.
    (b) If weather conditions are hazardous, drivers must reduce speed to maintain safe operation.
    (c) Emergency vehicles may exceed speed limits when responding to emergencies, provided warning signals are activated.
    
    SECTION 3. PENALTIES
    
    (a) Any person who violates Section 2(a) shall be subject to a fine of not less than $100 and not more than $500.
    (b) Repeat violations within 12 months shall result in license suspension for 30 days.
    """
    
    async def _run_async():
        """Internal async function"""
        print("Processing sample legislation...")
        
        result = await process_legislation_to_rules(sample_legislation)
        
        print("\n=== PROCESSING RESULTS ===")
        print(f"Status: {result['status']}")
        print(f"Number of messages: {len(result['messages'])}")
        
        if result['json_rules']:
            print(f"\nGenerated {len(result['json_rules'])} JSON rules:")
            for i, rule in enumerate(result['json_rules']):
                print(f"\nRule {i+1}:")
                print(json.dumps(rule, indent=2))
        
        # Print the conversation for debugging
        print("\n=== AGENT CONVERSATION ===")
        for msg in result['messages']:
            if hasattr(msg, 'content'):
                print(f"{msg.__class__.__name__}: {msg.content[:200]}...")
            print("-" * 50)
        
        return result
    
    # Handle both cases: running event loop and no event loop
    try:
        # Try to get the current event loop
        loop = asyncio.get_running_loop()
        # If we're here, there's already a running loop
        # Create a task and run it
        import concurrent.futures
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(asyncio.run, _run_async())
            return future.result()
    except RuntimeError:
        # No running event loop, safe to use asyncio.run()
        return asyncio.run(_run_async())


async def run_example_async():
    """Async version for use in async environments like Jupyter"""
    # Example legislation text
    sample_legislation = """
    SECTION 1. DEFINITIONS
    
    For the purposes of this Act:
    (a) "Vehicle" means any motorized conveyance designed for transportation on public roads.
    (b) "Driver" means any person operating a vehicle on a public road.
    (c) "Speed limit" means the maximum lawful speed for vehicles on a particular road segment.
    
    SECTION 2. SPEED REGULATIONS
    
    (a) No person shall operate a vehicle at a speed greater than the posted speed limit.
    (b) If weather conditions are hazardous, drivers must reduce speed to maintain safe operation.
    (c) Emergency vehicles may exceed speed limits when responding to emergencies, provided warning signals are activated.
    
    SECTION 3. PENALTIES
    
    (a) Any person who violates Section 2(a) shall be subject to a fine of not less than $100 and not more than $500.
    (b) Repeat violations within 12 months shall result in license suspension for 30 days.
    """
    
    print("Processing sample legislation...")
    
    result = await process_legislation_to_rules(sample_legislation)
    
    print("\n=== PROCESSING RESULTS ===")
    print(f"Status: {result['status']}")
    print(f"Number of messages: {len(result['messages'])}")
    
    if result['json_rules']:
        print(f"\nGenerated {len(result['json_rules'])} JSON rules:")
        for i, rule in enumerate(result['json_rules']):
            print(f"\nRule {i+1}:")
            print(json.dumps(rule, indent=2))
    
    # Print the conversation for debugging
    print("\n=== AGENT CONVERSATION ===")
    for msg in result['messages']:
        if hasattr(msg, 'content'):
            print(f"{msg.__class__.__name__}: {msg.content[:200]}...")
        print("-" * 50)
    
    return result


if __name__ == "__main__":
    # Run the example - this handles both sync and async contexts
    run_example_sync()


# Additional Utility Functions

def save_rules_to_file(rules: List[Dict[str, Any]], filename: str):
    """Save JSON rules to a file"""
    with open(filename, 'w') as f:
        json.dump(rules, f, indent=2)
    print(f"Rules saved to {filename}")


def load_rules_from_file(filename: str) -> List[Dict[str, Any]]:
    """Load JSON rules from a file"""
    with open(filename, 'r') as f:
        return json.load(f)


def create_rules_engine_config(rules: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Create a configuration object for json-rules-engine"""
    return {
        "rules": rules,
        "metadata": {
            "created_by": "langgraph_legislation_processor",
            "created_at": "2025-08-08",
            "rule_count": len(rules),
            "engine_version": "json-rules-engine"
        }
    }


# Rule Testing Framework

class LegislationRulesTester:
    """Class for testing generated rules against sample data"""
    
    def __init__(self, rules: List[Dict[str, Any]]):
        self.rules = rules
    
    def create_test_facts(self) -> List[Dict[str, Any]]:
        """Create sample facts for testing rules"""
        return [
            {
                "subject_context": {"subject": "driver"},
                "action_required": True,
                "speed": 45,
                "speed_limit": 35,
                "weather_conditions": "clear",
                "vehicle_type": "car",
                "emergency_vehicle": False
            },
            {
                "subject_context": {"subject": "emergency vehicle"},
                "action_required": False,
                "speed": 60,
                "speed_limit": 35,
                "weather_conditions": "clear",
                "vehicle_type": "ambulance",
                "emergency_vehicle": True,
                "warning_signals": True
            },
            {
                "violation_detected": True,
                "compliance_status": "non_compliant",
                "previous_violations": 2,
                "violation_date": "2025-08-08"
            }
        ]
    
    def test_rules(self) -> Dict[str, Any]:
        """Test the rules against sample facts"""
        test_facts = self.create_test_facts()
        results = []
        
        for fact_set in test_facts:
            fact_results = []
            for rule in self.rules:
                # Simulate rule evaluation (simplified)
                rule_fired = self._evaluate_rule(rule, fact_set)
                fact_results.append({
                    "rule_id": rule.get("metadata", {}).get("rule_id", "unknown"),
                    "fired": rule_fired,
                    "event_type": rule.get("event", {}).get("type", "unknown")
                })
            results.append({
                "facts": fact_set,
                "rule_results": fact_results
            })
        
        return {
            "test_results": results,
            "total_rules": len(self.rules),
            "total_fact_sets": len(test_facts)
        }
    
    def _evaluate_rule(self, rule: Dict[str, Any], facts: Dict[str, Any]) -> bool:
        """Simplified rule evaluation for testing"""
        # This is a simplified evaluation - in practice, you'd use json-rules-engine
        conditions = rule.get("conditions", {})
        
        if "all" in conditions:
            return all(self._evaluate_condition(cond, facts) for cond in conditions["all"])
        elif "any" in conditions:
            return any(self._evaluate_condition(cond, facts) for cond in conditions["any"])
        elif "not" in conditions:
            return not self._evaluate_condition(conditions["not"], facts)
        
        return False


# Synchronous Wrapper for Easier Usage

def process_legislation_sync(legislation_text: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Synchronous wrapper for processing legislation.
    Handles event loop management automatically.
    
    Args:
        legislation_text: The legislation text to process
        config: Optional configuration for the agent
        
    Returns:
        Dictionary containing the processed results
    """
    
    async def _process_async():
        return await process_legislation_to_rules(legislation_text, config)
    
    # Handle both cases: running event loop and no event loop
    try:
        # Try to get the current event loop
        loop = asyncio.get_running_loop()
        # If we're here, there's already a running loop
        # Use a thread pool to run in a separate thread
        import concurrent.futures
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(asyncio.run, _process_async())
            return future.result()
    except RuntimeError:
        # No running event loop, safe to use asyncio.run()
        return asyncio.run(_process_async())


# Quick Start Functions

def quick_demo():
    """Quick demonstration with minimal legislation text"""
    simple_law = """
    Section 1. Speed Limit
    No vehicle shall exceed 25 mph in school zones during school hours.
    
    Section 2. Penalties  
    Violation of Section 1 shall result in a fine of $150.
    """
    
    print("=== QUICK DEMO ===")
    print("Processing simple legislation...")
    
    try:
        result = process_legislation_sync(simple_law)
        print(f"âœ… Successfully processed! Generated {len(result.get('json_rules', []))} rules")
        
        # Show first rule if available
        if result.get('json_rules'):
            print("\nðŸ“‹ Sample Rule:")
            first_rule = result['json_rules'][0]
            print(json.dumps(first_rule, indent=2))
        
        return result
    except Exception as e:
        print(f"âŒ Error: {e}")
        return None


def process_file(file_path: str, output_path: Optional[str] = None) -> Dict[str, Any]:
    """
    Process legislation from a text file.
    
    Args:
        file_path: Path to the legislation text file
        output_path: Optional path to save the JSON rules
        
    Returns:
        Dictionary containing the processed results
    """
    try:
        # Read the legislation file
        with open(file_path, 'r', encoding='utf-8') as f:
            legislation_text = f.read()
        
        print(f"ðŸ“– Reading legislation from: {file_path}")
        print(f"ðŸ“ Text length: {len(legislation_text)} characters")
        
        # Process the legislation
        result = process_legislation_sync(legislation_text)
        
        # Save results if output path provided
        if output_path and result.get('json_rules'):
            save_rules_to_file(result['json_rules'], output_path)
            print(f"ðŸ’¾ Rules saved to: {output_path}")
        
        return result
        
    except FileNotFoundError:
        print(f"âŒ File not found: {file_path}")
        return {"status": "error", "message": "File not found"}
    except Exception as e:
        print(f"âŒ Error processing file: {e}")
        return {"status": "error", "message": str(e)}


# Usage Examples and Documentation

"""
USAGE EXAMPLES:

1. Quick Demo (simplest):
   >>> quick_demo()

2. Process text directly (sync):
   >>> result = process_legislation_sync("Your legislation text here...")
   >>> print(result['json_rules'])

3. Process text directly (async - for Jupyter/async environments):
   >>> result = await process_legislation_to_rules("Your legislation text here...")

4. Process from file:
   >>> result = process_file("my_law.txt", "output_rules.json")

5. In Jupyter Notebook:
   >>> result = await run_example_async()

6. Custom configuration:
   >>> config = {"configurable": {"thread_id": "my_session"}}
   >>> result = process_legislation_sync(text, config)

DEPENDENCIES:
pip install langgraph langchain-openai langchain-core

ENVIRONMENT SETUP:
export OPENAI_API_KEY="your-openai-api-key"

NOTE: This system uses OpenAI's o3-mini model which requires an OpenAI API key
with access to reasoning models.
"""
    
    def _evaluate_condition(self, condition: Dict[str, Any], facts: Dict[str, Any]) -> bool:
        """Evaluate a single condition"""
        fact_name = condition.get("fact")
        operator = condition.get("operator")
        expected_value = condition.get("value")
        path = condition.get("path")
        
        if fact_name not in facts:
            return False
        
        fact_value = facts[fact_name]
        
        # Handle path-based access (simplified)
        if path and isinstance(fact_value, dict):
            # Simple path resolution for testing
            if path.startswith("$."):
                key = path[2:]
                fact_value = fact_value.get(key)
        
        # Evaluate operator (simplified)
        if operator == "equal":
            return fact_value == expected_value
        elif operator == "greaterThan":
            return fact_value > expected_value
        elif operator == "lessThan":
            return fact_value < expected_value
        elif operator == "contains":
            return expected_value in str(fact_value).lower()
        
        return False
