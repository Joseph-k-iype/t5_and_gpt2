# backend/app/api/chat.py
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks, Request
from typing import List
import logging

from app.models.chat import (
    QuickChatRequest, QuickChatResponse, 
    ConversationHistory, ChatMessage
)
from app.core.session_manager import SessionManager, SessionData
from app.core.research_engine import ResearchEngineWrapper

logger = logging.getLogger(__name__)
router = APIRouter()

def get_session_manager(request: Request) -> SessionManager:
    """Dependency to get session manager"""
    if not hasattr(request.app.state, 'session_manager') or request.app.state.session_manager is None:
        raise HTTPException(status_code=503, detail="Session manager not available")
    return request.app.state.session_manager

def get_research_engine(request: Request) -> ResearchEngineWrapper:
    """Dependency to get research engine"""
    if not hasattr(request.app.state, 'research_engine') or request.app.state.research_engine is None:
        raise HTTPException(status_code=503, detail="Research engine not available")
    return request.app.state.research_engine

@router.post("/quick", response_model=QuickChatResponse)
async def quick_chat(
    request: QuickChatRequest,
    background_tasks: BackgroundTasks,
    session_manager: SessionManager = Depends(get_session_manager),
    research_engine: ResearchEngineWrapper = Depends(get_research_engine)
):
    """
    Quick chat endpoint for fast AI responses
    """
    try:
        # Get or create session
        if request.session_id:
            session = await session_manager.get_session(request.session_id)
            if not session:
                raise HTTPException(status_code=404, detail="Session not found")
        else:
            session = await session_manager.create_session(request.user_id)
        
        # Add user message to conversation history
        user_message = {
            "role": "user",
            "content": request.message,
            "timestamp": session.last_activity.isoformat()
        }
        await session_manager.add_conversation_message(session.session_id, user_message)
        
        # Process with research engine
        result = await research_engine.quick_chat(
            question=request.message,
            user_id=session.user_id,
            session_id=session.session_id
        )
        
        # Add assistant response to conversation history
        assistant_message = {
            "role": "assistant", 
            "content": result.get("answer", ""),
            "metadata": {
                "confidence": result.get("confidence"),
                "approach": result.get("approach")
            }
        }
        background_tasks.add_task(
            session_manager.add_conversation_message,
            session.session_id,
            assistant_message
        )
        
        # Return structured response
        return QuickChatResponse(
            answer=result.get("answer", "No response generated"),
            confidence=result.get("confidence", "unknown"),
            approach=result.get("approach", "unknown"),
            session_id=session.session_id,
            user_id=session.user_id,
            timestamp=session.last_activity,
            metadata=result.get("metadata", {})
        )
        
    except Exception as e:
        logger.error(f"Error in quick chat: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/conversation/{session_id}", response_model=ConversationHistory)
async def get_conversation_history(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """
    Get conversation history for a session
    """
    try:
        session = await session_manager.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        messages = [
            ChatMessage(
                role=msg.get("role", "unknown"),
                content=msg.get("content", ""),
                timestamp=msg.get("timestamp"),
                metadata=msg.get("metadata", {})
            )
            for msg in session.conversation_history
        ]
        
        return ConversationHistory(
            messages=messages,
            session_id=session_id,
            total_messages=len(messages)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting conversation history: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.delete("/session/{session_id}")
async def delete_session(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """
    Delete a chat session
    """
    try:
        success = await session_manager.delete_session(session_id)
        if not success:
            raise HTTPException(status_code=404, detail="Session not found")
        
        return {"message": "Session deleted successfully", "session_id": session_id}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting session: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
