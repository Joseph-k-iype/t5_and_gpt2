"""
OpenAI API service for the legislation rules converter.
Updated to support both standard OpenAI and HSBC APIs
Uses error-driven token refresh for HSBC
Location: src/services/openai_service.py
"""
import logging
from typing import List, Union, Dict, Optional, Any
from openai import OpenAI, AuthenticationError, APIError
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

from ..config import Config, get_openai_client, get_hsbc_credentials

logger = logging.getLogger(__name__)


class OpenAIService:
    """Service for OpenAI API interactions with HSBC support and auto-retry."""

    def __init__(self, api_key: str = None, base_url: str = None, use_hsbc: bool = None):
        """
        Initialize OpenAI service
        
        Args:
            api_key: OpenAI API key (defaults to Config.API_KEY or HSBC token)
            base_url: OpenAI API base URL (defaults to Config.BASE_URL or HSBC URL)
            use_hsbc: Override USE_HSBC_API config (optional)
        """
        # Determine if we're using HSBC
        self.use_hsbc = use_hsbc if use_hsbc is not None else Config.USE_HSBC_API
        
        if self.use_hsbc:
            # Get HSBC client wrapper for auto-retry functionality
            from ..hsbc_openai_client import create_hsbc_client
            
            self.hsbc_client = create_hsbc_client(
                token_api_url=Config.HSBC_TOKEN_API_URL,
                base_url=Config.HSBC_BASE_URL,
                username=Config.HSBC_USERNAME,
                password=Config.HSBC_PASSWORD,
                user_id=Config.HSBC_USER_ID,
                default_model=Config.HSBC_MODEL
            )
            
            # Get credentials for display
            creds = get_hsbc_credentials()
            self.api_key = api_key or creds["api_key"]
            self.base_url = base_url or creds["base_url"]
            self.model = creds["model"]
            self.headers = creds["headers"]
            logger.info("ðŸ¦ Using HSBC API with error-driven token refresh")
        else:
            # Standard OpenAI
            self.hsbc_client = None
            self.api_key = api_key or Config.API_KEY
            self.base_url = base_url or Config.BASE_URL
            self.model = Config.CHAT_MODEL
            self.headers = {}
            logger.info("ðŸ¤– Using OpenAI API")
        
        if not self.api_key:
            raise ValueError(
                "API key is required. Set OPENAI_API_KEY or HSBC_PASSWORD environment variable."
            )
        
        logger.info(f"Initializing OpenAI Service:")
        logger.info(f"  Base URL: {self.base_url}")
        logger.info(f"  Model: {self.model}")
        logger.info(f"  API Key: ***{self.api_key[-4:] if self.api_key else 'NOT SET'}")
        
        # Initialize client
        self.client = get_openai_client()
        
        logger.info("âœ“ OpenAI client initialized")

    async def get_embeddings(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings using configured connection."""
        try:
            response = self.client.embeddings.create(
                model=Config.EMBEDDING_MODEL,
                input=texts,
                encoding_format="float"
            )
            embeddings = [data.embedding for data in response.data]
            logger.info(f"Generated {len(embeddings)} embeddings")
            return embeddings
        except Exception as e:
            logger.error(f"Error generating embeddings: {e}")
            logger.error(f"Base URL used: {self.base_url}")
            logger.error(f"Model: {Config.EMBEDDING_MODEL}")
            raise

    async def chat_completion(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> str:
        """
        Generate chat completion with automatic token refresh on auth errors.
        
        Args:
            messages: List of messages in the conversation
            
        Returns:
            String response from the model
        """
        formatted_messages = self._format_messages(messages)
        
        if self.use_hsbc and self.hsbc_client:
            # Use HSBC client with built-in retry logic
            try:
                response = self.hsbc_client.chat_completion_with_retry(
                    model=self.model,
                    messages=formatted_messages
                )
                return response.choices[0].message.content
            except Exception as e:
                logger.error(f"Error in chat completion: {e}")
                logger.error(f"Base URL used: {self.base_url}")
                logger.error(f"Model: {self.model}")
                raise
        else:
            # Standard OpenAI - no auto-retry needed
            try:
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=formatted_messages
                )
                return response.choices[0].message.content
            except Exception as e:
                logger.error(f"Error in chat completion: {e}")
                logger.error(f"Base URL used: {self.base_url}")
                logger.error(f"Model: {self.model}")
                raise

    async def get_completion(
        self,
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> Any:
        """
        Generate chat completion with automatic token refresh on auth errors.
        
        Args:
            messages: List of messages in the conversation
            
        Returns:
            Response object with content attribute
        """
        formatted_messages = self._format_messages(messages)
        
        if self.use_hsbc and self.hsbc_client:
            # Use HSBC client with built-in retry logic
            try:
                response = self.hsbc_client.chat_completion_with_retry(
                    model=self.model,
                    messages=formatted_messages
                )
                
                # Return a simple object with content attribute for compatibility
                class CompletionResponse:
                    def __init__(self, content):
                        self.content = content
                
                return CompletionResponse(response.choices[0].message.content)
                
            except Exception as e:
                logger.error(f"Error in get_completion: {e}")
                logger.error(f"Base URL used: {self.base_url}")
                logger.error(f"Model: {self.model}")
                raise
        else:
            # Standard OpenAI
            try:
                response = self.client.chat.completions.create(
                    model=self.model,
                    messages=formatted_messages
                )
                
                # Return a simple object with content attribute for compatibility
                class CompletionResponse:
                    def __init__(self, content):
                        self.content = content
                
                return CompletionResponse(response.choices[0].message.content)
                
            except Exception as e:
                logger.error(f"Error in get_completion: {e}")
                logger.error(f"Base URL used: {self.base_url}")
                logger.error(f"Model: {self.model}")
                raise
    
    def _format_messages(
        self, 
        messages: List[Union[Dict[str, str], SystemMessage, HumanMessage, AIMessage]]
    ) -> List[Dict[str, str]]:
        """
        Format messages for API call.
        
        Args:
            messages: Input messages in various formats
            
        Returns:
            List of formatted message dictionaries
        """
        formatted_messages = []
        for msg in messages:
            if isinstance(msg, (SystemMessage, HumanMessage, AIMessage)):
                if isinstance(msg, SystemMessage):
                    formatted_messages.append({"role": "system", "content": msg.content})
                elif isinstance(msg, HumanMessage):
                    formatted_messages.append({"role": "user", "content": msg.content})
                elif isinstance(msg, AIMessage):
                    formatted_messages.append({"role": "assistant", "content": msg.content})
            elif isinstance(msg, dict):
                # Handle HSBC's "developer" role by converting to "system"
                if msg.get("role") == "developer":
                    formatted_messages.append({"role": "system", "content": msg["content"]})
                else:
                    formatted_messages.append(msg)
            else:
                formatted_messages.append({"role": "user", "content": str(msg)})
        
        return formatted_messages
    
    def refresh_token_if_hsbc(self) -> None:
        """Manually refresh HSBC token if using HSBC API."""
        if self.use_hsbc and self.hsbc_client:
            self.hsbc_client.refresh_token()
            logger.info("HSBC token manually refreshed")
        else:
            logger.debug("Not using HSBC API - no token to refresh")
