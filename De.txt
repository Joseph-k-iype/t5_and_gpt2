# backend/app/core/research_engine.py
import asyncio
import logging
import sys
import os
from typing import Dict, Any, Optional
from datetime import datetime

# Add the parent directory to path to import the enhanced chatbot
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

try:
    from enhanced_chatbot import EnhancedChatbotInterface
    ENHANCED_CHATBOT_AVAILABLE = True
    logger = logging.getLogger(__name__)
    logger.info("✓ Enhanced chatbot imported successfully")
except ImportError as e:
    ENHANCED_CHATBOT_AVAILABLE = False
    logger = logging.getLogger(__name__)
    logger.error(f"❌ Failed to import enhanced_chatbot: {e}")
    logger.info("Creating mock interface for development")

class ResearchEngineWrapper:
    """
    Wrapper for the enhanced chatbot research engine
    Provides async interface and session management
    """
    
    def __init__(self):
        self.chatbot_interface = None
        self.is_initialized = False
        self._initialization_lock = asyncio.Lock()
        self.initialization_error = None
    
    async def initialize(self):
        """Initialize the research engine"""
        async with self._initialization_lock:
            if self.is_initialized:
                return True
            
            try:
                logger.info("Initializing Enhanced Chatbot Research Engine...")
                
                if not ENHANCED_CHATBOT_AVAILABLE:
                    logger.warning("Enhanced chatbot not available, using mock interface")
                    self.chatbot_interface = MockChatbotInterface()
                    self.is_initialized = True
                    return True
                
                self.chatbot_interface = EnhancedChatbotInterface()
                
                # The initialize method is async in the enhanced chatbot
                success = await self.chatbot_interface.initialize()
                
                if success:
                    self.is_initialized = True
                    self.initialization_error = None
                    logger.info("✅ Research engine initialized successfully")
                    return True
                else:
                    self.initialization_error = "Enhanced chatbot initialization returned False"
                    logger.error(f"❌ {self.initialization_error}")
                    # Fallback to mock interface
                    self.chatbot_interface = MockChatbotInterface()
                    self.is_initialized = True
                    return True
                    
            except Exception as e:
                self.initialization_error = str(e)
                logger.error(f"❌ Failed to initialize research engine: {e}")
                # Fallback to mock interface
                try:
                    self.chatbot_interface = MockChatbotInterface()
                    self.is_initialized = True
                    logger.warning("✅ Using mock research interface as fallback")
                    return True
                except Exception as mock_error:
                    logger.error(f"❌ Even mock interface failed: {mock_error}")
                    return False
    
    async def quick_chat(self, question: str, user_id: str, session_id: str) -> Dict[str, Any]:
        """
        Handle quick chat queries
        """
        if not self.is_initialized:
            await self.initialize()
        
        if self.chatbot_interface is None:
            return self._create_error_response("Research engine not available", session_id, user_id)
        
        try:
            logger.info(f"Processing quick chat: {question[:100]}...")
            
            # The ask_question method is async and takes the expected parameters
            result = await self.chatbot_interface.ask_question(
                question, 
                user_id=user_id, 
                thread_id=session_id
            )
            
            # The enhanced chatbot returns a well-structured response
            # Map it to our expected format
            enhanced_result = {
                "answer": result.get("answer", "No response generated"),
                "confidence": result.get("confidence", "unknown"),
                "approach": result.get("approach", "enhanced_chatbot"),
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "query_type": "quick_chat",
                "processing_time": "fast",
                # Additional metadata from enhanced chatbot
                "metadata": {
                    "iterations_completed": result.get("iterations_completed", 0),
                    "agents_used": result.get("agents_used", []),
                    "overall_confidence_score": result.get("overall_confidence_score", 0.0),
                    "domain_analysis": result.get("domain_analysis", {}),
                    "token_info": result.get("token_info", {}),
                    "session_id_internal": result.get("session_id"),
                    "initialization_warning": self.initialization_error
                }
            }
            
            logger.info(f"Quick chat completed with confidence: {result.get('confidence', 'unknown')}")
            return enhanced_result
            
        except Exception as e:
            logger.error(f"Error in quick chat: {e}")
            return self._create_error_response(f"Quick chat failed: {str(e)}", session_id, user_id)
    
    async def deep_research(self, topic: str, user_id: str, session_id: str, 
                          progress_callback=None) -> Dict[str, Any]:
        """
        Handle deep research queries with progress updates
        """
        if not self.is_initialized:
            await self.initialize()
        
        if self.chatbot_interface is None:
            return self._create_research_error_response("Research engine not available", session_id, user_id)
        
        try:
            logger.info(f"Starting deep research: {topic[:100]}...")
            
            if progress_callback:
                await progress_callback({
                    "stage": "initialization",
                    "message": "Initializing enhanced multi-agent research system...",
                    "progress": 0
                })
            
            # Progress tracking wrapper
            async def research_with_progress():
                if progress_callback:
                    await progress_callback({
                        "stage": "planning",
                        "message": "Creating research plan and assigning specialized agents...",
                        "progress": 20
                    })
                
                # The conduct_deep_research method is async
                result = await self.chatbot_interface.conduct_deep_research(
                    topic, 
                    user_id=user_id
                )
                
                if progress_callback:
                    await progress_callback({
                        "stage": "research",
                        "message": "Multi-agent research in progress...",
                        "progress": 60
                    })
                
                await asyncio.sleep(1)
                
                if progress_callback:
                    await progress_callback({
                        "stage": "synthesis",
                        "message": "Synthesizing findings with token optimization...",
                        "progress": 80
                    })
                
                await asyncio.sleep(1)
                
                if progress_callback:
                    await progress_callback({
                        "stage": "completion",
                        "message": "Deep research completed successfully!",
                        "progress": 100
                    })
                
                return result
            
            result = await research_with_progress()
            
            # Map the enhanced chatbot result to our expected format
            enhanced_result = {
                "final_synthesis": result.get("final_synthesis", "No synthesis available"),
                "overall_confidence": result.get("overall_confidence", 0.0),
                "agents_used": result.get("agents_used", []),
                "iterations_completed": result.get("iterations_completed", 0),
                "session_id": session_id,
                "user_id": user_id,
                "timestamp": datetime.utcnow().isoformat(),
                "query_type": "deep_research",
                "processing_time": "extended",
                # Additional rich metadata from enhanced chatbot
                "metadata": {
                    "research_session_id": result.get("session_id"),
                    "research_plan": result.get("research_plan", {}),
                    "agent_findings": result.get("agent_findings", {}),
                    "shared_knowledge": result.get("shared_knowledge", {}),
                    "memory_keys": result.get("memory_keys", []),
                    "token_info": result.get("token_info", {}),
                    "query_original": result.get("query", topic),
                    "initialization_warning": self.initialization_error
                }
            }
            
            logger.info(f"Deep research completed with confidence: {enhanced_result['overall_confidence']:.2f}")
            return enhanced_result
            
        except Exception as e:
            logger.error(f"Error in deep research: {e}")
            if progress_callback:
                await progress_callback({
                    "stage": "error",
                    "message": f"Research failed: {str(e)}",
                    "progress": 0,
                    "error": True
                })
            
            return self._create_research_error_response(f"Deep research failed: {str(e)}", session_id, user_id)
    
    def _create_error_response(self, error_msg: str, session_id: str, user_id: str) -> Dict[str, Any]:
        """Create standardized error response for quick chat"""
        return {
            "answer": f"I encountered an error: {error_msg}",
            "confidence": "low",
            "approach": "error",
            "session_id": session_id,
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat(),
            "error": error_msg,
            "metadata": {
                "initialization_error": self.initialization_error,
                "enhanced_chatbot_available": ENHANCED_CHATBOT_AVAILABLE
            }
        }
    
    def _create_research_error_response(self, error_msg: str, session_id: str, user_id: str) -> Dict[str, Any]:
        """Create standardized error response for deep research"""
        return {
            "final_synthesis": f"Research failed: {error_msg}",
            "overall_confidence": 0.0,
            "agents_used": [],
            "iterations_completed": 0,
            "session_id": session_id,
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat(),
            "error": error_msg,
            "metadata": {
                "initialization_error": self.initialization_error,
                "enhanced_chatbot_available": ENHANCED_CHATBOT_AVAILABLE
            }
        }
    
    async def get_engine_status(self) -> Dict[str, Any]:
        """Get the status of the research engine"""
        available_methods = []
        interface_type = "none"
        
        if self.chatbot_interface:
            interface_type = type(self.chatbot_interface).__name__
            for method in ['ask_question', 'conduct_deep_research', 'initialize']:
                if hasattr(self.chatbot_interface, method):
                    available_methods.append(method)
        
        return {
            "initialized": self.is_initialized,
            "interface_available": self.chatbot_interface is not None,
            "interface_type": interface_type,
            "available_methods": available_methods,
            "enhanced_chatbot_available": ENHANCED_CHATBOT_AVAILABLE,
            "initialization_error": self.initialization_error,
            "engine_type": "EnhancedChatbotInterface",
            "capabilities": [
                "Quick Chat with Multi-Agent Processing",
                "Deep Multi-Agent Research",
                "Knowledge Synthesis with Token Management",
                "Domain Filtering and Validation",
                "Session Management with Long-term Memory",
                "Progressive Synthesis for Large Results"
            ],
            "timestamp": datetime.utcnow().isoformat()
        }
    
    async def cleanup(self):
        """Clean up resources"""
        try:
            # The enhanced chatbot interface doesn't have a cleanup method
            # but we check for it just in case
            if self.chatbot_interface and hasattr(self.chatbot_interface, 'cleanup'):
                if asyncio.iscoroutinefunction(self.chatbot_interface.cleanup):
                    await self.chatbot_interface.cleanup()
                else:
                    self.chatbot_interface.cleanup()
            
            self.chatbot_interface = None
            self.is_initialized = False
            logger.info("Research engine cleanup completed")
            
        except Exception as e:
            logger.error(f"Error during research engine cleanup: {e}")


class MockChatbotInterface:
    """Mock interface for development/testing when enhanced chatbot is not available"""
    
    def __init__(self):
        self.name = "MockChatbotInterface"
    
    async def initialize(self):
        """Mock initialization"""
        logger.info("Mock chatbot interface initialized")
        return True
    
    async def ask_question(self, question: str, user_id: str = None, thread_id: str = None):
        """Mock question answering"""
        return {
            "answer": f"Mock response for: {question[:100]}...\n\nThis is a mock response because the enhanced chatbot is not available. The actual system would provide comprehensive multi-agent research with domain expertise, token management, and advanced synthesis capabilities.",
            "confidence": "low",
            "approach": "mock_interface",
            "agents_used": ["mock_agent"],
            "iterations_completed": 1,
            "overall_confidence_score": 0.3,
            "token_info": {
                "response_tokens": 50,
                "was_optimized": False,
                "optimization_method": "none"
            }
        }
    
    async def conduct_deep_research(self, topic: str, user_id: str = None):
        """Mock deep research"""
        return {
            "query": topic,
            "session_id": f"mock_session_{hash(topic) % 10000}",
            "final_synthesis": f"Mock deep research synthesis for: {topic}\n\nThis is a mock research result. The actual enhanced chatbot would provide:\n\n• Multi-agent specialized research\n• Comprehensive domain analysis\n• Cross-jurisdictional insights\n• Token-optimized synthesis\n• Long-term memory integration\n• Advanced planning and execution\n\nPlease configure the enhanced chatbot for full functionality.",
            "overall_confidence": 0.4,
            "agents_used": ["mock_planner", "mock_researcher", "mock_synthesizer"],
            "iterations_completed": 2,
            "research_plan": {
                "main_query": topic,
                "research_objectives": ["Mock objective 1", "Mock objective 2"],
                "coordination_strategy": "mock_sequential"
            },
            "agent_findings": {
                "mock_researcher": {
                    "findings": [{"insight": "Mock finding", "confidence": 0.5}]
                }
            },
            "shared_knowledge": {"mock_knowledge": "placeholder"},
            "memory_keys": [],
            "token_info": {
                "synthesis_tokens": 150,
                "token_optimization_applied": True,
                "optimization_method": "mock_optimization"
            }
        }
