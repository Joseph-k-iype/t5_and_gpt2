import pandas as pd
import requests
import json
import time
from typing import List, Dict, Any, Optional

def send_row_to_api(
    df: pd.DataFrame, 
    api_url: str,
    headers: Optional[Dict[str, str]] = None,
    max_iterations: int = 5,
    delay_between_requests: float = 0.1,
    processes: Optional[List[Dict[str, str]]] = None
) -> List[Dict[str, Any]]:
    """
    Send each row from DataFrame to API endpoint
    
    Args:
        df: DataFrame with columns matching the payload structure
        api_url: The API endpoint URL
        headers: Optional headers for the API request (e.g., authentication)
        max_iterations: Default max_iterations for all requests
        delay_between_requests: Delay between API calls to avoid rate limiting
        processes: Optional default processes array for all requests
    
    Returns:
        List of dictionaries containing results from each API call
    """
    
    if headers is None:
        headers = {'Content-Type': 'application/json'}
    
    results = []
    
    for index, row in df.iterrows():
        try:
            # Construct payload from row data
            payload = {
                "id": str(row.get('element_id', row.get('id', f'element_{index}'))),
                "existing_name": str(row.get('element_name', row.get('existing_name', ''))),
                "existing_description": str(row.get('element_description', row.get('existing_description', ''))),
                "example": str(row.get('optional_example', row.get('example', ''))) if pd.notna(row.get('optional_example', row.get('example'))) else None,
                "max_iterations": int(row.get('max_iterations', max_iterations))
            }
            
            # Handle processes - can come from row data or use default
            if 'processes' in row and pd.notna(row['processes']):
                # If processes is stored as JSON string in DataFrame
                if isinstance(row['processes'], str):
                    try:
                        payload["processes"] = json.loads(row['processes'])
                    except json.JSONDecodeError:
                        payload["processes"] = processes or []
                else:
                    payload["processes"] = row['processes']
            else:
                payload["processes"] = processes or []
            
            # Remove None values from payload
            payload = {k: v for k, v in payload.items() if v is not None}
            
            print(f"Sending request {index + 1}/{len(df)} for ID: {payload['id']}")
            
            # Make API request
            response = requests.post(
                api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            # Store result
            result = {
                'row_index': index,
                'element_id': payload['id'],
                'status_code': response.status_code,
                'success': response.status_code == 200,
                'response_data': None,
                'error': None
            }
            
            if response.status_code == 200:
                try:
                    result['response_data'] = response.json()
                except json.JSONDecodeError:
                    result['response_data'] = response.text
            else:
                result['error'] = f"HTTP {response.status_code}: {response.text}"
                print(f"Error for row {index}: {result['error']}")
            
            results.append(result)
            
            # Add delay to avoid rate limiting
            if delay_between_requests > 0:
                time.sleep(delay_between_requests)
                
        except requests.exceptions.RequestException as e:
            error_result = {
                'row_index': index,
                'element_id': str(row.get('element_id', row.get('id', f'element_{index}'))),
                'status_code': None,
                'success': False,
                'response_data': None,
                'error': f"Request exception: {str(e)}"
            }
            results.append(error_result)
            print(f"Request failed for row {index}: {str(e)}")
            
        except Exception as e:
            error_result = {
                'row_index': index,
                'element_id': str(row.get('element_id', row.get('id', f'element_{index}'))),
                'status_code': None,
                'success': False,
                'response_data': None,
                'error': f"Unexpected error: {str(e)}"
            }
            results.append(error_result)
            print(f"Unexpected error for row {index}: {str(e)}")
    
    return results

def create_sample_processes():
    """Helper function to create sample processes array"""
    return [
        {
            "process_id": "PROC-001",
            "process_name": "Customer Onboarding",
            "process_description": "Process description..."
        },
        {
            "process_id": "PROC-002", 
            "process_name": "Another Process",
            "process_description": "Another description..."
        }
    ]

# Example usage
if __name__ == "__main__":
    # Sample DataFrame
    sample_data = {
        'element_id': ['elem_001', 'elem_002', 'elem_003'],
        'element_name': ['First Element', 'Second Element', 'Third Element'],
        'element_description': ['Description 1', 'Description 2', 'Description 3'],
        'optional_example': ['Example 1', None, 'Example 3'],
        'max_iterations': [5, 3, 7]
    }
    
    df = pd.DataFrame(sample_data)
    
    # API configuration
    api_url = "https://your-api-endpoint.com/process"
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer your-api-token'  # Add your auth token
    }
    
    # Default processes for all requests
    default_processes = create_sample_processes()
    
    # Send requests
    results = send_row_to_api(
        df=df,
        api_url=api_url,
        headers=headers,
        processes=default_processes,
        delay_between_requests=0.5  # 500ms delay between requests
    )
    
    # Process results
    successful_requests = [r for r in results if r['success']]
    failed_requests = [r for r in results if not r['success']]
    
    print(f"\nSummary:")
    print(f"Total requests: {len(results)}")
    print(f"Successful: {len(successful_requests)}")
    print(f"Failed: {len(failed_requests)}")
    
    if failed_requests:
        print("\nFailed requests:")
        for fail in failed_requests:
            print(f"Row {fail['row_index']} (ID: {fail['element_id']}): {fail['error']}")
    
    # Convert results to DataFrame for easy analysis
    results_df = pd.DataFrame(results)
    print(f"\nResults saved to DataFrame with shape: {results_df.shape}")

# Alternative: More flexible approach with custom payload builder
def build_custom_payload(row: pd.Series, processes: List[Dict] = None) -> Dict[str, Any]:
    """
    Custom payload builder - modify this function to match your exact DataFrame structure
    """
    payload = {
        "id": row['your_id_column'],
        "existing_name": row['your_name_column'], 
        "existing_description": row['your_description_column'],
        "max_iterations": row.get('max_iterations', 5)
    }
    
    # Add example if it exists and is not null
    if 'example_column' in row and pd.notna(row['example_column']):
        payload["example"] = row['example_column']
    
    # Add processes
    payload["processes"] = processes or []
    
    return payload

def send_with_custom_builder(df: pd.DataFrame, api_url: str, headers: Dict[str, str] = None) -> List[Dict]:
    """Send requests using custom payload builder"""
    results = []
    default_processes = create_sample_processes()
    
    for index, row in df.iterrows():
        try:
            payload = build_custom_payload(row, default_processes)
            
            response = requests.post(api_url, headers=headers, json=payload, timeout=30)
            
            results.append({
                'row_index': index,
                'success': response.status_code == 200,
                'status_code': response.status_code,
                'response': response.json() if response.status_code == 200 else response.text
            })
            
        except Exception as e:
            results.append({
                'row_index': index,
                'success': False,
                'error': str(e)
            })
    
    return results
