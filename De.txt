import { JsonRule, ParsedRuleNode, RuleEdge, RuleGraph, ConditionDisplay, RuleAnalytics, RuleCondition } from '../types/rules';

export const parseRulesData = (rawRules: JsonRule[]): RuleGraph => {
  const nodes: ParsedRuleNode[] = [];
  const edges: RuleEdge[] = [];

  rawRules.forEach((rule, index) => {
    const node: ParsedRuleNode = {
      id: rule.rule_id || `rule-${index}`,
      type: 'rule',
      position: { x: 0, y: 0 }, // Will be calculated by layout
      data: {
        rule,
        label: rule.rule_text || `Rule ${index + 1}`,
        conditions: extractConditions(rule.conditions),
        event: rule.event,
        priority: rule.priority || 50,
        countries: rule.applies_to_countries || [],
        adequacyCountries: rule.adequacy_countries || []
      }
    };
    nodes.push(node);
  });

  // Create edges based on rule relationships (priority order, shared conditions, etc.)
  nodes.forEach((node, index) => {
    if (index > 0) {
      const prevNode = nodes[index - 1];
      if (shouldCreateEdge(prevNode.data, node.data)) {
        edges.push({
          id: `edge-${prevNode.id}-${node.id}`,
          source: prevNode.id,
          target: node.id,
          type: 'smoothstep',
          animated: true,
          style: { stroke: '#64748b', strokeWidth: 2 }
        });
      }
    }
  });

  return { nodes, edges };
};

const extractConditions = (conditions: any): RuleCondition[] => {
  const result: RuleCondition[] = [];
  
  if (conditions.all) {
    result.push(...conditions.all);
  }
  if (conditions.any) {
    result.push(...conditions.any);
  }
  
  return result;
};

const shouldCreateEdge = (nodeA: any, nodeB: any): boolean => {
  // Create edges based on priority proximity or shared facts
  const priorityDiff = Math.abs(nodeA.priority - nodeB.priority);
  return priorityDiff <= 10 || hasSharedFacts(nodeA.conditions, nodeB.conditions);
};

const hasSharedFacts = (conditionsA: RuleCondition[], conditionsB: RuleCondition[]): boolean => {
  const factsA = new Set(conditionsA.map(c => 'fact' in c ? c.fact : ''));
  const factsB = new Set(conditionsB.map(c => 'fact' in c ? c.fact : ''));
  
  for (const fact of factsA) {
    if (factsB.has(fact)) return true;
  }
  return false;
};

export const formatConditionForDisplay = (condition: RuleCondition): ConditionDisplay => {
  if ('fact' in condition) {
    return {
      fact: condition.fact,
      operator: condition.operator,
      value: condition.value,
      readable: `${condition.fact} ${formatOperator(condition.operator)} ${formatValue(condition.value)}`
    };
  }
  
  // Handle group conditions
  return {
    fact: 'group',
    operator: 'group',
    value: condition,
    readable: 'Complex condition group'
  };
};

const formatOperator = (operator: string): string => {
  const operatorMap: Record<string, string> = {
    'equal': '=',
    'notEqual': '≠',
    'greaterThan': '>',
    'lessThan': '<',
    'greaterThanInclusive': '≥',
    'lessThanInclusive': '≤',
    'contains': 'contains',
    'notContains': 'does not contain',
    'in': 'in',
    'notIn': 'not in'
  };
  
  return operatorMap[operator] || operator;
};

const formatValue = (value: any): string => {
  if (Array.isArray(value)) {
    return `[${value.join(', ')}]`;
  }
  if (typeof value === 'string') {
    return `"${value}"`;
  }
  return String(value);
};

export const generateRuleAnalytics = (rules: JsonRule[]): RuleAnalytics => {
  const analytics: RuleAnalytics = {
    totalRules: rules.length,
    conditionTypes: {},
    eventTypes: {},
    priorityDistribution: {},
    countryDistribution: {}
  };

  rules.forEach(rule => {
    // Count event types
    const eventType = rule.event.type;
    analytics.eventTypes[eventType] = (analytics.eventTypes[eventType] || 0) + 1;

    // Count priority distribution
    const priority = rule.priority || 50;
    const priorityRange = getPriorityRange(priority);
    analytics.priorityDistribution[priorityRange] = (analytics.priorityDistribution[priorityRange] || 0) + 1;

    // Count countries
    if (rule.applies_to_countries) {
      rule.applies_to_countries.forEach(country => {
        analytics.countryDistribution[country] = (analytics.countryDistribution[country] || 0) + 1;
      });
    }

    // Count condition types
    const conditions = extractConditions(rule.conditions);
    conditions.forEach(condition => {
      if ('fact' in condition) {
        analytics.conditionTypes[condition.fact] = (analytics.conditionTypes[condition.fact] || 0) + 1;
      }
    });
  });

  return analytics;
};

const getPriorityRange = (priority: number): string => {
  if (priority >= 80) return 'High (80-100)';
  if (priority >= 60) return 'Medium (60-79)';
  if (priority >= 40) return 'Low (40-59)';
  return 'Very Low (0-39)';
};
