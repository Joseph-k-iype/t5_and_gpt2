"""
ODRL Rule Generator - Creates machine-readable ODRL policies with STRICT action taxonomy.
Generates W3C ODRL-compliant JSON-LD output using ONLY 5 standard actions.

ABSOLUTELY COMPLETE VERSION - ALL METHODS INCLUDED

CRITICAL: Only these 5 actions are allowed: share, store, process, update, create
All synonyms are mapped to these standard actions.

Location: src/generators/odrl_rule_generator.py
"""
import logging
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
import uuid

logger = logging.getLogger(__name__)


class ODRLRuleGenerator:
    """
    Generates W3C ODRL 2.2 compliant policies with STRICT action taxonomy.
    Creates machine-readable rules with proper ODRL structure.
    
    ONLY these 5 actions are permitted: share, store, process, update, create
    
    ABSOLUTELY COMPLETE - ALL METHODS INCLUDED:
    - Action validation and normalization
    - Policy generation (CSV, PDF, multiple components)
    - Permission/Prohibition/Duty/Constraint creation
    - Comment generation  
    - Validation
    - Helper methods
    """
    
    # ============================================================================
    # STANDARD ACTION TAXONOMY - THESE ARE THE ONLY 5 ACTIONS ALLOWED
    # ============================================================================
    STANDARD_ACTIONS = {
        "share", "store", "process", "update", "create"
    }
    
    # ============================================================================
    # NAMESPACE CONFIGURATION
    # ============================================================================
    ODRL_NAMESPACE = "http://www.w3.org/ns/odrl/2/"
    CUSTOM_ACTION_NAMESPACE = "https://w3id.org/dpv/actions#"
    
    # ============================================================================
    # ACTION URI MAPPING - Uses custom namespace with our 5 standard actions
    # ============================================================================
    ODRL_ACTIONS = {
        "share": f"{CUSTOM_ACTION_NAMESPACE}Share",
        "store": f"{CUSTOM_ACTION_NAMESPACE}Store",
        "process": f"{CUSTOM_ACTION_NAMESPACE}Process",
        "update": f"{CUSTOM_ACTION_NAMESPACE}Update",
        "create": f"{CUSTOM_ACTION_NAMESPACE}Create"
    }
    
    # ============================================================================
    # COMPREHENSIVE SYNONYM MAPPING - All synonyms map to one of 5 standard actions
    # ============================================================================
    ACTION_SYNONYMS = {
        # Share synonyms - any form of transfer/distribution/disclosure
        "share": "share",
        "distribute": "share",
        "transfer": "share",
        "disclose": "share",
        "transmit": "share",
        "send": "share",
        "communicate": "share",
        "provide": "share",
        "give": "share",
        "forward": "share",
        "reveal": "share",
        "expose": "share",
        
        # Store synonyms - any form of retention/archiving
        "store": "store",
        "archive": "store",
        "retain": "store",
        "keep": "store",
        "maintain": "store",
        "hold": "store",
        "save": "store",
        "preserve": "store",
        "backup": "store",
        
        # Process synonyms - any form of use/analysis/transformation
        "process": "process",
        "use": "process",
        "analyze": "process",
        "transform": "process",
        "modify": "process",
        "manipulate": "process",
        "handle": "process",
        "execute": "process",
        "apply": "process",
        "implement": "process",
        "perform": "process",
        "read": "process",
        "access": "process",
        "view": "process",
        
        # Update synonyms - any form of change/amendment
        "update": "update",
        "change": "update",
        "amend": "update",
        "revise": "update",
        "alter": "update",
        "edit": "update",
        "correct": "update",
        "rectify": "update",
        "fix": "update",
        
        # Create synonyms - any form of collection/generation
        "create": "create",
        "collect": "create",
        "generate": "create",
        "produce": "create",
        "derive": "create",
        "obtain": "create",
        "gather": "create",
        "acquire": "create",
        "compile": "create"
    }
    
    # ============================================================================
    # ODRL OPERATORS
    # ============================================================================
    ODRL_OPERATORS = {
        "eq": f"{ODRL_NAMESPACE}eq",
        "neq": f"{ODRL_NAMESPACE}neq",
        "gt": f"{ODRL_NAMESPACE}gt",
        "gteq": f"{ODRL_NAMESPACE}gteq",
        "lt": f"{ODRL_NAMESPACE}lt",
        "lteq": f"{ODRL_NAMESPACE}lteq",
        "isAnyOf": f"{ODRL_NAMESPACE}isAnyOf",
        "isAllOf": f"{ODRL_NAMESPACE}isAllOf",
        "isNoneOf": f"{ODRL_NAMESPACE}isNoneOf",
        "isPartOf": f"{ODRL_NAMESPACE}isPartOf"
    }
    
    # ============================================================================
    # COMMON CONSTRAINT LEFT OPERANDS
    # ============================================================================
    ODRL_LEFT_OPERANDS = {
        "dateTime": f"{ODRL_NAMESPACE}dateTime",
        "delayPeriod": f"{ODRL_NAMESPACE}delayPeriod",
        "elapsedTime": f"{ODRL_NAMESPACE}elapsedTime",
        "event": f"{ODRL_NAMESPACE}event",
        "count": f"{ODRL_NAMESPACE}count",
        "percentage": f"{ODRL_NAMESPACE}percentage",
        "spatial": f"{ODRL_NAMESPACE}spatial",
        "purpose": f"{ODRL_NAMESPACE}purpose",
        "industry": f"{ODRL_NAMESPACE}industry",
        "fileFormat": f"{ODRL_NAMESPACE}fileFormat",
        "deliveryChannel": f"{ODRL_NAMESPACE}deliveryChannel",
        "language": f"{ODRL_NAMESPACE}language",
        "media": f"{ODRL_NAMESPACE}media",
        "timeInterval": f"{ODRL_NAMESPACE}timeInterval",
        "unitOfCount": f"{ODRL_NAMESPACE}unitOfCount",
        "version": f"{ODRL_NAMESPACE}version",
        "requestor": f"{ODRL_NAMESPACE}requestor",
        "recipient": f"{ODRL_NAMESPACE}recipient"
    }
    
    def __init__(self):
        """Initialize ODRL rule generator."""
        logger.info("Initialized ODRLRuleGenerator with STRICT 5-action taxonomy")
    
    # ============================================================================
    # ACTION VALIDATION AND NORMALIZATION
    # ============================================================================
    
    def validate_action(self, action: str) -> str:
        """
        Validate and normalize action to standard taxonomy.
        
        This is the CRITICAL method that ensures ONLY standard actions are used.
        All actions must go through this method before being used.
        
        Args:
            action: Action name (may be synonym)
            
        Returns:
            Normalized standard action (share/store/process/update/create)
            
        Raises:
            ValueError: If action cannot be mapped to standard taxonomy
        """
        if not action:
            logger.warning("Empty action provided, defaulting to 'process'")
            return "process"
        
        # Normalize to lowercase and strip whitespace
        action_normalized = action.lower().strip()
        
        # Remove common prefixes/suffixes
        action_normalized = action_normalized.replace("data ", "").replace(" data", "")
        
        # Check if it's already a standard action
        if action_normalized in self.STANDARD_ACTIONS:
            return action_normalized
        
        # Try to map from synonyms
        if action_normalized in self.ACTION_SYNONYMS:
            mapped_action = self.ACTION_SYNONYMS[action_normalized]
            logger.info(f"Mapped action '{action}' to standard action '{mapped_action}'")
            return mapped_action
        
        # Try partial matching for complex action names
        for synonym, standard in self.ACTION_SYNONYMS.items():
            if synonym in action_normalized or action_normalized in synonym:
                logger.info(f"Partially matched action '{action}' to standard action '{standard}'")
                return standard
        
        # If we can't map it, log error and default to process
        logger.error(f"Could not map action '{action}' to standard taxonomy, defaulting to 'process'")
        return "process"
    
    def _get_action_uri(self, action: str) -> str:
        """
        Get action URI for a validated action.
        
        CRITICAL: This method MUST only return URIs from ODRL_ACTIONS mapping,
        which uses our custom namespace with the 5 standard actions.
        
        Args:
            action: Action name (will be validated)
            
        Returns:
            Action URI from custom namespace (e.g., https://w3id.org/dpv/actions#Share)
        """
        # ALWAYS validate first - this ensures only standard actions are used
        normalized_action = self.validate_action(action)
        
        # Get URI from our mapping - this will always succeed because validate_action
        # guarantees one of the 5 standard actions
        action_uri = self.ODRL_ACTIONS[normalized_action]
        
        logger.debug(f"Action '{action}' → normalized to '{normalized_action}' → URI '{action_uri}'")
        
        return action_uri
    
    # ============================================================================
    # POLICY GENERATION - MAIN METHODS
    # ============================================================================
    
    def generate_policy_json(
        self,
        policy_id: str,
        rule_name: str,
        odrl_components: Any,
        framework_type: str = "DSS",
        restriction_condition: str = "restriction",
        data_category_uuids: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """
        Generate complete ODRL policy as JSON-LD from ODRL components.
        Used by CSV/Excel processing.
        
        Args:
            policy_id: Unique identifier for the policy
            rule_name: Human-readable rule name
            odrl_components: Extracted ODRL components
            framework_type: DSS or DataVISA
            restriction_condition: restriction or condition
            data_category_uuids: Mapping of data category names to UUIDs
            
        Returns:
            ODRL policy as dictionary (JSON-LD)
        """
        policy_uid = f"urn:policy:{policy_id}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "actions": "https://w3id.org/dpv/actions#",
                "custom": "http://example.org/custom#"
            },
            "@type": "odrl:Policy",
            "uid": policy_uid,
            "profile": f"urn:profile:{framework_type.lower().replace(' ', '_')}",
            "dc:title": rule_name,
            "dc:description": f"{framework_type} {restriction_condition}: {rule_name}",
            "dc:created": datetime.now().isoformat(),
            "dc:identifier": policy_id
        }
        
        # Add permissions
        if odrl_components.permissions:
            permissions = []
            for perm in odrl_components.permissions:
                odrl_perm = self._create_permission(perm, data_category_uuids)
                if odrl_perm:
                    permissions.append(odrl_perm)
            
            if permissions:
                policy["permission"] = permissions
        
        # Add prohibitions
        if odrl_components.prohibitions:
            prohibitions = []
            for prohib in odrl_components.prohibitions:
                odrl_prohib = self._create_prohibition(prohib, data_category_uuids)
                if odrl_prohib:
                    prohibitions.append(odrl_prohib)
            
            if prohibitions:
                policy["prohibition"] = prohibitions
        
        # Add metadata
        if odrl_components.data_categories:
            policy["dc:subject"] = odrl_components.data_categories
        
        if odrl_components.geographic_scope:
            policy["dc:coverage"] = odrl_components.geographic_scope
        
        if odrl_components.purpose:
            policy["dc:purpose"] = odrl_components.purpose
        
        # Add custom metadata
        policy["custom:framework"] = framework_type
        policy["custom:type"] = restriction_condition
        policy["custom:confidenceScore"] = odrl_components.confidence_score
        
        if data_category_uuids:
            policy["custom:dataCategoryUUIDs"] = data_category_uuids
        
        return policy
    
    def generate_policy_from_multiple_components(
        self,
        entry_id: str,
        parent_title: str,
        all_components: List[Any],
        countries: List[str],
        adequacy_countries: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate ONE policy from multiple ODRL components (from multiple rules/segments).
        All rules go into ONE policy with the SAME policy ID.
        Used by PDF processing.
        
        Args:
            entry_id: Parent entry ID from legislation_metadata.json
            parent_title: Title to use (typically same as entry_id)
            all_components: List of ODRLComponents from all rules
            countries: Applicable countries
            adequacy_countries: Adequacy countries
            
        Returns:
            Single ODRL policy with all rules included
        """
        # Create single policy UID for parent
        safe_id = entry_id.replace(" ", "_").replace("/", "_")
        policy_uid = f"urn:policy:{safe_id}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "dpv": "https://w3id.org/dpv#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "actions": "https://w3id.org/dpv/actions#",
                "custom": "http://example.org/custom#"
            },
            "@type": "odrl:Set",
            "uid": policy_uid,
            "profile": "http://www.w3.org/ns/odrl/2/core"
        }
        
        # Add metadata
        policy["dct:created"] = datetime.now().isoformat()
        policy["dct:creator"] = "Legislation Analysis System"
        
        # Use entry_id as title
        policy["dc:title"] = parent_title or entry_id
        
        # Create complete sentence description
        if countries:
            country_str = ", ".join(countries)
            if len(countries) == 1:
                policy["dc:description"] = f"Data protection and privacy requirements for {entry_id} applicable in {country_str}."
            else:
                policy["dc:description"] = f"Data protection and privacy requirements for {entry_id} applicable across {country_str}."
        else:
            policy["dc:description"] = f"Data protection and privacy requirements for {entry_id}."
        
        # Add geographic coverage
        if countries:
            policy["dc:coverage"] = countries
        
        # Add adequacy countries if provided
        if adequacy_countries:
            policy["custom:adequacyCountries"] = adequacy_countries
        
        # Add entry_id as identifier
        policy["dc:identifier"] = entry_id
        
        # Collect ALL permissions and prohibitions from ALL components
        all_permissions = []
        all_prohibitions = []
        all_data_categories = set()
        
        for components in all_components:
            # Handle both ODRLComponents objects and dicts
            if hasattr(components, 'permissions'):
                permissions = components.permissions
            else:
                permissions = components.get("permissions", [])
            
            if hasattr(components, 'prohibitions'):
                prohibitions = components.prohibitions
            else:
                prohibitions = components.get("prohibitions", [])
            
            if hasattr(components, 'data_categories'):
                data_cats = components.data_categories
            else:
                data_cats = components.get("data_categories", [])
            
            # Add permissions
            if permissions:
                for perm in permissions:
                    odrl_perm = self._create_permission(perm)
                    if odrl_perm:
                        all_permissions.append(odrl_perm)
            
            # Add prohibitions
            if prohibitions:
                for prohib in prohibitions:
                    odrl_prohib = self._create_prohibition(prohib)
                    if odrl_prohib:
                        all_prohibitions.append(odrl_prohib)
            
            # Collect data categories
            if data_cats:
                all_data_categories.update(data_cats)
        
        # Add to policy
        if all_permissions:
            policy["permission"] = all_permissions
        if all_prohibitions:
            policy["prohibition"] = all_prohibitions
        if all_data_categories:
            policy["dc:subject"] = list(all_data_categories)
        
        logger.info(f"Generated policy for {entry_id}: {len(all_permissions)} permissions, {len(all_prohibitions)} prohibitions")
        
        return policy
    
    def generate_policy(
        self, 
        rules: List[Any] = None,
        policy_uid: str = None,
        policy_type: str = "Set",
        # CSV/Excel converter parameters
        policy_id: str = None,
        rule_name: str = None,
        odrl_components: Any = None,
        framework_type: str = None,
        restriction_condition: str = None,
        data_category_uuids: Dict[str, str] = None,
        # Additional parameters for PDF processing
        entry_id: str = None,
        parent_title: str = None,
        countries: List[str] = None,
        adequacy_countries: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate complete ODRL policy from rules OR from ODRL components.
        Unified interface supporting both PDF and CSV/Excel processing.
        
        Supports two calling patterns:
        1. PDF Processing: generate_policy(rules=..., policy_uid=..., entry_id=..., parent_title=...)
        2. CSV/Excel Processing: generate_policy(policy_id=..., rule_name=..., odrl_components=...)
        
        Args:
            rules: List of rules (for PDF processing)
            policy_uid: Policy UID (for PDF processing)
            policy_type: Policy type (for PDF processing)
            policy_id: Policy ID (for CSV/Excel processing)
            rule_name: Rule name (for CSV/Excel processing)
            odrl_components: ODRL components (for CSV/Excel processing)
            framework_type: Framework type
            restriction_condition: Restriction condition
            data_category_uuids: Data category UUIDs
            entry_id: Entry ID (for PDF processing)
            parent_title: Parent title (for PDF processing)
            countries: Countries (for PDF processing)
            adequacy_countries: Adequacy countries (for PDF processing)
            
        Returns:
            ODRL policy as dictionary (JSON-LD)
        """
        # Determine which calling pattern is being used
        if odrl_components is not None:
            # CSV/Excel processing - use generate_policy_json
            return self.generate_policy_json(
                policy_id=policy_id,
                rule_name=rule_name,
                odrl_components=odrl_components,
                framework_type=framework_type or "DSS",
                restriction_condition=restriction_condition or "restriction",
                data_category_uuids=data_category_uuids
            )
        elif rules is not None:
            # PDF processing - use generate_policy_from_rules
            return self.generate_policy_from_rules(
                rules=rules,
                policy_uid=policy_uid,
                policy_type=policy_type,
                entry_id=entry_id,
                parent_title=parent_title,
                countries=countries,
                adequacy_countries=adequacy_countries
            )
        else:
            raise ValueError("Must provide either 'odrl_components' or 'rules' parameter")
    
    def generate_policy_from_rules(
        self,
        rules: List[Any],
        policy_uid: str,
        policy_type: str = "Set",
        entry_id: str = None,
        parent_title: str = None,
        countries: List[str] = None,
        adequacy_countries: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate ODRL policy from a list of rules (PDF processing).
        
        Args:
            rules: List of rules
            policy_uid: Unique policy identifier
            policy_type: Type of policy (Set, Offer, Agreement)
            entry_id: Entry ID
            parent_title: Parent title
            countries: List of countries
            adequacy_countries: List of adequacy countries
            
        Returns:
            ODRL policy dictionary
        """
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "actions": "https://w3id.org/dpv/actions#",
                "custom": "http://example.org/custom#"
            },
            "@type": f"odrl:{policy_type}",
            "uid": policy_uid,
            "dc:title": parent_title or entry_id,
            "dc:created": datetime.now().isoformat()
        }
        
        # Add countries if provided
        if countries:
            policy["dc:coverage"] = countries
        
        if adequacy_countries:
            policy["custom:adequacyCountries"] = adequacy_countries
        
        # Collect all permissions and prohibitions from rules
        all_permissions = []
        all_prohibitions = []
        
        for rule in rules:
            if hasattr(rule, 'permissions') and rule.permissions:
                for perm in rule.permissions:
                    odrl_perm = self._create_permission(perm)
                    if odrl_perm:
                        all_permissions.append(odrl_perm)
            
            if hasattr(rule, 'prohibitions') and rule.prohibitions:
                for prohib in rule.prohibitions:
                    odrl_prohib = self._create_prohibition(prohib)
                    if odrl_prohib:
                        all_prohibitions.append(odrl_prohib)
        
        # Add to policy
        if all_permissions:
            policy["permission"] = all_permissions
        
        if all_prohibitions:
            policy["prohibition"] = all_prohibitions
        
        return policy
    
    # ============================================================================
    # PERMISSION CREATION
    # ============================================================================
    
    def _create_permission(
        self, 
        permission: Dict[str, Any],
        data_category_uuids: Dict[str, str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL permission from extracted permission data.
        
        NOTE: Assigner and assignee fields are NOT included (by design).
        Focus is on the action, target, and conditions.
        """
        try:
            odrl_permission = {}
            
            # Add action (ALWAYS validated through _get_action_uri)
            action = permission.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_permission["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_permission["action"] = self.ODRL_ACTIONS["process"]
                logger.warning("No action specified in permission, defaulting to 'process'")
            
            # Add target (asset)
            target = permission.get("target", "data")
            odrl_permission["target"] = self._create_asset_reference(target)
            
            # Add constraints
            constraints = permission.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_permission["constraint"] = odrl_constraints
            
            # Add duties
            duties = permission.get("duties", [])
            if duties:
                odrl_duties = []
                for duty in duties:
                    odrl_duty = self._create_duty(duty)
                    if odrl_duty:
                        odrl_duties.append(odrl_duty)
                
                if odrl_duties:
                    odrl_permission["duty"] = odrl_duties
            
            # Add detailed description as comment
            description = permission.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self._generate_permission_comment(
                    permission.get("action", "process"),
                    target,
                    constraints
                )
            
            odrl_permission["rdfs:comment"] = description
            
            return odrl_permission
        
        except Exception as e:
            logger.error(f"Error creating permission: {e}")
            logger.error(f"Permission data: {permission}")
            return None
    
    # ============================================================================
    # PROHIBITION CREATION
    # ============================================================================
    
    def _create_prohibition(
        self, 
        prohibition: Dict[str, Any],
        data_category_uuids: Dict[str, Any] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL prohibition from extracted prohibition data.
        
        NOTE: Assigner and assignee fields are NOT included (by design).
        """
        try:
            odrl_prohibition = {}
            
            # Add action (ALWAYS validated through _get_action_uri)
            action = prohibition.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_prohibition["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_prohibition["action"] = self.ODRL_ACTIONS["process"]
                logger.warning("No action specified in prohibition, defaulting to 'process'")
            
            # Add target (asset)
            target = prohibition.get("target", "data")
            odrl_prohibition["target"] = self._create_asset_reference(target)
            
            # Add constraints
            constraints = prohibition.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_prohibition["constraint"] = odrl_constraints
            
            # Add detailed description as comment
            description = prohibition.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self._generate_prohibition_comment(
                    prohibition.get("action", "process"),
                    target,
                    constraints
                )
            
            odrl_prohibition["rdfs:comment"] = description
            
            return odrl_prohibition
        
        except Exception as e:
            logger.error(f"Error creating prohibition: {e}")
            logger.error(f"Prohibition data: {prohibition}")
            return None
    
    # ============================================================================
    # CONSTRAINT CREATION
    # ============================================================================
    
    def _create_constraint(self, constraint: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Create ODRL constraint."""
        try:
            if not constraint:
                return None
            
            odrl_constraint = {}
            
            # Left operand
            left_operand = constraint.get("leftOperand")
            if left_operand:
                odrl_constraint["leftOperand"] = self._get_left_operand_uri(left_operand)
            
            # Operator
            operator = constraint.get("operator", "eq")
            odrl_constraint["operator"] = self._get_operator_uri(operator)
            
            # Right operand
            right_operand = constraint.get("rightOperand")
            if right_operand:
                odrl_constraint["rightOperand"] = right_operand
            
            # Add description if available
            description = constraint.get("description")
            if description:
                odrl_constraint["rdfs:comment"] = description
            
            return odrl_constraint
        
        except Exception as e:
            logger.error(f"Error creating constraint: {e}")
            logger.error(f"Constraint data: {constraint}")
            return None
    
    # ============================================================================
    # DUTY CREATION
    # ============================================================================
    
    def _create_duty(self, duty: Union[str, Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Create ODRL duty - handles both string and dict formats."""
        try:
            if not duty:
                return None
            
            odrl_duty = {}
            
            # Handle string duties (simple description)
            if isinstance(duty, str):
                odrl_duty["action"] = self.ODRL_ACTIONS["process"]
                odrl_duty["rdfs:comment"] = duty
                return odrl_duty
            
            # Handle dict duties (structured)
            if isinstance(duty, dict):
                # Add action (ALWAYS validated)
                action = duty.get("action")
                if action:
                    action_uri = self._get_action_uri(action)
                    odrl_duty["action"] = action_uri
                else:
                    odrl_duty["action"] = self.ODRL_ACTIONS["process"]
                
                # Add target if specified
                target = duty.get("target")
                if target:
                    odrl_duty["target"] = self._create_asset_reference(target)
                
                # Add constraints
                constraints = duty.get("constraints", [])
                if constraints:
                    odrl_constraints = []
                    for constraint in constraints:
                        odrl_constraint = self._create_constraint(constraint)
                        if odrl_constraint:
                            odrl_constraints.append(odrl_constraint)
                    
                    if odrl_constraints:
                        odrl_duty["constraint"] = odrl_constraints
                
                # Add description
                description = duty.get("description")
                if description:
                    odrl_duty["rdfs:comment"] = description
                else:
                    # Generate if not provided
                    odrl_duty["rdfs:comment"] = self._generate_duty_comment(
                        duty.get("action", "process"),
                        target or "data",
                        constraints
                    )
                
                return odrl_duty
            
            logger.warning(f"Duty is neither string nor dict: {type(duty)}")
            return None
        
        except Exception as e:
            logger.error(f"Error creating duty: {e}")
            logger.error(f"Duty data: {duty}")
            return None
    
    # ============================================================================
    # HELPER METHODS
    # ============================================================================
    
    def _create_asset_reference(self, target: str) -> str:
        """Create asset/target reference."""
        if not target:
            return "urn:data:unspecified"
        
        # If it looks like a URI, use it
        if target.startswith("http://") or target.startswith("https://") or target.startswith("urn:"):
            return target
        
        # Otherwise create a URN from the description
        safe_target = target.replace(" ", "_").replace("/", "_")
        return f"urn:data:{safe_target}"
    
    def _get_operator_uri(self, operator: str) -> str:
        """Get ODRL operator URI."""
        operator_lower = operator.lower().strip()
        
        if operator_lower in self.ODRL_OPERATORS:
            return self.ODRL_OPERATORS[operator_lower]
        
        # Try common aliases
        aliases = {
            "equals": "eq",
            "equal": "eq",
            "==": "eq",
            "not_equal": "neq",
            "!=": "neq",
            "greater_than": "gt",
            ">": "gt",
            "less_than": "lt",
            "<": "lt",
            ">=": "gteq",
            "<=": "lteq"
        }
        
        if operator_lower in aliases:
            return self.ODRL_OPERATORS[aliases[operator_lower]]
        
        # Default to eq
        logger.warning(f"Unknown operator '{operator}', defaulting to 'eq'")
        return self.ODRL_OPERATORS["eq"]
    
    def _get_left_operand_uri(self, left_operand: str) -> str:
        """Get ODRL left operand URI, creating custom if needed."""
        operand_lower = left_operand.lower().strip()
        
        # Check standard operands
        if operand_lower in self.ODRL_LEFT_OPERANDS:
            return self.ODRL_LEFT_OPERANDS[operand_lower]
        
        # Try to find similar operand
        for key, uri in self.ODRL_LEFT_OPERANDS.items():
            if key in operand_lower or operand_lower in key:
                return uri
        
        # Create custom left operand
        custom_operand = left_operand.replace(" ", "_").replace("-", "_")
        return f"{self.ODRL_NAMESPACE}{custom_operand}"
    
    # ============================================================================
    # COMMENT GENERATION
    # ============================================================================
    
    def _generate_permission_comment(
        self, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None
    ) -> str:
        """Generate detailed permission comment."""
        # Normalize action first
        action_normalized = self.validate_action(action)
        
        # Action descriptions using our standard taxonomy
        action_descriptions = {
            "share": "shared with third parties or transferred to other organizations",
            "store": "retained and stored in organizational systems",
            "process": "analyzed, used, or otherwise processed",
            "update": "modified, corrected, or amended",
            "create": "collected, generated, or derived from other sources"
        }
        
        action_desc = action_descriptions.get(action_normalized, "processed")
        
        comment = f"This permission allows {target} to be {action_desc} under specific conditions. "
        
        if constraints:
            constraint_count = len(constraints)
            if constraint_count == 1:
                comment += "One specific condition must be satisfied before this action can be performed. "
            else:
                comment += f"All {constraint_count} specified conditions must be satisfied before this action can be performed. "
            
            comment += f"Organizations must verify that all requirements are met before {action_normalized}ing {target}, and must maintain records of compliance verification."
        else:
            comment += f"Organizations must ensure that appropriate legal basis exists and that all general data protection principles are upheld when {action_normalized}ing {target}."
        
        return comment
    
    def _generate_prohibition_comment(
        self, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None
    ) -> str:
        """Generate detailed prohibition comment."""
        # Normalize action first
        action_normalized = self.validate_action(action)
        
        # Action descriptions using our standard taxonomy
        action_descriptions = {
            "share": "shared, transferred, or disclosed",
            "store": "retained, stored, or archived",
            "process": "used, analyzed, or processed",
            "update": "modified, changed, or amended",
            "create": "collected, generated, or created"
        }
        
        action_desc = action_descriptions.get(action_normalized, "processed")
        
        comment = f"This prohibition forbids {target} from being {action_desc} under specified circumstances. "
        
        if constraints:
            comment += "The prohibition applies when specific conditions are met. "
            comment += f"Organizations must ensure that {target} is never {action_desc} under these prohibited conditions, as doing so would violate data protection requirements and could result in regulatory penalties."
        else:
            comment += f"This is an absolute prohibition - {target} must never be {action_desc} under any circumstances."
        
        return comment
    
    def _generate_duty_comment(
        self, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None
    ) -> str:
        """Generate detailed duty comment."""
        # Normalize action first
        action_normalized = self.validate_action(action)
        
        # Action descriptions using our standard taxonomy
        action_descriptions = {
            "share": "provide notification or disclosure of",
            "store": "maintain records of",
            "process": "implement appropriate measures for",
            "update": "regularly review and update",
            "create": "establish and document"
        }
        
        action_desc = action_descriptions.get(action_normalized, "take appropriate action regarding")
        
        comment = f"This duty requires organizations to {action_desc} {target} to fulfill compliance obligations. "
        
        if constraints:
            constraint_count = len(constraints)
            if constraint_count == 1:
                comment += "The duty must be fulfilled under the specified condition. "
            else:
                comment += f"The duty must be fulfilled when any of the {constraint_count} specified conditions apply. "
        
        comment += f"Failure to fulfill this duty may result in non-compliance with data protection requirements and could expose the organization to regulatory enforcement actions."
        
        return comment
    
    def generate_detailed_comment(
        self, 
        rule_type: str, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None,
        existing_description: str = None
    ) -> str:
        """
        Generate detailed, grammatically correct comment for lawyers and non-lawyers.
        
        Ensures comments are:
        - Complete sentences
        - 2-3+ sentences minimum
        - Grammatically correct
        - Understandable by non-lawyers
        - Include legal context for lawyers
        
        Args:
            rule_type: 'permission', 'prohibition', or 'duty'
            action: The action being performed (from standard taxonomy)
            target: What the action applies to
            constraints: List of constraints
            existing_description: Existing description if any
            
        Returns:
            Detailed, grammatically correct comment (2-3+ sentences)
        """
        # Validate action first
        action = self.validate_action(action)
        
        # If we have a good existing description, use it
        if existing_description and len(existing_description) > 100 and existing_description[0].isupper() and existing_description.endswith('.'):
            return existing_description
        
        # Clean target description
        target_clean = target.replace("urn:data:", "").replace("_", " ").strip()
        if not target_clean:
            target_clean = "data"
        
        # Generate based on rule type
        if rule_type == "permission":
            comment = self._generate_permission_comment(action, target_clean, constraints)
        elif rule_type == "prohibition":
            comment = self._generate_prohibition_comment(action, target_clean, constraints)
        elif rule_type == "duty":
            comment = self._generate_duty_comment(action, target_clean, constraints)
        else:
            comment = f"This rule applies to {target_clean} and requires specific actions to be taken in accordance with data protection requirements."
        
        # Ensure comment ends with period
        if not comment.endswith('.'):
            comment += '.'
        
        # Ensure comment starts with capital letter
        if comment and not comment[0].isupper():
            comment = comment[0].upper() + comment[1:]
        
        return comment
    
    # ============================================================================
    # VALIDATION
    # ============================================================================
    
    def validate_policy(self, policy: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate ODRL policy structure and ensure all actions are from standard taxonomy.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            Validation result with any errors or warnings
        """
        errors = []
        warnings = []
        issues = []
        
        # Check basic structure
        if "@context" not in policy:
            errors.append("Missing @context")
        
        if "uid" not in policy:
            errors.append("Missing uid")
        
        # Validate all actions in permissions
        if "permission" in policy:
            for i, perm in enumerate(policy["permission"]):
                action_uri = perm.get("action", "")
                
                # Check if action URI is from our custom namespace
                if not action_uri.startswith(self.CUSTOM_ACTION_NAMESPACE):
                    error_msg = f"Permission {i}: Action URI '{action_uri}' not from custom namespace"
                    errors.append(error_msg)
                    issues.append(error_msg)
                
                # Extract action name from URI and verify it's a standard action
                action_name = action_uri.split("#")[-1].lower()
                if action_name not in self.STANDARD_ACTIONS:
                    error_msg = f"Permission {i}: Action '{action_name}' not in standard taxonomy"
                    errors.append(error_msg)
                    issues.append(error_msg)
        
        # Validate all actions in prohibitions
        if "prohibition" in policy:
            for i, prohib in enumerate(policy["prohibition"]):
                action_uri = prohib.get("action", "")
                
                # Check if action URI is from our custom namespace
                if not action_uri.startswith(self.CUSTOM_ACTION_NAMESPACE):
                    error_msg = f"Prohibition {i}: Action URI '{action_uri}' not from custom namespace"
                    errors.append(error_msg)
                    issues.append(error_msg)
                
                # Extract action name from URI and verify it's a standard action
                action_name = action_uri.split("#")[-1].lower()
                if action_name not in self.STANDARD_ACTIONS:
                    error_msg = f"Prohibition {i}: Action '{action_name}' not in standard taxonomy"
                    errors.append(error_msg)
                    issues.append(error_msg)
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
            "issues": issues  # For backward compatibility
        }
