"""
TTL to Property Graph Converter
===============================

A comprehensive solution to convert TTL (Turtle) files to property graphs
and upload them to both FalkorDB and Neo4j databases.

Dependencies:
- rdflib: For parsing TTL files
- falkordb: For FalkorDB connectivity  
- neo4j: For Neo4j connectivity
- urllib.parse: For URL handling

Install dependencies:
pip install rdflib falkordb neo4j
"""

import logging
import re
from typing import Dict, List, Tuple, Set, Any, Optional
from urllib.parse import urlparse
from collections import defaultdict
import hashlib

from rdflib import Graph, URIRef, Literal, BNode
from rdflib.namespace import RDF, RDFS, XSD, FOAF, SKOS
import falkordb
from neo4j import GraphDatabase


class TTLToPropertyGraphConverter:
    """
    Converts TTL files to property graph format and uploads to FalkorDB and Neo4j.
    
    This converter:
    1. Parses TTL files using RDFLib
    2. Extracts nodes (resources) and relationships (predicates)
    3. Converts RDF triples to property graph format
    4. Uploads to both FalkorDB and Neo4j
    5. Preserves all attributes and relationships
    """
    
    def __init__(self, 
                 falkor_host: str = "localhost",
                 falkor_port: int = 6379,
                 falkor_password: str = None,
                 neo4j_uri: str = "bolt://localhost:7687",
                 neo4j_username: str = "neo4j", 
                 neo4j_password: str = "password"):
        """
        Initialize the converter with database connection parameters.
        
        Args:
            falkor_host: FalkorDB host
            falkor_port: FalkorDB port
            falkor_password: FalkorDB password
            neo4j_uri: Neo4j connection URI
            neo4j_username: Neo4j username
            neo4j_password: Neo4j password
        """
        self.falkor_host = falkor_host
        self.falkor_port = falkor_port
        self.falkor_password = falkor_password
        self.neo4j_uri = neo4j_uri
        self.neo4j_username = neo4j_username
        self.neo4j_password = neo4j_password
        
        # RDF Graph to store parsed data
        self.rdf_graph = Graph()
        
        # Property graph data structures
        self.nodes: Dict[str, Dict] = {}
        self.relationships: List[Dict] = []
        self.node_labels: Dict[str, Set[str]] = defaultdict(set)
        
        # Configure logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        # Common namespace prefixes for cleaner node IDs
        self.namespace_prefixes = {
            "http://www.w3.org/1999/02/22-rdf-syntax-ns#": "rdf:",
            "http://www.w3.org/2000/01/rdf-schema#": "rdfs:",
            "http://www.w3.org/2001/XMLSchema#": "xsd:",
            "http://xmlns.com/foaf/0.1/": "foaf:",
            "http://www.w3.org/2004/02/skos/core#": "skos:",
            "http://purl.org/dc/elements/1.1/": "dc:",
            "http://purl.org/dc/terms/": "dcterms:",
            "http://schema.org/": "schema:",
            "http://dbpedia.org/resource/": "dbr:",
            "http://dbpedia.org/ontology/": "dbo:",
            "https://www.wikidata.org/wiki/": "wd:"
        }

    def load_ttl_file(self, file_path: str) -> None:
        """
        Load and parse a TTL file using RDFLib.
        
        Args:
            file_path: Path to the TTL file
        """
        try:
            self.logger.info(f"Loading TTL file: {file_path}")
            self.rdf_graph.parse(file_path, format="turtle")
            self.logger.info(f"Successfully loaded {len(self.rdf_graph)} triples")
        except Exception as e:
            self.logger.error(f"Error loading TTL file: {e}")
            raise

    def _get_node_id(self, term) -> str:
        """
        Generate a clean, unique identifier for a graph node.
        
        Args:
            term: RDF term (URIRef, Literal, or BNode)
            
        Returns:
            Clean node identifier
        """
        if isinstance(term, URIRef):
            uri_str = str(term)
            # Try to use namespace prefixes for cleaner IDs
            for namespace, prefix in self.namespace_prefixes.items():
                if uri_str.startswith(namespace):
                    return uri_str.replace(namespace, prefix)
            
            # Extract the last part of the URI for cleaner IDs
            parsed = urlparse(uri_str)
            if parsed.fragment:
                return f"{parsed.netloc}#{parsed.fragment}"
            elif "/" in parsed.path:
                return f"{parsed.netloc}{parsed.path.split('/')[-1]}"
            else:
                return uri_str
                
        elif isinstance(term, Literal):
            # For literals, create a hash-based ID to avoid duplication
            content = str(term)
            if len(content) > 50:
                hash_obj = hashlib.md5(content.encode())
                return f"literal_{hash_obj.hexdigest()[:8]}"
            else:
                # Use sanitized content for short literals
                sanitized = re.sub(r'[^\w\s-]', '_', content)
                return f"literal_{sanitized}"
                
        elif isinstance(term, BNode):
            return f"bnode_{str(term)}"
        else:
            return f"unknown_{str(term)}"

    def _get_clean_property_name(self, predicate: URIRef) -> str:
        """
        Generate a clean property name from a predicate URI.
        
        Args:
            predicate: RDF predicate URI
            
        Returns:
            Clean property name
        """
        uri_str = str(predicate)
        
        # Use namespace prefixes
        for namespace, prefix in self.namespace_prefixes.items():
            if uri_str.startswith(namespace):
                return uri_str.replace(namespace, prefix).replace(":", "_")
        
        # Extract the last part of the URI
        parsed = urlparse(uri_str)
        if parsed.fragment:
            return parsed.fragment
        elif "/" in parsed.path:
            return parsed.path.split("/")[-1]
        else:
            return "property"

    def _infer_node_labels(self, subject_id: str, subject: URIRef) -> Set[str]:
        """
        Infer appropriate labels for a node based on RDF types and patterns.
        
        Args:
            subject_id: Node identifier
            subject: RDF subject URI
            
        Returns:
            Set of inferred labels
        """
        labels = set()
        
        # Check for explicit rdf:type declarations
        for _, _, obj in self.rdf_graph.triples((subject, RDF.type, None)):
            if isinstance(obj, URIRef):
                type_name = self._get_clean_property_name(obj)
                labels.add(type_name)
        
        # Infer labels from URI patterns
        uri_str = str(subject)
        if "Person" in uri_str or "people" in uri_str.lower():
            labels.add("Person")
        elif "Organization" in uri_str or "company" in uri_str.lower():
            labels.add("Organization")  
        elif "Place" in uri_str or "location" in uri_str.lower():
            labels.add("Place")
        elif "Event" in uri_str:
            labels.add("Event")
        elif "Concept" in uri_str:
            labels.add("Concept")
        
        # Default label if none found
        if not labels:
            labels.add("Resource")
            
        return labels

    def convert_to_property_graph(self) -> None:
        """
        Convert RDF triples to property graph format.
        
        This method:
        1. Processes all RDF triples
        2. Creates nodes for subjects and objects
        3. Creates relationships for predicates
        4. Preserves all attributes and datatypes
        """
        self.logger.info("Converting RDF triples to property graph format...")
        
        # Process all triples
        for subject, predicate, obj in self.rdf_graph:
            
            # Create subject node
            subject_id = self._get_node_id(subject)
            if subject_id not in self.nodes:
                self.nodes[subject_id] = {
                    "id": subject_id,
                    "uri": str(subject) if isinstance(subject, URIRef) else None,
                    "type": "URI" if isinstance(subject, URIRef) else "BNode"
                }
                
                # Infer labels for the subject
                if isinstance(subject, URIRef):
                    self.node_labels[subject_id] = self._infer_node_labels(subject_id, subject)
            
            # Handle object based on its type
            if isinstance(obj, URIRef):
                # Object is another resource - create relationship
                obj_id = self._get_node_id(obj)
                
                # Create object node if it doesn't exist
                if obj_id not in self.nodes:
                    self.nodes[obj_id] = {
                        "id": obj_id,
                        "uri": str(obj),
                        "type": "URI"
                    }
                    self.node_labels[obj_id] = self._infer_node_labels(obj_id, obj)
                
                # Create relationship
                relationship = {
                    "source": subject_id,
                    "target": obj_id,
                    "type": self._get_clean_property_name(predicate),
                    "predicate_uri": str(predicate)
                }
                self.relationships.append(relationship)
                
            elif isinstance(obj, Literal):
                # Object is a literal - add as node property
                property_name = self._get_clean_property_name(predicate)
                
                # Handle literal value and datatype
                value = str(obj)
                if obj.datatype:
                    datatype = str(obj.datatype)
                    if datatype == str(XSD.integer):
                        try:
                            value = int(value)
                        except ValueError:
                            pass
                    elif datatype == str(XSD.float) or datatype == str(XSD.double):
                        try:
                            value = float(value)
                        except ValueError:
                            pass
                    elif datatype == str(XSD.boolean):
                        value = value.lower() in ('true', '1')
                    
                    # Store datatype information
                    self.nodes[subject_id][f"{property_name}_datatype"] = datatype
                
                # Handle language tags
                if obj.language:
                    self.nodes[subject_id][f"{property_name}_lang"] = obj.language
                
                self.nodes[subject_id][property_name] = value
                
            elif isinstance(obj, BNode):
                # Object is a blank node - create relationship
                obj_id = self._get_node_id(obj)
                
                if obj_id not in self.nodes:
                    self.nodes[obj_id] = {
                        "id": obj_id,
                        "type": "BNode"
                    }
                    self.node_labels[obj_id] = {"BlankNode"}
                
                relationship = {
                    "source": subject_id,
                    "target": obj_id,
                    "type": self._get_clean_property_name(predicate),
                    "predicate_uri": str(predicate)
                }
                self.relationships.append(relationship)
        
        self.logger.info(f"Created {len(self.nodes)} nodes and {len(self.relationships)} relationships")

    def _escape_cypher_string(self, value: str) -> str:
        """Escape string values for Cypher queries."""
        if isinstance(value, str):
            # Escape quotes and backslashes
            return value.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
        return str(value)

    def _format_cypher_value(self, value: Any) -> str:
        """Format a value for Cypher query."""
        if isinstance(value, str):
            return f"'{self._escape_cypher_string(value)}'"
        elif isinstance(value, bool):
            return "true" if value else "false"
        elif isinstance(value, (int, float)):
            return str(value)
        else:
            return f"'{self._escape_cypher_string(str(value))}'"

    def upload_to_falkordb(self, graph_name: str = "rdf_graph") -> None:
        """
        Upload the property graph to FalkorDB.
        
        Args:
            graph_name: Name of the graph in FalkorDB
        """
        try:
            self.logger.info(f"Connecting to FalkorDB at {self.falkor_host}:{self.falkor_port}")
            
            # Connect to FalkorDB
            if self.falkor_password:
                db = falkordb.FalkorDB(host=self.falkor_host, port=self.falkor_port, password=self.falkor_password)
            else:
                db = falkordb.FalkorDB(host=self.falkor_host, port=self.falkor_port)
            
            graph = db.select_graph(graph_name)
            
            # Clear existing data
            self.logger.info("Clearing existing data in FalkorDB...")
            graph.query("MATCH (n) DETACH DELETE n")
            
            # Create nodes in batches
            self.logger.info("Creating nodes in FalkorDB...")
            batch_size = 100
            node_list = list(self.nodes.values())
            
            for i in range(0, len(node_list), batch_size):
                batch = node_list[i:i + batch_size]
                
                for node in batch:
                    node_id = node["id"]
                    labels = ":".join(self.node_labels.get(node_id, ["Resource"]))
                    
                    # Build properties string
                    properties = []
                    for key, value in node.items():
                        if key != "id":
                            properties.append(f"{key}: {self._format_cypher_value(value)}")
                    
                    props_str = "{" + ", ".join(properties) + "}" if properties else ""
                    
                    # Create node query
                    query = f"CREATE (n:{labels} {props_str})"
                    graph.query(query)
            
            # Create relationships in batches
            self.logger.info("Creating relationships in FalkorDB...")
            for i in range(0, len(self.relationships), batch_size):
                batch = self.relationships[i:i + batch_size]
                
                for rel in batch:
                    source_labels = ":".join(self.node_labels.get(rel["source"], ["Resource"]))
                    target_labels = ":".join(self.node_labels.get(rel["target"], ["Resource"]))
                    
                    # Build relationship properties
                    rel_props = []
                    for key, value in rel.items():
                        if key not in ["source", "target", "type"]:
                            rel_props.append(f"{key}: {self._format_cypher_value(value)}")
                    
                    rel_props_str = "{" + ", ".join(rel_props) + "}" if rel_props else ""
                    
                    query = f"""
                    MATCH (a:{source_labels} {{id: {self._format_cypher_value(rel["source"])}}})
                    MATCH (b:{target_labels} {{id: {self._format_cypher_value(rel["target"])}}})
                    CREATE (a)-[r:{rel["type"]} {rel_props_str}]->(b)
                    """
                    graph.query(query)
            
            self.logger.info(f"Successfully uploaded {len(self.nodes)} nodes and {len(self.relationships)} relationships to FalkorDB")
            
        except Exception as e:
            self.logger.error(f"Error uploading to FalkorDB: {e}")
            raise

    def upload_to_neo4j(self) -> None:
        """
        Upload the property graph to Neo4j.
        """
        try:
            self.logger.info(f"Connecting to Neo4j at {self.neo4j_uri}")
            
            # Connect to Neo4j
            driver = GraphDatabase.driver(self.neo4j_uri, auth=(self.neo4j_username, self.neo4j_password))
            
            with driver.session() as session:
                # Clear existing data
                self.logger.info("Clearing existing data in Neo4j...")
                session.run("MATCH (n) DETACH DELETE n")
                
                # Create nodes in batches
                self.logger.info("Creating nodes in Neo4j...")
                batch_size = 100
                node_list = list(self.nodes.values())
                
                for i in range(0, len(node_list), batch_size):
                    batch = node_list[i:i + batch_size]
                    
                    for node in batch:
                        node_id = node["id"]
                        labels = ":".join(self.node_labels.get(node_id, ["Resource"]))
                        
                        # Prepare properties for parameterized query
                        properties = {k: v for k, v in node.items() if k != "id"}
                        
                        # Create node query with parameters
                        query = f"CREATE (n:{labels} $props)"
                        session.run(query, props=properties)
                
                # Create relationships in batches
                self.logger.info("Creating relationships in Neo4j...")
                for i in range(0, len(self.relationships), batch_size):
                    batch = self.relationships[i:i + batch_size]
                    
                    for rel in batch:
                        source_labels = ":".join(self.node_labels.get(rel["source"], ["Resource"]))
                        target_labels = ":".join(self.node_labels.get(rel["target"], ["Resource"]))
                        
                        # Prepare relationship properties
                        rel_props = {k: v for k, v in rel.items() if k not in ["source", "target", "type"]}
                        
                        query = f"""
                        MATCH (a:{source_labels} {{id: $source_id}})
                        MATCH (b:{target_labels} {{id: $target_id}})
                        CREATE (a)-[r:{rel["type"]} $props]->(b)
                        """
                        session.run(query, 
                                   source_id=rel["source"], 
                                   target_id=rel["target"], 
                                   props=rel_props)
            
            driver.close()
            self.logger.info(f"Successfully uploaded {len(self.nodes)} nodes and {len(self.relationships)} relationships to Neo4j")
            
        except Exception as e:
            self.logger.error(f"Error uploading to Neo4j: {e}")
            raise

    def print_statistics(self) -> None:
        """Print conversion statistics."""
        print("\n" + "="*50)
        print("TTL to Property Graph Conversion Statistics")
        print("="*50)
        print(f"Total RDF Triples: {len(self.rdf_graph)}")
        print(f"Total Nodes: {len(self.nodes)}")
        print(f"Total Relationships: {len(self.relationships)}")
        print("\nNode Labels Distribution:")
        label_counts = defaultdict(int)
        for labels in self.node_labels.values():
            for label in labels:
                label_counts[label] += 1
        
        for label, count in sorted(label_counts.items()):
            print(f"  {label}: {count}")
        
        print("\nRelationship Types Distribution:")
        rel_type_counts = defaultdict(int)
        for rel in self.relationships:
            rel_type_counts[rel["type"]] += 1
        
        for rel_type, count in sorted(rel_type_counts.items()):
            print(f"  {rel_type}: {count}")
        print("="*50)

    def convert_and_upload(self, 
                          ttl_file_path: str,
                          falkor_graph_name: str = "rdf_graph",
                          upload_to_falkor: bool = True,
                          upload_to_neo: bool = True) -> None:
        """
        Complete pipeline to convert TTL file and upload to both databases.
        
        Args:
            ttl_file_path: Path to the TTL file
            falkor_graph_name: Name for the FalkorDB graph
            upload_to_falkor: Whether to upload to FalkorDB
            upload_to_neo: Whether to upload to Neo4j
        """
        try:
            # Load and parse TTL file
            self.load_ttl_file(ttl_file_path)
            
            # Convert to property graph
            self.convert_to_property_graph()
            
            # Print statistics
            self.print_statistics()
            
            # Upload to databases
            if upload_to_falkor:
                self.upload_to_falkordb(falkor_graph_name)
            
            if upload_to_neo:
                self.upload_to_neo4j()
                
            self.logger.info("Conversion and upload completed successfully!")
            
        except Exception as e:
            self.logger.error(f"Error in conversion pipeline: {e}")
            raise


# Example usage
if __name__ == "__main__":
    """
    Example usage of the TTL to Property Graph Converter
    """
    
    # Initialize converter with database connection details
    converter = TTLToPropertyGraphConverter(
        # FalkorDB settings
        falkor_host="localhost",
        falkor_port=6379,
        falkor_password=None,  # Set if FalkorDB requires password
        
        # Neo4j settings  
        neo4j_uri="bolt://localhost:7687",
        neo4j_username="neo4j",
        neo4j_password="password"
    )
    
    # Convert and upload TTL file
    try:
        converter.convert_and_upload(
            ttl_file_path="your_file.ttl",  # Replace with your TTL file path
            falkor_graph_name="my_knowledge_graph",
            upload_to_falkor=True,
            upload_to_neo=True
        )
        
        print("\n✅ Successfully converted TTL to property graphs!")
        print("🔍 You can now query your data using Cypher in both FalkorDB and Neo4j")
        
        # Example queries
        print("\n📊 Example Cypher queries:")
        print("1. Count all nodes: MATCH (n) RETURN count(n)")
        print("2. Find all relationships: MATCH ()-[r]->() RETURN type(r), count(r)")
        print("3. Explore node types: MATCH (n) RETURN labels(n), count(n)")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        print("Please check your database connections and TTL file path.")
