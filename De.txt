"""
ODRL to Excel Converter for Stakeholder Review
Converts ODRL JSON policies to business-friendly Excel format
"""

import json
import pandas as pd
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
from typing import Dict, List, Any, Optional
from datetime import datetime
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


class ODRLToExcelConverter:
    """Converts ODRL policies to formatted Excel spreadsheets for stakeholder review"""
    
    def __init__(self, input_file: str, output_file: Optional[str] = None):
        """
        Initialize converter
        
        Args:
            input_file: Path to ODRL JSON file
            output_file: Path for output Excel file (optional)
        """
        self.input_file = Path(input_file)
        self.output_file = output_file
        self.data = None
        
        if not self.input_file.exists():
            raise FileNotFoundError(f"Input file not found: {input_file}")
        
        # Generate output filename if not provided
        if self.output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.output_file = self.input_file.parent / f"{self.input_file.stem}_review_{timestamp}.xlsx"
        else:
            self.output_file = Path(output_file)
            
        # Create output directory if it doesn't exist
        self.output_file.parent.mkdir(parents=True, exist_ok=True)
    
    def load_odrl_data(self) -> List[Dict]:
        """Load and parse ODRL JSON data"""
        try:
            with open(self.input_file, 'r', encoding='utf-8') as f:
                self.data = json.load(f)
            
            # Handle both single policy and array of policies
            if isinstance(self.data, list):
                policies = self.data
            elif '@graph' in self.data:
                policies = self.data['@graph']
            elif '@type' in self.data or 'uid' in self.data:
                # Single policy
                policies = [self.data]
            else:
                raise ValueError("Unknown ODRL format")
            
            print(f"✓ Loaded {len(policies)} policies from {self.input_file}")
            return policies
            
        except Exception as e:
            raise Exception(f"Error loading ODRL file: {str(e)}")
    
    def _extract_value(self, obj: Any, default: str = "") -> str:
        """Extract value from various ODRL object formats"""
        if obj is None:
            return default
        if isinstance(obj, dict):
            # Try different keys
            for key in ['@value', '@id', 'uid', 'value']:
                if key in obj:
                    return str(obj[key])
            return str(obj)
        if isinstance(obj, list):
            if len(obj) == 0:
                return default
            return '; '.join([self._extract_value(item, default) for item in obj])
        return str(obj)
    
    def _extract_action(self, action: Any) -> str:
        """Extract action name from URI or direct value"""
        action_str = self._extract_value(action)
        
        # Extract action name from URI
        if '/' in action_str or '#' in action_str:
            # Get last part of URI
            action_name = action_str.split('/')[-1].split('#')[-1]
        else:
            action_name = action_str
        
        # Capitalize and format
        return action_name.replace('_', ' ').replace('-', ' ').title()
    
    def _format_constraint(self, constraint: Any) -> str:
        """Format constraint as readable string"""
        if not constraint:
            return ""
        
        if isinstance(constraint, dict):
            left = self._extract_value(constraint.get('leftOperand', ''))
            operator = self._extract_value(constraint.get('operator', ''))
            right = self._extract_value(constraint.get('rightOperand', ''))
            
            # Clean up operator
            operator = operator.replace('odrl:', '').replace('http://www.w3.org/ns/odrl/2/', '')
            left = left.split('/')[-1].split('#')[-1]  # Get last part of URI
            
            # Format based on operator
            if operator in ['eq', 'equals']:
                return f"{left} = {right}"
            elif operator in ['neq', 'notEquals']:
                return f"{left} ≠ {right}"
            elif operator in ['gt', 'greaterThan']:
                return f"{left} > {right}"
            elif operator in ['lt', 'lessThan']:
                return f"{left} < {right}"
            elif operator in ['gteq', 'greaterOrEqual']:
                return f"{left} ≥ {right}"
            elif operator in ['lteq', 'lessOrEqual']:
                return f"{left} ≤ {right}"
            elif operator in ['isAnyOf']:
                return f"{left} is one of: {right}"
            elif operator in ['isPartOf']:
                return f"{left} is part of {right}"
            else:
                return f"{left} {operator} {right}"
        elif isinstance(constraint, list):
            return '; '.join([self._format_constraint(c) for c in constraint])
        
        return str(constraint)
    
    def extract_policy_overview(self, policies: List[Dict]) -> pd.DataFrame:
        """Extract high-level policy information"""
        rows = []
        
        for policy in policies:
            if not isinstance(policy, dict):
                continue
            
            row = {
                'Policy ID': self._extract_value(policy.get('uid', '')),
                'Title': self._extract_value(policy.get('dc:title', '')),
                'Description': self._extract_value(policy.get('dc:description', '')),
                'Framework': self._extract_value(policy.get('custom:framework', '')),
                'Rule Type': self._extract_value(policy.get('custom:type', '')),
                'Created Date': self._extract_value(policy.get('dc:created', '')),
                'Data Categories': '; '.join(policy.get('dc:subject', [])),
                'Geographic Coverage': '; '.join(policy.get('dc:coverage', [])),
                'Purpose': self._extract_value(policy.get('dc:purpose', '')),
                'Confidence Score': self._extract_value(policy.get('custom:confidenceScore', '')),
                'Total Permissions': len(policy.get('permission', [])),
                'Total Prohibitions': len(policy.get('prohibition', []))
            }
            rows.append(row)
        
        return pd.DataFrame(rows)
    
    def extract_permissions(self, policies: List[Dict]) -> pd.DataFrame:
        """Extract all permissions from policies"""
        rows = []
        
        for policy in policies:
            if not isinstance(policy, dict):
                continue
            
            policy_id = self._extract_value(policy.get('uid', ''))
            policy_title = self._extract_value(policy.get('dc:title', ''))
            permissions = policy.get('permission', [])
            
            if not isinstance(permissions, list):
                permissions = [permissions]
            
            for idx, perm in enumerate(permissions, 1):
                if not isinstance(perm, dict):
                    continue
                
                constraints = perm.get('constraint', [])
                if not isinstance(constraints, list):
                    constraints = [constraints] if constraints else []
                
                duties = perm.get('duty', [])
                if not isinstance(duties, list):
                    duties = [duties] if duties else []
                
                row = {
                    'Policy ID': policy_id,
                    'Policy Title': policy_title,
                    'Permission #': idx,
                    'What is Allowed': self._extract_action(perm.get('action')),
                    'Applies To (Target)': self._extract_value(perm.get('target', '')),
                    'Who Grants This': self._extract_value(perm.get('assigner', '')),
                    'Who Can Do This': self._extract_value(perm.get('assignee', '')),
                    'Conditions/Constraints': '\n'.join([self._format_constraint(c) for c in constraints]) if constraints else 'None',
                    'Required Duties': '\n'.join([self._extract_action(d.get('action', '')) for d in duties]) if duties else 'None',
                    'Details/Notes': self._extract_value(perm.get('rdfs:comment', ''))
                }
                rows.append(row)
        
        return pd.DataFrame(rows)
    
    def extract_prohibitions(self, policies: List[Dict]) -> pd.DataFrame:
        """Extract all prohibitions from policies"""
        rows = []
        
        for policy in policies:
            if not isinstance(policy, dict):
                continue
            
            policy_id = self._extract_value(policy.get('uid', ''))
            policy_title = self._extract_value(policy.get('dc:title', ''))
            prohibitions = policy.get('prohibition', [])
            
            if not isinstance(prohibitions, list):
                prohibitions = [prohibitions]
            
            for idx, prohib in enumerate(prohibitions, 1):
                if not isinstance(prohib, dict):
                    continue
                
                constraints = prohib.get('constraint', [])
                if not isinstance(constraints, list):
                    constraints = [constraints] if constraints else []
                
                row = {
                    'Policy ID': policy_id,
                    'Policy Title': policy_title,
                    'Prohibition #': idx,
                    'What is Forbidden': self._extract_action(prohib.get('action')),
                    'Applies To (Target)': self._extract_value(prohib.get('target', '')),
                    'Who Sets This': self._extract_value(prohib.get('assigner', '')),
                    'Who is Restricted': self._extract_value(prohib.get('assignee', '')),
                    'When/Where Forbidden': '\n'.join([self._format_constraint(c) for c in constraints]) if constraints else 'Always',
                    'Details/Notes': self._extract_value(prohib.get('rdfs:comment', ''))
                }
                rows.append(row)
        
        return pd.DataFrame(rows)
    
    def extract_summary(self, policies: List[Dict], 
                        df_permissions: pd.DataFrame, 
                        df_prohibitions: pd.DataFrame) -> pd.DataFrame:
        """Create summary statistics"""
        
        # Count unique actions
        perm_actions = []
        prohib_actions = []
        
        for policy in policies:
            for perm in policy.get('permission', []):
                action = self._extract_action(perm.get('action', ''))
                if action:
                    perm_actions.append(action)
            
            for prohib in policy.get('prohibition', []):
                action = self._extract_action(prohib.get('action', ''))
                if action:
                    prohib_actions.append(action)
        
        # Get most common
        from collections import Counter
        perm_counter = Counter(perm_actions)
        prohib_counter = Counter(prohib_actions)
        
        most_common_perm = perm_counter.most_common(1)[0][0] if perm_counter else 'N/A'
        most_common_prohib = prohib_counter.most_common(1)[0][0] if prohib_counter else 'N/A'
        
        # Count frameworks
        frameworks = [p.get('custom:framework', '') for p in policies]
        framework_counts = Counter(frameworks)
        
        summary_data = {
            'Metric': [
                'Total Policies',
                'Total Permissions',
                'Total Prohibitions',
                'Unique Permission Actions',
                'Unique Prohibition Actions',
                'Most Common Permission',
                'Most Common Prohibition',
                'Frameworks',
            ],
            'Value': [
                len(policies),
                len(df_permissions),
                len(df_prohibitions),
                len(set(perm_actions)),
                len(set(prohib_actions)),
                most_common_perm,
                most_common_prohib,
                '; '.join([f"{k}: {v}" for k, v in framework_counts.items()])
            ]
        }
        
        return pd.DataFrame(summary_data)
    
    def format_excel(self, writer: pd.ExcelWriter):
        """Apply professional formatting to Excel workbook"""
        workbook = writer.book
        
        # Define styles
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_font = Font(name='Calibri', size=11, bold=True, color="FFFFFF")
        
        summary_fill = PatternFill(start_color="D9E1F2", end_color="D9E1F2", fill_type="solid")
        summary_font = Font(name='Calibri', size=10, bold=True)
        
        cell_border = Border(
            left=Side(style='thin', color='D0D0D0'),
            right=Side(style='thin', color='D0D0D0'),
            top=Side(style='thin', color='D0D0D0'),
            bottom=Side(style='thin', color='D0D0D0')
        )
        
        # Format each worksheet
        for sheet_name in workbook.sheetnames:
            worksheet = workbook[sheet_name]
            
            # Set row height for header
            worksheet.row_dimensions[1].height = 25
            
            # Format headers
            for cell in worksheet[1]:
                cell.fill = header_fill
                cell.font = header_font
                cell.alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
                cell.border = cell_border
            
            # Auto-adjust columns and apply formatting
            for column in worksheet.columns:
                max_length = 0
                column_letter = get_column_letter(column[0].column)
                
                for cell in column:
                    cell.border = cell_border
                    cell.alignment = Alignment(vertical='top', wrap_text=True)
                    
                    if cell.row > 1:  # Data rows
                        cell.font = Font(name='Calibri', size=10)
                    
                    # Special formatting for Summary sheet
                    if sheet_name == 'Summary' and column[0].column == 1 and cell.row > 1:
                        cell.fill = summary_fill
                        cell.font = summary_font
                    
                    try:
                        if cell.value:
                            cell_length = len(str(cell.value))
                            if cell_length > max_length:
                                max_length = cell_length
                    except:
                        pass
                
                # Set column width (with reasonable limits)
                adjusted_width = min(max(max_length + 2, 15), 70)
                worksheet.column_dimensions[column_letter].width = adjusted_width
            
            # Freeze top row
            worksheet.freeze_panes = 'A2'
            
            # Add autofilter
            if worksheet.max_row > 1:
                worksheet.auto_filter.ref = worksheet.dimensions
        
        print("  ✓ Applied professional formatting")
    
    def convert(self) -> str:
        """Main conversion process"""
        print("\n" + "="*80)
        print("ODRL to Excel Converter - Creating Stakeholder Review File")
        print("="*80 + "\n")
        
        try:
            # Load data
            policies = self.load_odrl_data()
            
            if not policies:
                raise ValueError("No policies found in file")
            
            # Extract all data
            print("Extracting policy data...")
            df_overview = self.extract_policy_overview(policies)
            df_permissions = self.extract_permissions(policies)
            df_prohibitions = self.extract_prohibitions(policies)
            df_summary = self.extract_summary(policies, df_permissions, df_prohibitions)
            
            print(f"  ✓ Found {len(policies)} policies")
            print(f"  ✓ Extracted {len(df_permissions)} permissions")
            print(f"  ✓ Extracted {len(df_prohibitions)} prohibitions")
            
            # Create Excel file
            print(f"\nCreating Excel file: {self.output_file}")
            
            with pd.ExcelWriter(self.output_file, engine='openpyxl') as writer:
                # Write sheets
                df_summary.to_excel(writer, sheet_name='Summary', index=False)
                print("  ✓ Summary sheet created")
                
                df_overview.to_excel(writer, sheet_name='Policy Overview', index=False)
                print("  ✓ Policy Overview sheet created")
                
                if not df_permissions.empty:
                    df_permissions.to_excel(writer, sheet_name='Permissions', index=False)
                    print("  ✓ Permissions sheet created")
                else:
                    pd.DataFrame({'Note': ['No permissions found']}).to_excel(
                        writer, sheet_name='Permissions', index=False)
                
                if not df_prohibitions.empty:
                    df_prohibitions.to_excel(writer, sheet_name='Prohibitions', index=False)
                    print("  ✓ Prohibitions sheet created")
                else:
                    pd.DataFrame({'Note': ['No prohibitions found']}).to_excel(
                        writer, sheet_name='Prohibitions', index=False)
                
                # Apply formatting
                print("\nApplying formatting...")
                self.format_excel(writer)
            
            print(f"\n{'='*80}")
            print(f"✅ SUCCESS! Excel file created")
            print(f"{'='*80}")
            print(f"Output file: {self.output_file}")
            print(f"File size: {self.output_file.stat().st_size:,} bytes")
            print(f"{'='*80}\n")
            
            return str(self.output_file)
            
        except Exception as e:
            print(f"\n{'='*80}")
            print(f"❌ ERROR during conversion")
            print(f"{'='*80}")
            print(f"Error: {str(e)}")
            print(f"Input file: {self.input_file}")
            print(f"{'='*80}\n")
            raise


def convert_odrl_to_excel(input_file: str, output_file: Optional[str] = None) -> str:
    """
    Convenience function to convert ODRL to Excel
    
    Args:
        input_file: Path to ODRL JSON file
        output_file: Optional path for output Excel file
    
    Returns:
        Path to created Excel file
    """
    converter = ODRLToExcelConverter(input_file, output_file)
    return converter.convert()


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python odrl_to_excel.py <input_file.json> [output_file.xlsx]")
        print("\nExample:")
        print("  python odrl_to_excel.py sample_result.jsonld")
        print("  python odrl_to_excel.py odrl_output/pdf_odrl_policies_20240115.json review.xlsx")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    try:
        result = convert_odrl_to_excel(input_file, output_file)
        print(f"Done! You can now open: {result}")
    except Exception as e:
        print(f"\n❌ Conversion failed: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
