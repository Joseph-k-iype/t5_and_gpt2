"""
HSBC OpenAI Client wrapper - CORRECTLY FIXED VERSION
Creates properly configured clients for HSBC authentication with token refresh
Uses custom httpx transport for token management
FIXED: Proper LangChain integration using http_client parameter
"""
import logging
import uuid
import httpx
from typing import Any, Optional
from openai import OpenAI

from .hsbc_token_service import HSBCTokenService
from ..config import Config

logger = logging.getLogger(__name__)


class TokenRefreshingHTTPClient(httpx.Client):
    """
    Custom httpx Client that handles HSBC token refresh.
    Intercepts 401 errors and retries with fresh token.
    """
    
    def __init__(self, token_service: HSBCTokenService, user_id: str, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.token_service = token_service
        self.user_id = user_id
        self._max_retries = 3
        logger.info("Token-refreshing HTTP client initialized")
    
    def send(self, request: httpx.Request, *args, **kwargs) -> httpx.Response:
        """
        Override send to handle token refresh on 401.
        This is the method httpx calls for every request.
        """
        retry_count = 0
        
        while retry_count < self._max_retries:
            try:
                # Get fresh token (will auto-refresh if expiring)
                force_refresh = retry_count > 0
                fresh_token = self.token_service.get_token(force_refresh=force_refresh)
                
                # Update headers with fresh token and new correlation IDs
                request.headers["X-HSBC-E2E-Trust-Token"] = fresh_token
                request.headers["Token_Type"] = "SESSION_TOKEN"
                request.headers["x-correlation-id"] = str(uuid.uuid4())
                request.headers["x-usersession-id"] = str(uuid.uuid4())
                request.headers["Content-Type"] = "application/json"
                
                if retry_count > 0:
                    logger.info(f"üîÑ Retrying request with fresh token (attempt {retry_count + 1}/{self._max_retries})")
                
                # Make the actual request
                response = super().send(request, *args, **kwargs)
                
                # Check for 401 Unauthorized
                if response.status_code == 401:
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"‚ùå Token refresh failed after {self._max_retries} attempts")
                        return response
                    
                    logger.warning(f"‚ö†Ô∏è Got 401 Unauthorized - refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate current token to force refresh
                    self.token_service.invalidate_token()
                    
                    # Continue to next iteration for retry
                    continue
                
                # Success or non-401 error - return response
                return response
                
            except Exception as e:
                # Check if it's an auth-related error
                error_msg = str(e).lower()
                if any(keyword in error_msg for keyword in ['unauthorized', 'token', 'expired', 'sso', 'credential']):
                    retry_count += 1
                    
                    if retry_count >= self._max_retries:
                        logger.error(f"‚ùå Request failed after {self._max_retries} token refresh attempts")
                        raise
                    
                    logger.warning(f"‚ö†Ô∏è Authentication error: {e}")
                    logger.warning(f"   Refreshing token (attempt {retry_count}/{self._max_retries})")
                    
                    # Invalidate and retry
                    self.token_service.invalidate_token()
                    continue
                else:
                    # Not an auth error, raise immediately
                    raise
        
        # Should not reach here, but just in case
        raise Exception(f"Request failed after {self._max_retries} attempts")


def create_hsbc_client() -> OpenAI:
    """
    Factory function to create OpenAI client with HSBC authentication and token refresh.
    
    Returns:
        OpenAI: Standard OpenAI client with custom HTTP client for token management
    """
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("Creating HSBC token service...")
    
    token_service = HSBCTokenService(
        token_endpoint=Config.HSBC_TOKEN_ENDPOINT,
        username=Config.HSBC_USERNAME,
        password=Config.HSBC_PASSWORD,
        token_buffer_seconds=300  # Refresh 5 minutes before expiry
    )
    
    # Get initial token
    initial_token = token_service.get_token()
    
    # Get base httpx client from token service (has truststore SSL)
    base_httpx_client = token_service.get_httpx_client()
    
    # Create custom httpx client with token refresh capability
    logger.info("Creating custom HTTP client with token refresh...")
    custom_httpx_client = TokenRefreshingHTTPClient(
        token_service=token_service,
        user_id=Config.HSBC_USER_ID,
        http2=True,
        timeout=30.0,
        verify=base_httpx_client._transport._pool._ssl_context  # Use truststore SSL context
    )
    
    # Initial headers
    default_headers = {
        "X-HSBC-E2E-Trust-Token": initial_token,
        "Token_Type": "SESSION_TOKEN",
        "x-correlation-id": str(uuid.uuid4()),
        "x-usersession-id": str(uuid.uuid4()),
        "Content-Type": "application/json"
    }
    
    logger.info("Creating OpenAI client with HSBC authentication...")
    
    # Create standard OpenAI client with custom http client
    client = OpenAI(
        api_key=initial_token,
        base_url=Config.BASE_URL,
        http_client=custom_httpx_client,
        default_headers=default_headers
    )
    
    # Store token service reference for external access if needed
    client._hsbc_token_service = token_service
    client._hsbc_user_id = Config.HSBC_USER_ID
    client._hsbc_httpx_client = custom_httpx_client
    
    logger.info(f"‚úì HSBC OpenAI Client initialized")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User ID: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: ‚úì Automatic on 401")
    
    return client


def create_langchain_client():
    """
    Create a properly configured ChatOpenAI instance for LangChain
    WITH automatic token refresh through custom httpx client
    
    CRITICAL FIX: Pass http_client (httpx) not client (OpenAI)
    LangChain will create its own OpenAI client internally using our httpx client
    
    Returns:
        ChatOpenAI instance configured for HSBC with token management
    """
    from langchain_openai import ChatOpenAI
    
    if not Config.HSBC_PASSWORD:
        raise ValueError(
            "HSBC_PASSWORD environment variable required for HSBC authentication. "
            "Set it using: export HSBC_PASSWORD='your-password'"
        )
    
    logger.info("=" * 60)
    logger.info("Creating LangChain ChatOpenAI with HSBC authentication")
    logger.info("=" * 60)
    
    # Create token service
    logger.info("Creating HSBC token service...")
    token_service = HSBCTokenService(
        token_endpoint=Config.HSBC_TOKEN_ENDPOINT,
        username=Config.HSBC_USERNAME,
        password=Config.HSBC_PASSWORD,
        token_buffer_seconds=300
    )
    
    # Get initial token
    initial_token = token_service.get_token()
    
    # Get base httpx client (has truststore SSL)
    base_httpx_client = token_service.get_httpx_client()
    
    # Create custom httpx client with token refresh
    logger.info("Creating custom HTTP client with token refresh...")
    custom_httpx_client = TokenRefreshingHTTPClient(
        token_service=token_service,
        user_id=Config.HSBC_USER_ID,
        http2=True,
        timeout=30.0,
        verify=base_httpx_client._transport._pool._ssl_context
    )
    
    logger.info(f"LangChain client configuration:")
    logger.info(f"  Model: {Config.CHAT_MODEL}")
    logger.info(f"  Base URL: {Config.BASE_URL}")
    logger.info(f"  User: {Config.HSBC_USER_ID}")
    logger.info(f"  Token refresh: ‚úì Enabled (auto-refresh on 401)")
    
    # CRITICAL: Pass http_client (httpx.Client), NOT client (OpenAI)
    # LangChain will create its own OpenAI client internally using our httpx client
    llm = ChatOpenAI(
        model=Config.CHAT_MODEL,
        openai_api_key=initial_token,
        openai_api_base=Config.BASE_URL,
        http_client=custom_httpx_client,  # ‚Üê THE CRITICAL FIX
        model_kwargs={
            "user": Config.HSBC_USER_ID
        }
    )
    
    # Store references for external access
    llm._hsbc_token_service = token_service
    llm._hsbc_httpx_client = custom_httpx_client
    
    logger.info("=" * 60)
    logger.info("‚úì LangChain ChatOpenAI created with HSBC token management")
    logger.info("  Custom httpx client with automatic token refresh")
    logger.info("  LangChain creates its own OpenAI client using our httpx client")
    logger.info("  All requests will auto-retry on 401 errors")
    logger.info("=" * 60)
    
    return llm
