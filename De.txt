"""
Data Transfer Compliance Dashboard - Fixed Query Timeout
Uses optimized query strategy to avoid timeouts
"""

from flask import Flask, jsonify, render_template, request
from flask_cors import CORS
from flask_caching import Cache
from falkordb import FalkorDB
from redis import ConnectionPool
import logging
from functools import lru_cache
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__, static_folder='static', template_folder='templates')
CORS(app, resources={r"/api/*": {"origins": "*"}})

# Configure caching for performance
cache = Cache(app, config={
    'CACHE_TYPE': 'simple',
    'CACHE_DEFAULT_TIMEOUT': 300  # 5 minutes
})

# ==================== COUNTRY LISTS ====================
# Using frozenset for immutability and hashability (enables caching)

EU_EEA_UK_FULL = frozenset({
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden', 'United Kingdom', 'Jersey', 'Guernsey', 
    'Isle of Man', 'Switzerland'
})

EU_EEA_ONLY = frozenset({
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden'
})

ADEQUACY_COUNTRIES = frozenset({
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Japan', 'Jersey', 'New Zealand', 'Republic of Korea', 
    'Switzerland', 'United Kingdom', 'Uruguay'
})

CROWN_DEPENDENCIES = frozenset({'Jersey', 'Isle of Man', 'Guernsey'})

SWITZERLAND_DEST_LIST = frozenset({
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Jersey', 'New Zealand', 'Switzerland', 'Uruguay',
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden', 'Gibraltar', 'Monaco'
})

UK_DEST_LIST = frozenset({
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Japan', 'Jersey', 'New Zealand', 'Republic of Korea', 
    'Switzerland', 'Uruguay',
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden'
})

HIGH_RISK_COUNTRIES = frozenset({
    'Algeria', 'Australia', 'Bahrain', 'Bangladesh', 'Belgium', 'Bermuda', 
    'Brazil', 'Canada', 'Cayman Islands', 'Chile', 'China', 'Czech Republic', 
    'British Virgin Islands', 'Denmark', 'Egypt', 'France', 'Germany', 
    'Guernsey', 'Hong Kong', 'India', 'Indonesia', 'Ireland', 'Isle of Man', 
    'Italy', 'Japan', 'Jersey', 'Korea, Republic Of (South)', 'Kuwait', 
    'Luxembourg', 'Macao', 'Malaysia', 'Maldives', 'Malta', 'Mauritius', 
    'Mexico', 'Netherlands', 'New Zealand', 'Oman', 'Philippines', 'Poland', 
    'Qatar', 'Saudi Arabia', 'Singapore', 'South Africa', 'Spain', 'Sri Lanka', 
    'Sweden', 'Switzerland', 'Taiwan', 'Thailand', 'Turkey', 'Turkiye',
    'United Arab Emirates', 'United Kingdom', 'United States of America', 
    'Uruguay', 'Vietnam'
})

COMBINED_ADEQUACY_EU = EU_EEA_ONLY | ADEQUACY_COUNTRIES | frozenset({'United Kingdom'})

# ==================== COUNTRY NORMALIZATION ====================

COUNTRY_VARIATIONS = {
    'korea': 'Republic of Korea',
    'south korea': 'Republic of Korea',
    'republic of korea': 'Republic of Korea',
    'korea, republic of (south)': 'Republic of Korea',
    'turkey': 'Turkey',
    'turkiye': 'Turkey',
    'czech republic': 'Czechia',
    'czechia': 'Czechia',
    'united states': 'United States of America',
    'usa': 'United States of America',
    'us': 'United States of America',
    'united states of america': 'United States of America',
    'uk': 'United Kingdom',
    'united kingdom': 'United Kingdom',
    'uae': 'United Arab Emirates',
    'united arab emirates': 'United Arab Emirates',
    'new zeland': 'New Zealand',
    'luxemborg': 'Luxembourg',
    'uruguay': 'Uruguay',
    'uruguar': 'Uruguay',
}

@lru_cache(maxsize=1000)
def normalize_country_name(country):
    if not country:
        return country
    country_lower = country.strip().lower()
    if country_lower in COUNTRY_VARIATIONS:
        return COUNTRY_VARIATIONS[country_lower]
    for variation, normalized in COUNTRY_VARIATIONS.items():
        if variation in country_lower or country_lower in variation:
            return normalized
    return country.strip().title()

@lru_cache(maxsize=100)
def country_matches(country1, country2):
    if not country1 or not country2:
        return False
    norm1 = normalize_country_name(country1)
    norm2 = normalize_country_name(country2)
    return norm1.lower() == norm2.lower()

@lru_cache(maxsize=100)
def is_country_in_list(country, country_set):
    if not country:
        return False
    normalized = normalize_country_name(country)
    if normalized in country_set:
        return True
    for country_in_set in country_set:
        if country_matches(normalized, country_in_set):
            return True
    return False


class ComplianceAnalyzer:
    def __init__(self, host='localhost', port=6379, graph_name='DataTransferGraph'):
        logger.info(f"Connecting to FalkorDB at {host}:{port}")
        
        self.pool = ConnectionPool(
            host=host,
            port=port,
            max_connections=10,
            socket_timeout=300,  # 5 minute timeout
            socket_connect_timeout=10,
            decode_responses=True,
            health_check_interval=30,
            retry_on_timeout=True
        )
        
        self.db = FalkorDB(connection_pool=self.pool)
        self.graph = self.db.select_graph(graph_name)
        
        logger.info(f"Connected to FalkorDB graph: {graph_name}")
        
        # Test connection
        try:
            result = self.graph.query("MATCH (c:Case) RETURN count(c) as count", timeout=10000)
            total = result.result_set[0][0] if result.result_set else 0
            logger.info(f"Database has {total:,} cases")
        except Exception as e:
            logger.error(f"Connection test failed: {e}")
            raise
    
    def check_compliance_rule(self, origin, destination, pia, tia, hrpr, has_personal_data):
        """Apply compliance rules with fuzzy country matching"""
        origin = normalize_country_name(origin)
        destination = normalize_country_name(destination)
        
        required = {'PIA': False, 'TIA': False, 'HRPR': False}
        rule = None
        explanation = ""
        
        if (is_country_in_list(origin, EU_EEA_UK_FULL) and 
            is_country_in_list(destination, EU_EEA_UK_FULL)):
            required['PIA'] = True
            rule = "Rule 1"
            explanation = "Both origin and destination in EU/EEA/UK/CH → PIA required"
        
        elif (is_country_in_list(origin, EU_EEA_ONLY) and 
              is_country_in_list(destination, ADEQUACY_COUNTRIES)):
            required['PIA'] = True
            rule = "Rule 2"
            explanation = "EU origin to adequacy country → PIA required"
        
        elif (is_country_in_list(origin, CROWN_DEPENDENCIES) and 
              (is_country_in_list(destination, ADEQUACY_COUNTRIES) or 
               is_country_in_list(destination, EU_EEA_ONLY))):
            required['PIA'] = True
            rule = "Rule 3"
            explanation = "Crown Dependencies to adequacy/EU → PIA required"
        
        elif (country_matches(origin, 'United Kingdom') and 
              is_country_in_list(destination, UK_DEST_LIST)):
            required['PIA'] = True
            rule = "Rule 4"
            explanation = "UK to adequacy/EU countries → PIA required"
        
        elif (country_matches(origin, 'Switzerland') and 
              is_country_in_list(destination, SWITZERLAND_DEST_LIST)):
            required['PIA'] = True
            rule = "Rule 5"
            explanation = "Switzerland to specific approved countries → PIA required"
        
        elif is_country_in_list(origin, HIGH_RISK_COUNTRIES):
            required['PIA'] = True
            required['HRPR'] = True
            rule = "Rule 7"
            explanation = f"High-risk origin country ({origin}) → PIA + HRPR required"
        
        elif (is_country_in_list(origin, COMBINED_ADEQUACY_EU) and 
              not is_country_in_list(destination, COMBINED_ADEQUACY_EU)):
            required['PIA'] = True
            required['TIA'] = True
            rule = "Rule 6"
            explanation = "Transfer from adequacy/EU to non-adequacy country → PIA + TIA required"
        
        elif has_personal_data:
            required['PIA'] = True
            rule = "Rule 8"
            explanation = "Transfer with personal data (default rule) → PIA required"
        
        compliant = True
        missing = []
        
        if required['PIA'] and pia != 'CM':
            compliant = False
            missing.append('PIA')
        if required['TIA'] and tia != 'CM':
            compliant = False
            missing.append('TIA')
        if required['HRPR'] and hrpr != 'CM':
            compliant = False
            missing.append('HRPR')
        
        return {
            'required_modules': required,
            'rule_matched': rule,
            'explanation': explanation,
            'compliant': compliant,
            'missing_modules': missing,
            'actual_modules': {'PIA': pia, 'TIA': tia, 'HRPR': hrpr}
        }
    
    @cache.memoize(timeout=300)
    def get_all_transfers(self):
        """
        Get ALL transfers using OPTIMIZED APPROACH
        Fetch in two steps to avoid timeout:
        1. Get case metadata
        2. Get personal data separately and merge
        """
        logger.info("Fetching transfers using optimized two-step approach...")
        
        try:
            # STEP 1: Get cases with origin/destination (FAST - no OPTIONAL MATCH)
            logger.info("  Step 1: Fetching case metadata...")
            query1 = """
            MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
            MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
            RETURN 
                c.case_id AS case_id,
                origin.name AS origin_country,
                dest.name AS destination_country,
                c.pia_module AS pia_module,
                c.tia_module AS tia_module,
                c.hrpr_module AS hrpr_module,
                c.eim_id AS eim_id,
                c.business_app_id AS business_app_id
            """
            
            result1 = self.graph.query(query1, timeout=30000)  # 30 second timeout
            logger.info(f"  ✅ Fetched {len(result1.result_set):,} cases")
            
            # Build transfers dict
            transfers_dict = {}
            for row in result1.result_set:
                case_id = row[0]
                transfers_dict[case_id] = {
                    'case_id': case_id,
                    'origin_country': row[1],
                    'destination_country': row[2],
                    'pia_module': row[3],
                    'tia_module': row[4],
                    'hrpr_module': row[5],
                    'eim_id': row[6],
                    'business_app_id': row[7],
                    'personal_data': []  # Will fill in step 2
                }
            
            # STEP 2: Get personal data mappings (FAST - simple query)
            logger.info("  Step 2: Fetching personal data...")
            query2 = """
            MATCH (c:Case)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
            RETURN c.case_id, pd.name
            """
            
            result2 = self.graph.query(query2, timeout=30000)
            logger.info(f"  ✅ Fetched {len(result2.result_set):,} personal data relationships")
            
            # Aggregate personal data by case
            personal_data_map = defaultdict(list)
            for row in result2.result_set:
                case_id = row[0]
                pd_name = row[1]
                if pd_name and pd_name not in personal_data_map[case_id]:
                    personal_data_map[case_id].append(pd_name)
            
            # STEP 3: Merge and apply compliance rules
            logger.info("  Step 3: Applying compliance rules...")
            transfers = []
            for case_id, transfer in transfers_dict.items():
                # Add personal data
                transfer['personal_data'] = personal_data_map.get(case_id, [])
                
                # Check compliance
                has_personal_data = len(transfer['personal_data']) > 0
                compliance = self.check_compliance_rule(
                    transfer['origin_country'],
                    transfer['destination_country'],
                    transfer['pia_module'],
                    transfer['tia_module'],
                    transfer['hrpr_module'],
                    has_personal_data
                )
                
                transfer['compliance'] = compliance
                transfers.append(transfer)
            
            logger.info(f"✅ Total transfers processed: {len(transfers):,}")
            return transfers
            
        except Exception as e:
            logger.error(f"❌ Error fetching transfers: {e}", exc_info=True)
            raise
    
    def check_scenario_compliance(self, origin, destination, purpose, has_pii):
        """Check compliance for a hypothetical scenario"""
        origin = normalize_country_name(origin)
        destination = normalize_country_name(destination)
        
        compliance = self.check_compliance_rule(
            origin, destination, None, None, None, has_pii
        )
        
        return {
            'origin_country': origin,
            'destination_country': destination,
            'purpose': purpose,
            'has_pii': has_pii,
            'required_modules': compliance['required_modules'],
            'rule_matched': compliance['rule_matched'],
            'explanation': compliance['explanation']
        }
    
    def get_summary_statistics(self, transfers):
        """Calculate summary statistics"""
        total = len(transfers)
        compliant = sum(1 for t in transfers if t['compliance']['compliant'])
        non_compliant = total - compliant
        
        rule_counts = {}
        for t in transfers:
            rule = t['compliance']['rule_matched']
            if rule:
                rule_counts[rule] = rule_counts.get(rule, 0) + 1
        
        missing_pia = sum(1 for t in transfers if 'PIA' in t['compliance']['missing_modules'])
        missing_tia = sum(1 for t in transfers if 'TIA' in t['compliance']['missing_modules'])
        missing_hrpr = sum(1 for t in transfers if 'HRPR' in t['compliance']['missing_modules'])
        
        route_counts = {}
        for t in transfers:
            route = f"{t['origin_country']} → {t['destination_country']}"
            route_counts[route] = route_counts.get(route, 0) + 1
        
        top_routes = sorted(route_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        
        return {
            'total_transfers': total,
            'compliant': compliant,
            'non_compliant': non_compliant,
            'compliance_rate': round((compliant / total * 100), 2) if total > 0 else 0,
            'rule_counts': rule_counts,
            'missing_modules': {
                'PIA': missing_pia,
                'TIA': missing_tia,
                'HRPR': missing_hrpr
            },
            'top_routes': [{'route': r[0], 'count': r[1]} for r in top_routes]
        }
    
    def get_non_compliant_cases(self, transfers):
        """Get only non-compliant cases"""
        return [t for t in transfers if not t['compliance']['compliant']]
    
    def get_compliance_by_rule(self, transfers):
        """Get compliance breakdown by rule"""
        rule_compliance = {}
        
        for t in transfers:
            rule = t['compliance']['rule_matched']
            if rule:
                if rule not in rule_compliance:
                    rule_compliance[rule] = {
                        'total': 0,
                        'compliant': 0,
                        'non_compliant': 0,
                        'explanation': t['compliance']['explanation']
                    }
                
                rule_compliance[rule]['total'] += 1
                if t['compliance']['compliant']:
                    rule_compliance[rule]['compliant'] += 1
                else:
                    rule_compliance[rule]['non_compliant'] += 1
        
        return rule_compliance


# Initialize analyzer
try:
    analyzer = ComplianceAnalyzer()
    logger.info("✅ Analyzer initialized successfully")
except Exception as e:
    logger.error(f"❌ Failed to initialize analyzer: {e}")
    analyzer = None


# ==================== API ENDPOINTS ====================

@app.route('/')
def index():
    return render_template('dashboard.html')

@app.route('/api/transfers')
def get_transfers():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        logger.info("API: Fetching all transfers...")
        transfers = analyzer.get_all_transfers()
        
        return jsonify({
            'success': True,
            'data': transfers,
            'total': len(transfers)
        })
    except Exception as e:
        logger.error(f"API Error in /transfers: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/summary')
def get_summary():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        logger.info("API: Getting summary...")
        transfers = analyzer.get_all_transfers()
        summary = analyzer.get_summary_statistics(transfers)
        
        return jsonify({'success': True, 'data': summary})
    except Exception as e:
        logger.error(f"API Error in /summary: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/non-compliant')
def get_non_compliant():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        logger.info("API: Getting non-compliant cases...")
        transfers = analyzer.get_all_transfers()
        non_compliant = analyzer.get_non_compliant_cases(transfers)
        
        return jsonify({'success': True, 'data': non_compliant})
    except Exception as e:
        logger.error(f"API Error in /non-compliant: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/compliance-by-rule')
def get_compliance_by_rule():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        logger.info("API: Getting compliance by rule...")
        transfers = analyzer.get_all_transfers()
        rule_compliance = analyzer.get_compliance_by_rule(transfers)
        
        return jsonify({'success': True, 'data': rule_compliance})
    except Exception as e:
        logger.error(f"API Error in /compliance-by-rule: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/check-scenario', methods=['POST'])
def check_scenario():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        data = request.get_json()
        origin = data.get('origin_country', '').strip()
        destination = data.get('destination_country', '').strip()
        purpose = data.get('purpose', '').strip()
        has_pii = data.get('has_pii', False)
        
        if not origin or not destination:
            return jsonify({'success': False, 'error': 'origin and destination required'}), 400
        
        result = analyzer.check_scenario_compliance(origin, destination, purpose, has_pii)
        return jsonify({'success': True, 'data': result})
    except Exception as e:
        logger.error(f"API Error in /check-scenario: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/purposes')
def get_purposes():
    purposes = [
        "Prevention of Financial Crime",
        "Risk Management (excluding any Financial Crime related Risk Mgmt.)",
        "Back Office Operations Support",
        "Security / Prevention and Detecting Crime (excluding Financial Crime)",
        "Compliance with Laws and Regulations",
        "Disclosures to Authorities",
        "Identifying Target Subjects Need",
        "Marketing to Target Subjects",
        "Provision of Banking and Financial Services",
        "Product and Service Improvement",
        "Front Office Operations Support",
        "Personal Data as a Product",
        "Provision of a Communication Platform"
    ]
    return jsonify({'success': True, 'data': purposes})

@app.route('/api/search-similar-cases', methods=['POST'])
def search_similar_cases():
    try:
        if not analyzer:
            return jsonify({'success': False, 'error': 'Database not initialized'}), 500
        
        data = request.get_json()
        origin = data.get('origin_country', '').strip()
        destination = data.get('destination_country', '').strip()
        
        query_parts = ["MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)"]
        query_parts.append("MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)")
        
        conditions = []
        if origin:
            conditions.append(f"toLower(origin.name) CONTAINS toLower('{origin}')")
        if destination:
            conditions.append(f"toLower(dest.name) CONTAINS toLower('{destination}')")
        
        if conditions:
            query_parts.append("WHERE " + " AND ".join(conditions))
        
        query_parts.append("""
            RETURN c.case_id, origin.name, dest.name, 
                   c.pia_module, c.tia_module, c.hrpr_module
            LIMIT 100
        """)
        
        query = "\n".join(query_parts)
        result = analyzer.graph.query(query, timeout=10000)
        
        similar_cases = []
        for row in result.result_set:
            similar_cases.append({
                'case_id': row[0],
                'origin': row[1],
                'destination': row[2],
                'pia_module': row[3],
                'tia_module': row[4],
                'hrpr_module': row[5]
            })
        
        return jsonify({'success': True, 'data': similar_cases, 'count': len(similar_cases)})
    except Exception as e:
        logger.error(f"API Error in /search-similar-cases: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/health')
def health_check():
    try:
        if not analyzer:
            return jsonify({'status': 'unhealthy', 'error': 'Analyzer not initialized'}), 500
        
        result = analyzer.graph.query("MATCH (c:Case) RETURN count(c) as count", timeout=5000)
        total = result.result_set[0][0] if result.result_set else 0
        
        return jsonify({
            'status': 'healthy',
            'service': 'Compliance Dashboard',
            'total_cases': total,
            'database': 'connected'
        })
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return jsonify({'status': 'unhealthy', 'error': str(e)}), 500


if __name__ == '__main__':
    logger.info("="*60)
    logger.info("Starting Flask Application")
    logger.info("="*60)
    app.run(debug=True, host='0.0.0.0', port=5000, threaded=True)
