import React, { useCallback, useState, useMemo } from 'react';
import {
  ReactFlow,
  Edge,
  NodeTypes,
  useNodesState,
  useEdgesState,
  addEdge,
  Connection,
  Background,
  Controls,
  Panel,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';

// Import components
import RuleNode from './nodes/RuleNode';
import DetailNode from './nodes/DetailNode';
import CountryNode from './nodes/CountryNode';
import ConditionNode from './nodes/ConditionNode';
import RoleNode from './nodes/RoleNode';
import ContextMenu from './ui/ContextMenu';

// Import types
import type { 
  CustomNode, 
  RuleNode as RuleNodeType, 
  DetailNode as DetailNodeType,
  CountryNode as CountryNodeType,
  ConditionNode as ConditionNodeType,
  RoleNode as RoleNodeType,
  ContextMenuState 
} from '../types/node.types';
import type { GDPRData, GDPRRule } from '../types/gdpr.types';

// Sample GDPR data (in production, import from data/gdprRules.ts)
const gdprData: GDPRData = {
  "engine_version": "1.0",
  "rules": [
    {
      "rule_id": "a1b2c3d4_access_right_001",
      "rule_definition": "Data subjects have the right to obtain confirmation from the controller about whether their personal data is being processed",
      "rule_type": "access_right",
      "applicable_countries": ["DE", "FR", "IT", "ES"],
      "adequacy_countries": ["CA", "CH", "JP"],
      "conditions": [
        {
          "condition_id": "cond_12345678",
          "condition_definition": "When a data subject submits a valid access request",
          "fact": "request.type",
          "operator": "equal",
          "value": "subject_access_request",
          "role": "data_subject",
          "if_condition": "IF the request is a valid access request",
          "else_condition": "ELSE reject the invalid request"
        }
      ],
      "aggregated_roles": ["data_subject", "data_controller"],
      "data_category": "personal_data",
      "domain": "data_subject_rights",
      "action": "Provide confirmation and copy of personal data being processed",
      "consequence": "Administrative fine up to 4% of annual worldwide turnover",
      "reference": "GDPR Article 15(1)",
      "priority": "high",
      "event_type": "rule_evaluation",
      "params": {}
    },
    {
      "rule_id": "a1b2c3d4_processing_obligation_002",
      "rule_definition": "Data controllers must implement appropriate technical and organizational measures to ensure data security",
      "rule_type": "processing_obligation",
      "applicable_countries": ["DE", "FR", "IT", "ES"],
      "adequacy_countries": ["CA", "CH", "JP"],
      "conditions": [
        {
          "condition_id": "cond_87654321",
          "condition_definition": "When the controller processes personal data",
          "fact": "data.category",
          "operator": "equal",
          "value": "personal_data",
          "role": "data_controller",
          "if_condition": "IF processing personal data",
          "else_condition": "ELSE no obligation applies"
        }
      ],
      "aggregated_roles": ["data_controller"],
      "data_category": "personal_data",
      "domain": "data_protection_compliance",
      "action": "Implement appropriate technical and organizational security measures",
      "consequence": "Administrative fine and potential data breach liability",
      "reference": "GDPR Article 32(1)",
      "priority": "high",
      "event_type": "rule_evaluation",
      "params": {}
    },
    {
      "rule_id": "a1b2c3d4_consent_requirement_005",
      "rule_definition": "Controllers must obtain freely given, specific, informed and unambiguous consent from data subjects",
      "rule_type": "consent_requirement",
      "applicable_countries": ["DE", "FR", "IT", "ES"],
      "adequacy_countries": ["CA", "CH", "JP"],
      "conditions": [
        {
          "condition_id": "cond_99887766",
          "condition_definition": "When consent is required for processing",
          "fact": "processing.lawful_basis",
          "operator": "equal",
          "value": "consent",
          "role": "data_controller",
          "if_condition": "IF consent is the lawful basis",
          "else_condition": "ELSE use alternative lawful basis"
        }
      ],
      "aggregated_roles": ["data_controller", "data_subject"],
      "data_category": "personal_data",
      "domain": "consent_management",
      "action": "Obtain clear and unambiguous consent with easy withdrawal mechanism",
      "consequence": "Processing becomes unlawful and subject to penalties",
      "reference": "GDPR Article 7(1)",
      "priority": "high",
      "event_type": "rule_evaluation",
      "params": {}
    }
  ],
  "metadata": {
    "generated_by": "Multi-Agent Legal Rule Extraction System with Supervisor",
    "generation_date": "2025-01-27T10:30:00.000Z",
    "total_rules": 3,
    "methodology": "Mixture of Experts with Supervisor Agent and Chain of Thought",
    "supervisor_validated": true,
    "simple_english_rules": true
  }
};

// Define node types
const nodeTypes: NodeTypes = {
  ruleNode: RuleNode,
  detailNode: DetailNode,
  countryNode: CountryNode,
  conditionNode: ConditionNode,
  roleNode: RoleNode,
};

// Main Visualizer Component
const GDPRRulesVisualizer: React.FC = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState<CustomNode>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>([]);
  const [contextMenu, setContextMenu] = useState<ContextMenuState | null>(null);
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());

  // Generate initial nodes from GDPR data
  const initialNodes: CustomNode[] = useMemo(() => {
    return gdprData.rules.map((rule, index): RuleNodeType => ({
      id: rule.rule_id,
      type: 'ruleNode',
      position: { 
        x: (index % 2) * 500, 
        y: Math.floor(index / 2) * 350 
      },
      data: { rule },
    }));
  }, []);

  // Initialize nodes
  React.useEffect(() => {
    setNodes(initialNodes);
  }, [initialNodes, setNodes]);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const onNodeContextMenu = useCallback(
    (event: React.MouseEvent, node: CustomNode) => {
      event.preventDefault();
      
      if (node.type !== 'ruleNode') return;

      const rule = (node.data as { rule: GDPRRule }).rule;
      const menuOptions = [
        {
          key: 'countries',
          label: 'Show Applicable Countries',
          icon: '🌍',
          available: rule.applicable_countries?.length > 0
        },
        {
          key: 'adequacy',
          label: 'Show Adequacy Countries',
          icon: '✅',
          available: rule.adequacy_countries?.length > 0
        },
        {
          key: 'conditions',
          label: 'Show Conditions',
          icon: '⚙️',
          available: rule.conditions?.length > 0
        },
        {
          key: 'roles',
          label: 'Show Roles',
          icon: '👥',
          available: rule.aggregated_roles?.length > 0
        },
        {
          key: 'action',
          label: 'Show Action',
          icon: '⚡',
          available: !!rule.action
        },
        {
          key: 'consequence',
          label: 'Show Consequence',
          icon: '⚠️',
          available: !!rule.consequence
        }
      ];

      setContextMenu({
        x: event.clientX,
        y: event.clientY,
        nodeId: node.id,
        options: menuOptions
      });
    },
    []
  );

  const closeContextMenu = useCallback(() => {
    setContextMenu(null);
  }, []);

  const expandNode = useCallback((nodeId: string, expansionType: string) => {
    const rule = gdprData.rules.find(r => r.rule_id === nodeId);
    if (!rule) return;

    const expansionKey = `${nodeId}-${expansionType}`;
    if (expandedNodes.has(expansionKey)) return;

    setExpandedNodes(prev => new Set([...prev, expansionKey]));

    const parentNode = nodes.find(n => n.id === nodeId);
    if (!parentNode) return;

    const baseX = parentNode.position.x;
    const baseY = parentNode.position.y + 250;

    const newNodes: CustomNode[] = [];
    const newEdges: Edge[] = [];

    switch (expansionType) {
      case 'countries':
        if (rule.applicable_countries?.length > 0) {
          const countryNodeId = `${nodeId}-countries`;
          newNodes.push({
            id: countryNodeId,
            type: 'countryNode',
            position: { x: baseX - 100, y: baseY },
            data: {
              label: 'Applicable Countries',
              countries: rule.applicable_countries,
              type: 'applicable'
            }
          } as CountryNodeType);
          newEdges.push({
            id: `${nodeId}-to-countries`,
            source: nodeId,
            target: countryNodeId,
            type: 'smoothstep',
            style: { stroke: '#10b981', strokeWidth: 2 }
          });
        }
        break;

      case 'adequacy':
        if (rule.adequacy_countries?.length > 0) {
          const adequacyNodeId = `${nodeId}-adequacy`;
          newNodes.push({
            id: adequacyNodeId,
            type: 'countryNode',
            position: { x: baseX + 250, y: baseY },
            data: {
              label: 'Adequacy Countries',
              countries: rule.adequacy_countries,
              type: 'adequacy'
            }
          } as CountryNodeType);
          newEdges.push({
            id: `${nodeId}-to-adequacy`,
            source: nodeId,
            target: adequacyNodeId,
            type: 'smoothstep',
            style: { stroke: '#059669', strokeWidth: 2 }
          });
        }
        break;

      case 'conditions':
        if (rule.conditions?.length > 0) {
          rule.conditions.forEach((condition, index) => {
            const conditionNodeId = `${nodeId}-condition-${index}`;
            newNodes.push({
              id: conditionNodeId,
              type: 'conditionNode',
              position: { x: baseX - 150 + (index * 250), y: baseY + 150 },
              data: { condition, index }
            } as ConditionNodeType);
            newEdges.push({
              id: `${nodeId}-to-condition-${index}`,
              source: nodeId,
              target: conditionNodeId,
              type: 'smoothstep',
              style: { stroke: '#8b5cf6', strokeWidth: 2 }
            });
          });
        }
        break;

      case 'roles':
        if (rule.aggregated_roles?.length > 0) {
          const rolesNodeId = `${nodeId}-roles`;
          newNodes.push({
            id: rolesNodeId,
            type: 'roleNode',
            position: { x: baseX + 200, y: baseY + 80 },
            data: { roles: rule.aggregated_roles }
          } as RoleNodeType);
          newEdges.push({
            id: `${nodeId}-to-roles`,
            source: nodeId,
            target: rolesNodeId,
            type: 'smoothstep',
            style: { stroke: '#f97316', strokeWidth: 2 }
          });
        }
        break;

      case 'action':
        const actionNodeId = `${nodeId}-action`;
        newNodes.push({
          id: actionNodeId,
          type: 'detailNode',
          position: { x: baseX - 250, y: baseY - 50 },
          data: {
            label: 'Required Action',
            content: rule.action,
            type: 'action'
          }
        } as DetailNodeType);
        newEdges.push({
          id: `${nodeId}-to-action`,
          source: nodeId,
          target: actionNodeId,
          type: 'smoothstep',
          style: { stroke: '#3b82f6', strokeWidth: 2 }
        });
        break;

      case 'consequence':
        const consequenceNodeId = `${nodeId}-consequence`;
        newNodes.push({
          id: consequenceNodeId,
          type: 'detailNode',
          position: { x: baseX + 350, y: baseY - 50 },
          data: {
            label: 'Consequence',
            content: rule.consequence,
            type: 'consequence'
          }
        } as DetailNodeType);
        newEdges.push({
          id: `${nodeId}-to-consequence`,
          source: nodeId,
          target: consequenceNodeId,
          type: 'smoothstep',
          style: { stroke: '#ef4444', strokeWidth: 2 }
        });
        break;
    }

    setNodes((nds) => [...nds, ...newNodes]);
    setEdges((eds) => [...eds, ...newEdges]);
  }, [nodes, expandedNodes, setNodes, setEdges]);

  const handleExpand = useCallback((expansionType: string) => {
    if (contextMenu) {
      expandNode(contextMenu.nodeId, expansionType);
    }
  }, [contextMenu, expandNode]);

  const resetView = useCallback(() => {
    setNodes(initialNodes);
    setEdges([]);
    setExpandedNodes(new Set());
  }, [initialNodes, setNodes, setEdges]);

  return (
    <div className="w-full h-screen bg-gradient-to-br from-gray-50 to-gray-100">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onNodeContextMenu={onNodeContextMenu}
        nodeTypes={nodeTypes}
        fitView
        className="bg-transparent"
      >
        <Background color="#e5e7eb" />
        <Controls />
        <Panel position="top-right" className="bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg border">
          <div className="space-y-3">
            <h2 className="font-bold text-lg text-gray-800">GDPR Rules Visualizer</h2>
            <p className="text-sm text-gray-600 max-w-[200px]">
              Right-click on rule nodes to explore details and relationships
            </p>
            <button
              onClick={resetView}
              className="w-full px-3 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 transition-colors shadow-sm"
            >
              Reset View
            </button>
            <div className="text-xs text-gray-500 pt-2 border-t">
              <div>Total Rules: {gdprData.metadata.total_rules}</div>
              <div>Engine: v{gdprData.engine_version}</div>
            </div>
          </div>
        </Panel>
      </ReactFlow>
      
      {contextMenu && (
        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          options={contextMenu.options}
          onExpand={handleExpand}
          onClose={closeContextMenu}
        />
      )}
    </div>
  );
};

export default GDPRRulesVisualizer;
