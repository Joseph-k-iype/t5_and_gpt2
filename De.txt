from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import asyncio
import json
import uuid
import threading
from datetime import datetime
import logging

# Import your existing chatbot code
from privacy_chatbot import DynamicPrivacyChatbotInterface

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global chatbot interface
chatbot_interface = None
active_sessions = {}
_chatbot_initialized = False

class ChatSession:
    def __init__(self, session_id):
        self.session_id = session_id
        self.thread_id = f"privacy_{uuid.uuid4().hex[:8]}"
        self.messages = []
        self.is_processing = False
        self.current_thoughts = []
        self.research_state = None

def create_app():
    """Application factory pattern for Flask"""
    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'your-secret-key-here'
    
    # Enable CORS
    CORS(app, origins=["http://localhost:5173"])
    
    # Initialize SocketIO
    socketio = SocketIO(app, cors_allowed_origins=["http://localhost:5173"])
    
    return app, socketio

def get_event_loop():
    """Get or create event loop for async operations"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_closed():
            raise RuntimeError("Event loop is closed")
        return loop
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop

def initialize_chatbot():
    """Initialize the chatbot interface"""
    global chatbot_interface, _chatbot_initialized
    
    if _chatbot_initialized:
        logger.info("Chatbot already initialized")
        return True
    
    def init_async():
        try:
            loop = get_event_loop()
            
            async def init_chatbot():
                global chatbot_interface
                try:
                    chatbot_interface = DynamicPrivacyChatbotInterface()
                    success = await chatbot_interface.initialize()
                    if success:
                        logger.info("✅ Dynamic Privacy Chatbot initialized successfully!")
                        return True
                    else:
                        logger.error("❌ Failed to initialize chatbot")
                        return False
                except Exception as e:
                    logger.error(f"Error initializing chatbot: {e}")
                    return False
            
            if loop.is_running():
                import concurrent.futures
                with concurrent.futures.ThreadPoolExecutor() as executor:
                    future = executor.submit(asyncio.run, init_chatbot())
                    result = future.result()
                    return result
            else:
                result = loop.run_until_complete(init_chatbot())
                return result
                
        except Exception as e:
            logger.error(f"Error in async initialization: {e}")
            return False
    
    try:
        success = init_async()
        if success:
            _chatbot_initialized = True
            logger.info("Chatbot initialization completed successfully")
        return success
    except Exception as e:
        logger.error(f"Failed to initialize chatbot: {e}")
        return False

def serialize_for_websocket(obj):
    """Convert objects to JSON-serializable format for WebSocket transmission"""
    if obj is None:
        return None
    
    if hasattr(obj, 'to_dict'):
        # Use the to_dict method if available
        return obj.to_dict()
    elif hasattr(obj, '__dict__'):
        # For regular objects, convert their attributes
        result = {}
        for key, value in obj.__dict__.items():
            try:
                result[key] = serialize_for_websocket(value)
            except Exception as e:
                logger.warning(f"Failed to serialize attribute {key}: {e}")
                result[key] = str(value)
        return result
    elif isinstance(obj, dict):
        # For dictionaries, recursively serialize values
        return {key: serialize_for_websocket(value) for key, value in obj.items()}
    elif isinstance(obj, (list, tuple)):
        # For lists/tuples, recursively serialize elements
        return [serialize_for_websocket(item) for item in obj]
    elif isinstance(obj, (str, int, float, bool)) or obj is None:
        # Basic types are already serializable
        return obj
    else:
        # Fallback to string representation
        return str(obj)

# Create Flask app and SocketIO
app, socketio = create_app()

# Modern Flask initialization - no more @app.before_first_request
def ensure_chatbot_initialized():
    """Ensure chatbot is initialized before processing requests"""
    global _chatbot_initialized
    if not _chatbot_initialized:
        logger.info("Initializing chatbot on first request...")
        success = initialize_chatbot()
        if not success:
            logger.error("Failed to initialize chatbot")

@app.before_request
def before_request():
    """Initialize chatbot on first request using modern Flask pattern"""
    ensure_chatbot_initialized()

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    ensure_chatbot_initialized()
    return jsonify({
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "chatbot_ready": chatbot_interface is not None
    })

@app.route('/api/chat/start', methods=['POST'])
def start_chat_session():
    """Start a new chat session"""
    ensure_chatbot_initialized()
    session_id = str(uuid.uuid4())
    session = ChatSession(session_id)
    active_sessions[session_id] = session
    
    return jsonify({
        "session_id": session_id,
        "thread_id": session.thread_id,
        "status": "ready",
        "message": "Chat session started successfully"
    })

@app.route('/api/chat/message', methods=['POST'])
def send_message():
    """Send a message to the chatbot"""
    try:
        ensure_chatbot_initialized()
        data = request.get_json()
        session_id = data.get('session_id')
        message = data.get('message', '').strip()
        
        if not session_id or session_id not in active_sessions:
            return jsonify({"error": "Invalid session ID"}), 400
        
        if not message:
            return jsonify({"error": "Message cannot be empty"}), 400
        
        session = active_sessions[session_id]
        
        if session.is_processing:
            return jsonify({"error": "Already processing a message"}), 429
        
        # Mark session as processing
        session.is_processing = True
        session.current_thoughts = []
        
        # Add user message to session
        user_message = {
            "id": str(uuid.uuid4()),
            "type": "user",
            "content": message,
            "timestamp": datetime.now().isoformat()
        }
        session.messages.append(user_message)
        
        # Process message asynchronously
        def process_async():
            try:
                loop = get_event_loop()
                
                async def process_message():
                    try:
                        if not chatbot_interface:
                            return {
                                "error": "Chatbot not initialized",
                                "content": "The chatbot is still initializing. Please try again in a moment."
                            }
                        
                        # Emit thinking status
                        socketio.emit('thinking_start', {
                            "session_id": session_id,
                            "message": "Analyzing your query..."
                        })
                        
                        # Get response from chatbot
                        response = await chatbot_interface.ask_question(message, session.thread_id)
                        
                        return response
                        
                    except Exception as e:
                        logger.error(f"Error processing message: {e}")
                        return {
                            "error": str(e),
                            "content": "I apologize, but I encountered an error processing your question. Please try again."
                        }
                
                if loop.is_running():
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(asyncio.run, process_message())
                        response = future.result()
                else:
                    response = loop.run_until_complete(process_message())
                
                # Create AI response message
                ai_message = {
                    "id": str(uuid.uuid4()),
                    "type": "assistant",
                    "content": response.get("answer", "No response generated"),
                    "confidence": response.get("confidence", "unknown"),
                    "intent": response.get("intent", "unknown"),
                    "approach": response.get("approach", "unknown"),
                    "timestamp": datetime.now().isoformat(),
                    "metadata": {
                        "thread_id": response.get("thread_id", session.thread_id),
                        "processing_time": "calculated_on_frontend"
                    }
                }
                
                session.messages.append(ai_message)
                session.is_processing = False
                
                # Emit response via WebSocket
                socketio.emit('message_response', {
                    "session_id": session_id,
                    "message": ai_message,
                    "user_message": user_message
                })
                
            except Exception as e:
                logger.error(f"Error in async processing: {e}")
                session.is_processing = False
                
                error_message = {
                    "id": str(uuid.uuid4()),
                    "type": "error",
                    "content": f"Error processing message: {str(e)}",
                    "timestamp": datetime.now().isoformat()
                }
                
                socketio.emit('message_error', {
                    "session_id": session_id,
                    "error": error_message
                })
        
        # Start processing in background thread
        thread = threading.Thread(target=process_async)
        thread.start()
        
        return jsonify({
            "status": "processing",
            "message": "Message received and processing started",
            "user_message": user_message
        })
        
    except Exception as e:
        logger.error(f"Error in send_message: {e}")
        return jsonify({"error": f"Server error: {str(e)}"}), 500

@app.route('/api/chat/deep-research', methods=['POST'])
def start_deep_research():
    """Start deep research on a topic"""
    try:
        ensure_chatbot_initialized()
        data = request.get_json()
        session_id = data.get('session_id')
        topic = data.get('topic', '').strip()
        max_iterations = data.get('max_iterations', 3)
        
        if not session_id or session_id not in active_sessions:
            return jsonify({"error": "Invalid session ID"}), 400
        
        if not topic:
            return jsonify({"error": "Research topic cannot be empty"}), 400
        
        session = active_sessions[session_id]
        
        if session.is_processing:
            return jsonify({"error": "Already processing"}), 429
        
        session.is_processing = True
        
        def research_async():
            try:
                loop = get_event_loop()
                
                async def conduct_research():
                    try:
                        if not chatbot_interface:
                            return {"error": "Chatbot not initialized"}
                        
                        # Emit research start
                        socketio.emit('research_start', {
                            "session_id": session_id,
                            "topic": topic,
                            "max_iterations": max_iterations
                        })
                        
                        # Conduct deep research
                        research_result = await chatbot_interface.conduct_deep_research(
                            topic, max_iterations
                        )
                        
                        return research_result
                        
                    except Exception as e:
                        logger.error(f"Error in deep research: {e}")
                        return {"error": str(e)}
                
                if loop.is_running():
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(asyncio.run, conduct_research())
                        result = future.result()
                else:
                    result = loop.run_until_complete(conduct_research())
                
                # Serialize the research result for WebSocket transmission
                serialized_result = serialize_for_websocket(result)
                
                session.research_state = serialized_result
                session.is_processing = False
                
                # Emit research complete with serialized data
                socketio.emit('research_complete', {
                    "session_id": session_id,
                    "result": serialized_result
                })
                
            except Exception as e:
                logger.error(f"Error in research async: {e}")
                session.is_processing = False
                
                socketio.emit('research_error', {
                    "session_id": session_id,
                    "error": str(e)
                })
        
        thread = threading.Thread(target=research_async)
        thread.start()
        
        return jsonify({
            "status": "research_started",
            "topic": topic,
            "max_iterations": max_iterations
        })
        
    except Exception as e:
        logger.error(f"Error in deep research: {e}")
        return jsonify({"error": f"Server error: {str(e)}"}), 500

@app.route('/api/chat/history/<session_id>', methods=['GET'])
def get_chat_history(session_id):
    """Get chat history for a session"""
    if session_id not in active_sessions:
        return jsonify({"error": "Session not found"}), 404
    
    session = active_sessions[session_id]
    
    # Serialize research state if it exists
    serialized_research_state = None
    if session.research_state:
        serialized_research_state = serialize_for_websocket(session.research_state)
    
    return jsonify({
        "session_id": session_id,
        "messages": session.messages,
        "is_processing": session.is_processing,
        "research_state": serialized_research_state
    })

@app.route('/api/diagnostics', methods=['GET'])
def get_diagnostics():
    """Get system diagnostics"""
    try:
        ensure_chatbot_initialized()
        if not chatbot_interface or not chatbot_interface.chatbot:
            return jsonify({
                "status": "not_ready",
                "message": "Chatbot not initialized"
            })
        
        diagnostics = chatbot_interface.chatbot.get_diagnostics()
        
        # Serialize diagnostics for JSON response
        serialized_diagnostics = serialize_for_websocket(diagnostics)
        
        return jsonify({
            "status": "ready",
            "diagnostics": serialized_diagnostics,
            "active_sessions": len(active_sessions)
        })
        
    except Exception as e:
        logger.error(f"Error getting diagnostics: {e}")
        return jsonify({
            "status": "error",
            "error": str(e)
        })

# WebSocket Events
@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    logger.info(f"Client connected: {request.sid}")
    emit('connected', {'status': 'Connected to Privacy Chatbot'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    logger.info(f"Client disconnected: {request.sid}")

@socketio.on('join_session')
def handle_join_session(data):
    """Handle client joining a chat session"""
    session_id = data.get('session_id')
    if session_id and session_id in active_sessions:
        emit('session_joined', {
            'session_id': session_id,
            'status': 'joined'
        })
    else:
        emit('session_error', {
            'error': 'Invalid session ID'
        })

@socketio.on('thinking_update')
def handle_thinking_update(data):
    """Handle thinking process updates"""
    session_id = data.get('session_id')
    thought = data.get('thought')
    
    if session_id in active_sessions:
        session = active_sessions[session_id]
        session.current_thoughts.append({
            "timestamp": datetime.now().isoformat(),
            "content": thought
        })
        
        emit('thinking_update', {
            "session_id": session_id,
            "thought": thought,
            "thoughts": session.current_thoughts
        }, broadcast=True)

# Initialize chatbot before running the app
def startup_initialization():
    """Initialize chatbot during application startup"""
    logger.info("Starting Privacy Chatbot API Server...")
    logger.info("Initializing chatbot during startup...")
    
    success = initialize_chatbot()
    if success:
        logger.info("✅ Chatbot initialized successfully during startup!")
    else:
        logger.warning("⚠️ Chatbot initialization failed during startup - will retry on first request")

if __name__ == '__main__':
    startup_initialization()
    
    print("🚀 Starting Privacy Chatbot API Server...")
    print("🔍 Glassmorphic UI will be available at: http://localhost:5173")
    print("🧠 Deep Research capabilities enabled")
    print("💬 Real-time chat with WebSocket support")
    print("=" * 60)
    
    socketio.run(
        app,
        host='0.0.0.0',
        port=5000,
        debug=True,
        allow_unsafe_werkzeug=True
    )
