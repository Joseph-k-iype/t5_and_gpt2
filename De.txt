"""
Advanced Prompting Strategies for Legal Document Analysis
Implements Chain of Thought, Mixture of Experts, Mixture of Reasoning, and Dynamic Prompting
"""

from typing import Dict, List, Optional, Any
from enum import Enum


class ExpertRole(Enum):
    """Different expert perspectives for analysis"""
    LEGAL_EXPERT = "legal_expert"
    COMPLIANCE_OFFICER = "compliance_officer"
    DATA_PRIVACY_SPECIALIST = "data_privacy_specialist"
    TECHNICAL_ARCHITECT = "technical_architect"
    BUSINESS_ANALYST = "business_analyst"


class ReasoningMode(Enum):
    """Different reasoning approaches"""
    DEDUCTIVE = "deductive"  # From general principles to specific conclusions
    INDUCTIVE = "inductive"  # From specific cases to general principles
    ABDUCTIVE = "abductive"  # Best explanation for observations
    ANALOGICAL = "analogical"  # Reasoning by analogy
    CAUSAL = "causal"  # Cause and effect reasoning


class AdvancedPromptingStrategies:
    """
    Advanced prompting strategies for legal document analysis
    """
    
    def __init__(self, rule_name: str, jurisdiction: str = None):
        self.rule_name = rule_name
        self.jurisdiction = jurisdiction or "general"
        
    def get_chain_of_thought_prompt(
        self, 
        document_text: str, 
        analysis_type: str,
        context: Optional[Dict[str, Any]] = None,
        chunk_info: Optional[str] = None
    ) -> str:
        """
        Generate Chain of Thought prompt for detailed step-by-step reasoning
        """
        context_info = ""
        if context:
            if context.get("is_enterprise_policy"):
                context_info += f"\nNote: This is an enterprise-specific policy for {context.get('organization', 'the organization')}."
            if context.get("tools_mentioned"):
                tools = ", ".join(context.get("tools_mentioned", []))
                context_info += f"\nInternal tools referenced: {tools}"
        
        chunk_context = ""
        if chunk_info:
            chunk_context = f"\n\n{chunk_info}"
        
        prompt = f"""You are analyzing a legal document for the rule: "{self.rule_name}" 
in the jurisdiction: {self.jurisdiction}.{context_info}{chunk_context}

TASK: {analysis_type}

DOCUMENT TEXT:
{document_text}

CRITICAL: This text may be part of a larger document. Extract ALL relevant information from this section completely.

Please analyze this document using a detailed Chain of Thought approach:

Step 1: INITIAL UNDERSTANDING
- What is the primary purpose of this regulation/rule?
- What problem is it trying to solve?
- Who are the key stakeholders (data subjects, controllers, processors, etc.)?

Step 2: IDENTIFY KEY ELEMENTS
- What specific actions are mentioned (e.g., collect, store, process, share, delete)?
- What are the permissions granted?
- What are the prohibitions/restrictions imposed?
- What duties or obligations are specified?

Step 3: EXTRACT CONDITIONS AND CONSTRAINTS
- Under what conditions can actions be performed?
- What limitations or restrictions apply?
- Are there time-based constraints?
- Are there purpose-based limitations?
- Are there technical/security requirements?

Step 4: DETERMINE ACTORS AND ROLES
- Who can perform which actions (user/system)?
- Who has which duties (user/system)?
- Are there multiple parties involved?

Step 5: CLASSIFY RULE TYPE
- Is this primarily a permission (allowing something)?
- Is this primarily a prohibition (forbidding something)?
- Is this an obligation (requiring something)?
- Or is it a combination?

Step 6: SYNTHESIZE FINDINGS
Based on the above analysis, provide a clear summary that addresses:
- Description of the rule
- Actions by user
- Actions by system
- Duties by user
- Duties by system
- All applicable constraints/conditions
- Whether this is a permission, prohibition, or obligation

Think through each step carefully and show your reasoning."""

        return prompt
    
    def get_mixture_of_experts_prompt(
        self, 
        document_text: str,
        expert_roles: List[ExpertRole] = None,
        chunk_info: Optional[str] = None
    ) -> str:
        """
        Generate Mixture of Experts prompt where different experts analyze the same document
        """
        if expert_roles is None:
            expert_roles = [
                ExpertRole.LEGAL_EXPERT,
                ExpertRole.COMPLIANCE_OFFICER,
                ExpertRole.DATA_PRIVACY_SPECIALIST
            ]
        
        chunk_context = ""
        if chunk_info:
            chunk_context = f"\n\n{chunk_info}\nEach expert should focus on extracting complete information from this section."
        
        expert_descriptions = {
            ExpertRole.LEGAL_EXPERT: "interprets legal language, identifies binding obligations, and determines legal implications",
            ExpertRole.COMPLIANCE_OFFICER: "focuses on practical compliance requirements, implementation steps, and audit trails",
            ExpertRole.DATA_PRIVACY_SPECIALIST: "analyzes data handling practices, privacy implications, and data subject rights",
            ExpertRole.TECHNICAL_ARCHITECT: "evaluates technical implementation, system requirements, and security measures",
            ExpertRole.BUSINESS_ANALYST: "considers business impact, operational feasibility, and stakeholder needs"
        }
        
        expert_sections = []
        for role in expert_roles:
            expert_sections.append(f"""
EXPERT {role.value.upper().replace('_', ' ')} ANALYSIS:
As a {role.value.replace('_', ' ')}, who {expert_descriptions[role]}, analyze this document and provide:
1. Your interpretation of the key requirements
2. What actions/duties you identify from your perspective
3. What constraints/conditions are most critical from your viewpoint
4. Whether you see this as permission, prohibition, or obligation
5. Any concerns or considerations specific to your domain""")
        
        prompt = f"""You are analyzing a legal document for the rule: "{self.rule_name}"
in the jurisdiction: {self.jurisdiction}.{chunk_context}

DOCUMENT TEXT:
{document_text}

CRITICAL: Extract ALL relevant information from this text completely. Do not assume anything is covered elsewhere.

Please analyze this document from multiple expert perspectives. For each expert role, 
provide a distinct analysis that reflects their unique viewpoint and expertise.

{''.join(expert_sections)}

CONSENSUS SYNTHESIS:
After reviewing all expert perspectives, synthesize a comprehensive understanding that:
- Integrates insights from all experts
- Resolves any conflicting interpretations
- Provides a unified view of:
  * Description of the rule
  * Actions by user/system
  * Duties by user/system
  * All applicable constraints
  * Classification as permission/prohibition/obligation
  
Ensure the synthesis is practical, implementable, and legally sound."""

        return prompt
    
    def get_mixture_of_reasoning_prompt(
        self, 
        document_text: str,
        reasoning_modes: List[ReasoningMode] = None,
        chunk_info: Optional[str] = None
    ) -> str:
        """
        Generate Mixture of Reasoning prompt using different reasoning approaches
        """
        if reasoning_modes is None:
            reasoning_modes = [
                ReasoningMode.DEDUCTIVE,
                ReasoningMode.INDUCTIVE,
                ReasoningMode.CAUSAL
            ]
        
        chunk_context = ""
        if chunk_info:
            chunk_context = f"\n\n{chunk_info}\nApply each reasoning mode to extract complete information from this section."
        
        reasoning_descriptions = {
            ReasoningMode.DEDUCTIVE: """
DEDUCTIVE REASONING (General Principles → Specific Conclusions):
1. Identify the general legal principles stated in the document
2. Apply these principles to specific scenarios
3. Deduce what actions are permitted/prohibited
4. Derive specific requirements from general rules""",
            
            ReasoningMode.INDUCTIVE: """
INDUCTIVE REASONING (Specific Examples → General Rules):
1. Identify specific examples or cases mentioned
2. Find patterns across these examples
3. Generalize to broader principles
4. Infer the overall intent and scope""",
            
            ReasoningMode.ABDUCTIVE: """
ABDUCTIVE REASONING (Best Explanation):
1. Observe the requirements stated
2. Consider multiple possible interpretations
3. Select the most likely/best explanation
4. Justify why this interpretation makes most sense""",
            
            ReasoningMode.ANALOGICAL: """
ANALOGICAL REASONING (Comparison to Known Cases):
1. Compare to similar regulations you know
2. Identify similarities and differences
3. Apply insights from analogous cases
4. Adapt principles to this specific context""",
            
            ReasoningMode.CAUSAL: """
CAUSAL REASONING (Cause and Effect):
1. Identify what behaviors this rule aims to prevent/enable
2. Trace the causal chain: action → consequence
3. Understand why certain constraints are imposed
4. Determine what compliance/non-compliance leads to"""
        }
        
        reasoning_sections = []
        for mode in reasoning_modes:
            reasoning_sections.append(reasoning_descriptions[mode])
        
        prompt = f"""You are analyzing a legal document for the rule: "{self.rule_name}"
in the jurisdiction: {self.jurisdiction}.{chunk_context}

DOCUMENT TEXT:
{document_text}

CRITICAL: Extract ALL information from this text. This may be part of a larger document, so be thorough.

Apply multiple reasoning approaches to deeply understand this document:

{''.join(reasoning_sections)}

INTEGRATED ANALYSIS:
Combining insights from all reasoning approaches, provide:
1. Description of the rule (what it says and why it exists)
2. Actions permitted/prohibited for user and system
3. Duties and obligations for user and system
4. All constraints and conditions
5. Classification as permission, prohibition, or obligation
6. How the different reasoning approaches converge or diverge

Show how each reasoning mode contributed to your final understanding."""

        return prompt
    
    def get_dynamic_contextualized_prompt(
        self,
        document_text: str,
        previous_analyses: Optional[List[str]] = None,
        enterprise_context: Optional[Dict[str, Any]] = None,
        chunk_info: Optional[str] = None
    ) -> str:
        """
        Generate dynamic prompt that adapts based on context and previous analyses
        """
        chunk_context_section = ""
        if chunk_info:
            chunk_context_section = f"\n\nCHUNK CONTEXT:\n{chunk_info}\nExtract ALL relevant information from this section completely."
        
        context_section = ""
        
        if enterprise_context:
            org_name = enterprise_context.get("organization", "the organization")
            context_section += f"\nENTERPRISE CONTEXT:\n"
            context_section += f"- Organization: {org_name}\n"
            
            if enterprise_context.get("internal_tools"):
                tools = enterprise_context["internal_tools"]
                context_section += f"- Internal Tools: {', '.join(tools)}\n"
                context_section += f"  Note: These tools are part of {org_name}'s internal infrastructure.\n"
                
                if "DataVisa" in tools:
                    context_section += f"  DataVisa: {org_name}'s internal data privacy governance platform.\n"
            
            if enterprise_context.get("business_units"):
                context_section += f"- Relevant Business Units: {', '.join(enterprise_context['business_units'])}\n"
            
            if enterprise_context.get("data_flows"):
                context_section += f"- Data Flows: {enterprise_context['data_flows']}\n"
        
        previous_insights = ""
        if previous_analyses:
            previous_insights = "\nPREVIOUS ANALYSIS INSIGHTS:\n"
            for i, analysis in enumerate(previous_analyses, 1):
                previous_insights += f"\nLevel {i} Analysis Key Points:\n{analysis}\n"
            previous_insights += "\nUse these insights to build a more comprehensive understanding.\n"
        
        prompt = f"""You are conducting a sophisticated analysis of a legal document for the rule: "{self.rule_name}"
in the jurisdiction: {self.jurisdiction}.
{context_section}{chunk_context_section}

DOCUMENT TEXT:
{document_text}
{previous_insights}

CRITICAL: Extract ALL information from this text completely. Do not skip any details.

ANALYSIS FRAMEWORK:

1. CONTEXTUAL UNDERSTANDING
   - Consider the jurisdiction-specific legal framework
   - Account for enterprise-specific requirements and tools
   - Integrate insights from previous analysis levels (if any)

2. COMPREHENSIVE EXTRACTION
   For USER-side requirements:
   - What actions can/must/cannot the user take?
   - What are the user's duties and obligations?
   - Under what conditions?
   
   For SYSTEM-side requirements:
   - What actions can/must/cannot the system perform?
   - What are the system's duties and obligations?
   - What technical/security measures are required?

3. CONSTRAINT ANALYSIS
   Identify all types of constraints:
   - Temporal: time limits, retention periods, deadlines
   - Purpose: purpose limitation, specified purposes
   - Technical: encryption, anonymization, security measures
   - Procedural: consent requirements, notification requirements
   - Scope: data categories, geographic limitations
   - Conditional: if-then scenarios, prerequisite conditions

4. CLASSIFICATION
   Determine if this rule represents:
   - PERMISSION: Explicitly allows certain actions (may, can, is permitted to)
   - PROHIBITION: Explicitly forbids actions (must not, cannot, is prohibited from)
   - OBLIGATION: Requires actions (must, shall, is required to)
   - Or a COMBINATION with specific conditions

5. PRACTICAL SYNTHESIS
   Provide a clear, actionable summary that a legal team can review and implement:
   - Clear description in plain language
   - Specific actions mapped to actors (user/system)
   - Specific duties mapped to actors (user/system)
   - Complete list of all applicable constraints
   - Definitive classification with justification

Be thorough, precise, and practical in your analysis."""

        return prompt
    
    def get_react_agent_system_prompt(self) -> str:
        """
        System prompt for ReAct (Reasoning + Acting) agent
        """
        return f"""You are a specialized legal document analysis agent using the ReAct (Reasoning + Acting) framework.

Your mission: Analyze legal documents for the rule "{self.rule_name}" in {self.jurisdiction} jurisdiction.

REACT FRAMEWORK:
1. THOUGHT: Reason about what you need to understand
2. ACTION: Decide what analytical step to take
3. OBSERVATION: Process the results
4. Repeat until you have complete understanding

AVAILABLE ACTIONS:
- extract_text: Extract and read text from a section
- identify_actors: Determine who the subjects/actors are
- extract_actions: Find all actions mentioned
- extract_duties: Find all obligations and duties
- extract_constraints: Find all conditions and limitations
- classify_rule_type: Determine if permission/prohibition/obligation
- synthesize: Combine all findings into final summary
- verify: Check completeness and accuracy

QUALITY STANDARDS:
- Be thorough: Don't miss any requirements
- Be precise: Use exact language from the document
- Be clear: Make complex legal language understandable
- Be practical: Focus on implementable requirements
- Be generic: Don't assume specific jurisdictions unless stated

CONTEXT AWARENESS:
- Recognize references to internal tools (e.g., DataVisa)
- Understand enterprise-specific policies
- Distinguish between different legal frameworks
- Consider multi-jurisdictional requirements

OUTPUT FORMAT:
For each thought-action cycle, format as:
THOUGHT: [Your reasoning]
ACTION: [The action you're taking]
OBSERVATION: [What you learned]

Continue until you can provide a complete analysis covering:
- Rule description
- Actions by user/system
- Duties by user/system  
- All constraints
- Permission/prohibition/obligation classification"""

    def get_reflection_prompt(self, initial_analysis: str, document_text: str) -> str:
        """
        Prompt for reflection and self-correction
        """
        return f"""You previously analyzed a legal document for the rule "{self.rule_name}".

DOCUMENT TEXT:
{document_text}

YOUR PREVIOUS ANALYSIS:
{initial_analysis}

Now, reflect on your analysis with critical thinking:

1. COMPLETENESS CHECK:
   - Did you miss any actions, duties, or constraints?
   - Are there implicit requirements you didn't capture?
   - Did you consider all actors (user, system, third parties)?

2. ACCURACY CHECK:
   - Are your interpretations legally sound?
   - Did you correctly classify permissions vs prohibitions?
   - Are the constraints precisely stated?

3. CLARITY CHECK:
   - Is the description clear and understandable?
   - Are technical/legal terms properly explained?
   - Is the classification unambiguous?

4. PRACTICAL CHECK:
   - Can this analysis be implemented?
   - Are the requirements actionable?
   - Is it useful for legal review?

Based on this reflection, provide:
- What was correct in the original analysis
- What needs to be corrected or enhanced
- The improved, final analysis

Be honest about limitations and uncertainties."""

    def get_multi_level_synthesis_prompt(
        self,
        level_1_analysis: str,
        level_2_analysis: str,
        level_3_analysis: str
    ) -> str:
        """
        Synthesize analyses from multiple document levels
        """
        return f"""You have analyzed three levels of documentation for the rule "{self.rule_name}" 
in {self.jurisdiction}.

LEVEL 1 ANALYSIS (Overview/Summary):
{level_1_analysis}

LEVEL 2 ANALYSIS (Detailed Requirements):
{level_2_analysis}

LEVEL 3 ANALYSIS (Technical/Implementation Details):
{level_3_analysis}

SYNTHESIS TASK:
Integrate insights from all three levels to create a comprehensive, unified analysis.

SYNTHESIS APPROACH:
1. Identify CONSISTENT themes across all levels
2. Resolve any CONFLICTS or contradictions
3. Integrate COMPLEMENTARY information
4. Build from GENERAL (L1) to SPECIFIC (L3)
5. Ensure NO information is lost

FINAL OUTPUT should include:
1. DESCRIPTION: Comprehensive description synthesizing all levels
2. USER ACTIONS: All actions a user can/must/cannot take
3. SYSTEM ACTIONS: All actions a system can/must/cannot perform
4. USER DUTIES: All obligations for the user
5. SYSTEM DUTIES: All obligations for the system
6. CONSTRAINTS: Complete list from all levels (temporal, technical, procedural, etc.)
7. CLASSIFICATION: Permission/Prohibition/Obligation with confidence level

The synthesis should be:
- More comprehensive than any single level
- Internally consistent
- Practically implementable
- Ready for legal review and eventual ODRL conversion"""

        return prompt
