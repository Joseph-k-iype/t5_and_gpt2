"""
Data Transfer Compliance Dashboard - Optimized Flask Backend
High-performance with fuzzy matching, compliance checker, and pagination
"""

from flask import Flask, jsonify, render_template, request
from flask_cors import CORS
from flask_caching import Cache
from falkordb import FalkorDB
from redis import ConnectionPool
import logging
from functools import lru_cache
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__, static_folder='static', template_folder='templates')
CORS(app)

# Configure caching for performance
cache = Cache(app, config={
    'CACHE_TYPE': 'simple',
    'CACHE_DEFAULT_TIMEOUT': 300  # 5 minutes
})

# ==================== COUNTRY LISTS ====================

# EU/EEA + UK + Jersey, Guernsey, Isle of Man, Switzerland
EU_EEA_UK_FULL = {
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden', 'United Kingdom', 'Jersey', 'Guernsey', 
    'Isle of Man', 'Switzerland'
}

# EU/EEA only (without UK, Jersey, Guernsey, IoM, Switzerland)
EU_EEA_ONLY = {
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden'
}

# Adequacy countries
ADEQUACY_COUNTRIES = {
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Japan', 'Jersey', 'New Zealand', 'Republic of Korea', 
    'Switzerland', 'United Kingdom', 'Uruguay'
}

# Crown Dependencies
CROWN_DEPENDENCIES = {'Jersey', 'Isle of Man', 'Guernsey'}

# Switzerland special list
SWITZERLAND_DEST_LIST = {
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Jersey', 'New Zealand', 'Switzerland', 'Uruguay',
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden', 'Gibraltar', 'Monaco'
}

# UK destination list
UK_DEST_LIST = {
    'Andorra', 'Argentina', 'Canada', 'Faroe Islands', 'Guernsey', 'Israel', 
    'Isle of Man', 'Japan', 'Jersey', 'New Zealand', 'Republic of Korea', 
    'Switzerland', 'Uruguay',
    'Belgium', 'Bulgaria', 'Czechia', 'Denmark', 'Germany', 'Estonia', 
    'Ireland', 'Greece', 'Spain', 'France', 'Croatia', 'Italy', 'Cyprus', 
    'Latvia', 'Lithuania', 'Luxembourg', 'Hungary', 'Malta', 'Netherlands', 
    'Austria', 'Poland', 'Portugal', 'Romania', 'Slovenia', 'Slovakia', 
    'Finland', 'Sweden'
}

# High-risk countries requiring HRPR
HIGH_RISK_COUNTRIES = {
    'Algeria', 'Australia', 'Bahrain', 'Bangladesh', 'Belgium', 'Bermuda', 
    'Brazil', 'Canada', 'Cayman Islands', 'Chile', 'China', 'Czech Republic', 
    'British Virgin Islands', 'Denmark', 'Egypt', 'France', 'Germany', 
    'Guernsey', 'Hong Kong', 'India', 'Indonesia', 'Ireland', 'Isle of Man', 
    'Italy', 'Japan', 'Jersey', 'Korea, Republic Of (South)', 'Kuwait', 
    'Luxembourg', 'Macao', 'Malaysia', 'Maldives', 'Malta', 'Mauritius', 
    'Mexico', 'Netherlands', 'New Zealand', 'Oman', 'Philippines', 'Poland', 
    'Qatar', 'Saudi Arabia', 'Singapore', 'South Africa', 'Spain', 'Sri Lanka', 
    'Sweden', 'Switzerland', 'Taiwan', 'Thailand', 'Turkey', 'Turkiye',
    'United Arab Emirates', 'United Kingdom', 'United States of America', 
    'Uruguay', 'Vietnam'
}

# Combined list for Rule 6
COMBINED_ADEQUACY_EU = EU_EEA_ONLY | ADEQUACY_COUNTRIES | {'United Kingdom'}


# ==================== DATABASE CONNECTION ====================

# Country name variations for fuzzy matching
COUNTRY_VARIATIONS = {
    'korea': 'Republic of Korea',
    'south korea': 'Republic of Korea',
    'republic of korea': 'Republic of Korea',
    'korea, republic of (south)': 'Republic of Korea',
    'turkey': 'Turkey',
    'turkiye': 'Turkey',
    'czech republic': 'Czechia',
    'czechia': 'Czechia',
    'united states': 'United States of America',
    'usa': 'United States of America',
    'us': 'United States of America',
    'united states of america': 'United States of America',
    'uk': 'United Kingdom',
    'united kingdom': 'United Kingdom',
    'uae': 'United Arab Emirates',
    'united arab emirates': 'United Arab Emirates',
    'new zeland': 'New Zealand',
    'luxemborg': 'Luxembourg',
    'uruguay': 'Uruguay',
    'uruguar': 'Uruguay',
}

@lru_cache(maxsize=1000)
def normalize_country_name(country):
    """
    Normalize country names with fuzzy matching
    Case-insensitive, handles variations
    """
    if not country:
        return country
    
    country_lower = country.strip().lower()
    
    if country_lower in COUNTRY_VARIATIONS:
        return COUNTRY_VARIATIONS[country_lower]
    
    for variation, normalized in COUNTRY_VARIATIONS.items():
        if variation in country_lower or country_lower in variation:
            return normalized
    
    return country.strip().title()

@lru_cache(maxsize=100)
def country_matches(country1, country2):
    """Check if two country names match (case-insensitive, fuzzy)"""
    if not country1 or not country2:
        return False
    
    norm1 = normalize_country_name(country1)
    norm2 = normalize_country_name(country2)
    
    return norm1.lower() == norm2.lower()

@lru_cache(maxsize=100)
def is_country_in_list(country, country_set):
    """Check if country is in a set (case-insensitive, fuzzy)"""
    if not country:
        return False
    
    normalized = normalize_country_name(country)
    
    if normalized in country_set:
        return True
    
    for country_in_set in country_set:
        if country_matches(normalized, country_in_set):
            return True
    
    return False


class ComplianceAnalyzer:
    def __init__(self, host='localhost', port=6379, graph_name='DataTransferGraph'):
        """Initialize with proper connection pooling and timeouts"""
        logger.info(f"Initializing FalkorDB connection to {host}:{port}")
        
        # Create connection pool with timeouts (similar to load.py)
        self.pool = ConnectionPool(
            host=host,
            port=port,
            max_connections=10,
            socket_timeout=60,  # 60 second query timeout
            socket_connect_timeout=10,
            decode_responses=True,
            health_check_interval=30,
            retry_on_timeout=True
        )
        
        self.db = FalkorDB(connection_pool=self.pool)
        self.graph = self.db.select_graph(graph_name)
        
        logger.info(f"✅ Connected to FalkorDB graph: {graph_name}")
        
        # Test connection
        try:
            result = self.graph.query("MATCH (c:Case) RETURN count(c) as count LIMIT 1")
            total = result.result_set[0][0] if result.result_set else 0
            logger.info(f"✅ Database has {total:,} cases")
        except Exception as e:
            logger.error(f"❌ Connection test failed: {e}")
            raise
    
    def normalize_country_name(self, country):
        """Use the global normalize function"""
        return normalize_country_name(country)
    
    def check_compliance_rule(self, origin, destination, pia, tia, hrpr, has_personal_data):
        """
        Apply compliance rules with fuzzy country matching
        Returns: dict with required_modules, rule_matched, and explanation
        """
        origin = normalize_country_name(origin)
        destination = normalize_country_name(destination)
        
        required = {'PIA': False, 'TIA': False, 'HRPR': False}
        rule = None
        explanation = ""
        
        # Rule 1: Both in EU/EEA/UK/CH list → PIA
        if (is_country_in_list(origin, EU_EEA_UK_FULL) and 
            is_country_in_list(destination, EU_EEA_UK_FULL)):
            required['PIA'] = True
            rule = "Rule 1"
            explanation = "Both origin and destination in EU/EEA/UK/CH → PIA required"
        
        # Rule 2: EU origin, adequacy destination → PIA
        elif (is_country_in_list(origin, EU_EEA_ONLY) and 
              is_country_in_list(destination, ADEQUACY_COUNTRIES)):
            required['PIA'] = True
            rule = "Rule 2"
            explanation = "EU origin to adequacy country → PIA required"
        
        # Rule 3: Crown Dependencies origin, adequacy+EU destination → PIA
        elif (is_country_in_list(origin, CROWN_DEPENDENCIES) and 
              (is_country_in_list(destination, ADEQUACY_COUNTRIES) or 
               is_country_in_list(destination, EU_EEA_ONLY))):
            required['PIA'] = True
            rule = "Rule 3"
            explanation = "Crown Dependencies to adequacy/EU → PIA required"
        
        # Rule 4: UK origin, specific destination list → PIA
        elif (country_matches(origin, 'United Kingdom') and 
              is_country_in_list(destination, UK_DEST_LIST)):
            required['PIA'] = True
            rule = "Rule 4"
            explanation = "UK to adequacy/EU countries → PIA required"
        
        # Rule 5: Switzerland origin, specific destination list → PIA
        elif (country_matches(origin, 'Switzerland') and 
              is_country_in_list(destination, SWITZERLAND_DEST_LIST)):
            required['PIA'] = True
            rule = "Rule 5"
            explanation = "Switzerland to specific approved countries → PIA required"
        
        # Rule 7: High-risk origin → PIA + HRPR (check before Rule 6)
        elif is_country_in_list(origin, HIGH_RISK_COUNTRIES):
            required['PIA'] = True
            required['HRPR'] = True
            rule = "Rule 7"
            explanation = f"High-risk origin country ({origin}) → PIA + HRPR required"
        
        # Rule 6: Combined list origin, outside destination → PIA + TIA
        elif (is_country_in_list(origin, COMBINED_ADEQUACY_EU) and 
              not is_country_in_list(destination, COMBINED_ADEQUACY_EU)):
            required['PIA'] = True
            required['TIA'] = True
            rule = "Rule 6"
            explanation = "Transfer from adequacy/EU to non-adequacy country → PIA + TIA required"
        
        # Rule 8: Default - has personal data → PIA
        elif has_personal_data:
            required['PIA'] = True
            rule = "Rule 8"
            explanation = "Transfer with personal data (default rule) → PIA required"
        
        # Check compliance status
        compliant = True
        missing = []
        
        if required['PIA'] and pia != 'CM':
            compliant = False
            missing.append('PIA')
        if required['TIA'] and tia != 'CM':
            compliant = False
            missing.append('TIA')
        if required['HRPR'] and hrpr != 'CM':
            compliant = False
            missing.append('HRPR')
        
        return {
            'required_modules': required,
            'rule_matched': rule,
            'explanation': explanation,
            'compliant': compliant,
            'missing_modules': missing,
            'actual_modules': {'PIA': pia, 'TIA': tia, 'HRPR': hrpr}
        }
    
    @cache.memoize(timeout=300)
    def get_all_transfers_paginated(self, limit=10000, offset=0):
        """
        Get transfers with PAGINATION to avoid timeout
        Use this for large datasets
        """
        query = """
        MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
        MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
        OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
        WITH c, origin, dest, collect(DISTINCT pd.name) AS personal_data
        RETURN 
            c.case_id AS case_id,
            origin.name AS origin_country,
            dest.name AS destination_country,
            personal_data,
            c.pia_module AS pia_module,
            c.tia_module AS tia_module,
            c.hrpr_module AS hrpr_module,
            c.eim_id AS eim_id,
            c.business_app_id AS business_app_id
        SKIP $offset
        LIMIT $limit
        """
        
        try:
            result = self.graph.query(query, params={'limit': limit, 'offset': offset})
            transfers = []
            
            for row in result.result_set:
                case_id = row[0]
                origin = row[1]
                destination = row[2]
                personal_data = row[3] if row[3] else []
                pia = row[4]
                tia = row[5]
                hrpr = row[6]
                eim_id = row[7]
                business_app_id = row[8]
                
                has_personal_data = len(personal_data) > 0
                
                compliance = self.check_compliance_rule(
                    origin, destination, pia, tia, hrpr, has_personal_data
                )
                
                transfers.append({
                    'case_id': case_id,
                    'origin_country': origin,
                    'destination_country': destination,
                    'personal_data': personal_data,
                    'pia_module': pia,
                    'tia_module': tia,
                    'hrpr_module': hrpr,
                    'eim_id': eim_id,
                    'business_app_id': business_app_id,
                    'compliance': compliance
                })
            
            return transfers
            
        except Exception as e:
            logger.error(f"Error fetching transfers (limit={limit}, offset={offset}): {e}")
            raise
    
    def get_all_transfers(self, max_records=50000):
        """
        Get ALL transfers by fetching in batches
        For very large datasets, use pagination
        """
        logger.info(f"Fetching up to {max_records:,} transfers in batches...")
        
        all_transfers = []
        batch_size = 5000
        offset = 0
        
        while offset < max_records:
            logger.info(f"  Fetching batch: offset={offset}, limit={batch_size}")
            
            try:
                batch = self.get_all_transfers_paginated(limit=batch_size, offset=offset)
                
                if not batch:
                    logger.info(f"  No more records found at offset {offset}")
                    break
                
                all_transfers.extend(batch)
                logger.info(f"  Retrieved {len(batch):,} records (total: {len(all_transfers):,})")
                
                # Stop if we got fewer records than requested (end of data)
                if len(batch) < batch_size:
                    logger.info(f"  Reached end of data")
                    break
                
                offset += batch_size
                
            except Exception as e:
                logger.error(f"  Error in batch at offset {offset}: {e}")
                break
        
        logger.info(f"✅ Total transfers loaded: {len(all_transfers):,}")
        return all_transfers
    
    @cache.memoize(timeout=300)
    def get_total_count(self):
        """Get total count of cases - fast query"""
        try:
            query = "MATCH (c:Case) RETURN count(c) as total"
            result = self.graph.query(query)
            return result.result_set[0][0] if result.result_set else 0
        except Exception as e:
            logger.error(f"Error getting total count: {e}")
            return 0
    
    def check_scenario_compliance(self, origin, destination, purpose, has_pii):
        """Check compliance for a hypothetical scenario"""
        origin = normalize_country_name(origin)
        destination = normalize_country_name(destination)
        
        compliance = self.check_compliance_rule(
            origin, destination, None, None, None, has_pii
        )
        
        return {
            'origin_country': origin,
            'destination_country': destination,
            'purpose': purpose,
            'has_pii': has_pii,
            'required_modules': compliance['required_modules'],
            'rule_matched': compliance['rule_matched'],
            'explanation': compliance['explanation']
        }
    
    def get_summary_statistics(self, transfers):
        """Calculate summary statistics"""
        total = len(transfers)
        compliant = sum(1 for t in transfers if t['compliance']['compliant'])
        non_compliant = total - compliant
        
        rule_counts = {}
        for t in transfers:
            rule = t['compliance']['rule_matched']
            if rule:
                rule_counts[rule] = rule_counts.get(rule, 0) + 1
        
        missing_pia = sum(1 for t in transfers if 'PIA' in t['compliance']['missing_modules'])
        missing_tia = sum(1 for t in transfers if 'TIA' in t['compliance']['missing_modules'])
        missing_hrpr = sum(1 for t in transfers if 'HRPR' in t['compliance']['missing_modules'])
        
        route_counts = {}
        for t in transfers:
            route = f"{t['origin_country']} → {t['destination_country']}"
            route_counts[route] = route_counts.get(route, 0) + 1
        
        top_routes = sorted(route_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        
        return {
            'total_transfers': total,
            'compliant': compliant,
            'non_compliant': non_compliant,
            'compliance_rate': round((compliant / total * 100), 2) if total > 0 else 0,
            'rule_counts': rule_counts,
            'missing_modules': {
                'PIA': missing_pia,
                'TIA': missing_tia,
                'HRPR': missing_hrpr
            },
            'top_routes': [{'route': r[0], 'count': r[1]} for r in top_routes]
        }
    
    def get_non_compliant_cases(self, transfers):
        """Get only non-compliant cases"""
        return [t for t in transfers if not t['compliance']['compliant']]
    
    def get_compliance_by_rule(self, transfers):
        """Get compliance breakdown by rule"""
        rule_compliance = {}
        
        for t in transfers:
            rule = t['compliance']['rule_matched']
            if rule:
                if rule not in rule_compliance:
                    rule_compliance[rule] = {
                        'total': 0,
                        'compliant': 0,
                        'non_compliant': 0,
                        'explanation': t['compliance']['explanation']
                    }
                
                rule_compliance[rule]['total'] += 1
                if t['compliance']['compliant']:
                    rule_compliance[rule]['compliant'] += 1
                else:
                    rule_compliance[rule]['non_compliant'] += 1
        
        return rule_compliance


# Initialize analyzer
analyzer = ComplianceAnalyzer()


# ==================== API ENDPOINTS ====================

@app.route('/')
def index():
    """Serve the dashboard"""
    return render_template('dashboard.html')

@app.route('/api/transfers')
def get_transfers():
    """
    Get all transfers with compliance analysis
    For large datasets (100k+), this may take time on first load
    Results are cached for 5 minutes
    """
    try:
        # Check if user wants to limit results
        limit = request.args.get('limit', type=int, default=50000)
        
        logger.info(f"API request for transfers (limit={limit})")
        transfers = analyzer.get_all_transfers(max_records=limit)
        
        return jsonify({
            'success': True,
            'data': transfers,
            'total': len(transfers),
            'limited': len(transfers) >= limit
        })
    except Exception as e:
        logger.error(f"Error getting transfers: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e),
            'hint': 'Try reducing the limit or check database connection'
        }), 500

@app.route('/api/summary')
def get_summary():
    """Get summary statistics"""
    try:
        transfers = analyzer.get_all_transfers(max_records=50000)
        summary = analyzer.get_summary_statistics(transfers)
        return jsonify({
            'success': True,
            'data': summary
        })
    except Exception as e:
        logger.error(f"Error getting summary: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/non-compliant')
def get_non_compliant():
    """Get non-compliant cases only"""
    try:
        transfers = analyzer.get_all_transfers(max_records=50000)
        non_compliant = analyzer.get_non_compliant_cases(transfers)
        return jsonify({
            'success': True,
            'data': non_compliant
        })
    except Exception as e:
        logger.error(f"Error getting non-compliant: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/compliance-by-rule')
def get_compliance_by_rule():
    """Get compliance breakdown by rule"""
    try:
        transfers = analyzer.get_all_transfers(max_records=50000)
        rule_compliance = analyzer.get_compliance_by_rule(transfers)
        return jsonify({
            'success': True,
            'data': rule_compliance
        })
    except Exception as e:
        logger.error(f"Error getting compliance by rule: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/total-count')
def get_total_count():
    """Get total count of cases (fast query)"""
    try:
        total = analyzer.get_total_count()
        return jsonify({
            'success': True,
            'total': total
        })
    except Exception as e:
        logger.error(f"Error getting total count: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/check-scenario', methods=['POST'])
def check_scenario():
    """Check compliance for a hypothetical scenario"""
    try:
        data = request.get_json()
        
        origin = data.get('origin_country', '').strip()
        destination = data.get('destination_country', '').strip()
        purpose = data.get('purpose', '').strip()
        has_pii = data.get('has_pii', False)
        
        if not origin or not destination:
            return jsonify({
                'success': False,
                'error': 'origin_country and destination_country are required'
            }), 400
        
        result = analyzer.check_scenario_compliance(origin, destination, purpose, has_pii)
        
        return jsonify({
            'success': True,
            'data': result
        })
    except Exception as e:
        logger.error(f"Error checking scenario: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/purposes')
def get_purposes():
    """Get list of valid processing purposes"""
    purposes = [
        "Prevention of Financial Crime",
        "Risk Management (excluding any Financial Crime related Risk Mgmt.)",
        "Back Office Operations Support",
        "Security / Prevention and Detecting Crime (excluding Financial Crime)",
        "Compliance with Laws and Regulations",
        "Disclosures to Authorities",
        "Identifying Target Subjects Need",
        "Marketing to Target Subjects",
        "Provision of Banking and Financial Services",
        "Product and Service Improvement",
        "Front Office Operations Support",
        "Personal Data as a Product",
        "Provision of a Communication Platform"
    ]
    return jsonify({
        'success': True,
        'data': purposes
    })

@app.route('/api/search-similar-cases', methods=['POST'])
def search_similar_cases():
    """Search for similar cases in the database using fuzzy matching"""
    try:
        data = request.get_json()
        
        origin = data.get('origin_country', '').strip()
        destination = data.get('destination_country', '').strip()
        purpose = data.get('purpose', '').strip()
        
        query_parts = ["MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)"]
        query_parts.append("MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)")
        
        conditions = []
        if origin:
            conditions.append(f"toLower(origin.name) CONTAINS toLower('{origin}')")
        if destination:
            conditions.append(f"toLower(dest.name) CONTAINS toLower('{destination}')")
        
        if conditions:
            query_parts.append("WHERE " + " AND ".join(conditions))
        
        if purpose:
            query_parts.append("OPTIONAL MATCH (c)-[:HAS_PURPOSE]->(p:Purpose)")
            query_parts.append(f"WHERE toLower(p.name) CONTAINS toLower('{purpose}')")
        
        query_parts.append("""
            RETURN c.case_id, origin.name, dest.name, 
                   c.pia_module, c.tia_module, c.hrpr_module
            LIMIT 100
        """)
        
        query = "\n".join(query_parts)
        result = analyzer.graph.query(query)
        
        similar_cases = []
        for row in result.result_set:
            similar_cases.append({
                'case_id': row[0],
                'origin': row[1],
                'destination': row[2],
                'pia_module': row[3],
                'tia_module': row[4],
                'hrpr_module': row[5]
            })
        
        return jsonify({
            'success': True,
            'data': similar_cases,
            'count': len(similar_cases)
        })
    except Exception as e:
        logger.error(f"Error searching similar cases: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/health')
def health_check():
    """Health check endpoint"""
    try:
        total = analyzer.get_total_count()
        return jsonify({
            'status': 'healthy',
            'service': 'Compliance Dashboard',
            'total_cases': total
        })
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e)
        }), 500


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
