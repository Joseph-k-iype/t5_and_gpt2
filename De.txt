# backend/app/api/research.py
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks, Request
from fastapi.responses import StreamingResponse
from typing import Dict, Any
import asyncio
import json
import logging

from app.models.research import (
    DeepResearchRequest, ResearchResult, ResearchStatus,
    ResearchProgressUpdate, ResearchStage
)
from app.core.session_manager import SessionManager
from app.core.research_engine import ResearchEngineWrapper

logger = logging.getLogger(__name__)
router = APIRouter()

# Store active research sessions
active_research: Dict[str, Dict[str, Any]] = {}

def get_session_manager(request: Request) -> SessionManager:
    """Dependency to get session manager"""
    if not hasattr(request.app.state, 'session_manager') or request.app.state.session_manager is None:
        raise HTTPException(status_code=503, detail="Session manager not available")
    return request.app.state.session_manager

def get_research_engine(request: Request) -> ResearchEngineWrapper:
    """Dependency to get research engine"""
    if not hasattr(request.app.state, 'research_engine') or request.app.state.research_engine is None:
        raise HTTPException(status_code=503, detail="Research engine not available")
    return request.app.state.research_engine

@router.post("/deep", response_model=ResearchResult)
async def start_deep_research(
    request: DeepResearchRequest,
    background_tasks: BackgroundTasks,
    session_manager: SessionManager = Depends(get_session_manager),
    research_engine: ResearchEngineWrapper = Depends(get_research_engine)
):
    """
    Start deep research process
    """
    try:
        # Get or create session
        if request.session_id:
            session = await session_manager.get_session(request.session_id)
            if not session:
                raise HTTPException(status_code=404, detail="Session not found")
        else:
            session = await session_manager.create_session(request.user_id)
        
        # Check if research is already running for this session
        if session.session_id in active_research:
            raise HTTPException(
                status_code=409, 
                detail="Research already in progress for this session"
            )
        
        # Check cache first
        cached_result = await session_manager.get_cached_research(
            session.session_id, request.topic
        )
        if cached_result:
            logger.info(f"Returning cached research result for: {request.topic}")
            return ResearchResult(**cached_result)
        
        # Mark research as active
        active_research[session.session_id] = {
            "status": "running",
            "stage": ResearchStage.INITIALIZATION,
            "progress": 0
        }
        
        try:
            # Start deep research
            result = await research_engine.deep_research(
                topic=request.topic,
                user_id=session.user_id,
                session_id=session.session_id
            )
            
            # Cache the result
            background_tasks.add_task(
                session_manager.cache_research_result,
                session.session_id,
                request.topic,
                result
            )
            
            # Return structured response
            research_result = ResearchResult(
                final_synthesis=result.get("final_synthesis", "No synthesis available"),
                overall_confidence=result.get("overall_confidence", 0.0),
                agents_used=result.get("agents_used", []),
                iterations_completed=result.get("iterations_completed", 0),
                session_id=session.session_id,
                user_id=session.user_id,
                timestamp=session.last_activity,
                processing_time=result.get("processing_time", "extended"),
                metadata=result.get("metadata", {})
            )
            
            return research_result
            
        finally:
            # Remove from active research
            active_research.pop(session.session_id, None)
        
    except HTTPException:
        # Remove from active research on HTTP errors
        active_research.pop(request.session_id or "unknown", None)
        raise
    except Exception as e:
        # Remove from active research on any error
        active_research.pop(request.session_id or "unknown", None)
        logger.error(f"Error in deep research: {e}")
        raise HTTPException(status_code=500, detail=f"Research failed: {str(e)}")

@router.get("/status/{session_id}", response_model=ResearchStatus)
async def get_research_status(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """
    Get research status for a session
    """
    try:
        session = await session_manager.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Check if research is active
        if session_id in active_research:
            research_info = active_research[session_id]
            return ResearchStatus(
                session_id=session_id,
                is_active=True,
                current_stage=research_info.get("stage"),
                progress_percentage=research_info.get("progress", 0),
                estimated_completion=None,  # Could be calculated based on progress
                error_message=research_info.get("error")
            )
        else:
            return ResearchStatus(
                session_id=session_id,
                is_active=False,
                current_stage=None,
                progress_percentage=100,
                estimated_completion=None,
                error_message=None
            )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting research status: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/stream/{session_id}")
async def stream_research_progress(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager),
    research_engine: ResearchEngineWrapper = Depends(get_research_engine)
):
    """
    Stream research progress updates
    """
    async def generate_progress():
        """Generate progress updates as Server-Sent Events"""
        try:
            session = await session_manager.get_session(session_id)
            if not session:
                yield f"data: {json.dumps({'error': 'Session not found'})}\n\n"
                return
            
            # Mock progress updates for demonstration
            # In real implementation, this would connect to the research engine's progress
            stages = [
                (ResearchStage.INITIALIZATION, "Initializing research system...", 10),
                (ResearchStage.PLANNING, "Creating research plan...", 25),
                (ResearchStage.RESEARCH, "Conducting research...", 70),
                (ResearchStage.SYNTHESIS, "Synthesizing findings...", 90),
                (ResearchStage.COMPLETION, "Research completed!", 100)
            ]
            
            for stage, message, progress in stages:
                if session_id not in active_research:
                    break
                
                update = ResearchProgressUpdate(
                    stage=stage,
                    message=message,
                    progress=progress,
                    details={"session_id": session_id}
                )
                
                # Update active research status
                active_research[session_id].update({
                    "stage": stage,
                    "progress": progress
                })
                
                yield f"data: {update.json()}\n\n"
                await asyncio.sleep(2)  # Simulate processing time
            
        except Exception as e:
            error_update = ResearchProgressUpdate(
                stage=ResearchStage.ERROR,
                message=f"Error: {str(e)}",
                progress=0,
                error=True
            )
            yield f"data: {error_update.json()}\n\n"
    
    return StreamingResponse(
        generate_progress(),
        media_type="text/plain",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Content-Type": "text/event-stream"
        }
    )
