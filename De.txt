import os
import re
import json
import logging
import pandas as pd
from typing import Dict, List, Optional
from langgraph.graph import StateGraph, END
from langchain.agents import Tool, AgentExecutor
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from pydantic import BaseModel, ValidationError, field_validator

# Previous base classes (OSEnv, AzureChatbot) remain unchanged

class RegexGeneratorConfig(BaseModel):
    max_iterations: int = 3
    min_coverage: float = 0.85
    complexity_level: str = "high"
    allowed_charset: str = r"\w\s\-$%().,;:@#&*+!?'"

class RegexPattern(BaseModel):
    name: str
    pattern: str
    status: str
    reasons: List[str]
    coverage: str
    examples: Dict[str, bool]

    @field_validator('pattern')
    def validate_pattern(cls, v):
        try:
            re.compile(v)
            return v
        except re.error as e:
            raise ValueError(f"Invalid regex: {e}") from e

class RegexGenerationWorkflow:
    def __init__(self, csv_path: str, config: RegexGeneratorConfig = RegexGeneratorConfig()):
        self.df = pd.read_csv(csv_path)
        self.chatbot = AzureChatbot(CONFIG_PATH, CREDS_PATH, CERT_PATH)
        self.config = config
        self.workflow = StateGraph(dict)
        self._build_workflow()

    def _build_workflow(self):
        self.workflow.add_node("analyze_term", self.analyze_term)
        self.workflow.add_node("generate_candidates", self.generate_candidates)
        self.workflow.add_node("validate_pattern", self.validate_pattern)
        self.workflow.add_node("refine_pattern", self.refine_pattern)
        self.workflow.add_node("finalize_pattern", self.finalize_pattern)
        
        self.workflow.set_entry_point("analyze_term")
        self.workflow.add_edge("analyze_term", "generate_candidates")
        self.workflow.add_edge("generate_candidates", "validate_pattern")
        self.workflow.add_edge("validate_pattern", "refine_pattern")
        self.workflow.add_conditional_edges(
            "refine_pattern",
            self.decide_to_continue,
            {"continue": "validate_pattern", "done": "finalize_pattern"}
        )
        self.workflow.add_edge("finalize_pattern", END)

    def analyze_term(self, state: dict) -> dict:
        terms = []
        for _, row in self.df.iterrows():
            terms.append({
                "name": row["name"],
                "definition": row["definition"],
                "related_terms": self._get_related_terms(row["name"]),
                "iteration": 0,
                "best_pattern": None,
                "validation_history": []
            })
        return {"terms": terms}

    def _get_related_terms(self, term_name: str) -> str:
        related = self.df[self.df["name"] == term_name]
        return "\n".join(
            f"{r['related_term_name']}: {r['related_term_definition']} (e.g., {r['related_term_example']})"
            for _, r in related.iterrows()
        )

    def generate_candidates(self, state: dict) -> dict:
        prompt = ChatPromptTemplate.from_template("""Generate 3 regex patterns for '{name}' considering:
        - ALL possible representations: text, numbers, symbols, unicode
        - Case variations (upper/lower/mixed)
        - Language variations
        - Common abbreviations
        - Partial matches
        - Boundary conditions
        
        Definition: {definition}
        Related Terms: {related_terms}
        
        Requirements:
        1. Use character set: {charset}
        2. Allow partial matches with word boundaries
        3. Include unicode support
        4. Handle numeric/currency formats
        5. Support multilingual representations
        
        Return ONLY as JSON array: ["pattern1", "pattern2", "pattern3"]""")
        
        chain = prompt | self.chatbot.llm | StrOutputParser()
        
        for term in state["terms"]:
            response = chain.invoke({
                **term,
                "charset": self.config.allowed_charset
            })
            term["candidates"] = json.loads(response)
        
        return state

    def validate_pattern(self, state: dict) -> dict:
        prompt = ChatPromptTemplate.from_template("""Generate test cases for regex validation:
        Term: {name}
        Pattern: {pattern}
        
        Generate:
        1. 5 POSITIVE examples that should match
        2. 5 NEGATIVE examples that should NOT match
        
        Return as JSON: {{"positive": [], "negative": []}}""")
        
        chain = prompt | self.chatbot.llm | StrOutputParser()
        
        for term in state["terms"]:
            term["validation_results"] = []
            for pattern in term["candidates"]:
                test_cases = json.loads(chain.invoke({"name": term["name"], "pattern": pattern}))
                term["validation_results"].append({
                    "pattern": pattern,
                    "tests": test_cases,
                    "score": 0
                })
        
        return state

    def refine_pattern(self, state: dict) -> dict:
        prompt = ChatPromptTemplate.from_template("""Improve regex pattern based on test results:
        Original Pattern: {pattern}
        Test Results:
        Passed: {passed}/{total}
        Failed Cases: {failed_cases}
        
        Requirements:
        1. Maintain original matching capability
        2. Fix failed test cases
        3. Improve coverage
        4. Keep pattern efficient
        
        Return ONLY the improved regex pattern""")
        
        chain = prompt | self.chatbot.llm | StrOutputParser()
        
        for term in state["terms"]:
            term["iteration"] += 1
            new_candidates = []
            for result in term["validation_results"]:
                total = len(result["tests"]["positive"] + len(result["tests"]["negative"])
                passed = sum(1 for t in result["tests"]["positive"] if re.search(result["pattern"], t, re.IGNORECASE))
                passed += sum(1 for t in result["tests"]["negative"] if not re.search(result["pattern"], t, re.IGNORECASE))
                
                if passed/total >= self.config.min_coverage:
                    new_candidates.append(result["pattern"])
                else:
                    improved = chain.invoke({
                        "pattern": result["pattern"],
                        "passed": passed,
                        "total": total,
                        "failed_cases": json.dumps({
                            "false_negatives": [t for t in result["tests"]["positive"] 
                                              if not re.search(result["pattern"], t, re.IGNORECASE)],
                            "false_positives": [t for t in result["tests"]["negative"] 
                                              if re.search(result["pattern"], t, re.IGNORECASE)]
                        })
                    })
                    new_candidates.append(improved)
            
            term["candidates"] = new_candidates
        
        return state

    def finalize_pattern(self, state: dict) -> dict:
        prompt = ChatPromptTemplate.from_template("""Select best regex pattern:
        Candidates: {candidates}
        
        Criteria:
        1. Highest test coverage
        2. Pattern simplicity
        3. Readability
        4. Performance
        
        Return as JSON: {{"pattern": "...", "reason": "..."}}""")
        
        chain = prompt | self.chatbot.llm | StrOutputParser()
        
        final_patterns = []
        for term in state["terms"]:
            selection = json.loads(chain.invoke({"candidates": term["candidates"]}))
            final_patterns.append(RegexPattern(
                name=term["name"],
                pattern=selection["pattern"],
                status="GREEN",  # Simplified for example
                reasons=[selection["reason"]],
                coverage="N/A",
                examples=self._generate_final_examples(term, selection["pattern"])
            ))
        
        return {"patterns": final_patterns}

    def _generate_final_examples(self, term: dict, pattern: str) -> Dict[str, bool]:
        prompt = ChatPromptTemplate.from_template("""Generate comprehensive test examples for '{name}':
        Pattern: {pattern}
        
        Generate 10 varied examples (5 valid, 5 invalid) covering:
        - Different languages
        - Character cases
        - Numeric formats
        - Special characters
        - Common edge cases
        
        Return as JSON: {{"valid": [], "invalid": []}}""")
        
        chain = prompt | self.chatbot.llm | StrOutputParser()
        examples = json.loads(chain.invoke({"name": term["name"], "pattern": pattern}))
        return {
            "valid": examples["valid"],
            "invalid": examples["invalid"]
        }

    def decide_to_continue(self, state: dict) -> str:
        return "done" if state["terms"][0]["iteration"] >= self.config.max_iterations else "continue"

    def run(self) -> dict:
        app = self.workflow.compile()
        return app.invoke({})

# Example Usage
if __name__ == "__main__":
    workflow = RegexGenerationWorkflow("technical_terms.csv")
    results = workflow.run()
    
    # Save results
    with open("regex_patterns.json", "w") as f:
        json.dump([p.model_dump() for p in results["patterns"]], f, indent=2)
    
    # Example currency pattern output
    currency_pattern = next(p for p in results["patterns"] if p.name == "CurrencyCode")
    print(f"Currency Code Pattern: {currency_pattern.pattern}")
    print("Example Matches:")
    print("\n".join(currency_pattern.examples["valid"][:5]))
