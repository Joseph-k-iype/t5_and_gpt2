from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel, Field
import requests
import json
from urllib.parse import urlparse, unquote
import uuid
from typing import Dict, List, Optional, Any

# --- Constants ---
RDFS_LABEL_URI = "http://www.w3.org/2000/01/rdf-schema#label" # Standard URI for labels

# --- Helper Functions ---
def _get_label_from_uri(uri_str: str) -> str:
    """Extracts a human-readable label from a URI."""
    if not isinstance(uri_str, str):
        return str(uri_str)
    try:
        parsed_uri = urlparse(uri_str)
        if parsed_uri.fragment:
            return unquote(parsed_uri.fragment)
        path_segments = [seg for seg in parsed_uri.path.split('/') if seg]
        if path_segments:
            return unquote(path_segments[-1])
        if parsed_uri.scheme and parsed_uri.opaque:
            opaque_parts = parsed_uri.opaque.split(':')
            return unquote(opaque_parts[-1]) if len(opaque_parts) > 1 else unquote(parsed_uri.opaque)
        return uri_str
    except Exception:
        # Fallback for any parsing error
        return uri_str

def _add_value_to_json_ld_object(obj: Dict[str, Any], key: str, value_to_add: Any):
    """
    Helper to add potentially multi-valued properties to a JSON-LD object.
    Ensures that values are added to a list, creating the list if it doesn't exist.
    Avoids adding duplicate dictionary objects or identical literal objects to the list.
    """
    if key not in obj:
        obj[key] = value_to_add
    else:
        if not isinstance(obj[key], list):
            obj[key] = [obj[key]] # Convert existing single value to a list
        
        # Check for duplicates before appending
        is_new_value_dict = isinstance(value_to_add, dict)
        
        should_add = True
        for existing_item in obj[key]:
            if is_new_value_dict and isinstance(existing_item, dict):
                if existing_item == value_to_add: # Deep comparison for dicts
                    should_add = False
                    break
            elif not is_new_value_dict and not isinstance(existing_item, dict):
                if existing_item == value_to_add: # Simple comparison for non-dicts
                    should_add = False
                    break
        
        if should_add:
            obj[key].append(value_to_add)


def _execute_sparql_query(endpoint_url: str, query: str, query_type_label: str, token: Optional[str] = None) -> Dict[str, Any]:
    """Executes a SPARQL query and returns parsed JSON or an error dictionary."""
    headers = {'Accept': 'application/sparql-results+json', 'Content-Type': 'application/x-www-form-urlencoded'}
    if token:
        headers['Authorization'] = f'Bearer {token}'
    
    payload = {'query': query}
    try:
        response = requests.post(endpoint_url, data=payload, headers=headers, timeout=60) # 60s timeout
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        details = e.response.text
        try: details = e.response.json()
        except json.JSONDecodeError: pass
        return {"error": f"HTTP error for {query_type_label}: {e.response.status_code} {e.response.reason}", "details": details, "query_type": query_type_label}
    except requests.exceptions.Timeout:
        return {"error": f"Request timed out for {query_type_label}", "query_type": query_type_label}
    except requests.exceptions.RequestException as e:
        return {"error": f"Request failed for {query_type_label}: {e}", "query_type": query_type_label}
    except json.JSONDecodeError as e_json:
        return {"error": f"Failed to decode JSON response for {query_type_label}: {e_json}", "details": response.text if 'response' in locals() else "No response text available", "query_type": query_type_label}

def _create_minimal_node_entry(node_id: str, nodes_dict: Dict[str, Any], json_ld_objects: Optional[Dict[str, Any]] = None, include_json_ld: bool = False):
    """Creates a minimal entry for a node if it doesn't exist in custom format and optionally in JSON-LD."""
    if node_id not in nodes_dict:
        node_type_guess = "uri" 
        if node_id.startswith("_:"):
            node_type_guess = "bnode"
        elif "://" not in node_id and not node_id.startswith("urn:"):
            node_type_guess = "literal_or_identifier" # Could be a simple ID not meant as a URI

        nodes_dict[node_id] = {
            "id": node_id,
            "label": _get_label_from_uri(node_id), # Default label derived from ID
            "type": node_type_guess, 
            "properties": {},
            "group": None # Initialize group as None
        }
    if include_json_ld and json_ld_objects is not None and node_id not in json_ld_objects:
        json_ld_objects[node_id] = {"@id": node_id}


# --- Core Logic Function ---
def query_sparql_to_graph_flexible(
    endpoint_url: str,
    node_query: str,
    node_id_var: str,
    node_label_var: Optional[str] = None,
    node_attributes_map: Optional[Dict[str, str]] = None,
    node_group_id_var: Optional[str] = None,
    edge_query: str,
    edge_source_var: str,
    edge_target_var: str,
    edge_predicate_var: str,
    group_query: Optional[str] = None,
    group_id_var: Optional[str] = None,
    group_label_var: Optional[str] = None,
    bearer_token: Optional[str] = None,
    include_json_ld: bool = False,
    json_ld_group_predicate_uri: Optional[str] = None 
) -> Dict[str, Any]:
    """
    Queries a SPARQL endpoint using user-defined queries for nodes, edges, and groups.
    Transforms results into a custom graph structure and/or JSON-LD.
    All query parameters, endpoint, and token are provided by the caller.
    """
    nodes_dict: Dict[str, Any] = {}
    edges_list: List[Dict[str, Any]] = []
    groups_dict: Dict[str, Any] = {}
    
    json_ld_objects: Optional[Dict[str, Any]] = {} if include_json_ld else None
    json_ld_context: Optional[Dict[str, Any]] = None

    if include_json_ld:
        json_ld_context = {
            "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
            "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
            "xsd": "http://www.w3.org/2001/XMLSchema#",
            "owl": "http://www.w3.org/2002/07/owl#",
            # Common prefixes. User-specific prefixes from queries are not automatically added here,
            # but full URIs are used in the @graph, which is valid JSON-LD.
        }
        if node_attributes_map: # Add attribute predicates to context for brevity if possible
            for pred_uri in node_attributes_map.values():
                 short_name = _get_label_from_uri(pred_uri).replace(" ", "_").lower()
                 if short_name and (short_name not in json_ld_context or json_ld_context[short_name] == pred_uri):
                    json_ld_context[short_name] = pred_uri
        
        if json_ld_group_predicate_uri: # Add group predicate to context if provided
            short_name = _get_label_from_uri(json_ld_group_predicate_uri).replace(" ", "_").lower()
            if short_name and (short_name not in json_ld_context or json_ld_context[short_name] == json_ld_group_predicate_uri):
                json_ld_context[short_name] = json_ld_group_predicate_uri

    # 1. Process Node Query
    node_results_json = _execute_sparql_query(endpoint_url, node_query, "Node Query", bearer_token)
    if "error" in node_results_json: return node_results_json

    node_query_vars = node_results_json.get('head', {}).get('vars', [])
    if node_id_var not in node_query_vars:
        return {"error": f"Node ID variable '{node_id_var}' not found in Node Query results variables: {node_query_vars}."}

    discovered_group_ids_from_nodes = set()

    for binding in node_results_json.get('results', {}).get('bindings', []):
        if node_id_var not in binding: continue # Skip if node ID is missing for this binding
        
        node_id = binding[node_id_var]['value']
        node_id_type = binding[node_id_var]['type'] # 'uri' or 'bnode'

        if node_id not in nodes_dict: # Initialize node if not seen before
            nodes_dict[node_id] = {"id": node_id, "type": node_id_type, "properties": {}, "group": None}
        
        current_node_obj = nodes_dict[node_id]
        
        # Determine and set label for the custom graph output
        node_label_for_custom_graph = _get_label_from_uri(node_id) # Default label is derived from ID
        if node_label_var and node_label_var in binding:
            label_binding = binding[node_label_var]
            if label_binding['type'] == 'literal': 
                node_label_for_custom_graph = label_binding['value']
            elif label_binding['type'] == 'uri': # If label var itself is a URI, derive label from it
                node_label_for_custom_graph = _get_label_from_uri(label_binding['value'])
        current_node_obj['label'] = node_label_for_custom_graph

        # Process attributes for custom graph output
        if node_attributes_map:
            for attr_var, pred_uri in node_attributes_map.items():
                if attr_var in binding:
                    attr_binding = binding[attr_var]
                    prop_val_obj = {"value": attr_binding['value']}
                    if 'datatype' in attr_binding: prop_val_obj['datatype'] = attr_binding['datatype']
                    if 'xml:lang' in attr_binding: prop_val_obj['lang'] = attr_binding['xml:lang']
                    current_node_obj['properties'].setdefault(pred_uri, []).append(prop_val_obj)

        # Process group assignment for custom graph output
        if node_group_id_var and node_group_id_var in binding:
            group_id_val = binding[node_group_id_var]['value']
            current_node_obj['group'] = group_id_val
            discovered_group_ids_from_nodes.add(group_id_val)

        # JSON-LD processing for the current node
        if include_json_ld and json_ld_objects is not None and json_ld_context is not None:
            json_ld_node = json_ld_objects.setdefault(node_id, {"@id": node_id})
            
            # Add rdfs:label to JSON-LD node (using the same label determined for custom graph)
            # This assumes the label is a literal. If node_label_var could point to a URI to be used as label object,
            # more complex handling for JSON-LD label would be needed.
            label_value_for_jsonld = current_node_obj['label']
            json_ld_label_obj = {"@value": str(label_value_for_jsonld)}
            # Attempt to find lang tag for label if node_label_var was used and had one
            if node_label_var and node_label_var in binding and 'xml:lang' in binding[node_label_var]:
                json_ld_label_obj["@language"] = binding[node_label_var]['xml:lang']
            _add_value_to_json_ld_object(json_ld_node, RDFS_LABEL_URI, json_ld_label_obj)

            # Add attributes to JSON-LD node
            if node_attributes_map:
                for attr_var, pred_uri in node_attributes_map.items():
                    if attr_var in binding:
                        attr_binding = binding[attr_var]
                        ld_literal = {"@value": attr_binding['value']}
                        if 'datatype' in attr_binding: ld_literal["@type"] = attr_binding['datatype']
                        if 'xml:lang' in attr_binding: ld_literal["@language"] = attr_binding['xml:lang']
                        _add_value_to_json_ld_object(json_ld_node, pred_uri, ld_literal)

    # 2. Process Group Query (if provided)
    if group_query and group_id_var and group_label_var:
        group_results_json = _execute_sparql_query(endpoint_url, group_query, "Group Query", bearer_token)
        if "error" in group_results_json: return group_results_json
        group_query_vars = group_results_json.get('head', {}).get('vars', [])
        if not (group_id_var in group_query_vars and group_label_var in group_query_vars):
            return {"error": f"Group ID var '{group_id_var}' or Group Label var '{group_label_var}' not found in Group Query results."}

        for binding in group_results_json.get('results', {}).get('bindings', []):
            if group_id_var not in binding or group_label_var not in binding : continue
            gid = binding[group_id_var]['value']
            glabel_val_binding = binding[group_label_var]
            
            actual_glabel = glabel_val_binding['value']
            if glabel_val_binding['type'] == 'uri': # If group label var is a URI, derive label
                actual_glabel = _get_label_from_uri(glabel_val_binding['value'])

            groups_dict[gid] = {"id": gid, "label": actual_glabel}
            if include_json_ld and json_ld_objects is not None and json_ld_context is not None:
                json_ld_group = json_ld_objects.setdefault(gid, {"@id": gid})
                json_ld_group_label_obj = {"@value": str(actual_glabel)}
                if 'xml:lang' in glabel_val_binding: # If original group label had lang
                     json_ld_group_label_obj["@language"] = glabel_val_binding['xml:lang']
                _add_value_to_json_ld_object(json_ld_group, RDFS_LABEL_URI, json_ld_group_label_obj)
    else: # Create groups from discovered_group_ids_from_nodes if no explicit group query
        for gid in discovered_group_ids_from_nodes:
            if gid not in groups_dict:
                default_group_label = _get_label_from_uri(gid)
                groups_dict[gid] = {"id": gid, "label": default_group_label}
                if include_json_ld and json_ld_objects is not None and json_ld_context is not None:
                    json_ld_group = json_ld_objects.setdefault(gid, {"@id": gid})
                    _add_value_to_json_ld_object(json_ld_group, RDFS_LABEL_URI, {"@value": str(default_group_label)})
    
    # Link nodes to groups in JSON-LD (only if json_ld_group_predicate_uri is provided by user)
    if include_json_ld and json_ld_objects is not None and node_group_id_var and json_ld_group_predicate_uri:
        for node_id_val, node_data_custom_graph in nodes_dict.items():
            assigned_group_id = node_data_custom_graph.get("group")
            if assigned_group_id:
                json_ld_node_to_update = json_ld_objects.get(node_id_val)
                if json_ld_node_to_update: # Node should exist in json_ld_objects
                    # Ensure group entity itself exists in JSON-LD graph (minimal entry)
                    _create_minimal_node_entry(assigned_group_id, {}, json_ld_objects, include_json_ld)
                    _add_value_to_json_ld_object(json_ld_node_to_update, json_ld_group_predicate_uri, {"@id": assigned_group_id})

    # 3. Process Edge Query
    edge_results_json = _execute_sparql_query(endpoint_url, edge_query, "Edge Query", bearer_token)
    if "error" in edge_results_json: return edge_results_json
    edge_query_vars = edge_results_json.get('head', {}).get('vars', [])
    required_edge_vars = [edge_source_var, edge_target_var, edge_predicate_var]
    if not all(v in edge_query_vars for v in required_edge_vars):
        return {"error": f"One or more edge variables ({', '.join(required_edge_vars)}) not found in Edge Query results."}

    for binding in edge_results_json.get('results', {}).get('bindings', []):
        if not all(v in binding for v in required_edge_vars): continue # Skip if essential edge vars missing
        source_id = binding[edge_source_var]['value']
        target_id = binding[edge_target_var]['value']
        predicate_uri = binding[edge_predicate_var]['value']

        # Ensure source and target nodes exist in our dictionaries (custom graph and JSON-LD if active)
        # This creates minimal entries if they weren't defined by the node_query
        _create_minimal_node_entry(source_id, nodes_dict, json_ld_objects, include_json_ld)
        _create_minimal_node_entry(target_id, nodes_dict, json_ld_objects, include_json_ld)

        edges_list.append({
            "id": str(uuid.uuid4()), # Unique ID for the edge in custom format
            "source": source_id,
            "target": target_id,
            "label": _get_label_from_uri(predicate_uri), # Label for the edge predicate
            "uri": predicate_uri # Full URI of the edge predicate
        })

        # Add edge to JSON-LD (as a property on the source node pointing to target node)
        if include_json_ld and json_ld_objects is not None and json_ld_context is not None:
            json_ld_source_node = json_ld_objects.get(source_id) # Should exist due to _create_minimal_node_entry
            if json_ld_source_node:
                 _add_value_to_json_ld_object(json_ld_source_node, predicate_uri, {"@id": target_id})

    # 4. Assemble Final Output
    output = {
        "nodes": list(nodes_dict.values()),
        "edges": edges_list,
        "groups": list(groups_dict.values())
    }
    if include_json_ld and json_ld_objects is not None and json_ld_context is not None:
        output["json_ld"] = {
            "@context": json_ld_context,
            "@graph": list(json_ld_objects.values())
        }
    return output


# --- FastAPI Pydantic Models for Request Body ---
class SparqlQueryInput(BaseModel):
    endpoint_url: str = Field(..., example="https://dbpedia.org/sparql", description="The URL of the SPARQL endpoint (user-provided).")
    
    node_query: str = Field(..., description="User-provided SPARQL query to define nodes.")
    node_id_var: str = Field(..., description="Variable name in node_query for node ID.")
    node_label_var: Optional[str] = Field(None, description="Optional: Variable name in node_query for node label.")
    node_attributes_map: Optional[Dict[str, str]] = Field(None, description="Optional: Map of query variable names to predicate URIs for node attributes.")
    node_group_id_var: Optional[str] = Field(None, description="Optional: Variable in node_query for assigning a group ID to the node.")

    edge_query: str = Field(..., description="User-provided SPARQL query to define edges.")
    edge_source_var: str = Field(..., description="Variable name in edge_query for edge source ID.")
    edge_target_var: str = Field(..., description="Variable name in edge_query for edge target ID.")
    edge_predicate_var: str = Field(..., description="Variable name in edge_query for edge predicate URI.")

    group_query: Optional[str] = Field(None, description="Optional: User-provided SPARQL query to define groups explicitly.")
    group_id_var: Optional[str] = Field(None, description="Variable name in group_query for group ID (if group_query is used).")
    group_label_var: Optional[str] = Field(None, description="Variable name in group_query for group label (if group_query is used).")
    
    bearer_token: Optional[str] = Field(None, description="Optional: User-provided Bearer token for authentication.")
    include_json_ld: bool = Field(False, description="Whether to include JSON-LD output.")
    json_ld_group_predicate_uri: Optional[str] = Field(None, 
                                                       example="http://example.org/customGroupProp", 
                                                       description="Optional: Predicate URI for group membership in JSON-LD. If provided and node_group_id_var is used, this predicate will link nodes to their group IDs in the JSON-LD output.")

    # The 'json_schema_extra' provides an EXAMPLE payload for API documentation (e.g., Swagger UI).
    # It does NOT define hardcoded default values for the application's runtime if fields are required.
    class Config:
        json_schema_extra = {
            "example": {
                "endpoint_url": "https://dbpedia.org/sparql",
                "node_query": "PREFIX dbo: <http://dbpedia.org/ontology/> PREFIX dbr: <http://dbpedia.org/resource/> PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?person ?personName ?birthDate (STRAFTER(STR(?person), \"resource/\") AS ?derivedGroup) WHERE { VALUES ?person { dbr:Tim_Berners-Lee dbr:Vinton_Cerf } ?person rdfs:label ?personName . OPTIONAL { ?person dbo:birthDate ?birthDate . } FILTER(LANG(?personName) = \"en\") } LIMIT 10",
                "node_id_var": "person",
                "node_label_var": "personName",
                "node_attributes_map": {"birthDate": "http://dbpedia.org/ontology/birthDate"},
                "node_group_id_var": "derivedGroup",
                "edge_query": "PREFIX dbr: <http://dbpedia.org/resource/> PREFIX foaf: <http://xmlns.com/foaf/0.1/> SELECT ?person1 ?relation ?person2 WHERE { VALUES (?person1 ?relation ?person2) { (dbr:Tim_Berners-Lee foaf:knows dbr:Vinton_Cerf) (dbr:Vinton_Cerf foaf:knows dbr:Tim_Berners-Lee) } }",
                "edge_source_var": "person1",
                "edge_target_var": "person2",
                "edge_predicate_var": "relation",
                "group_query": None, # Example: "PREFIX ex: <http://example.org/group/> SELECT ?gid ?glabel WHERE { VALUES (?gid ?glabel) { (ex:ComputerScientists \"Computer Scientists\"@en) } }",
                "group_id_var": None, # Example: "gid",
                "group_label_var": None, # Example: "glabel",
                "bearer_token": None, # Example: "YOUR_ACTUAL_TOKEN"
                "include_json_ld": True,
                "json_ld_group_predicate_uri": "http://example.org/belongsToCategory" 
            }
        }

# --- FastAPI App Instance ---
app = FastAPI(
    title="SPARQL to Graph API",
    description="An API to query a SPARQL endpoint using user-defined flexible node, edge, and group definitions. Returns graph data in custom format and/or JSON-LD. All endpoint, token, and query information is provided by the user in the request.",
    version="1.0.2" # Incremented version
)

# --- API Endpoint ---
@app.post("/sparql-to-graph/", summary="Convert SPARQL results to Graph Data", response_model_exclude_none=True)
async def convert_sparql_to_graph(query_input: SparqlQueryInput = Body(...)):
    """
    Accepts SPARQL queries and configurations (all user-provided) to fetch 
    and structure graph data from the specified SPARQL endpoint.
    """
    result = query_sparql_to_graph_flexible(
        endpoint_url=query_input.endpoint_url,
        node_query=query_input.node_query,
        node_id_var=query_input.node_id_var,
        node_label_var=query_input.node_label_var,
        node_attributes_map=query_input.node_attributes_map,
        node_group_id_var=query_input.node_group_id_var,
        edge_query=query_input.edge_query,
        edge_source_var=query_input.edge_source_var,
        edge_target_var=query_input.edge_target_var,
        edge_predicate_var=query_input.edge_predicate_var,
        group_query=query_input.group_query,
        group_id_var=query_input.group_id_var,
        group_label_var=query_input.group_label_var,
        bearer_token=query_input.bearer_token,
        include_json_ld=query_input.include_json_ld,
        json_ld_group_predicate_uri=query_input.json_ld_group_predicate_uri
    )

    if "error" in result:
        status_code = 400 # Default for client-side errors (e.g., bad query var name)
        if "HTTP error" in result.get("error", ""): # Check if error string indicates an HTTP issue
            # Attempt to parse status code from error message if it's from upstream
            try:
                # Example error: "HTTP error for Node Query: 500 Internal Server Error"
                parts = result["error"].split(":")
                if len(parts) > 1:
                    status_part = parts[1].strip().split(" ")[0]
                    if status_part.isdigit():
                        parsed_status = int(status_part)
                        if 400 <= parsed_status < 600: # Valid HTTP status codes
                            status_code = parsed_status 
            except Exception:
                pass # Keep default status_code if parsing fails

            if status_code == 401 or status_code == 403: # Specific upstream auth errors
                 raise HTTPException(status_code=status_code, detail=result)
            elif status_code >= 500: # Upstream server error
                 raise HTTPException(status_code=502, detail={"message": "Error from upstream SPARQL endpoint.", "original_error": result}) # Bad Gateway
            else: # Other upstream client errors (e.g. 400, 404 from SPARQL endpoint)
                 raise HTTPException(status_code=status_code, detail=result) # Reflect upstream client error
        
        # For errors generated by this app's logic (e.g., variable not found in query results)
        raise HTTPException(status_code=400, detail=result) # Bad Request
    return result

# To run this FastAPI app (save as main.py or similar):
# 1. Install FastAPI and Uvicorn:
#    pip install fastapi uvicorn[standard] requests
#
# 2. Run the server from your terminal:
#    uvicorn main:app --reload
#
# 3. Access the API docs (Swagger UI) at: http://127.0.0.1:8000/docs
#    Or ReDoc at: http://127.0.0.1:8000/redoc
