#!/usr/bin/env python3
"""
Ontology Schema Extractor
Extracts the schema (classes, subclasses, properties) from a TTL file
and saves it as a new TTL file without instance data.
"""

import argparse
import sys
from pathlib import Path
from rdflib import Graph, Namespace, RDF, RDFS, OWL, URIRef
from rdflib.namespace import XSD


def extract_ontology_schema(input_file, output_file):
    """
    Extract ontology schema from a TTL file and save it to a new TTL file.
    
    Args:
        input_file (str): Path to input TTL file
        output_file (str): Path to output TTL file
    """
    try:
        # Load the input TTL file
        print(f"Loading ontology from: {input_file}")
        input_graph = Graph()
        input_graph.parse(input_file, format="turtle")
        print(f"Loaded {len(input_graph)} triples")
        
        # Create a new graph for the schema
        schema_graph = Graph()
        
        # Copy namespace prefixes from input graph
        for prefix, namespace in input_graph.namespaces():
            schema_graph.bind(prefix, namespace)
        
        # Ensure common ontology namespaces are bound
        schema_graph.bind("rdf", RDF)
        schema_graph.bind("rdfs", RDFS)
        schema_graph.bind("owl", OWL)
        schema_graph.bind("xsd", XSD)
        
        # Extract schema elements
        schema_triples = 0
        
        # 1. Extract all class definitions
        print("Extracting classes...")
        class_queries = [
            (None, RDF.type, RDFS.Class),
            (None, RDF.type, OWL.Class),
        ]
        
        for subject, predicate, obj in class_queries:
            for triple in input_graph.triples((subject, predicate, obj)):
                schema_graph.add(triple)
                schema_triples += 1
        
        # 2. Extract subclass relationships
        print("Extracting subclass relationships...")
        for triple in input_graph.triples((None, RDFS.subClassOf, None)):
            schema_graph.add(triple)
            schema_triples += 1
        
        # 3. Extract object properties
        print("Extracting object properties...")
        object_property_queries = [
            (None, RDF.type, OWL.ObjectProperty),
            (None, RDF.type, RDF.Property),  # Some ontologies use rdf:Property
        ]
        
        for subject, predicate, obj in object_property_queries:
            for triple in input_graph.triples((subject, predicate, obj)):
                schema_graph.add(triple)
                schema_triples += 1
        
        # 4. Extract data properties
        print("Extracting data properties...")
        for triple in input_graph.triples((None, RDF.type, OWL.DatatypeProperty)):
            schema_graph.add(triple)
            schema_triples += 1
        
        # 5. Extract property characteristics and restrictions
        print("Extracting property characteristics...")
        property_characteristics = [
            RDFS.domain, RDFS.range, 
            OWL.inverseOf, OWL.equivalentProperty,
            OWL.propertyDisjointWith, OWL.propertyChainAxiom,
            RDF.type  # For functional, transitive, etc.
        ]
        
        # Get all properties first
        properties = set()
        for triple in schema_graph.triples((None, RDF.type, OWL.ObjectProperty)):
            properties.add(triple[0])
        for triple in schema_graph.triples((None, RDF.type, OWL.DatatypeProperty)):
            properties.add(triple[0])
        for triple in schema_graph.triples((None, RDF.type, RDF.Property)):
            properties.add(triple[0])
        
        # Extract characteristics for these properties
        for prop in properties:
            for characteristic in property_characteristics:
                for triple in input_graph.triples((prop, characteristic, None)):
                    schema_graph.add(triple)
                    schema_triples += 1
        
        # 6. Extract class characteristics and restrictions
        print("Extracting class characteristics...")
        
        # Get all classes
        classes = set()
        for triple in schema_graph.triples((None, RDF.type, RDFS.Class)):
            classes.add(triple[0])
        for triple in schema_graph.triples((None, RDF.type, OWL.Class)):
            classes.add(triple[0])
        
        class_characteristics = [
            RDFS.label, RDFS.comment, 
            OWL.equivalentClass, OWL.disjointWith,
            RDFS.subClassOf  # Additional subclass relationships
        ]
        
        for cls in classes:
            for characteristic in class_characteristics:
                for triple in input_graph.triples((cls, characteristic, None)):
                    schema_graph.add(triple)
                    schema_triples += 1
        
        # 7. Extract OWL restrictions and complex class expressions
        print("Extracting OWL restrictions...")
        restriction_predicates = [
            OWL.onProperty, OWL.someValuesFrom, OWL.allValuesFrom,
            OWL.hasValue, OWL.cardinality, OWL.minCardinality, OWL.maxCardinality,
            OWL.qualifiedCardinality, OWL.minQualifiedCardinality, OWL.maxQualifiedCardinality,
            OWL.onClass, OWL.onDataRange
        ]
        
        # Find all restrictions
        restrictions = set()
        for triple in input_graph.triples((None, RDF.type, OWL.Restriction)):
            restrictions.add(triple[0])
            schema_graph.add(triple)
            schema_triples += 1
        
        # Extract restriction details
        for restriction in restrictions:
            for predicate in restriction_predicates:
                for triple in input_graph.triples((restriction, predicate, None)):
                    schema_graph.add(triple)
                    schema_triples += 1
        
        # 8. Extract union, intersection, and complement class expressions
        print("Extracting complex class expressions...")
        complex_class_predicates = [
            OWL.unionOf, OWL.intersectionOf, OWL.complementOf, OWL.oneOf
        ]
        
        for predicate in complex_class_predicates:
            for triple in input_graph.triples((None, predicate, None)):
                schema_graph.add(triple)
                schema_triples += 1
        
        # 9. Extract annotation properties and their usage on schema elements
        print("Extracting annotation properties...")
        for triple in input_graph.triples((None, RDF.type, OWL.AnnotationProperty)):
            schema_graph.add(triple)
            schema_triples += 1
        
        # Extract annotations for classes and properties
        all_schema_subjects = set()
        for s, p, o in schema_graph:
            all_schema_subjects.add(s)
        
        annotation_properties = set()
        for triple in input_graph.triples((None, RDF.type, OWL.AnnotationProperty)):
            annotation_properties.add(triple[0])
        
        # Add common annotation properties
        common_annotations = [RDFS.label, RDFS.comment]
        annotation_properties.update(common_annotations)
        
        for subject in all_schema_subjects:
            if isinstance(subject, URIRef):
                for annotation_prop in annotation_properties:
                    for triple in input_graph.triples((subject, annotation_prop, None)):
                        schema_graph.add(triple)
                        schema_triples += 1
        
        # 10. Extract ontology metadata
        print("Extracting ontology metadata...")
        for triple in input_graph.triples((None, RDF.type, OWL.Ontology)):
            schema_graph.add(triple)
            schema_triples += 1
            
            # Extract ontology properties
            ontology = triple[0]
            ontology_properties = [
                OWL.versionInfo, OWL.imports, OWL.versionIRI,
                RDFS.label, RDFS.comment
            ]
            
            for prop in ontology_properties:
                for ont_triple in input_graph.triples((ontology, prop, None)):
                    schema_graph.add(ont_triple)
                    schema_triples += 1
        
        # Save the schema graph
        print(f"Saving schema with {schema_triples} triples to: {output_file}")
        schema_graph.serialize(destination=output_file, format="turtle")
        
        # Print summary
        print("\n" + "="*50)
        print("EXTRACTION SUMMARY")
        print("="*50)
        print(f"Input file: {input_file}")
        print(f"Output file: {output_file}")
        print(f"Original triples: {len(input_graph)}")
        print(f"Schema triples: {len(schema_graph)}")
        
        # Count specific elements
        classes = len(list(schema_graph.triples((None, RDF.type, RDFS.Class)))) + \
                 len(list(schema_graph.triples((None, RDF.type, OWL.Class))))
        subclass_relations = len(list(schema_graph.triples((None, RDFS.subClassOf, None))))
        object_properties = len(list(schema_graph.triples((None, RDF.type, OWL.ObjectProperty))))
        data_properties = len(list(schema_graph.triples((None, RDF.type, OWL.DatatypeProperty))))
        
        print(f"Classes extracted: {classes}")
        print(f"Subclass relationships: {subclass_relations}")
        print(f"Object properties: {object_properties}")
        print(f"Data properties: {data_properties}")
        
        print("\nSchema extraction completed successfully!")
        
    except Exception as e:
        print(f"Error processing ontology: {str(e)}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="Extract ontology schema from TTL file")
    parser.add_argument("input_file", help="Input TTL file path")
    parser.add_argument("-o", "--output", 
                       help="Output TTL file path (default: input_schema.ttl)")
    
    args = parser.parse_args()
    
    # Validate input file
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: Input file '{args.input_file}' does not exist")
        sys.exit(1)
    
    # Set output file
    if args.output:
        output_file = args.output
    else:
        output_file = input_path.stem + "_schema.ttl"
    
    # Extract schema
    extract_ontology_schema(args.input_file, output_file)


if __name__ == "__main__":
    main()
