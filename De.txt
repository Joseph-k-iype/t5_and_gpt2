"""
Pydantic models for the Enhanced RDF Knowledge Graph Chatbot API.
"""

from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict, validator, field_validator

class EntityType(str, Enum):
    """Enumeration of supported entity types."""
    CLASS = "Class"
    OBJECT_PROPERTY = "ObjectProperty"
    DATATYPE_PROPERTY = "DatatypeProperty"
    INDIVIDUAL = "Individual"
    INSTANCE = "Instance"

class QueryIntent(str, Enum):
    """Enumeration of query intent classifications."""
    DEFINITION = "definition"
    RELATIONSHIP = "relationship"
    PROPERTY = "property"
    LISTING = "listing"
    COMPARISON = "comparison"
    HIERARCHICAL = "hierarchical"
    EXISTENCE = "existence"
    COUNT = "count"
    GENERAL = "general"

class ProcessingMethod(str, Enum):
    """Enumeration of query processing methods."""
    VECTOR_SEARCH = "vector_search"
    SPARQL_CHAIN = "sparql_chain"
    DIRECT_SPARQL = "direct_sparql"

# Base models
class BaseResponse(BaseModel):
    """Base response model with common fields."""
    model_config = ConfigDict(extra="forbid")
    
    success: bool = Field(..., description="Whether the operation was successful")
    message: Optional[str] = Field(None, description="Optional message")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")
    request_id: Optional[str] = Field(None, description="Request ID for tracking")

class PaginationParams(BaseModel):
    """Pagination parameters."""
    skip: int = Field(0, ge=0, description="Number of items to skip")
    limit: int = Field(100, ge=1, le=1000, description="Number of items to return")

class FilterParams(BaseModel):
    """Filter parameters for search operations."""
    entity_types: Optional[List[EntityType]] = Field(None, description="Filter by entity types")
    min_score: float = Field(0.0, ge=0.0, le=1.0, description="Minimum similarity score")
    include_metadata: bool = Field(True, description="Include entity metadata")
    namespaces: Optional[List[str]] = Field(None, description="Filter by namespaces")

# Chat-related models
class ChatRequest(BaseModel):
    """Request model for chat endpoint."""
    model_config = ConfigDict(extra="forbid")
    
    message: str = Field(..., min_length=1, max_length=10000, description="User's question or message")
    include_context: bool = Field(False, description="Include detailed context in response")
    use_sparql_chain: bool = Field(True, description="Use GraphSparqlQAChain for processing")
    max_entities: int = Field(10, ge=1, le=50, description="Maximum number of entities to retrieve")
    preferred_methods: Optional[List[ProcessingMethod]] = Field(None, description="Preferred processing methods")
    
    @field_validator('message')
    @classmethod
    def validate_message(cls, v: str) -> str:
        """Validate and clean the message."""
        cleaned = v.strip()
        if not cleaned:
            raise ValueError("Message cannot be empty or only whitespace")
        return cleaned

class QueryClassification(BaseModel):
    """Query classification details."""
    primary_intent: QueryIntent = Field(..., description="Primary query intent")
    secondary_intent: Optional[QueryIntent] = Field(None, description="Secondary query intent")
    confidence: float = Field(..., ge=0.0, description="Classification confidence score")
    all_scores: Dict[str, float] = Field(..., description="Scores for all intent categories")

class RelatedEntity(BaseModel):
    """Related entity information."""
    uri: str = Field(..., description="Entity URI")
    local_name: str = Field(..., description="Local name")
    relationship: str = Field(..., description="Relationship type")
    relationship_uri: str = Field(..., description="Relationship URI")
    depth: int = Field(..., ge=0, description="Relationship depth")
    direction: str = Field(..., description="Relationship direction (incoming/outgoing)")

class PropertyInfo(BaseModel):
    """Property information."""
    uri: str = Field(..., description="Property URI")
    local_name: str = Field(..., description="Property local name")
    type: str = Field(..., description="Property type")
    ranges: Optional[List[str]] = Field(None, description="Property ranges")

class SparqlResult(BaseModel):
    """SPARQL query result."""
    query_type: str = Field(..., description="Type of SPARQL query")
    sparql_query: str = Field(..., description="The SPARQL query string")
    results: List[Dict[str, Any]] = Field(..., description="Query results")
    description: str = Field(..., description="Query description")
    execution_time: Optional[float] = Field(None, description="Query execution time in seconds")

class ChatResponse(BaseModel):
    """Response model for chat endpoint."""
    response: str = Field(..., description="Generated response")
    user_message: str = Field(..., description="Original user message")
    query_classification: Optional[QueryClassification] = Field(None, description="Query classification details")
    key_concepts: Optional[List[str]] = Field(None, description="Extracted key concepts")
    processing_methods: Optional[List[ProcessingMethod]] = Field(None, description="Methods used for processing")
    num_relevant_entities: Optional[int] = Field(None, description="Number of relevant entities found")
    success: bool = Field(..., description="Whether the request was successful")
    error: Optional[str] = Field(None, description="Error message if any")
    
    # Optional detailed context (when include_context=True)
    vector_search_results: Optional[List[Dict[str, Any]]] = Field(None, description="Vector search results")
    sparql_chain_result: Optional[Dict[str, Any]] = Field(None, description="SPARQL chain result")
    direct_sparql_results: Optional[List[SparqlResult]] = Field(None, description="Direct SPARQL results")
    context_used: Optional[str] = Field(None, description="Context provided to LLM")

# Entity-related models
class EntityMetadata(BaseModel):
    """Entity metadata information."""
    entity_type: str = Field(..., description="OWL entity type")
    hierarchy_level: Optional[int] = Field(None, description="Hierarchy level for classes")
    property_type: Optional[str] = Field(None, description="Property type for properties")
    class_types: Optional[List[str]] = Field(None, description="Class types for individuals")

class EntityBase(BaseModel):
    """Base entity model."""
    uri: str = Field(..., description="Entity URI")
    type: EntityType = Field(..., description="Entity type")
    local_name: str = Field(..., description="Entity local name")
    namespace: Optional[str] = Field(None, description="Entity namespace")

class EntityDetails(EntityBase):
    """Detailed entity information."""
    labels: Optional[List[str]] = Field(None, description="Entity labels")
    comments: Optional[List[str]] = Field(None, description="Entity comments")
    descriptions: Optional[List[str]] = Field(None, description="Entity descriptions")
    text_content: Optional[str] = Field(None, description="Full text content for search")
    metadata: Optional[EntityMetadata] = Field(None, description="Entity metadata")
    
    # Type-specific fields
    superclasses: Optional[List[str]] = Field(None, description="Superclasses (for classes)")
    subclasses: Optional[List[str]] = Field(None, description="Subclasses (for classes)")
    domains: Optional[List[str]] = Field(None, description="Property domains")
    ranges: Optional[List[str]] = Field(None, description="Property ranges")
    types: Optional[List[str]] = Field(None, description="Individual types")
    property_values: Optional[Dict[str, List[str]]] = Field(None, description="Property values")
    
    # Related information
    related_entities: Optional[List[RelatedEntity]] = Field(None, description="Related entities")
    related_properties: Optional[List[PropertyInfo]] = Field(None, description="Related properties")
    instances: Optional[List[Dict[str, str]]] = Field(None, description="Class instances")
    sibling_classes: Optional[List[Dict[str, str]]] = Field(None, description="Sibling classes")
    usage_examples: Optional[List[Dict[str, str]]] = Field(None, description="Property usage examples")

class EntitySearchResult(EntityBase):
    """Entity search result with score."""
    similarity_score: Optional[float] = Field(None, description="Similarity score")
    search_score: Optional[float] = Field(None, description="Search score")
    search_type: Optional[str] = Field(None, description="Type of search performed")
    labels: Optional[List[str]] = Field(None, description="Entity labels")
    comments: Optional[List[str]] = Field(None, description="Entity comments")

# Search-related models
class SearchRequest(BaseModel):
    """Request model for entity search."""
    model_config = ConfigDict(extra="forbid")
    
    query: str = Field(..., min_length=1, max_length=1000, description="Search query")
    top_k: int = Field(10, ge=1, le=100, description="Number of results to return")
    entity_types: Optional[List[EntityType]] = Field(None, description="Filter by entity types")
    min_score: float = Field(0.5, ge=0.0, le=1.0, description="Minimum similarity score")
    include_metadata: bool = Field(True, description="Include entity metadata")
    search_method: Optional[str] = Field("hybrid", description="Search method (vector, text, hybrid)")

class SearchResponse(BaseModel):
    """Response model for entity search."""
    results: List[EntitySearchResult] = Field(..., description="Search results")
    total: int = Field(..., description="Total number of results")
    query: str = Field(..., description="Original search query")
    search_method: str = Field(..., description="Search method used")
    execution_time: Optional[float] = Field(None, description="Search execution time")

# SPARQL-related models
class SparqlRequest(BaseModel):
    """Request model for SPARQL queries."""
    model_config = ConfigDict(extra="forbid")
    
    query: str = Field(..., min_length=1, max_length=50000, description="SPARQL query")
    limit: Optional[int] = Field(1000, ge=1, le=10000, description="Result limit")
    timeout: Optional[float] = Field(30.0, ge=1.0, le=300.0, description="Query timeout in seconds")
    
    @field_validator('query')
    @classmethod
    def validate_sparql_query(cls, v: str) -> str:
        """Basic SPARQL query validation."""
        cleaned = v.strip()
        if not cleaned:
            raise ValueError("SPARQL query cannot be empty")
        
        # Check for dangerous operations
        dangerous_ops = ["DELETE", "INSERT", "DROP", "CREATE", "CLEAR", "COPY", "MOVE"]
        query_upper = cleaned.upper()
        
        for op in dangerous_ops:
            if op in query_upper:
                raise ValueError(f"SPARQL {op} operations are not allowed")
        
        return cleaned

class SparqlResponse(BaseModel):
    """Response model for SPARQL queries."""
    query: str = Field(..., description="Original SPARQL query")
    results: List[Dict[str, Any]] = Field(..., description="Query results")
    result_count: int = Field(..., description="Number of results")
    execution_time: Optional[float] = Field(None, description="Query execution time")
    variables: Optional[List[str]] = Field(None, description="Query variables")

class NaturalLanguageToSparqlRequest(BaseModel):
    """Request model for natural language to SPARQL conversion."""
    model_config = ConfigDict(extra="forbid")
    
    question: str = Field(..., min_length=1, max_length=1000, description="Natural language question")
    include_execution: bool = Field(True, description="Execute the generated SPARQL query")
    explain_query: bool = Field(False, description="Include query explanation")

class NaturalLanguageToSparqlResponse(BaseModel):
    """Response model for natural language to SPARQL conversion."""
    question: str = Field(..., description="Original natural language question")
    sparql_query: str = Field(..., description="Generated SPARQL query")
    answer: Optional[str] = Field(None, description="Natural language answer")
    explanation: Optional[str] = Field(None, description="Query explanation")
    execution_results: Optional[List[Dict[str, Any]]] = Field(None, description="Query execution results")
    success: bool = Field(..., description="Whether the conversion was successful")
    error: Optional[str] = Field(None, description="Error message if any")

# Statistics and monitoring models
class EntityTypeStats(BaseModel):
    """Statistics for entity types."""
    type: EntityType = Field(..., description="Entity type")
    count: int = Field(..., description="Number of entities")
    percentage: float = Field(..., description="Percentage of total entities")

class VectorStoreStats(BaseModel):
    """Vector store statistics."""
    total_entities: int = Field(..., description="Total number of indexed entities")
    index_size_bytes: int = Field(..., description="Index size in bytes")
    index_size_mb: float = Field(..., description="Index size in MB")
    embedding_model: str = Field(..., description="Embedding model used")
    embedding_dimensions: int = Field(..., description="Embedding vector dimensions")
    entity_type_distribution: Dict[str, int] = Field(..., description="Distribution by entity type")
    elasticsearch_hosts: List[str] = Field(..., description="Elasticsearch hosts")

class RdfGraphStats(BaseModel):
    """RDF graph statistics."""
    total_triples: int = Field(..., description="Total number of RDF triples")
    classes: int = Field(..., description="Number of classes")
    properties: int = Field(..., description="Number of properties")
    individuals: int = Field(..., description="Number of individuals")
    namespaces: List[str] = Field(..., description="Available namespaces")

class SystemStatus(BaseModel):
    """System status information."""
    initialization_status: Dict[str, bool] = Field(..., description="Component initialization status")
    components_ready: int = Field(..., description="Number of ready components")
    total_components: int = Field(..., description="Total number of components")
    ontology_path: str = Field(..., description="Path to ontology file")
    models: Dict[str, str] = Field(..., description="Model information")

class StatsResponse(BaseModel):
    """Response model for statistics."""
    vector_store: VectorStoreStats = Field(..., description="Vector store statistics")
    rdf_graph: RdfGraphStats = Field(..., description="RDF graph statistics")
    system_status: SystemStatus = Field(..., description="System status")

# Health check models
class ComponentHealth(BaseModel):
    """Health status for a single component."""
    healthy: bool = Field(..., description="Whether the component is healthy")
    error: Optional[str] = Field(None, description="Error message if unhealthy")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional health details")

class HealthResponse(BaseModel):
    """Response model for health checks."""
    overall_healthy: bool = Field(..., description="Overall system health")
    components: Dict[str, ComponentHealth] = Field(..., description="Individual component health")
    timestamp: datetime = Field(..., description="Health check timestamp")
    uptime: Optional[float] = Field(None, description="System uptime in seconds")

# Initialization models
class InitializeRequest(BaseModel):
    """Request model for knowledge base initialization."""
    model_config = ConfigDict(extra="forbid")
    
    force_rebuild: bool = Field(False, description="Force rebuild of existing index")
    batch_size: int = Field(50, ge=1, le=1000, description="Batch size for processing")
    include_instances: bool = Field(True, description="Include class instances")

class InitializeResponse(BaseModel):
    """Response model for knowledge base initialization."""
    success: bool = Field(..., description="Whether initialization was successful")
    message: str = Field(..., description="Initialization message")
    entities_indexed: int = Field(..., description="Number of entities indexed")
    entity_types: Optional[Dict[str, int]] = Field(None, description="Distribution by entity type")
    index_size_mb: Optional[float] = Field(None, description="Index size in MB")
    force_rebuild: bool = Field(..., description="Whether this was a force rebuild")
    processing_time: Optional[float] = Field(None, description="Processing time in seconds")

# Utility models
class ErrorResponse(BaseModel):
    """Standard error response model."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Error message")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional error details")
    request_id: Optional[str] = Field(None, description="Request ID")
    timestamp: datetime = Field(default_factory=datetime.now, description="Error timestamp")

class SuccessResponse(BaseModel):
    """Standard success response model."""
    message: str = Field(..., description="Success message")
    data: Optional[Dict[str, Any]] = Field(None, description="Response data")
    request_id: Optional[str] = Field(None, description="Request ID")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class PaginatedResponse(BaseModel):
    """Paginated response model."""
    items: List[Any] = Field(..., description="Response items")
    total: int = Field(..., description="Total number of items")
    page: int = Field(..., description="Current page number")
    size: int = Field(..., description="Page size")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_prev: bool = Field(..., description="Whether there are previous pages")

# Metrics models
class EndpointMetrics(BaseModel):
    """Metrics for a specific endpoint."""
    endpoint: str = Field(..., description="Endpoint path")
    count: int = Field(..., description="Total request count")
    average_time: float = Field(..., description="Average response time")
    min_time: float = Field(..., description="Minimum response time")
    max_time: float = Field(..., description="Maximum response time")
    error_rate: float = Field(..., description="Error rate (0-1)")
    errors: int = Field(..., description="Total error count")

class PerformanceMetrics(BaseModel):
    """Overall performance metrics."""
    total_requests: int = Field(..., description="Total requests processed")
    total_errors: int = Field(..., description="Total errors")
    slow_requests: int = Field(..., description="Number of slow requests")
    average_response_time: float = Field(..., description="Average response time")
    error_rate: float = Field(..., description="Overall error rate")

class MetricsResponse(BaseModel):
    """Response model for metrics."""
    performance: PerformanceMetrics = Field(..., description="Performance metrics")
    endpoints: List[EndpointMetrics] = Field(..., description="Endpoint-specific metrics")
    timestamp: datetime = Field(default_factory=datetime.now, description="Metrics timestamp")
