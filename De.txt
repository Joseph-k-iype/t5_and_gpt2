// src/contexts/ResearchContext.jsx - Fixed to sync with chat research
import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';
import { researchService } from '../services/researchService';
import { useSession } from './SessionContext';
import toast from 'react-hot-toast';

// Create Research Context
export const ResearchContext = createContext();

// Research reducer
const researchReducer = (state, action) => {
  switch (action.type) {
    case 'SET_RESEARCH':
      return {
        ...state,
        currentResearch: action.payload,
        isResearching: false,
        error: null,
      };
    case 'UPDATE_RESEARCH':
      // Update existing research or set new one
      return {
        ...state,
        currentResearch: action.payload,
        isResearching: false,
        error: null,
      };
    case 'SET_RESEARCHING':
      return {
        ...state,
        isResearching: action.payload,
      };
    case 'SET_PROGRESS':
      return {
        ...state,
        progress: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        isResearching: false,
      };
    case 'CLEAR_RESEARCH':
      return {
        ...state,
        currentResearch: null,
        progress: null,
        error: null,
        isResearching: false,
      };
    case 'ADD_RESEARCH_HISTORY':
      return {
        ...state,
        researchHistory: [action.payload, ...state.researchHistory.slice(0, 9)], // Keep last 10
      };
    case 'SET_CHAT_RESEARCH_ACTIVE':
      return {
        ...state,
        isChatResearchActive: action.payload,
      };
    default:
      return state;
  }
};

// Initial state
const initialState = {
  currentResearch: null,
  researchHistory: [],
  isResearching: false,
  isChatResearchActive: false, // New state to track chat-initiated research
  progress: null,
  error: null,
};

export const ResearchProvider = ({ children }) => {
  const [state, dispatch] = useReducer(researchReducer, initialState);
  const { sessionId, userId } = useSession();

  // Function to extract research from chat messages
  const extractResearchFromChatResponse = useCallback((chatResponse) => {
    // Check if this is a research response
    if (chatResponse.metadata?.real_ai && 
        (chatResponse.approach?.includes('REAL_AI') || 
         chatResponse.metadata?.approach?.includes('enhanced'))) {
      
      // Convert chat response to research format
      const researchResult = {
        final_synthesis: chatResponse.answer,
        overall_confidence: chatResponse.metadata?.confidence === 'high' ? 0.9 : 
                          chatResponse.metadata?.confidence === 'medium' ? 0.7 : 0.5,
        session_id: chatResponse.session_id,
        user_id: chatResponse.user_id,
        timestamp: chatResponse.timestamp,
        agents_used: chatResponse.metadata?.agents_used || ['chat_ai_agent'],
        iterations_completed: 1,
        processing_time: 'chat_research',
        metadata: {
          ...chatResponse.metadata,
          source: 'chat_research',
          confidence_level: chatResponse.confidence,
          approach: chatResponse.approach
        }
      };

      return researchResult;
    }
    return null;
  }, []);

  // Function to be called by ChatContext when research completes
  const updateFromChatResearch = useCallback((chatResponse, originalQuery) => {
    console.log('ðŸ”„ Updating research panel from chat response...');
    
    const researchResult = extractResearchFromChatResponse(chatResponse);
    
    if (researchResult) {
      console.log('âœ… Valid research response detected, updating research panel');
      
      // Update current research
      dispatch({ type: 'UPDATE_RESEARCH', payload: researchResult });
      
      // Add to history
      dispatch({
        type: 'ADD_RESEARCH_HISTORY',
        payload: {
          id: researchResult.session_id + '_' + Date.now(),
          topic: originalQuery || 'Chat Research',
          timestamp: researchResult.timestamp,
          confidence: researchResult.overall_confidence,
          summary: researchResult.final_synthesis.slice(0, 200) + '...',
          source: 'chat'
        },
      });

      // Mark chat research as inactive
      dispatch({ type: 'SET_CHAT_RESEARCH_ACTIVE', payload: false });
      
      console.log('ðŸ“Š Research panel updated with latest results');
    } else {
      console.log('â„¹ï¸ Chat response not identified as research result');
    }
  }, [extractResearchFromChatResponse]);

  // Function to be called when chat research starts
  const notifyChatResearchStarted = useCallback((query) => {
    console.log('ðŸ§  Chat research started:', query);
    dispatch({ type: 'SET_CHAT_RESEARCH_ACTIVE', payload: true });
    dispatch({ type: 'SET_RESEARCHING', payload: true });
  }, []);

  const startResearch = useCallback(async (topic, options = {}) => {
    if (!sessionId || !topic.trim()) return;

    try {
      dispatch({ type: 'SET_RESEARCHING', payload: true });
      dispatch({ type: 'SET_PROGRESS', payload: null });
      dispatch({ type: 'SET_CHAT_RESEARCH_ACTIVE', payload: false });

      console.log('ðŸ”¬ Starting dedicated deep research:', topic);

      // Start research
      const result = await researchService.startDeepResearch({
        topic: topic.trim(),
        session_id: sessionId,
        user_id: userId,
        ...options,
      });

      dispatch({ type: 'SET_RESEARCH', payload: result });
      
      // Add to history
      dispatch({
        type: 'ADD_RESEARCH_HISTORY',
        payload: {
          id: result.session_id + '_' + Date.now(),
          topic: topic.trim(),
          timestamp: result.timestamp,
          confidence: result.overall_confidence,
          summary: result.final_synthesis.slice(0, 200) + '...',
          source: 'dedicated_research'
        },
      });

      toast.success('ðŸŽ‰ Deep research completed successfully!');

    } catch (error) {
      console.error('Failed to start research:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
      toast.error('Research failed. Please try again.');
    }
  }, [sessionId, userId]);

  const getResearchStatus = useCallback(async () => {
    if (!sessionId) return;

    try {
      const status = await researchService.getResearchStatus(sessionId);
      return status;
    } catch (error) {
      console.error('Failed to get research status:', error);
      return null;
    }
  }, [sessionId]);

  const clearCurrentResearch = useCallback(() => {
    dispatch({ type: 'CLEAR_RESEARCH' });
  }, []);

  const value = {
    ...state,
    startResearch,
    getResearchStatus,
    clearCurrentResearch,
    updateFromChatResearch, // Expose this for ChatContext to call
    notifyChatResearchStarted, // Expose this for ChatContext to call
  };

  return (
    <ResearchContext.Provider value={value}>
      {children}
    </ResearchContext.Provider>
  );
};

export const useResearch = () => {
  const context = useContext(ResearchContext);
  if (!context) {
    throw new Error('useResearch must be used within a ResearchProvider');
  }
  return context;
};
