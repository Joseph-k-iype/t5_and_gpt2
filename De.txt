// frontend/src/contexts/SessionContext.jsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { sessionService } from '../services/sessionService';

// Session Context
const SessionContext = createContext();

// Session reducer
const sessionReducer = (state, action) => {
  switch (action.type) {
    case 'SET_SESSION':
      return {
        ...state,
        sessionId: action.payload.sessionId,
        userId: action.payload.userId,
        isLoading: false,
        error: null,
      };
    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        isLoading: false,
      };
    case 'UPDATE_STATS':
      return {
        ...state,
        sessionStats: action.payload,
      };
    case 'CLEAR_SESSION':
      return {
        ...state,
        sessionId: null,
        userId: null,
        sessionStats: null,
        error: null,
      };
    default:
      return state;
  }
};

// Initial state
const initialState = {
  sessionId: null,
  userId: null,
  sessionStats: null,
  isLoading: true,
  error: null,
};

export const SessionProvider = ({ children }) => {
  const [state, dispatch] = useReducer(sessionReducer, initialState);

  // Initialize session on mount
  useEffect(() => {
    initializeSession();
  }, []);

  const initializeSession = async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      // Try to get existing session from localStorage
      const existingSessionId = localStorage.getItem('research_session_id');
      const existingUserId = localStorage.getItem('research_user_id');

      if (existingSessionId && existingUserId) {
        // Validate existing session
        try {
          const isValid = await sessionService.validateSession(existingSessionId);
          if (isValid) {
            dispatch({
              type: 'SET_SESSION',
              payload: {
                sessionId: existingSessionId,
                userId: existingUserId,
              },
            });
            return;
          }
        } catch (error) {
          console.warn('Failed to validate existing session:', error);
        }
      }

      // Create new session
      const userId = existingUserId || `user_${uuidv4().slice(0, 8)}`;
      const sessionData = await sessionService.createSession(userId);
      
      // Store in localStorage
      localStorage.setItem('research_session_id', sessionData.sessionId);
      localStorage.setItem('research_user_id', sessionData.userId);
      
      dispatch({
        type: 'SET_SESSION',
        payload: sessionData,
      });
      
    } catch (error) {
      console.error('Failed to initialize session:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
    }
  };

  const clearSession = async () => {
    try {
      if (state.sessionId) {
        await sessionService.deleteSession(state.sessionId);
      }
      
      localStorage.removeItem('research_session_id');
      localStorage.removeItem('research_user_id');
      
      dispatch({ type: 'CLEAR_SESSION' });
      
      // Create new session
      await initializeSession();
      
    } catch (error) {
      console.error('Failed to clear session:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
    }
  };

  const updateSessionStats = (stats) => {
    dispatch({ type: 'UPDATE_STATS', payload: stats });
  };

  const value = {
    ...state,
    clearSession,
    updateSessionStats,
    initializeSession,
  };

  return (
    <SessionContext.Provider value={value}>
      {children}
    </SessionContext.Provider>
  );
};

export const useSession = () => {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error('useSession must be used within a SessionProvider');
  }
  return context;
};

// frontend/src/contexts/ChatContext.jsx
import React, { createContext, useContext, useReducer, useCallback } from 'react';
import { chatService } from '../services/chatService';
import { useSession } from './SessionContext';
import toast from 'react-hot-toast';

// Chat Context
const ChatContext = createContext();

// Chat reducer
const chatReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_MESSAGE':
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case 'SET_MESSAGES':
      return {
        ...state,
        messages: action.payload,
      };
    case 'SET_TYPING':
      return {
        ...state,
        isTyping: action.payload,
      };
    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        isLoading: false,
        isTyping: false,
      };
    case 'CLEAR_MESSAGES':
      return {
        ...state,
        messages: [],
        error: null,
      };
    default:
      return state;
  }
};

// Initial state
const initialState = {
  messages: [],
  isTyping: false,
  isLoading: false,
  error: null,
};

export const ChatProvider = ({ children }) => {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const { sessionId, userId, updateSessionStats } = useSession();

  const addMessage = useCallback((message) => {
    dispatch({ type: 'ADD_MESSAGE', payload: message });
  }, []);

  const sendMessage = useCallback(async (content) => {
    if (!sessionId || !content.trim()) return;

    try {
      // Add user message immediately
      const userMessage = {
        id: `user_${Date.now()}`,
        role: 'user',
        content: content.trim(),
        timestamp: new Date().toISOString(),
      };
      
      addMessage(userMessage);
      dispatch({ type: 'SET_LOADING', payload: true });
      dispatch({ type: 'SET_TYPING', payload: true });

      // Send to API
      const response = await chatService.sendQuickMessage({
        message: content.trim(),
        sessionId,
        userId,
      });

      // Add AI response
      const aiMessage = {
        id: `ai_${Date.now()}`,
        role: 'assistant',
        content: response.answer,
        timestamp: response.timestamp,
        metadata: {
          confidence: response.confidence,
          approach: response.approach,
        },
      };
      
      addMessage(aiMessage);
      
      // Update session stats
      updateSessionStats({
        messageCount: state.messages.length + 2, // +2 for user and AI messages
      });

    } catch (error) {
      console.error('Failed to send message:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
      toast.error('Failed to send message. Please try again.');
      
      // Add error message
      const errorMessage = {
        id: `error_${Date.now()}`,
        role: 'assistant',
        content: 'I apologize, but I encountered an error processing your message. Please try again.',
        timestamp: new Date().toISOString(),
        metadata: {
          confidence: 'low',
          approach: 'error',
        },
      };
      
      addMessage(errorMessage);
      
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
      dispatch({ type: 'SET_TYPING', payload: false });
    }
  }, [sessionId, userId, addMessage, state.messages.length, updateSessionStats]);

  const startDeepResearch = useCallback(async (topic) => {
    if (!sessionId || !topic.trim()) return;

    try {
      // Add user message
      const userMessage = {
        id: `research_user_${Date.now()}`,
        role: 'user',
        content: topic.trim(),
        timestamp: new Date().toISOString(),
        metadata: {
          type: 'research_request',
        },
      };
      
      addMessage(userMessage);
      dispatch({ type: 'SET_LOADING', payload: true });

      // Start research (this will be handled by ResearchContext)
      const researchMessage = {
        id: `research_start_${Date.now()}`,
        role: 'assistant',
        content: `Starting deep research on: "${topic.trim()}"\n\nThis may take a few minutes as I conduct comprehensive research using multiple specialized agents. You can monitor the progress in the Research panel.`,
        timestamp: new Date().toISOString(),
        metadata: {
          confidence: 'high',
          approach: 'deep_research_initiated',
          type: 'research_start',
        },
      };
      
      addMessage(researchMessage);

    } catch (error) {
      console.error('Failed to start research:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
      toast.error('Failed to start research. Please try again.');
      
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [sessionId, addMessage]);

  const loadConversationHistory = useCallback(async () => {
    if (!sessionId) return;

    try {
      const history = await chatService.getConversationHistory(sessionId);
      dispatch({ type: 'SET_MESSAGES', payload: history.messages });
      
    } catch (error) {
      console.error('Failed to load conversation history:', error);
      // Don't show error toast for this, as it's not critical
    }
  }, [sessionId]);

  const clearMessages = useCallback(() => {
    dispatch({ type: 'CLEAR_MESSAGES' });
  }, []);

  const value = {
    ...state,
    sendMessage,
    startDeepResearch,
    addMessage,
    loadConversationHistory,
    clearMessages,
  };

  return (
    <ChatContext.Provider value={value}>
      {children}
    </ChatContext.Provider>
  );
};

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};

// frontend/src/contexts/ResearchContext.jsx
import React, { createContext, useContext, useReducer, useCallback } from 'react';
import { researchService } from '../services/researchService';
import { useSession } from './SessionContext';
import toast from 'react-hot-toast';

// Research Context
const ResearchContext = createContext();

// Research reducer
const researchReducer = (state, action) => {
  switch (action.type) {
    case 'SET_RESEARCH':
      return {
        ...state,
        currentResearch: action.payload,
        isResearching: false,
        error: null,
      };
    case 'SET_RESEARCHING':
      return {
        ...state,
        isResearching: action.payload,
      };
    case 'SET_PROGRESS':
      return {
        ...state,
        progress: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        isResearching: false,
      };
    case 'CLEAR_RESEARCH':
      return {
        ...state,
        currentResearch: null,
        progress: null,
        error: null,
      };
    case 'ADD_RESEARCH_HISTORY':
      return {
        ...state,
        researchHistory: [action.payload, ...state.researchHistory.slice(0, 9)], // Keep last 10
      };
    default:
      return state;
  }
};

// Initial state
const initialState = {
  currentResearch: null,
  researchHistory: [],
  isResearching: false,
  progress: null,
  error: null,
};

export const ResearchProvider = ({ children }) => {
  const [state, dispatch] = useReducer(researchReducer, initialState);
  const { sessionId, userId } = useSession();

  const startResearch = useCallback(async (topic, options = {}) => {
    if (!sessionId || !topic.trim()) return;

    try {
      dispatch({ type: 'SET_RESEARCHING', payload: true });
      dispatch({ type: 'SET_PROGRESS', payload: null });

      // Start research
      const result = await researchService.startDeepResearch({
        topic: topic.trim(),
        sessionId,
        userId,
        ...options,
      });

      dispatch({ type: 'SET_RESEARCH', payload: result });
      
      // Add to history
      dispatch({
        type: 'ADD_RESEARCH_HISTORY',
        payload: {
          id: result.session_id,
          topic: topic.trim(),
          timestamp: result.timestamp,
          confidence: result.overall_confidence,
          summary: result.final_synthesis.slice(0, 200) + '...',
        },
      });

      toast.success('Research completed successfully!');

    } catch (error) {
      console.error('Failed to start research:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
      toast.error('Research failed. Please try again.');
    }
  }, [sessionId, userId]);

  const getResearchStatus = useCallback(async () => {
    if (!sessionId) return;

    try {
      const status = await researchService.getResearchStatus(sessionId);
      return status;
    } catch (error) {
      console.error('Failed to get research status:', error);
      return null;
    }
  }, [sessionId]);

  const clearCurrentResearch = useCallback(() => {
    dispatch({ type: 'CLEAR_RESEARCH' });
  }, []);

  const value = {
    ...state,
    startResearch,
    getResearchStatus,
    clearCurrentResearch,
  };

  return (
    <ResearchContext.Provider value={value}>
      {children}
    </ResearchContext.Provider>
  );
};

export const useResearch = () => {
  const context = useContext(ResearchContext);
  if (!context) {
    throw new Error('useResearch must be used within a ResearchProvider');
  }
  return context;
};

// frontend/src/hooks/useSession.js
import { useContext } from 'react';
import { SessionContext } from '../contexts/SessionContext';

export const useSession = () => {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error('useSession must be used within a SessionProvider');
  }
  return context;
};

// frontend/src/hooks/useChat.js
import { useContext } from 'react';
import { ChatContext } from '../contexts/ChatContext';

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};

// frontend/src/hooks/useResearch.js
import { useContext } from 'react';
import { ResearchContext } from '../contexts/ResearchContext';

export const useResearch = () => {
  const context = useContext(ResearchContext);
  if (!context) {
    throw new Error('useResearch must be used within a ResearchProvider');
  }
  return context;
};
