"""
ODRL Rule Generator - Creates ODRL policies from extracted components

UPDATED:
- Removed assigner and assignee fields from permissions/prohibitions/duties
- Enhanced comment generation for detailed explanations
- Action taxonomy validation to ensure only: share, store, process, update, create
- Handles both string and dictionary duty formats

Location: src/generators/odrl_rule_generator.py
"""

import logging
import uuid
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

logger = logging.getLogger(__name__)


class ODRLRuleGenerator:
    """Generates ODRL policies from extracted rule components."""
    
    # Standard action taxonomy - ONLY these actions are permitted
    STANDARD_ACTIONS = {
        "share", "store", "process", "update", "create"
    }
    
    # ODRL namespace and standard actions
    ODRL_NAMESPACE = "http://www.w3.org/ns/odrl/2/"
    ODRL_ACTIONS = {
        "share": "http://www.w3.org/ns/odrl/2/distribute",  # Map to ODRL distribute
        "store": "http://www.w3.org/ns/odrl/2/archive",     # Map to ODRL archive
        "process": "http://www.w3.org/ns/odrl/2/use",       # Map to ODRL use
        "update": "http://www.w3.org/ns/odrl/2/modify",     # Map to ODRL modify
        "create": "http://www.w3.org/ns/odrl/2/derive"      # Map to ODRL derive
    }
    
    # ODRL operator mappings
    ODRL_OPERATORS = {
        "eq": "http://www.w3.org/ns/odrl/2/eq",
        "neq": "http://www.w3.org/ns/odrl/2/neq",
        "gt": "http://www.w3.org/ns/odrl/2/gt",
        "gteq": "http://www.w3.org/ns/odrl/2/gteq",
        "lt": "http://www.w3.org/ns/odrl/2/lt",
        "lteq": "http://www.w3.org/ns/odrl/2/lteq",
        "isAnyOf": "http://www.w3.org/ns/odrl/2/isAnyOf",
        "isAllOf": "http://www.w3.org/ns/odrl/2/isAllOf",
        "isNoneOf": "http://www.w3.org/ns/odrl/2/isNoneOf",
        "isPartOf": "http://www.w3.org/ns/odrl/2/isPartOf"
    }
    
    def __init__(self):
        """Initialize ODRL rule generator."""
        pass
    
    def validate_action(self, action: str) -> str:
        """
        Validate and normalize action to standard taxonomy.
        
        Args:
            action: Action to validate
            
        Returns:
            Normalized action from standard taxonomy
            
        Raises:
            ValueError: If action cannot be mapped to standard taxonomy
        """
        if not action:
            logger.warning("Empty action provided, defaulting to 'process'")
            return "process"
        
        action_lower = action.lower().strip()
        
        # Direct match
        if action_lower in self.STANDARD_ACTIONS:
            return action_lower
        
        # Map common synonyms
        action_mapping = {
            # Share synonyms
            "transfer": "share",
            "distribute": "share",
            "disclose": "share",
            "transmit": "share",
            "send": "share",
            "communicate": "share",
            
            # Store synonyms
            "retain": "store",
            "keep": "store",
            "archive": "store",
            "maintain": "store",
            "hold": "store",
            "save": "store",
            
            # Process synonyms
            "use": "process",
            "analyze": "process",
            "transform": "process",
            "modify": "process",
            "manipulate": "process",
            "handle": "process",
            "execute": "process",
            
            # Update synonyms
            "change": "update",
            "amend": "update",
            "revise": "update",
            "alter": "update",
            "edit": "update",
            "correct": "update",
            
            # Create synonyms
            "collect": "create",
            "generate": "create",
            "produce": "create",
            "derive": "create",
            "obtain": "create",
            "gather": "create"
        }
        
        if action_lower in action_mapping:
            mapped_action = action_mapping[action_lower]
            logger.info(f"Mapped action '{action}' to standard action '{mapped_action}'")
            return mapped_action
        
        # If no mapping found, log warning and use process as default
        logger.warning(f"Unknown action '{action}', defaulting to 'process'")
        return "process"
    
    def generate_detailed_comment(
        self, 
        rule_type: str, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None,
        existing_description: str = None
    ) -> str:
        """
        Generate detailed comment for lawyers and non-lawyers.
        
        Args:
            rule_type: 'permission', 'prohibition', or 'duty'
            action: The action being performed
            target: What the action applies to
            constraints: List of constraints
            existing_description: Existing description if any
            
        Returns:
            Detailed comment (2-3+ sentences)
        """
        if existing_description and len(existing_description) > 100:
            # If we have a good existing description, use it
            return existing_description
        
        # Generate detailed comment based on rule type
        action_past = {
            "share": "shared", "store": "stored", "process": "processed",
            "update": "updated", "create": "created"
        }.get(action, "used")
        
        if rule_type == "permission":
            comment = f"This permission allows {target} to be {action_past} under specific conditions. "
            
            if constraints:
                constraint_desc = ", ".join([c.get('description', '') for c in constraints if c.get('description')])
                if constraint_desc:
                    comment += f"The following conditions must be met: {constraint_desc}. "
                else:
                    comment += "Specific conditions apply as defined in the constraints. "
            
            comment += f"Organizations must ensure all conditions are satisfied before {action}ing {target}."
            
        elif rule_type == "prohibition":
            comment = f"This prohibition forbids {target} from being {action_past} under certain circumstances. "
            
            if constraints:
                constraint_desc = ", ".join([c.get('description', '') for c in constraints if c.get('description')])
                if constraint_desc:
                    comment += f"The prohibition applies when: {constraint_desc}. "
                else:
                    comment += "Specific conditions trigger this prohibition as defined in the constraints. "
            
            comment += f"Violating this prohibition may result in non-compliance and potential legal consequences."
            
        else:  # duty
            comment = f"This duty requires that {target} must be {action_past} to fulfill compliance obligations. "
            
            if constraints:
                constraint_desc = ", ".join([c.get('description', '') for c in constraints if c.get('description')])
                if constraint_desc:
                    comment += f"The duty must be fulfilled when: {constraint_desc}. "
            
            comment += f"Failure to complete this duty may result in non-compliance with data protection requirements."
        
        return comment
    
    def generate_policy(
        self, 
        rules: List[Any] = None,
        policy_uid: str = None,
        policy_type: str = "Set",
        # CSV/Excel converter parameters
        policy_id: str = None,
        rule_name: str = None,
        odrl_components: Any = None,
        framework_type: str = None,
        restriction_condition: str = None,
        data_category_uuids: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """
        Generate complete ODRL policy from rules OR from ODRL components.
        
        Supports two calling patterns:
        1. PDF Processing: generate_policy(rules=..., policy_uid=...)
        2. CSV/Excel Processing: generate_policy(policy_id=..., rule_name=..., odrl_components=...)
        
        Args:
            rules: List of Rule objects (for PDF processing)
            policy_uid: Optional policy UID, will be generated if not provided
            policy_type: ODRL policy type (Set, Offer, Agreement)
            policy_id: Unique identifier for the policy (for CSV/Excel)
            rule_name: Human-readable rule name (for CSV/Excel)
            odrl_components: Extracted ODRL components (for CSV/Excel)
            framework_type: DSS or DataVISA (for CSV/Excel)
            restriction_condition: restriction or condition (for CSV/Excel)
            data_category_uuids: Mapping of data category names to UUIDs
            
        Returns:
            Complete ODRL policy dictionary
        """
        # Determine which calling pattern is being used
        if odrl_components is not None:
            # CSV/Excel processing pattern
            return self._generate_policy_from_components(
                policy_id=policy_id,
                rule_name=rule_name,
                odrl_components=odrl_components,
                framework_type=framework_type,
                restriction_condition=restriction_condition,
                data_category_uuids=data_category_uuids
            )
        else:
            # PDF processing pattern
            return self._generate_policy_from_rules(
                rules=rules,
                policy_uid=policy_uid,
                policy_type=policy_type
            )
    
    def _generate_policy_from_rules(
        self,
        rules: List[Any],
        policy_uid: str = None,
        policy_type: str = "Set"
    ) -> Dict[str, Any]:
        """
        Generate ODRL policy from rules (PDF processing).
        """
        if policy_uid is None:
            policy_uid = f"urn:uuid:{uuid.uuid4()}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "dpv": "https://w3id.org/dpv#"
            },
            "@type": f"odrl:{policy_type}",
            "uid": policy_uid,
            "profile": "http://www.w3.org/ns/odrl/2/core"
        }
        
        # Add metadata
        policy["dct:created"] = datetime.now().isoformat()
        policy["dct:creator"] = "ODRL Policy Generator"
        
        all_permissions = []
        all_prohibitions = []
        
        # Process each rule
        for rule in rules:
            # Extract permissions from rule
            if hasattr(rule, 'permissions') and rule.permissions:
                for perm in rule.permissions:
                    odrl_perm = self._create_permission(perm)
                    if odrl_perm:
                        all_permissions.append(odrl_perm)
            
            # Extract prohibitions from rule
            if hasattr(rule, 'prohibitions') and rule.prohibitions:
                for prohib in rule.prohibitions:
                    odrl_prohib = self._create_prohibition(prohib)
                    if odrl_prohib:
                        all_prohibitions.append(odrl_prohib)
        
        # Add to policy
        if all_permissions:
            policy["permission"] = all_permissions
        if all_prohibitions:
            policy["prohibition"] = all_prohibitions
        
        return policy
    
    def _generate_policy_from_components(
        self,
        policy_id: str,
        rule_name: str,
        odrl_components: Any,
        framework_type: str,
        restriction_condition: str,
        data_category_uuids: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """
        Generate ODRL policy from ODRL components (CSV/Excel processing).
        """
        policy_uid = f"urn:policy:{policy_id}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "custom": "http://example.org/custom#"
            },
            "@type": "odrl:Policy",
            "uid": policy_uid,
            "profile": f"urn:profile:{framework_type.lower()}",
            "dc:title": rule_name,
            "dc:description": f"{framework_type} {restriction_condition}: {rule_name}",
            "dc:created": datetime.now().isoformat(),
            "dc:identifier": policy_id
        }
        
        # Add permissions
        if odrl_components.permissions:
            permissions = []
            for perm in odrl_components.permissions:
                odrl_perm = self._create_permission(perm, data_category_uuids)
                if odrl_perm:
                    permissions.append(odrl_perm)
            
            if permissions:
                policy["permission"] = permissions
        
        # Add prohibitions
        if odrl_components.prohibitions:
            prohibitions = []
            for prohib in odrl_components.prohibitions:
                odrl_prohib = self._create_prohibition(prohib, data_category_uuids)
                if odrl_prohib:
                    prohibitions.append(odrl_prohib)
            
            if prohibitions:
                policy["prohibition"] = prohibitions
        
        # Add metadata about data categories
        if odrl_components.data_categories:
            policy["dc:subject"] = odrl_components.data_categories
        
        # Add geographic scope
        if odrl_components.geographic_scope:
            policy["dc:coverage"] = odrl_components.geographic_scope
        
        # Add purpose if specified
        if odrl_components.purpose:
            policy["dc:purpose"] = odrl_components.purpose
        
        # Add custom metadata
        policy["custom:framework"] = framework_type
        policy["custom:type"] = restriction_condition
        policy["custom:confidenceScore"] = odrl_components.confidence_score
        
        if data_category_uuids:
            policy["custom:dataCategoryUUIDs"] = data_category_uuids
        
        return policy
    
    def _get_action_uri(self, action: str) -> str:
        """
        Get ODRL action URI, validating against standard taxonomy.
        
        Args:
            action: Action name
            
        Returns:
            ODRL action URI
        """
        # Validate and normalize action
        normalized_action = self.validate_action(action)
        
        # Return corresponding ODRL URI
        return self.ODRL_ACTIONS.get(normalized_action, self.ODRL_ACTIONS["process"])
    
    def _create_asset_reference(self, target: str) -> str:
        """
        Create asset/target reference.
        
        Args:
            target: Target description
            
        Returns:
            Asset URI or description
        """
        if not target:
            return "urn:data:unspecified"
        
        # If it looks like a URI, use it
        if target.startswith("http://") or target.startswith("https://") or target.startswith("urn:"):
            return target
        
        # Otherwise create a URN from the description
        safe_target = target.replace(" ", "_").replace("/", "_")
        return f"urn:data:{safe_target}"
    
    def _create_permission(
        self, 
        permission: Dict[str, Any],
        data_category_uuids: Dict[str, str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL permission from extracted permission data.
        
        UPDATED: Removed assigner and assignee fields
        """
        try:
            odrl_permission = {}
            
            # Add action (validated)
            action = permission.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_permission["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_permission["action"] = self.ODRL_ACTIONS["process"]
            
            # Add target (asset)
            target = permission.get("target", "data")
            odrl_permission["target"] = self._create_asset_reference(target)
            
            # NOTE: Assigner and assignee fields REMOVED
            # Focus on the action and conditions, not who grants permission
            
            # Add constraints
            constraints = permission.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_permission["constraint"] = odrl_constraints
            
            # Add duties
            duties = permission.get("duties", [])
            if duties:
                odrl_duties = []
                for duty in duties:
                    odrl_duty = self._create_duty(duty)
                    if odrl_duty:
                        odrl_duties.append(odrl_duty)
                
                if odrl_duties:
                    odrl_permission["duty"] = odrl_duties
            
            # Add detailed description as comment
            description = permission.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self.generate_detailed_comment(
                    "permission",
                    permission.get("action", "process"),
                    target,
                    constraints,
                    description
                )
            
            odrl_permission["rdfs:comment"] = description
            
            return odrl_permission
        
        except Exception as e:
            logger.error(f"Error creating permission: {e}")
            logger.error(f"Permission data: {permission}")
            return None
    
    def _create_prohibition(
        self, 
        prohibition: Dict[str, Any],
        data_category_uuids: Dict[str, str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL prohibition from extracted prohibition data.
        
        UPDATED: Removed assigner and assignee fields
        """
        try:
            odrl_prohibition = {}
            
            # Add action (validated)
            action = prohibition.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_prohibition["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_prohibition["action"] = self.ODRL_ACTIONS["process"]
            
            # Add target (asset)
            target = prohibition.get("target", "data")
            odrl_prohibition["target"] = self._create_asset_reference(target)
            
            # NOTE: Assigner and assignee fields REMOVED
            
            # Add constraints
            constraints = prohibition.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_prohibition["constraint"] = odrl_constraints
            
            # Add detailed description as comment
            description = prohibition.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self.generate_detailed_comment(
                    "prohibition",
                    prohibition.get("action", "process"),
                    target,
                    constraints,
                    description
                )
            
            odrl_prohibition["rdfs:comment"] = description
            
            return odrl_prohibition
        
        except Exception as e:
            logger.error(f"Error creating prohibition: {e}")
            logger.error(f"Prohibition data: {prohibition}")
            return None
    
    def _create_duty(self, duty: Union[str, Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Create ODRL duty.
        
        UPDATED: Removed assigner and assignee fields
        Handles both string descriptions and structured duty dictionaries
        
        Args:
            duty: Either a string description or a dictionary with action, target, etc.
            
        Returns:
            ODRL duty dictionary
        """
        try:
            odrl_duty = {}
            
            # Handle string duties (simple descriptions)
            if isinstance(duty, str):
                # Infer action from description or use default
                duty_lower = duty.lower()
                inferred_action = "process"  # Default
                
                # Try to infer action from string
                if any(word in duty_lower for word in ["notify", "inform", "communicate"]):
                    inferred_action = "share"
                elif any(word in duty_lower for word in ["document", "record", "log", "maintain"]):
                    inferred_action = "store"
                elif any(word in duty_lower for word in ["obtain", "collect", "get"]):
                    inferred_action = "create"
                elif any(word in duty_lower for word in ["update", "correct", "amend"]):
                    inferred_action = "update"
                
                odrl_duty["action"] = self._get_action_uri(inferred_action)
                odrl_duty["rdfs:comment"] = duty
                
                return odrl_duty
            
            # Handle dictionary duties (structured)
            elif isinstance(duty, dict):
                # Add action (validated)
                action = duty.get("action")
                if action:
                    action_uri = self._get_action_uri(action)
                    odrl_duty["action"] = action_uri
                else:
                    odrl_duty["action"] = self.ODRL_ACTIONS["process"]
                
                # Add target if present
                target = duty.get("target")
                if target:
                    odrl_duty["target"] = self._create_asset_reference(target)
                
                # NOTE: Assigner and assignee fields REMOVED
                
                # Add constraints if present
                constraints = duty.get("constraints", [])
                if constraints:
                    odrl_constraints = []
                    for constraint in constraints:
                        odrl_constraint = self._create_constraint(constraint)
                        if odrl_constraint:
                            odrl_constraints.append(odrl_constraint)
                    
                    if odrl_constraints:
                        odrl_duty["constraint"] = odrl_constraints
                
                # Add detailed description as comment
                description = duty.get("description")
                if not description or len(description) < 50:
                    # Generate detailed comment if not provided or too short
                    description = self.generate_detailed_comment(
                        "duty",
                        duty.get("action", "process"),
                        target or "data",
                        constraints,
                        description
                    )
                
                odrl_duty["rdfs:comment"] = description
                
                return odrl_duty
            
            else:
                logger.warning(f"Duty is neither string nor dict: {type(duty)}")
                return None
        
        except Exception as e:
            logger.error(f"Error creating duty: {e}")
            logger.error(f"Duty data: {duty}")
            return None
    
    def _create_constraint(self, constraint: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Create ODRL constraint."""
        try:
            odrl_constraint = {}
            
            # Left operand
            left_operand = constraint.get("leftOperand")
            if left_operand:
                if left_operand.startswith("http://"):
                    odrl_constraint["leftOperand"] = left_operand
                else:
                    odrl_constraint["leftOperand"] = f"{self.ODRL_NAMESPACE}{left_operand}"
            
            # Operator
            operator = constraint.get("operator")
            if operator:
                if operator in self.ODRL_OPERATORS:
                    odrl_constraint["operator"] = self.ODRL_OPERATORS[operator]
                else:
                    odrl_constraint["operator"] = operator
            
            # Right operand
            right_operand = constraint.get("rightOperand")
            if right_operand is not None:
                odrl_constraint["rightOperand"] = right_operand
            
            # Optional fields
            if "unit" in constraint:
                odrl_constraint["unit"] = constraint["unit"]
            
            if "dataType" in constraint:
                odrl_constraint["dataType"] = constraint["dataType"]
            
            # Add detailed description as comment
            description = constraint.get("description")
            if description:
                odrl_constraint["rdfs:comment"] = description
            
            return odrl_constraint
        
        except Exception as e:
            logger.error(f"Error creating constraint: {e}")
            return None
    
    def validate_policy(self, policy: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate ODRL policy structure.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            Validation report with issues and warnings
        """
        issues = []
        warnings = []
        
        # Check required fields
        if "@context" not in policy:
            issues.append("Missing @context")
        
        if "@type" not in policy:
            issues.append("Missing @type")
        
        if "uid" not in policy:
            issues.append("Missing uid")
        
        # Check for at least one rule
        has_permission = "permission" in policy and policy["permission"]
        has_prohibition = "prohibition" in policy and policy["prohibition"]
        
        if not has_permission and not has_prohibition:
            warnings.append("Policy has no permissions or prohibitions")
        
        # Validate permissions
        if "permission" in policy:
            for i, perm in enumerate(policy["permission"]):
                if "action" not in perm:
                    issues.append(f"Permission {i}: missing action")
                
                # Check for assigner/assignee (should be removed)
                if "assigner" in perm:
                    warnings.append(f"Permission {i}: contains 'assigner' field (should be removed)")
                if "assignee" in perm:
                    warnings.append(f"Permission {i}: contains 'assignee' field (should be removed)")
        
        # Validate prohibitions
        if "prohibition" in policy:
            for i, prohib in enumerate(policy["prohibition"]):
                if "action" not in prohib:
                    issues.append(f"Prohibition {i}: missing action")
                
                # Check for assigner/assignee (should be removed)
                if "assigner" in prohib:
                    warnings.append(f"Prohibition {i}: contains 'assigner' field (should be removed)")
                if "assignee" in prohib:
                    warnings.append(f"Prohibition {i}: contains 'assignee' field (should be removed)")
        
        return {
            "valid": len(issues) == 0,
            "issues": issues,
            "warnings": warnings
        }
    
    def convert_to_json_ld(self, policy: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert ODRL policy to JSON-LD format.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            JSON-LD formatted policy
        """
        # ODRL is already in JSON-LD format with @context
        return policy
    
    def convert_to_turtle(self, policy: Dict[str, Any]) -> str:
        """
        Convert ODRL policy to Turtle/TTL format.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            Turtle formatted string
        """
        try:
            from rdflib import Graph
            import json
            
            # Create RDF graph from JSON-LD
            g = Graph()
            g.parse(data=json.dumps(policy), format='json-ld')
            
            # Serialize to Turtle
            return g.serialize(format='turtle')
        
        except Exception as e:
            logger.error(f"Error converting to Turtle: {e}")
            return ""
