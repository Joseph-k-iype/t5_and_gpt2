"""
Enhanced Auth Helper - Implements token caching for improved performance.

This module provides functions for retrieving and caching Azure AD tokens
to eliminate redundant token acquisition requests across multiple calls.
"""

import os
import time
import logging
import threading
import requests
from typing import Optional, Dict, Any, Tuple

logger = logging.getLogger(__name__)

class TokenCache:
    """Thread-safe token cache for storing and retrieving Azure tokens."""
    
    _instance = None
    _lock = threading.RLock()
    
    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TokenCache, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the token cache."""
        if self._initialized:
            return
            
        with self._lock:
            if not self._initialized:
                self._tokens = {}  # Format: {cache_key: (token, expiry_time)}
                self._initialized = True
                logger.info("Token cache initialized")
    
    def get(self, tenant_id: str, client_id: str, scope: str) -> Optional[str]:
        """
        Get a token from the cache if it exists and is not expired.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            
        Returns:
            Token if found and valid, None otherwise
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                token, expiry_time = self._tokens[cache_key]
                # Allow 5 minute buffer before expiration
                if time.time() < expiry_time - 300:
                    logger.debug(f"Token cache hit for {client_id[:8]}...")
                    return token
                else:
                    logger.debug(f"Token expired for {client_id[:8]}...")
                    # Remove expired token
                    del self._tokens[cache_key]
        
        return None
    
    def set(self, tenant_id: str, client_id: str, scope: str, token: str, expires_in: int = 3600) -> None:
        """
        Store a token in the cache.
        
        Args:
            tenant_id: Azure tenant ID
            client_id: Azure client ID
            scope: OAuth scope
            token: The token to store
            expires_in: Token expiration time in seconds
        """
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        expiry_time = time.time() + expires_in
        
        with self._lock:
            self._tokens[cache_key] = (token, expiry_time)
            
        logger.debug(f"Token cached for {client_id[:8]}... (expires in {expires_in}s)")
    
    def _get_cache_key(self, tenant_id: str, client_id: str, scope: str) -> str:
        """Generate a cache key."""
        return f"{tenant_id}:{client_id}:{scope}"
    
    def clear(self) -> None:
        """Clear all tokens from the cache."""
        with self._lock:
            self._tokens.clear()
        logger.info("Token cache cleared")
    
    def remove(self, tenant_id: str, client_id: str, scope: str) -> None:
        """Remove a specific token from the cache."""
        cache_key = self._get_cache_key(tenant_id, client_id, scope)
        
        with self._lock:
            if cache_key in self._tokens:
                del self._tokens[cache_key]
                logger.debug(f"Token removed from cache for {client_id[:8]}...")

# Initialize global token cache
token_cache = TokenCache()

def get_azure_token_cached(tenant_id: str, client_id: str, client_secret: str, 
                          scope: str = "https://cognitiveservices.azure.com/.default") -> Optional[str]:
    """
    Get an Azure AD token with caching support.
    This function first checks the cache before making a new token request.
    
    Args:
        tenant_id: Azure tenant ID
        client_id: Azure client ID
        client_secret: Azure client secret
        scope: OAuth scope to request
        
    Returns:
        Access token if successful, None otherwise
    """
    # Check cache first
    token = token_cache.get(tenant_id, client_id, scope)
    if token:
        return token
    
    # Cache miss - get new token
    try:
        logger.info(f"Token cache miss for {client_id[:8]}... - fetching new token")
        
        # OAuth2 token endpoint
        token_url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
        
        # Request body
        data = {
            "client_id": client_id,
            "client_secret": client_secret,
            "scope": scope,
            "grant_type": "client_credentials"
        }
        
        # Make the request
        response = requests.post(
            token_url, 
            data=data,
            timeout=30
        )
        
        # Handle response
        if response.status_code == 200:
            token_data = response.json()
            if "access_token" in token_data:
                token = token_data["access_token"]
                expires_in = token_data.get("expires_in", 3600)  # Default to 1 hour
                
                # Cache the token
                token_cache.set(tenant_id, client_id, scope, token, expires_in)
                
                logger.info(f"New token acquired and cached (expires in {expires_in}s)")
                return token
            else:
                logger.error("Token response did not contain access_token")
                return None
        else:
            logger.error(f"Token request failed with status {response.status_code}: {response.text}")
            return None
            
    except Exception as e:
        logger.error(f"Error getting Azure token: {e}")
        return None

# Original function (kept for backward compatibility)
def get_azure_token_manual(tenant_id: str, client_id: str, client_secret: str, 
                          scope: str = "https://cognitiveservices.azure.com/.default") -> Optional[str]:
    """
    Manually get an Azure AD token using requests instead of the Azure SDK.
    This function is kept for backward compatibility - use get_azure_token_cached instead.
    
    Args:
        tenant_id: Azure tenant ID
        client_id: Azure client ID
        client_secret: Azure client secret
        scope: OAuth scope to request
        
    Returns:
        Access token if successful, None otherwise
    """
    return get_azure_token_cached(tenant_id, client_id, client_secret, scope)
