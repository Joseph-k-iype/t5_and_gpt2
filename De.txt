// frontend/src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

// frontend/src/reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

// frontend/src/hooks/useWebSocket.js
import { useEffect, useRef, useState, useCallback } from 'react';
import { useSession } from './useSession';

export const useWebSocket = () => {
  const { sessionId } = useSession();
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  const [error, setError] = useState(null);
  const wsRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  const wsUrl = `${process.env.REACT_APP_WS_URL || 'ws://localhost:8000'}/ws/${sessionId}`;

  const connect = useCallback(() => {
    if (!sessionId || wsRef.current?.readyState === WebSocket.OPEN) {
      return;
    }

    try {
      wsRef.current = new WebSocket(wsUrl);

      wsRef.current.onopen = () => {
        console.log('✅ WebSocket connected');
        setIsConnected(true);
        setError(null);
        reconnectAttempts.current = 0;
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          setLastMessage(data);
        } catch (err) {
          console.error('Error parsing WebSocket message:', err);
        }
      };

      wsRef.current.onclose = (event) => {
        console.log('🔌 WebSocket disconnected');
        setIsConnected(false);
        
        // Attempt to reconnect if not a normal closure
        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {
          const timeout = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttempts.current++;
            connect();
          }, timeout);
        }
      };

      wsRef.current.onerror = (event) => {
        console.error('❌ WebSocket error:', event);
        setError('WebSocket connection failed');
      };

    } catch (err) {
      console.error('Error creating WebSocket connection:', err);
      setError(err.message);
    }
  }, [sessionId, wsUrl]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (wsRef.current) {
      wsRef.current.close(1000, 'Component unmounting');
      wsRef.current = null;
    }
    
    setIsConnected(false);
  }, []);

  const sendMessage = useCallback((message) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
      return true;
    }
    return false;
  }, []);

  // Connect when sessionId is available
  useEffect(() => {
    if (sessionId) {
      connect();
    }
    
    return disconnect;
  }, [sessionId, connect, disconnect]);

  // Cleanup on unmount
  useEffect(() => {
    return disconnect;
  }, [disconnect]);

  return {
    isConnected,
    lastMessage,
    error,
    sendMessage,
    connect,
    disconnect,
  };
};

// frontend/src/utils/knowledgeGraphUtils.js
export const layoutNodes = (nodes, layoutType = 'force') => {
  switch (layoutType) {
    case 'circle':
      return layoutCircle(nodes);
    case 'grid':
      return layoutGrid(nodes);
    case 'hierarchy':
      return layoutHierarchy(nodes);
    case 'force':
    default:
      return layoutForce(nodes);
  }
};

const layoutCircle = (nodes) => {
  const radius = Math.max(150, nodes.length * 20);
  const centerX = 300;
  const centerY = 200;

  return nodes.map((node, index) => {
    const angle = (index * 2 * Math.PI) / nodes.length;
    return {
      ...node,
      position: {
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
      },
    };
  });
};

const layoutGrid = (nodes) => {
  const cols = Math.ceil(Math.sqrt(nodes.length));
  const nodeWidth = 120;
  const nodeHeight = 100;

  return nodes.map((node, index) => {
    const row = Math.floor(index / cols);
    const col = index % cols;
    return {
      ...node,
      position: {
        x: 50 + col * nodeWidth,
        y: 50 + row * nodeHeight,
      },
    };
  });
};

const layoutHierarchy = (nodes) => {
  // Simple hierarchical layout based on node types
  const levels = {};
  nodes.forEach((node) => {
    const type = node.data?.type || 'default';
    if (!levels[type]) {
      levels[type] = [];
    }
    levels[type].push(node);
  });

  const levelKeys = Object.keys(levels);
  const levelHeight = 120;
  let result = [];

  levelKeys.forEach((levelKey, levelIndex) => {
    const levelNodes = levels[levelKey];
    const nodeWidth = 150;
    const startX = 50;

    levelNodes.forEach((node, nodeIndex) => {
      result.push({
        ...node,
        position: {
          x: startX + nodeIndex * nodeWidth,
          y: 50 + levelIndex * levelHeight,
        },
      });
    });
  });

  return result;
};

const layoutForce = (nodes) => {
  // Simple force-directed layout simulation
  const width = 600;
  const height = 400;
  
  // Initialize with random positions
  let positions = nodes.map(() => ({
    x: Math.random() * width,
    y: Math.random() * height,
    vx: 0,
    vy: 0,
  }));

  // Run simple simulation
  for (let i = 0; i < 100; i++) {
    // Repulsion between nodes
    for (let j = 0; j < positions.length; j++) {
      for (let k = j + 1; k < positions.length; k++) {
        const dx = positions[k].x - positions[j].x;
        const dy = positions[k].y - positions[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
        
        if (distance < 100) {
          const force = (100 - distance) / distance * 0.1;
          positions[j].vx -= (dx / distance) * force;
          positions[j].vy -= (dy / distance) * force;
          positions[k].vx += (dx / distance) * force;
          positions[k].vy += (dy / distance) * force;
        }
      }
    }

    // Center attraction
    for (let j = 0; j < positions.length; j++) {
      const centerX = width / 2;
      const centerY = height / 2;
      positions[j].vx += (centerX - positions[j].x) * 0.001;
      positions[j].vy += (centerY - positions[j].y) * 0.001;
    }

    // Apply velocities
    for (let j = 0; j < positions.length; j++) {
      positions[j].x += positions[j].vx;
      positions[j].y += positions[j].vy;
      positions[j].vx *= 0.9; // Damping
      positions[j].vy *= 0.9;
    }
  }

  return nodes.map((node, index) => ({
    ...node,
    position: {
      x: Math.max(50, Math.min(width - 50, positions[index].x)),
      y: Math.max(50, Math.min(height - 50, positions[index].y)),
    },
  }));
};

export const getNodeStyle = (node) => {
  const baseStyle = {
    padding: '8px 12px',
    borderRadius: '8px',
    border: '2px solid',
    fontSize: '12px',
    fontWeight: '500',
    textAlign: 'center',
    minWidth: '80px',
  };

  const typeStyles = {
    'domain_term': {
      backgroundColor: '#fee2e2',
      borderColor: '#dc2626',
      color: '#7f1d1d',
    },
    'proper_noun': {
      backgroundColor: '#dbeafe',
      borderColor: '#2563eb',
      color: '#1e3a8a',
    },
    'acronym': {
      backgroundColor: '#f3e8ff',
      borderColor: '#7c3aed',
      color: '#581c87',
    },
    'quoted_term': {
      backgroundColor: '#fed7aa',
      borderColor: '#ea580c',
      color: '#9a3412',
    },
    'concept': {
      backgroundColor: '#dcfce7',
      borderColor: '#16a34a',
      color: '#14532d',
    },
    'default': {
      backgroundColor: '#f1f5f9',
      borderColor: '#64748b',
      color: '#334155',
    },
  };

  const nodeType = node.data?.type || 'default';
  return {
    ...baseStyle,
    ...typeStyles[nodeType],
  };
};

export const getEdgeStyle = (edge) => {
  const weight = edge.data?.weight || 0.5;
  
  return {
    strokeWidth: Math.max(1, weight * 4),
    stroke: weight > 0.7 ? '#059669' : weight > 0.4 ? '#0891b2' : '#64748b',
    strokeOpacity: Math.max(0.3, weight),
  };
};

export const filterGraphByConfidence = (nodes, edges, minConfidence = 0.5) => {
  const filteredNodes = nodes.filter(node => {
    const confidence = node.data?.properties?.confidence || node.data?.confidence || 1;
    return confidence >= minConfidence;
  });

  const nodeIds = new Set(filteredNodes.map(node => node.id));
  const filteredEdges = edges.filter(edge => 
    nodeIds.has(edge.source) && nodeIds.has(edge.target)
  );

  return { nodes: filteredNodes, edges: filteredEdges };
};

export const searchGraph = (nodes, edges, searchTerm) => {
  if (!searchTerm.trim()) {
    return { nodes, edges };
  }

  const term = searchTerm.toLowerCase();
  
  const matchingNodes = nodes.filter(node => 
    node.data?.label?.toLowerCase().includes(term) ||
    node.data?.type?.toLowerCase().includes(term)
  );

  const matchingNodeIds = new Set(matchingNodes.map(node => node.id));
  
  // Also include connected nodes
  const connectedNodeIds = new Set();
  edges.forEach(edge => {
    if (matchingNodeIds.has(edge.source)) {
      connectedNodeIds.add(edge.target);
    }
    if (matchingNodeIds.has(edge.target)) {
      connectedNodeIds.add(edge.source);
    }
  });

  const resultNodes = nodes.filter(node => 
    matchingNodeIds.has(node.id) || connectedNodeIds.has(node.id)
  );

  const resultNodeIds = new Set(resultNodes.map(node => node.id));
  const resultEdges = edges.filter(edge =>
    resultNodeIds.has(edge.source) && resultNodeIds.has(edge.target)
  );

  return { nodes: resultNodes, edges: resultEdges };
};

// frontend/src/utils/analytics.js
class Analytics {
  constructor() {
    this.events = [];
    this.sessionStart = Date.now();
    this.isEnabled = process.env.NODE_ENV === 'production';
  }

  track(eventName, properties = {}) {
    if (!this.isEnabled) {
      console.log('📊 Analytics Event:', eventName, properties);
      return;
    }

    const event = {
      name: eventName,
      properties: {
        ...properties,
        timestamp: new Date().toISOString(),
        sessionId: localStorage.getItem('research_session_id'),
        userId: localStorage.getItem('research_user_id'),
        userAgent: navigator.userAgent,
        url: window.location.pathname,
      },
    };

    this.events.push(event);

    // Send to analytics service (implement as needed)
    this.sendToAnalytics(event);
  }

  async sendToAnalytics(event) {
    try {
      // Replace with your analytics endpoint
      await fetch('/api/analytics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(event),
      });
    } catch (error) {
      console.error('Failed to send analytics event:', error);
    }
  }

  // Pre-defined event tracking methods
  trackPageView(page) {
    this.track('page_view', { page });
  }

  trackChatMessage(messageType, messageLength) {
    this.track('chat_message', {
      type: messageType,
      length: messageLength,
    });
  }

  trackResearchStart(topic) {
    this.track('research_start', {
      topic: topic.slice(0, 100), // Truncate for privacy
    });
  }

  trackResearchComplete(duration, confidence, agentsUsed) {
    this.track('research_complete', {
      duration,
      confidence,
      agents_count: agentsUsed.length,
    });
  }

  trackKnowledgeGraphGeneration(nodeCount, edgeCount) {
    this.track('knowledge_graph_generated', {
      node_count: nodeCount,
      edge_count: edgeCount,
    });
  }

  trackError(error, context) {
    this.track('error', {
      message: error.message,
      stack: error.stack?.slice(0, 500),
      context,
    });
  }

  trackPerformance(metric, value) {
    this.track('performance', {
      metric,
      value,
    });
  }

  getSessionStats() {
    const sessionDuration = Date.now() - this.sessionStart;
    const eventCounts = this.events.reduce((acc, event) => {
      acc[event.name] = (acc[event.name] || 0) + 1;
      return acc;
    }, {});

    return {
      sessionDuration,
      totalEvents: this.events.length,
      eventCounts,
    };
  }
}

export const analytics = new Analytics();

// Error boundary with analytics
export const trackError = (error, errorInfo, context = {}) => {
  console.error('Application Error:', error, errorInfo);
  
  analytics.trackError(error, {
    ...context,
    errorInfo: errorInfo?.componentStack?.slice(0, 500),
  });
};

// Performance tracking
export const trackPerformance = (name, fn) => {
  const start = performance.now();
  
  const result = fn();
  
  if (result instanceof Promise) {
    return result.finally(() => {
      const duration = performance.now() - start;
      analytics.trackPerformance(name, duration);
    });
  } else {
    const duration = performance.now() - start;
    analytics.trackPerformance(name, duration);
    return result;
  }
};

// frontend/src/setupTests.js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

// Mock IntersectionObserver
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
};

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
  constructor() {}
  disconnect() {}
  observe() {}
  unobserve() {}
};

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // deprecated
    removeListener: jest.fn(), // deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});

// frontend/public/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#1a1a1a" />
    <meta
      name="description"
      content="Deep Research Chatbot - AI-powered research assistant for privacy and legal compliance"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    
    <!-- Preconnect to Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <title>Deep Research Chatbot</title>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://research-chatbot.example.com/" />
    <meta property="og:title" content="Deep Research Chatbot" />
    <meta property="og:description" content="AI-powered research assistant for privacy and legal compliance" />
    <meta property="og:image" content="%PUBLIC_URL%/og-image.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://research-chatbot.example.com/" />
    <meta property="twitter:title" content="Deep Research Chatbot" />
    <meta property="twitter:description" content="AI-powered research assistant for privacy and legal compliance" />
    <meta property="twitter:image" content="%PUBLIC_URL%/twitter-image.png" />
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

// frontend/public/manifest.json
{
  "short_name": "Deep Research",
  "name": "Deep Research Chatbot",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#1a1a1a",
  "background_color": "#fffef7"
}
