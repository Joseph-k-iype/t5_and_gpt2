"""
ODRL Rule Generator - Creates ODRL policies from extracted components

UPDATED:
- Removed assigner and assignee fields from permissions/prohibitions/duties
- Enhanced comment generation for detailed explanations
- Action taxonomy validation to ensure only: share, store, process, update, create
- Handles both string and dictionary duty formats

Location: src/generators/odrl_rule_generator.py
"""

import logging
import uuid
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

logger = logging.getLogger(__name__)


class ODRLRuleGenerator:
    """Generates ODRL policies from extracted rule components."""
    
    # Standard action taxonomy - ONLY these actions are permitted
    STANDARD_ACTIONS = {
        "share", "store", "process", "update", "create"
    }
    
    # ODRL namespace and standard actions - STRICTLY ENFORCED
    ODRL_NAMESPACE = "http://www.w3.org/ns/odrl/2/"
    ODRL_ACTIONS = {
        "share": "http://www.w3.org/ns/odrl/2/distribute",
        "store": "http://www.w3.org/ns/odrl/2/archive",
        "process": "http://www.w3.org/ns/odrl/2/use",
        "update": "http://www.w3.org/ns/odrl/2/modify",
        "create": "http://www.w3.org/ns/odrl/2/derive"
    }
    
    # Comprehensive synonym mapping - MUST map to one of 5 standard actions
    ACTION_SYNONYMS = {
        # Share synonyms
        "share": "share",
        "distribute": "share",
        "transfer": "share",
        "disclose": "share",
        "transmit": "share",
        "send": "share",
        "communicate": "share",
        "provide": "share",
        "give": "share",
        "forward": "share",
        
        # Store synonyms
        "store": "store",
        "archive": "store",
        "retain": "store",
        "keep": "store",
        "maintain": "store",
        "hold": "store",
        "save": "store",
        "preserve": "store",
        
        # Process synonyms
        "process": "process",
        "use": "process",
        "analyze": "process",
        "transform": "process",
        "modify": "process",
        "manipulate": "process",
        "handle": "process",
        "execute": "process",
        "apply": "process",
        "implement": "process",
        "perform": "process",
        
        # Update synonyms
        "update": "update",
        "change": "update",
        "amend": "update",
        "revise": "update",
        "alter": "update",
        "edit": "update",
        "correct": "update",
        "rectify": "update",
        
        # Create synonyms
        "create": "create",
        "collect": "create",
        "generate": "create",
        "produce": "create",
        "derive": "create",
        "obtain": "create",
        "gather": "create",
        "acquire": "create"
    }
    
    # ODRL operator mappings
    ODRL_OPERATORS = {
        "eq": "http://www.w3.org/ns/odrl/2/eq",
        "neq": "http://www.w3.org/ns/odrl/2/neq",
        "gt": "http://www.w3.org/ns/odrl/2/gt",
        "gteq": "http://www.w3.org/ns/odrl/2/gteq",
        "lt": "http://www.w3.org/ns/odrl/2/lt",
        "lteq": "http://www.w3.org/ns/odrl/2/lteq",
        "isAnyOf": "http://www.w3.org/ns/odrl/2/isAnyOf",
        "isAllOf": "http://www.w3.org/ns/odrl/2/isAllOf",
        "isNoneOf": "http://www.w3.org/ns/odrl/2/isNoneOf",
        "isPartOf": "http://www.w3.org/ns/odrl/2/isPartOf"
    }
    
    def __init__(self):
        """Initialize ODRL rule generator."""
        pass
    
    def validate_action(self, action: str) -> str:
        """
        Validate and normalize action to standard taxonomy.
        STRICTLY enforces the 5-action taxonomy with comprehensive synonym mapping.
        
        Args:
            action: Action to validate
            
        Returns:
            Normalized action from standard taxonomy
            
        Raises:
            ValueError: If action cannot be mapped to standard taxonomy
        """
        if not action:
            logger.warning("Empty action provided, defaulting to 'process'")
            return "process"
        
        # Clean and normalize the action string
        action_clean = action.lower().strip()
        
        # Remove any URI prefixes
        if "/" in action_clean:
            action_clean = action_clean.split("/")[-1]
        if ":" in action_clean:
            action_clean = action_clean.split(":")[-1]
        
        # Direct match in standard actions
        if action_clean in self.STANDARD_ACTIONS:
            return action_clean
        
        # Check comprehensive synonym mapping
        if action_clean in self.ACTION_SYNONYMS:
            mapped_action = self.ACTION_SYNONYMS[action_clean]
            if action_clean != mapped_action:  # Only log if mapping occurred
                logger.info(f"Mapped action '{action}' → '{mapped_action}'")
            return mapped_action
        
        # If no mapping found, try to infer from partial matches
        action_lower = action_clean.replace("_", " ").replace("-", " ")
        
        # Check if any synonym contains or is contained in the action
        for synonym, standard_action in self.ACTION_SYNONYMS.items():
            if synonym in action_lower or action_lower in synonym:
                logger.info(f"Inferred action '{action}' → '{standard_action}' (via '{synonym}')")
                return standard_action
        
        # Last resort: default to process and log warning
        logger.warning(f"Unknown action '{action}', defaulting to 'process'. Please add mapping to ACTION_SYNONYMS.")
        return "process"
    
    def generate_detailed_comment(
        self, 
        rule_type: str, 
        action: str, 
        target: str, 
        constraints: List[Dict[str, Any]] = None,
        existing_description: str = None
    ) -> str:
        """
        Generate detailed, grammatically correct comment for lawyers and non-lawyers.
        
        Ensures comments are:
        - Complete sentences
        - 2-3+ sentences minimum
        - Grammatically correct
        - Understandable by non-lawyers
        - Include legal context for lawyers
        
        Args:
            rule_type: 'permission', 'prohibition', or 'duty'
            action: The action being performed (from standard taxonomy)
            target: What the action applies to
            constraints: List of constraints
            existing_description: Existing description if any
            
        Returns:
            Detailed, grammatically correct comment (2-3+ sentences)
        """
        # Validate action first
        action = self.validate_action(action)
        
        # If we have a good existing description, use it
        if existing_description and len(existing_description) > 100 and existing_description[0].isupper() and existing_description.endswith('.'):
            return existing_description
        
        # Clean target description
        target_clean = target.replace("urn:data:", "").replace("_", " ").strip()
        if not target_clean:
            target_clean = "data"
        
        # Generate based on rule type
        if rule_type == "permission":
            comment = self._generate_permission_comment(action, target_clean, constraints)
        elif rule_type == "prohibition":
            comment = self._generate_prohibition_comment(action, target_clean, constraints)
        elif rule_type == "duty":
            comment = self._generate_duty_comment(action, target_clean, constraints)
        else:
            comment = f"This rule applies to {target_clean} and requires specific actions to be taken in accordance with data protection requirements."
        
        # Ensure comment ends with period
        if not comment.endswith('.'):
            comment += '.'
        
        # Ensure comment starts with capital letter
        if comment and not comment[0].isupper():
            comment = comment[0].upper() + comment[1:]
        
        return comment
    
    def _generate_permission_comment(self, action: str, target: str, constraints: List[Dict[str, Any]] = None) -> str:
        """Generate permission comment."""
        # Action descriptions
        action_descriptions = {
            "share": "shared with third parties or transferred to other organizations",
            "store": "retained and stored in organizational systems",
            "process": "analyzed, used, or otherwise processed",
            "update": "modified, corrected, or amended",
            "create": "collected, generated, or derived from other sources"
        }
        
        action_desc = action_descriptions.get(action, "processed")
        
        comment = f"This permission allows {target} to be {action_desc} under specific conditions. "
        
        if constraints:
            constraint_count = len(constraints)
            if constraint_count == 1:
                comment += "One specific condition must be satisfied before this action can be performed. "
            else:
                comment += f"All {constraint_count} specified conditions must be satisfied before this action can be performed. "
            
            comment += f"Organizations must verify that all requirements are met before {action}ing {target}, and must maintain records of compliance verification."
        else:
            comment += f"Organizations must ensure that appropriate legal basis exists and that all general data protection principles are upheld when {action}ing {target}."
        
        return comment
    
    def _generate_prohibition_comment(self, action: str, target: str, constraints: List[Dict[str, Any]] = None) -> str:
        """Generate prohibition comment."""
        # Action descriptions
        action_descriptions = {
            "share": "shared, transferred, or disclosed",
            "store": "retained, stored, or archived",
            "process": "used, analyzed, or processed",
            "update": "modified, changed, or amended",
            "create": "collected, generated, or created"
        }
        
        action_desc = action_descriptions.get(action, "processed")
        
        comment = f"This prohibition forbids {target} from being {action_desc} under specified circumstances. "
        
        if constraints:
            constraint_count = len(constraints)
            comment += f"The prohibition applies when specific conditions are met. "
            comment += f"Organizations must ensure that {target} is never {action_desc} under these prohibited conditions, as doing so would violate data protection requirements and could result in regulatory penalties."
        else:
            comment += f"The prohibition is absolute and applies in all cases. Organizations must never {action} {target} under any circumstances."
        
        return comment
    
    def _generate_duty_comment(self, action: str, target: str, constraints: List[Dict[str, Any]] = None) -> str:
        """Generate duty comment."""
        # Action descriptions
        action_descriptions = {
            "share": "provide notification or disclosure of",
            "store": "maintain records of",
            "process": "implement appropriate measures for",
            "update": "regularly review and update",
            "create": "establish and document"
        }
        
        action_desc = action_descriptions.get(action, "take appropriate action regarding")
        
        comment = f"This duty requires organizations to {action_desc} {target} to fulfill compliance obligations. "
        
        if constraints:
            constraint_count = len(constraints)
            if constraint_count == 1:
                comment += "The duty must be fulfilled under the specified condition. "
            else:
                comment += f"The duty must be fulfilled when any of the {constraint_count} specified conditions apply. "
        
        comment += f"Failure to fulfill this duty may result in non-compliance with data protection requirements and could expose the organization to regulatory enforcement actions."
        
        return comment
    
    def generate_policy(
        self, 
        rules: List[Any] = None,
        policy_uid: str = None,
        policy_type: str = "Set",
        # CSV/Excel converter parameters
        policy_id: str = None,
        rule_name: str = None,
        odrl_components: Any = None,
        framework_type: str = None,
        restriction_condition: str = None,
        data_category_uuids: Dict[str, str] = None,
        # Additional parameters for PDF processing
        entry_id: str = None,
        parent_title: str = None,
        countries: List[str] = None,
        adequacy_countries: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate complete ODRL policy from rules OR from ODRL components.
        
        Supports two calling patterns:
        1. PDF Processing: generate_policy(rules=..., policy_uid=..., entry_id=..., parent_title=...)
        2. CSV/Excel Processing: generate_policy(policy_id=..., rule_name=..., odrl_components=...)
        
        Args:
            rules: List of Rule objects (for PDF processing)
            policy_uid: Optional policy UID, will be generated if not provided
            policy_type: ODRL policy type (Set, Offer, Agreement)
            policy_id: Unique identifier for the policy (for CSV/Excel)
            rule_name: Human-readable rule name (for CSV/Excel)
            odrl_components: Extracted ODRL components (for CSV/Excel)
            framework_type: DSS or DataVISA (for CSV/Excel)
            restriction_condition: restriction or condition (for CSV/Excel)
            data_category_uuids: Mapping of data category names to UUIDs
            entry_id: Parent entry ID from legislation_metadata.json (for PDF)
            parent_title: Parent entry title to use as dc:title (for PDF)
            countries: List of applicable countries (for PDF)
            adequacy_countries: List of adequacy countries (for PDF)
            
        Returns:
            Complete ODRL policy dictionary
        """
        # Determine which calling pattern is being used
        if odrl_components is not None:
            # CSV/Excel processing pattern
            return self._generate_policy_from_components(
                policy_id=policy_id,
                rule_name=rule_name,
                odrl_components=odrl_components,
                framework_type=framework_type,
                restriction_condition=restriction_condition,
                data_category_uuids=data_category_uuids
            )
        else:
            # PDF processing pattern
            return self._generate_policy_from_rules(
                rules=rules,
                policy_uid=policy_uid,
                policy_type=policy_type,
                entry_id=entry_id,
                parent_title=parent_title,
                countries=countries,
                adequacy_countries=adequacy_countries
            )
    
    def _generate_policy_from_rules(
        self,
        rules: List[Any],
        policy_uid: str = None,
        policy_type: str = "Set",
        entry_id: str = None,
        parent_title: str = None,
        countries: List[str] = None,
        adequacy_countries: List[str] = None
    ) -> Dict[str, Any]:
        """
        Generate ODRL policy from rules (PDF processing).
        
        Uses parent entry_id from legislation_metadata.json as both identifier and title.
        ONE UUID per parent entry (not _1, _2, _3).
        
        Args:
            entry_id: The key from legislation_metadata.json (e.g., "Data minimization and proportionality")
            parent_title: Optional override for title (defaults to entry_id)
            
        Returns:
            ODRL policy with single UUID for entire parent entry
        """
        # Use entry_id as the policy UID (single UUID per parent entry)
        # This ensures all level_1, level_2, level_3 files are under ONE policy
        if policy_uid is None:
            if entry_id:
                # Create URL-safe identifier but use original entry_id for display
                safe_id = entry_id.replace(" ", "_").replace("/", "_")
                policy_uid = f"urn:policy:{safe_id}"
            else:
                policy_uid = f"urn:uuid:{uuid.uuid4()}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "dpv": "https://w3id.org/dpv#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "actions": "https://w3id.org/dpv/actions#"
            },
            "@type": f"odrl:{policy_type}",
            "uid": policy_uid,
            "profile": "http://www.w3.org/ns/odrl/2/core"
        }
        
        # Add metadata
        policy["dct:created"] = datetime.now().isoformat()
        policy["dct:creator"] = "Legislation Analysis System"
        
        # Use entry_id as title (e.g., "Data minimization and proportionality")
        # This is the KEY from legislation_metadata.json
        if parent_title:
            policy["dc:title"] = parent_title
        elif entry_id:
            policy["dc:title"] = entry_id  # Use original entry_id, not modified
        else:
            policy["dc:title"] = "Legislation Policy"
        
        # Add description with country information
        if entry_id and countries:
            country_str = ", ".join(countries)
            policy["dc:description"] = f"Data protection and privacy policy for {entry_id} applicable in {country_str}."
        else:
            policy["dc:description"] = "Data protection and privacy policy derived from legislation analysis."
        
        # Add geographic coverage
        if countries:
            policy["dc:coverage"] = countries
        
        # Add adequacy countries if provided
        if adequacy_countries:
            policy["custom:adequacyCountries"] = adequacy_countries
        
        # Add entry_id as identifier (original key from JSON)
        if entry_id:
            policy["dc:identifier"] = entry_id
        
        all_permissions = []
        all_prohibitions = []
        
        # Process each rule - ALL rules go into ONE policy
        for rule in rules:
            # Extract permissions from rule
            if hasattr(rule, 'permissions') and rule.permissions:
                for perm in rule.permissions:
                    odrl_perm = self._create_permission(perm)
                    if odrl_perm:
                        all_permissions.append(odrl_perm)
            
            # Extract prohibitions from rule
            if hasattr(rule, 'prohibitions') and rule.prohibitions:
                for prohib in rule.prohibitions:
                    odrl_prohib = self._create_prohibition(prohib)
                    if odrl_prohib:
                        all_prohibitions.append(odrl_prohib)
        
        # Add to policy
        if all_permissions:
            policy["permission"] = all_permissions
        if all_prohibitions:
            policy["prohibition"] = all_prohibitions
        
        return policy
    
    def _generate_policy_from_components(
        self,
        policy_id: str,
        rule_name: str,
        odrl_components: Any,
        framework_type: str,
        restriction_condition: str,
        data_category_uuids: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """
        Generate ODRL policy from ODRL components (CSV/Excel processing).
        """
        policy_uid = f"urn:policy:{policy_id}"
        
        policy = {
            "@context": {
                "odrl": "http://www.w3.org/ns/odrl/2/",
                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                "dc": "http://purl.org/dc/elements/1.1/",
                "dct": "http://purl.org/dc/terms/",
                "xsd": "http://www.w3.org/2001/XMLSchema#",
                "custom": "http://example.org/custom#"
            },
            "@type": "odrl:Policy",
            "uid": policy_uid,
            "profile": f"urn:profile:{framework_type.lower()}",
            "dc:title": rule_name,
            "dc:description": f"{framework_type} {restriction_condition}: {rule_name}",
            "dc:created": datetime.now().isoformat(),
            "dc:identifier": policy_id
        }
        
        # Add permissions
        if odrl_components.permissions:
            permissions = []
            for perm in odrl_components.permissions:
                odrl_perm = self._create_permission(perm, data_category_uuids)
                if odrl_perm:
                    permissions.append(odrl_perm)
            
            if permissions:
                policy["permission"] = permissions
        
        # Add prohibitions
        if odrl_components.prohibitions:
            prohibitions = []
            for prohib in odrl_components.prohibitions:
                odrl_prohib = self._create_prohibition(prohib, data_category_uuids)
                if odrl_prohib:
                    prohibitions.append(odrl_prohib)
            
            if prohibitions:
                policy["prohibition"] = prohibitions
        
        # Add metadata about data categories
        if odrl_components.data_categories:
            policy["dc:subject"] = odrl_components.data_categories
        
        # Add geographic scope
        if odrl_components.geographic_scope:
            policy["dc:coverage"] = odrl_components.geographic_scope
        
        # Add purpose if specified
        if odrl_components.purpose:
            policy["dc:purpose"] = odrl_components.purpose
        
        # Add custom metadata
        policy["custom:framework"] = framework_type
        policy["custom:type"] = restriction_condition
        policy["custom:confidenceScore"] = odrl_components.confidence_score
        
        if data_category_uuids:
            policy["custom:dataCategoryUUIDs"] = data_category_uuids
        
        return policy
    
    def _get_action_uri(self, action: str) -> str:
        """
        Get action URI, validating against standard taxonomy.
        STRICTLY returns only one of 5 standard actions.
        
        Args:
            action: Action name
            
        Returns:
            Action URI using custom namespace with our taxonomy
        """
        # Validate and normalize action first
        normalized_action = self.validate_action(action)
        
        # Return corresponding URI using our taxonomy
        action_uri = self.ODRL_ACTIONS.get(normalized_action)
        
        if not action_uri:
            # Should never happen after validation, but safety check
            logger.error(f"Action '{normalized_action}' not in standard taxonomy, defaulting to Process")
            action_uri = self.ODRL_ACTIONS["process"]
        
        return action_uri
    
    def _create_asset_reference(self, target: str) -> str:
        """
        Create asset/target reference.
        
        Args:
            target: Target description
            
        Returns:
            Asset URI or description
        """
        if not target:
            return "urn:data:unspecified"
        
        # If it looks like a URI, use it
        if target.startswith("http://") or target.startswith("https://") or target.startswith("urn:"):
            return target
        
        # Otherwise create a URN from the description
        safe_target = target.replace(" ", "_").replace("/", "_")
        return f"urn:data:{safe_target}"
    
    def _create_permission(
        self, 
        permission: Dict[str, Any],
        data_category_uuids: Dict[str, str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL permission from extracted permission data.
        
        UPDATED: Removed assigner and assignee fields
        """
        try:
            odrl_permission = {}
            
            # Add action (validated)
            action = permission.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_permission["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_permission["action"] = self.ODRL_ACTIONS["process"]
            
            # Add target (asset)
            target = permission.get("target", "data")
            odrl_permission["target"] = self._create_asset_reference(target)
            
            # NOTE: Assigner and assignee fields REMOVED
            # Focus on the action and conditions, not who grants permission
            
            # Add constraints
            constraints = permission.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_permission["constraint"] = odrl_constraints
            
            # Add duties
            duties = permission.get("duties", [])
            if duties:
                odrl_duties = []
                for duty in duties:
                    odrl_duty = self._create_duty(duty)
                    if odrl_duty:
                        odrl_duties.append(odrl_duty)
                
                if odrl_duties:
                    odrl_permission["duty"] = odrl_duties
            
            # Add detailed description as comment
            description = permission.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self.generate_detailed_comment(
                    "permission",
                    permission.get("action", "process"),
                    target,
                    constraints,
                    description
                )
            
            odrl_permission["rdfs:comment"] = description
            
            return odrl_permission
        
        except Exception as e:
            logger.error(f"Error creating permission: {e}")
            logger.error(f"Permission data: {permission}")
            return None
    
    def _create_prohibition(
        self, 
        prohibition: Dict[str, Any],
        data_category_uuids: Dict[str, str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Create ODRL prohibition from extracted prohibition data.
        
        UPDATED: Removed assigner and assignee fields
        """
        try:
            odrl_prohibition = {}
            
            # Add action (validated)
            action = prohibition.get("action")
            if action:
                action_uri = self._get_action_uri(action)
                odrl_prohibition["action"] = action_uri
            else:
                # Default to 'process' if no action specified
                odrl_prohibition["action"] = self.ODRL_ACTIONS["process"]
            
            # Add target (asset)
            target = prohibition.get("target", "data")
            odrl_prohibition["target"] = self._create_asset_reference(target)
            
            # NOTE: Assigner and assignee fields REMOVED
            
            # Add constraints
            constraints = prohibition.get("constraints", [])
            if constraints:
                odrl_constraints = []
                for constraint in constraints:
                    odrl_constraint = self._create_constraint(constraint)
                    if odrl_constraint:
                        odrl_constraints.append(odrl_constraint)
                
                if odrl_constraints:
                    odrl_prohibition["constraint"] = odrl_constraints
            
            # Add detailed description as comment
            description = prohibition.get("description")
            if not description or len(description) < 50:
                # Generate detailed comment if not provided or too short
                description = self.generate_detailed_comment(
                    "prohibition",
                    prohibition.get("action", "process"),
                    target,
                    constraints,
                    description
                )
            
            odrl_prohibition["rdfs:comment"] = description
            
            return odrl_prohibition
        
        except Exception as e:
            logger.error(f"Error creating prohibition: {e}")
            logger.error(f"Prohibition data: {prohibition}")
            return None
    
    def _create_duty(self, duty: Union[str, Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Create ODRL duty.
        
        UPDATED: Removed assigner and assignee fields
        Handles both string descriptions and structured duty dictionaries
        
        Args:
            duty: Either a string description or a dictionary with action, target, etc.
            
        Returns:
            ODRL duty dictionary
        """
        try:
            odrl_duty = {}
            
            # Handle string duties (simple descriptions)
            if isinstance(duty, str):
                # Infer action from description or use default
                duty_lower = duty.lower()
                inferred_action = "process"  # Default
                
                # Try to infer action from string
                if any(word in duty_lower for word in ["notify", "inform", "communicate"]):
                    inferred_action = "share"
                elif any(word in duty_lower for word in ["document", "record", "log", "maintain"]):
                    inferred_action = "store"
                elif any(word in duty_lower for word in ["obtain", "collect", "get"]):
                    inferred_action = "create"
                elif any(word in duty_lower for word in ["update", "correct", "amend"]):
                    inferred_action = "update"
                
                odrl_duty["action"] = self._get_action_uri(inferred_action)
                odrl_duty["rdfs:comment"] = duty
                
                return odrl_duty
            
            # Handle dictionary duties (structured)
            elif isinstance(duty, dict):
                # Add action (validated)
                action = duty.get("action")
                if action:
                    action_uri = self._get_action_uri(action)
                    odrl_duty["action"] = action_uri
                else:
                    odrl_duty["action"] = self.ODRL_ACTIONS["process"]
                
                # Add target if present
                target = duty.get("target")
                if target:
                    odrl_duty["target"] = self._create_asset_reference(target)
                
                # NOTE: Assigner and assignee fields REMOVED
                
                # Add constraints if present
                constraints = duty.get("constraints", [])
                if constraints:
                    odrl_constraints = []
                    for constraint in constraints:
                        odrl_constraint = self._create_constraint(constraint)
                        if odrl_constraint:
                            odrl_constraints.append(odrl_constraint)
                    
                    if odrl_constraints:
                        odrl_duty["constraint"] = odrl_constraints
                
                # Add detailed description as comment
                description = duty.get("description")
                if not description or len(description) < 50:
                    # Generate detailed comment if not provided or too short
                    description = self.generate_detailed_comment(
                        "duty",
                        duty.get("action", "process"),
                        target or "data",
                        constraints,
                        description
                    )
                
                odrl_duty["rdfs:comment"] = description
                
                return odrl_duty
            
            else:
                logger.warning(f"Duty is neither string nor dict: {type(duty)}")
                return None
        
        except Exception as e:
            logger.error(f"Error creating duty: {e}")
            logger.error(f"Duty data: {duty}")
            return None
    
    def _create_constraint(self, constraint: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Create ODRL constraint."""
        try:
            odrl_constraint = {}
            
            # Left operand
            left_operand = constraint.get("leftOperand")
            if left_operand:
                if left_operand.startswith("http://"):
                    odrl_constraint["leftOperand"] = left_operand
                else:
                    odrl_constraint["leftOperand"] = f"{self.ODRL_NAMESPACE}{left_operand}"
            
            # Operator
            operator = constraint.get("operator")
            if operator:
                if operator in self.ODRL_OPERATORS:
                    odrl_constraint["operator"] = self.ODRL_OPERATORS[operator]
                else:
                    odrl_constraint["operator"] = operator
            
            # Right operand
            right_operand = constraint.get("rightOperand")
            if right_operand is not None:
                odrl_constraint["rightOperand"] = right_operand
            
            # Optional fields
            if "unit" in constraint:
                odrl_constraint["unit"] = constraint["unit"]
            
            if "dataType" in constraint:
                odrl_constraint["dataType"] = constraint["dataType"]
            
            # Add detailed description as comment
            description = constraint.get("description")
            if description:
                odrl_constraint["rdfs:comment"] = description
            
            return odrl_constraint
        
        except Exception as e:
            logger.error(f"Error creating constraint: {e}")
            return None
    
    def validate_policy(self, policy: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate ODRL policy structure.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            Validation report with issues and warnings
        """
        issues = []
        warnings = []
        
        # Check required fields
        if "@context" not in policy:
            issues.append("Missing @context")
        
        if "@type" not in policy:
            issues.append("Missing @type")
        
        if "uid" not in policy:
            issues.append("Missing uid")
        
        # Check for at least one rule
        has_permission = "permission" in policy and policy["permission"]
        has_prohibition = "prohibition" in policy and policy["prohibition"]
        
        if not has_permission and not has_prohibition:
            warnings.append("Policy has no permissions or prohibitions")
        
        # Validate permissions
        if "permission" in policy:
            for i, perm in enumerate(policy["permission"]):
                if "action" not in perm:
                    issues.append(f"Permission {i}: missing action")
                
                # Check for assigner/assignee (should be removed)
                if "assigner" in perm:
                    warnings.append(f"Permission {i}: contains 'assigner' field (should be removed)")
                if "assignee" in perm:
                    warnings.append(f"Permission {i}: contains 'assignee' field (should be removed)")
        
        # Validate prohibitions
        if "prohibition" in policy:
            for i, prohib in enumerate(policy["prohibition"]):
                if "action" not in prohib:
                    issues.append(f"Prohibition {i}: missing action")
                
                # Check for assigner/assignee (should be removed)
                if "assigner" in prohib:
                    warnings.append(f"Prohibition {i}: contains 'assigner' field (should be removed)")
                if "assignee" in prohib:
                    warnings.append(f"Prohibition {i}: contains 'assignee' field (should be removed)")
        
        return {
            "valid": len(issues) == 0,
            "issues": issues,
            "warnings": warnings
        }
    
    def convert_to_json_ld(self, policy: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert ODRL policy to JSON-LD format.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            JSON-LD formatted policy
        """
        # ODRL is already in JSON-LD format with @context
        return policy
    
    def convert_to_turtle(self, policy: Dict[str, Any]) -> str:
        """
        Convert ODRL policy to Turtle/TTL format.
        
        Args:
            policy: ODRL policy dictionary
            
        Returns:
            Turtle formatted string
        """
        try:
            from rdflib import Graph
            import json
            
            # Create RDF graph from JSON-LD
            g = Graph()
            g.parse(data=json.dumps(policy), format='json-ld')
            
            # Serialize to Turtle
            return g.serialize(format='turtle')
        
        except Exception as e:
            logger.error(f"Error converting to Turtle: {e}")
            return ""
