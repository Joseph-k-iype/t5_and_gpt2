# Add these methods to ComplianceAnalyzer class for better performance

@cache.memoize(timeout=600)  # Cache for 10 minutes
def get_summary_statistics_direct(self):
    """
    Get summary statistics DIRECTLY from database
    Much faster than loading all transfers first
    """
    logger.info("Calculating summary statistics directly from database...")
    
    # Total count
    total_query = "MATCH (c:Case) RETURN count(c) as total"
    total_result = self.graph.query(total_query)
    total = total_result.result_set[0][0] if total_result.result_set else 0
    
    # Compliance counts by checking modules directly
    compliance_query = """
    MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
    MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
    OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
    WITH c, origin.name as origin, dest.name as dest, 
         count(pd) > 0 as has_data,
         c.pia_module as pia, c.tia_module as tia, c.hrpr_module as hrpr
    RETURN 
        origin,
        dest,
        has_data,
        pia,
        tia,
        hrpr,
        count(*) as cnt
    """
    
    result = self.graph.query(compliance_query)
    
    compliant = 0
    non_compliant = 0
    rule_counts = {}
    missing_modules = {'PIA': 0, 'TIA': 0, 'HRPR': 0}
    
    for row in result.result_set:
        origin = row[0]
        dest = row[1]
        has_data = row[2]
        pia = row[3]
        tia = row[4]
        hrpr = row[5]
        cnt = row[6]
        
        # Check compliance for this combination
        compliance = self.check_compliance_rule(
            origin, dest, pia, tia, hrpr, has_data
        )
        
        # Update counts
        if compliance['compliant']:
            compliant += cnt
        else:
            non_compliant += cnt
        
        # Rule counts
        rule = compliance['rule_matched']
        if rule:
            rule_counts[rule] = rule_counts.get(rule, 0) + cnt
        
        # Missing modules
        if 'PIA' in compliance['missing_modules']:
            missing_modules['PIA'] += cnt
        if 'TIA' in compliance['missing_modules']:
            missing_modules['TIA'] += cnt
        if 'HRPR' in compliance['missing_modules']:
            missing_modules['HRPR'] += cnt
    
    return {
        'total_transfers': total,
        'compliant': compliant,
        'non_compliant': non_compliant,
        'compliance_rate': round((compliant / total * 100), 2) if total > 0 else 0,
        'rule_counts': rule_counts,
        'missing_modules': missing_modules,
        'top_routes': []  # Can add separate query if needed
    }

@cache.memoize(timeout=600)
def get_non_compliant_cases_direct(self, limit=1000):
    """
    Get non-compliant cases directly from database
    Only fetch what's needed for display
    """
    query = """
    MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
    MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
    OPTIONAL MATCH (c)-[:HAS_PERSONAL_DATA]->(pd:PersonalData)
    WITH c, origin, dest, collect(DISTINCT pd.name) AS personal_data
    RETURN 
        c.case_id AS case_id,
        origin.name AS origin_country,
        dest.name AS destination_country,
        personal_data,
        c.pia_module AS pia_module,
        c.tia_module AS tia_module,
        c.hrpr_module AS hrpr_module
    LIMIT $limit
    """
    
    result = self.graph.query(query, params={'limit': limit})
    non_compliant = []
    
    for row in result.result_set:
        case_id = row[0]
        origin = row[1]
        destination = row[2]
        personal_data = row[3] if row[3] else []
        pia = row[4]
        tia = row[5]
        hrpr = row[6]
        
        has_personal_data = len(personal_data) > 0
        compliance = self.check_compliance_rule(
            origin, destination, pia, tia, hrpr, has_personal_data
        )
        
        # Only include if non-compliant
        if not compliance['compliant']:
            non_compliant.append({
                'case_id': case_id,
                'origin_country': origin,
                'destination_country': destination,
                'personal_data': personal_data,
                'pia_module': pia,
                'tia_module': tia,
                'hrpr_module': hrpr,
                'compliance': compliance
            })
    
    return non_compliant

@cache.memoize(timeout=600)
def get_top_routes(self, limit=20):
    """Get top transfer routes efficiently"""
    query = """
    MATCH (c:Case)-[:ORIGINATES_FROM]->(origin:Country)
    MATCH (c)-[:TRANSFERS_TO]->(dest:Jurisdiction)
    WITH origin.name as orig, dest.name as dst, count(*) as cnt
    ORDER BY cnt DESC
    LIMIT $limit
    RETURN orig, dst, cnt
    """
    
    result = self.graph.query(query, params={'limit': limit})
    routes = []
    
    for row in result.result_set:
        routes.append({
            'route': f"{row[0]} â†’ {row[1]}",
            'count': row[2]
        })
    
    return routes
