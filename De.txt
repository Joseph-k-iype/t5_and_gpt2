"""
FastAPI dependencies for the Enhanced RDF Knowledge Graph Chatbot.
"""

import logging
import time
from typing import Optional, Dict, Any, Generator, Annotated
from functools import lru_cache
from fastapi import Depends, HTTPException, Request, Header, Query
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from starlette.status import HTTP_401_UNAUTHORIZED, HTTP_429_TOO_MANY_REQUESTS

from app.core.chatbot import EnhancedRDFChatbot
from app.utils.exceptions import ChatbotException, AuthenticationError
from app.utils.validation import validate_sparql_query, sanitize_query

logger = logging.getLogger(__name__)

# Global instances
_chatbot_instance: Optional[EnhancedRDFChatbot] = None
_rate_limit_storage: Dict[str, Dict[str, Any]] = {}

# Security scheme
security = HTTPBearer(auto_error=False)

class RateLimitDependency:
    """Rate limiting dependency."""
    
    def __init__(self, calls: int = 100, period: int = 3600):  # 100 calls per hour
        self.calls = calls
        self.period = period
    
    def __call__(self, request: Request) -> bool:
        """Check rate limit for the client."""
        client_ip = self._get_client_ip(request)
        current_time = time.time()
        
        # Clean old entries
        self._cleanup_old_entries(current_time)
        
        # Get or create client entry
        if client_ip not in _rate_limit_storage:
            _rate_limit_storage[client_ip] = {
                'calls': [],
                'blocked_until': 0
            }
        
        client_data = _rate_limit_storage[client_ip]
        
        # Check if client is blocked
        if current_time < client_data['blocked_until']:
            raise HTTPException(
                status_code=HTTP_429_TOO_MANY_REQUESTS,
                detail={
                    "error": "Rate limit exceeded",
                    "retry_after": int(client_data['blocked_until'] - current_time)
                }
            )
        
        # Remove calls outside the time window
        client_data['calls'] = [
            call_time for call_time in client_data['calls']
            if current_time - call_time < self.period
        ]
        
        # Check rate limit
        if len(client_data['calls']) >= self.calls:
            # Block for the remaining period
            oldest_call = min(client_data['calls'])
            client_data['blocked_until'] = oldest_call + self.period
            
            raise HTTPException(
                status_code=HTTP_429_TOO_MANY_REQUESTS,
                detail={
                    "error": "Rate limit exceeded", 
                    "retry_after": int(client_data['blocked_until'] - current_time)
                }
            )
        
        # Record this call
        client_data['calls'].append(current_time)
        return True
    
    def _get_client_ip(self, request: Request) -> str:
        """Get client IP address."""
        # Check for forwarded headers first
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        
        return request.client.host if request.client else "unknown"
    
    def _cleanup_old_entries(self, current_time: float):
        """Clean up old rate limit entries."""
        for client_ip in list(_rate_limit_storage.keys()):
            client_data = _rate_limit_storage[client_ip]
            
            # Remove if no recent calls and not blocked
            if (not client_data['calls'] and 
                current_time > client_data.get('blocked_until', 0)):
                del _rate_limit_storage[client_ip]

# Rate limiting instances
standard_rate_limit = RateLimitDependency(calls=100, period=3600)  # 100/hour
chat_rate_limit = RateLimitDependency(calls=50, period=3600)       # 50/hour  
sparql_rate_limit = RateLimitDependency(calls=200, period=3600)    # 200/hour

@lru_cache()
def get_settings() -> Dict[str, Any]:
    """Get application settings (cached)."""
    import os
    return {
        "debug": os.getenv("DEBUG", "false").lower() == "true",
        "log_level": os.getenv("LOG_LEVEL", "INFO"),
        "max_query_length": int(os.getenv("MAX_QUERY_LENGTH", "10000")),
        "max_sparql_results": int(os.getenv("MAX_SPARQL_RESULTS", "1000")),
        "require_auth": os.getenv("REQUIRE_AUTH", "false").lower() == "true",
        "admin_api_key": os.getenv("ADMIN_API_KEY"),
    }

def get_chatbot() -> EnhancedRDFChatbot:
    """
    Get the singleton chatbot instance.
    
    Returns:
        EnhancedRDFChatbot instance
        
    Raises:
        HTTPException: If chatbot is not initialized
    """
    global _chatbot_instance
    
    if _chatbot_instance is None:
        try:
            logger.info("Initializing chatbot instance...")
            _chatbot_instance = EnhancedRDFChatbot()
            logger.info("Chatbot instance initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize chatbot: {e}")
            raise HTTPException(
                status_code=500,
                detail=f"Chatbot initialization failed: {str(e)}"
            )
    
    return _chatbot_instance

def get_authenticated_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    settings: Dict[str, Any] = Depends(get_settings)
) -> Optional[Dict[str, str]]:
    """
    Authenticate user based on API key (if authentication is required).
    
    Args:
        credentials: HTTP bearer token
        settings: Application settings
        
    Returns:
        User information if authenticated, None if auth not required
        
    Raises:
        HTTPException: If authentication fails
    """
    if not settings["require_auth"]:
        return None
    
    if not credentials:
        raise HTTPException(
            status_code=HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    token = credentials.credentials
    
    # Simple API key authentication (extend for more sophisticated auth)
    if token == settings.get("admin_api_key"):
        return {"role": "admin", "user_id": "admin"}
    
    # Add more authentication logic here (JWT, OAuth, etc.)
    raise HTTPException(
        status_code=HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"}
    )

def validate_query_parameters(
    query: str = Query(..., description="Query string"),
    settings: Dict[str, Any] = Depends(get_settings)
) -> str:
    """
    Validate and sanitize query parameters.
    
    Args:
        query: Raw query string
        settings: Application settings
        
    Returns:
        Sanitized query string
        
    Raises:
        HTTPException: If validation fails
    """
    if not query or not query.strip():
        raise HTTPException(
            status_code=400,
            detail="Query cannot be empty"
        )
    
    if len(query) > settings["max_query_length"]:
        raise HTTPException(
            status_code=400,
            detail=f"Query too long. Maximum length: {settings['max_query_length']}"
        )
    
    # Sanitize the query
    sanitized_query = sanitize_query(query)
    
    if not sanitized_query:
        raise HTTPException(
            status_code=400,
            detail="Query contains invalid characters"
        )
    
    return sanitized_query

def validate_sparql_parameters(
    query: str = Query(..., description="SPARQL query"),
    settings: Dict[str, Any] = Depends(get_settings)
) -> str:
    """
    Validate SPARQL query parameters.
    
    Args:
        query: SPARQL query string
        settings: Application settings
        
    Returns:
        Validated SPARQL query
        
    Raises:
        HTTPException: If validation fails
    """
    if not query or not query.strip():
        raise HTTPException(
            status_code=400,
            detail="SPARQL query cannot be empty"
        )
    
    if len(query) > settings["max_query_length"]:
        raise HTTPException(
            status_code=400,
            detail=f"Query too long. Maximum length: {settings['max_query_length']}"
        )
    
    # Validate SPARQL syntax
    if not validate_sparql_query(query):
        raise HTTPException(
            status_code=400,
            detail="Invalid SPARQL query syntax"
        )
    
    # Check for potentially dangerous operations
    dangerous_keywords = ["DELETE", "INSERT", "DROP", "CREATE", "CLEAR"]
    query_upper = query.upper()
    
    for keyword in dangerous_keywords:
        if keyword in query_upper:
            raise HTTPException(
                status_code=400,
                detail=f"SPARQL {keyword} operations are not allowed"
            )
    
    return query.strip()

def get_pagination_params(
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return")
) -> Dict[str, int]:
    """
    Get pagination parameters.
    
    Args:
        skip: Number of items to skip
        limit: Number of items to return
        
    Returns:
        Pagination parameters
    """
    return {"skip": skip, "limit": limit}

def get_filter_params(
    entity_types: Optional[str] = Query(None, description="Comma-separated entity types"),
    min_score: float = Query(0.0, ge=0.0, le=1.0, description="Minimum similarity score"),
    include_metadata: bool = Query(True, description="Include entity metadata")
) -> Dict[str, Any]:
    """
    Get filter parameters for search operations.
    
    Args:
        entity_types: Comma-separated entity types
        min_score: Minimum similarity score
        include_metadata: Whether to include metadata
        
    Returns:
        Filter parameters
    """
    filters = {
        "min_score": min_score,
        "include_metadata": include_metadata
    }
    
    if entity_types:
        # Parse and validate entity types
        types_list = [t.strip() for t in entity_types.split(",") if t.strip()]
        valid_types = ["Class", "ObjectProperty", "DatatypeProperty", "Individual", "Instance"]
        
        invalid_types = [t for t in types_list if t not in valid_types]
        if invalid_types:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid entity types: {invalid_types}. Valid types: {valid_types}"
            )
        
        filters["entity_types"] = types_list
    
    return filters

def get_request_id(request: Request) -> str:
    """
    Get or generate a request ID for tracking.
    
    Args:
        request: FastAPI request object
        
    Returns:
        Request ID string
    """
    # Check for existing request ID header
    request_id = request.headers.get("X-Request-ID")
    
    if not request_id:
        import uuid
        request_id = str(uuid.uuid4())
    
    return request_id

def log_request_info(
    request: Request,
    request_id: str = Depends(get_request_id)
) -> Dict[str, Any]:
    """
    Log request information for debugging and monitoring.
    
    Args:
        request: FastAPI request object
        request_id: Request ID
        
    Returns:
        Request information dictionary
    """
    client_ip = request.headers.get("X-Forwarded-For", 
                                   request.headers.get("X-Real-IP",
                                   request.client.host if request.client else "unknown"))
    
    user_agent = request.headers.get("User-Agent", "unknown")
    
    request_info = {
        "request_id": request_id,
        "method": request.method,
        "url": str(request.url),
        "client_ip": client_ip,
        "user_agent": user_agent,
        "timestamp": time.time()
    }
    
    logger.info(f"Request {request_id}: {request.method} {request.url.path} from {client_ip}")
    
    return request_info

def check_system_health(
    chatbot: EnhancedRDFChatbot = Depends(get_chatbot)
) -> Dict[str, Any]:
    """
    Check system health for endpoints that require it.
    
    Args:
        chatbot: Chatbot instance
        
    Returns:
        Health status
        
    Raises:
        HTTPException: If system is unhealthy
    """
    try:
        health = chatbot.check_health()
        
        if not health.get("overall_healthy", False):
            raise HTTPException(
                status_code=503,
                detail={
                    "error": "System is unhealthy",
                    "health_status": health
                }
            )
        
        return health
    
    except ChatbotException as e:
        raise HTTPException(
            status_code=503,
            detail=f"System health check failed: {str(e)}"
        )

def get_admin_user(
    user: Optional[Dict[str, str]] = Depends(get_authenticated_user)
) -> Dict[str, str]:
    """
    Ensure user has admin privileges.
    
    Args:
        user: Authenticated user information
        
    Returns:
        Admin user information
        
    Raises:
        HTTPException: If user is not admin
    """
    if not user or user.get("role") != "admin":
        raise HTTPException(
            status_code=403,
            detail="Admin privileges required"
        )
    
    return user

# Common dependency combinations
CommonDeps = Annotated[Dict[str, Any], Depends(log_request_info)]
ChatDeps = Annotated[bool, Depends(chat_rate_limit)]
SparqlDeps = Annotated[bool, Depends(sparql_rate_limit)]
StandardDeps = Annotated[bool, Depends(standard_rate_limit)]
AdminDeps = Annotated[Dict[str, str], Depends(get_admin_user)]
HealthDeps = Annotated[Dict[str, Any], Depends(check_system_health)]

def get_performance_monitor() -> Generator[Dict[str, Any], None, None]:
    """
    Monitor request performance.
    
    Yields:
        Performance metrics
    """
    start_time = time.time()
    start_cpu = time.process_time()
    
    try:
        yield {"start_time": start_time, "start_cpu": start_cpu}
    finally:
        end_time = time.time()
        end_cpu = time.process_time()
        
        duration = end_time - start_time
        cpu_time = end_cpu - start_cpu
        
        # Log performance metrics
        if duration > 5.0:  # Log slow requests
            logger.warning(f"Slow request: {duration:.2f}s wall time, {cpu_time:.2f}s CPU time")
        
        # Could send metrics to monitoring system here
        logger.debug(f"Request completed in {duration:.2f}s (CPU: {cpu_time:.2f}s)")

PerformanceDeps = Annotated[Dict[str, Any], Depends(get_performance_monitor)]
