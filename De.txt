"""
Safe JSON parsing utilities for handling LLM responses.

COMPLETE FIX - Handles all JSON issues:
✅ Preamble text removal
✅ Unquoted keys fixing
✅ Single quotes to double quotes
✅ Trailing commas
✅ Robust error recovery

Location: src/utils/json_parser.py
"""
import json
import logging
import re
from typing import Dict, Any

logger = logging.getLogger(__name__)


class SafeJsonParser:
    """Safe JSON parsing with comprehensive error handling."""

    @staticmethod
    def parse_json_response(response: str) -> Dict[str, Any]:
        """
        Safely parse JSON response from LLM.
        Handles preamble text, formatting issues, and malformed JSON.
        """
        try:
            cleaned = response.strip()

            # Remove markdown code blocks
            if "```json" in cleaned:
                start = cleaned.find("```json") + 7
                end = cleaned.find("```", start)
                if end != -1:
                    cleaned = cleaned[start:end].strip()
            elif "```" in cleaned:
                start = cleaned.find("```") + 3
                end = cleaned.find("```", start)
                if end != -1:
                    cleaned = cleaned[start:end].strip()
            
            # Remove preamble text
            json_start = cleaned.find('{')
            if json_start == -1:
                json_start = cleaned.find('[')
            
            if json_start > 0:
                logger.debug(f"Removing {json_start} characters of preamble text")
                cleaned = cleaned[json_start:]
            
            # Extract complete JSON object
            if cleaned.startswith('{'):
                cleaned = SafeJsonParser._extract_balanced_braces(cleaned, '{', '}')
            elif cleaned.startswith('['):
                cleaned = SafeJsonParser._extract_balanced_braces(cleaned, '[', ']')

            # Try to parse
            parsed = json.loads(cleaned)
            return parsed

        except json.JSONDecodeError as e:
            logger.warning(f"JSON decode error: {e}")
            
            try:
                # Apply comprehensive fixes
                fixed = SafeJsonParser.fix_common_json_errors(cleaned)
                parsed = json.loads(fixed)
                logger.info("Successfully parsed JSON after fixes")
                return parsed
            except Exception as fix_error:
                logger.error(f"Could not parse JSON after fixes: {str(fix_error)}")
                logger.error(f"First 300 chars: {cleaned[:300]}")
                logger.error(f"Last 200 chars: {cleaned[-200:]}")
                return {"error": "Failed to parse JSON", "raw_response": cleaned[:1000]}

    @staticmethod
    def _extract_balanced_braces(text: str, open_char: str, close_char: str) -> str:
        """Extract text up to matching closing brace/bracket."""
        count = 0
        for i, char in enumerate(text):
            if char == open_char:
                count += 1
            elif char == close_char:
                count -= 1
                if count == 0:
                    return text[:i+1]
        return text

    @staticmethod
    def fix_common_json_errors(text: str) -> str:
        """
        Fix common JSON formatting errors including unquoted keys.
        This is the key method for handling malformed JSON.
        """
        # 1. Remove trailing commas before } or ]
        text = re.sub(r',(\s*[}\]])', r'\1', text)
        
        # 2. Fix unquoted keys - THIS IS CRITICAL
        # Matches: word characters followed by colon
        # Converts: name: "value" → "name": "value"
        text = re.sub(r'([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'\1"\2":', text)
        
        # 3. Fix single quotes to double quotes (but be careful)
        # Replace single quotes around keys
        text = re.sub(r"'([a-zA-Z_][a-zA-Z0-9_]*)'\s*:", r'"\1":', text)
        
        # Replace single quotes around simple string values
        # But NOT if they contain apostrophes
        text = re.sub(r":\s*'([^']*)'(\s*[,}\]])", r': "\1"\2', text)
        
        # 4. Handle Python-style None/True/False
        text = re.sub(r'\bNone\b', 'null', text)
        text = re.sub(r'\bTrue\b', 'true', text)
        text = re.sub(r'\bFalse\b', 'false', text)
        
        # 5. Remove comments if present
        text = re.sub(r'//.*?$', '', text, flags=re.MULTILINE)
        text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)
        
        return text

    @staticmethod
    def extract_json_from_markdown(text: str) -> str:
        """Extract JSON from markdown code blocks."""
        if "```json" in text:
            start = text.find("```json") + 7
            end = text.find("```", start)
            if end != -1:
                return text[start:end].strip()
        elif "```" in text:
            start = text.find("```") + 3
            end = text.find("```", start)
            if end != -1:
                return text[start:end].strip()
        return text.strip()

    @staticmethod
    def validate_json_structure(data: Dict[str, Any], required_fields: list = None) -> bool:
        """Validate JSON structure against required fields."""
        if required_fields is None:
            return True
            
        if not isinstance(data, dict):
            return False
            
        for field in required_fields:
            if field not in data:
                logger.warning(f"Missing required field: {field}")
                return False
                
        return True

    @staticmethod
    def clean_and_parse(response: str, required_fields: list = None) -> Dict[str, Any]:
        """
        Most robust parsing method - use this when maximum reliability is needed.
        
        This method:
        1. Removes markdown blocks
        2. Removes preamble text
        3. Fixes common JSON errors (including unquoted keys)
        4. Validates structure
        5. Returns parsed JSON or error dict
        """
        try:
            # Step 1: Remove markdown
            extracted = SafeJsonParser.extract_json_from_markdown(response)
            
            # Step 2: Remove preamble
            json_start = extracted.find('{')
            if json_start == -1:
                json_start = extracted.find('[')
            if json_start > 0:
                extracted = extracted[json_start:]
            
            # Step 3: Extract complete JSON
            if extracted.startswith('{'):
                extracted = SafeJsonParser._extract_balanced_braces(extracted, '{', '}')
            elif extracted.startswith('['):
                extracted = SafeJsonParser._extract_balanced_braces(extracted, '[', ']')
            
            # Step 4: Fix common errors (including unquoted keys)
            fixed = SafeJsonParser.fix_common_json_errors(extracted)
            
            # Step 5: Parse
            parsed = json.loads(fixed)
            
            # Step 6: Validate structure
            if required_fields and not SafeJsonParser.validate_json_structure(parsed, required_fields):
                return {"error": "Invalid JSON structure", "raw_response": response[:1000]}
                
            return parsed
            
        except Exception as e:
            logger.error(f"Complete JSON parsing failed: {e}")
            logger.error(f"Response preview: {response[:500]}")
            return {"error": f"Failed to parse JSON: {str(e)}", "raw_response": response[:1000]}
    
    @staticmethod
    def extract_json_object(text: str) -> str:
        """
        Extract the first complete JSON object from text.
        Useful when LLM adds explanatory text.
        """
        start = text.find('{')
        if start == -1:
            start = text.find('[')
        if start == -1:
            return text
        
        if text[start] == '{':
            return SafeJsonParser._extract_balanced_braces(text[start:], '{', '}')
        elif text[start] == '[':
            return SafeJsonParser._extract_balanced_braces(text[start:], '[', ']')
        
        return text[start:]
