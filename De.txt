"""
Response data models and schemas for the Enhanced RDF Knowledge Graph Chatbot API.
"""

from typing import List, Dict, Any, Optional, Union, Generic, TypeVar
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict, computed_field
from app.schemas.entities import EntityTypeCategory, RDFEntity, EntityReference
from app.schemas.queries import QueryIntent, ProcessingMethod, QueryStatus

T = TypeVar('T')

class ResponseStatus(str, Enum):
    """Response status enumeration."""
    SUCCESS = "success"
    ERROR = "error"
    WARNING = "warning"
    PARTIAL = "partial"

class ErrorType(str, Enum):
    """Types of errors that can occur."""
    VALIDATION_ERROR = "validation_error"
    AUTHENTICATION_ERROR = "authentication_error"
    AUTHORIZATION_ERROR = "authorization_error"
    NOT_FOUND_ERROR = "not_found_error"
    CONFLICT_ERROR = "conflict_error"
    RATE_LIMIT_ERROR = "rate_limit_error"
    INTERNAL_ERROR = "internal_error"
    EXTERNAL_SERVICE_ERROR = "external_service_error"
    TIMEOUT_ERROR = "timeout_error"
    CONFIGURATION_ERROR = "configuration_error"

class BaseResponse(BaseModel, Generic[T]):
    """Base response model with common fields."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(..., description="Response status")
    message: Optional[str] = Field(None, description="Human-readable message")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")
    request_id: Optional[str] = Field(None, description="Request ID for tracking")
    processing_time_ms: Optional[float] = Field(None, description="Processing time in milliseconds")
    data: Optional[T] = Field(None, description="Response data")

class ErrorDetail(BaseModel):
    """Detailed error information."""
    model_config = ConfigDict(extra="forbid")
    
    code: str = Field(..., description="Error code")
    message: str = Field(..., description="Error message")
    field: Optional[str] = Field(None, description="Field that caused the error")
    context: Optional[Dict[str, Any]] = Field(None, description="Additional error context")

class ErrorResponse(BaseModel):
    """Error response model."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.ERROR, description="Response status")
    error_type: ErrorType = Field(..., description="Type of error")
    message: str = Field(..., description="Error message")
    details: List[ErrorDetail] = Field(default_factory=list, description="Detailed error information")
    timestamp: datetime = Field(default_factory=datetime.now, description="Error timestamp")
    request_id: Optional[str] = Field(None, description="Request ID for tracking")
    trace_id: Optional[str] = Field(None, description="Trace ID for debugging")
    suggestion: Optional[str] = Field(None, description="Suggested action to resolve error")

class PaginationInfo(BaseModel):
    """Pagination information."""
    model_config = ConfigDict(extra="forbid")
    
    page: int = Field(..., ge=1, description="Current page number")
    size: int = Field(..., ge=1, description="Page size")
    total_items: int = Field(..., ge=0, description="Total number of items")
    total_pages: int = Field(..., ge=0, description="Total number of pages")
    has_next: bool = Field(..., description="Whether there are more pages")
    has_previous: bool = Field(..., description="Whether there are previous pages")
    
    @computed_field
    @property
    def is_first_page(self) -> bool:
        """Check if this is the first page."""
        return self.page == 1
    
    @computed_field
    @property
    def is_last_page(self) -> bool:
        """Check if this is the last page."""
        return self.page == self.total_pages

class PaginatedResponse(BaseModel, Generic[T]):
    """Paginated response model."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    items: List[T] = Field(..., description="Response items")
    pagination: PaginationInfo = Field(..., description="Pagination information")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")
    request_id: Optional[str] = Field(None, description="Request ID for tracking")

class EntitySummary(BaseModel):
    """Summary information about an entity."""
    model_config = ConfigDict(extra="forbid")
    
    uri: str = Field(..., description="Entity URI")
    local_name: str = Field(..., description="Entity local name")
    type: EntityTypeCategory = Field(..., description="Entity type")
    labels: List[str] = Field(default_factory=list, description="Entity labels")
    description: Optional[str] = Field(None, description="Brief description")
    
    @computed_field
    @property
    def display_name(self) -> str:
        """Get the best display name."""
        return self.labels[0] if self.labels else self.local_name

class RelationshipSummary(BaseModel):
    """Summary of a relationship between entities."""
    model_config = ConfigDict(extra="forbid")
    
    source: EntitySummary = Field(..., description="Source entity")
    predicate: str = Field(..., description="Relationship predicate")
    target: EntitySummary = Field(..., description="Target entity")
    direction: str = Field(..., description="Relationship direction")
    confidence: Optional[float] = Field(None, description="Relationship confidence")

class SearchResultItem(BaseModel):
    """Individual search result item."""
    model_config = ConfigDict(extra="forbid")
    
    entity: EntitySummary = Field(..., description="Found entity")
    score: float = Field(..., ge=0.0, description="Relevance score")
    rank: int = Field(..., ge=1, description="Result rank")
    match_type: str = Field(..., description="Type of match (exact, partial, semantic)")
    highlights: Dict[str, List[str]] = Field(default_factory=dict, description="Search highlights")
    explanation: Optional[str] = Field(None, description="Explanation of why this result matched")

class SearchResponse(BaseModel):
    """Response for search operations."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    query: str = Field(..., description="Original search query")
    results: List[SearchResultItem] = Field(..., description="Search results")
    total_results: int = Field(..., ge=0, description="Total number of results")
    search_method: str = Field(..., description="Search method used")
    processing_time_ms: float = Field(..., description="Search processing time")
    suggestions: List[str] = Field(default_factory=list, description="Query suggestions")
    filters_applied: Dict[str, Any] = Field(default_factory=dict, description="Filters that were applied")
    
    @computed_field
    @property
    def has_results(self) -> bool:
        """Check if search returned any results."""
        return len(self.results) > 0

class ChatContextInfo(BaseModel):
    """Context information included in chat responses."""
    model_config = ConfigDict(extra="forbid")
    
    relevant_entities: List[EntitySummary] = Field(default_factory=list, description="Relevant entities found")
    relationships: List[RelationshipSummary] = Field(default_factory=list, description="Relevant relationships")
    sparql_queries: List[str] = Field(default_factory=list, description="SPARQL queries executed")
    processing_methods: List[ProcessingMethod] = Field(default_factory=list, description="Methods used")
    confidence_scores: Dict[str, float] = Field(default_factory=dict, description="Confidence scores")

class ChatResponse(BaseModel):
    """Response for chat interactions."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    answer: str = Field(..., description="Generated answer")
    user_query: str = Field(..., description="Original user query")
    
    # Query analysis
    query_intent: Optional[QueryIntent] = Field(None, description="Detected query intent")
    key_concepts: List[str] = Field(default_factory=list, description="Extracted key concepts")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Answer confidence")
    
    # Processing information
    processing_methods: List[ProcessingMethod] = Field(default_factory=list, description="Methods used")
    processing_time_ms: float = Field(..., description="Total processing time")
    token_usage: Optional[int] = Field(None, description="LLM tokens used")
    
    # Context (optional)
    context: Optional[ChatContextInfo] = Field(None, description="Additional context information")
    
    # Suggestions and metadata
    related_questions: List[str] = Field(default_factory=list, description="Related question suggestions")
    sources: List[str] = Field(default_factory=list, description="Information sources")
    warnings: List[str] = Field(default_factory=list, description="Processing warnings")
    
    @computed_field
    @property
    def was_successful(self) -> bool:
        """Check if chat interaction was successful."""
        return self.status == ResponseStatus.SUCCESS and bool(self.answer.strip())

class EntityDetailsResponse(BaseModel):
    """Response for entity details requests."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    entity: RDFEntity = Field(..., description="Complete entity information")
    related_entities: List[EntitySummary] = Field(default_factory=list, description="Related entities")
    usage_examples: List[str] = Field(default_factory=list, description="Usage examples")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class SparqlExecutionResult(BaseModel):
    """Result of SPARQL query execution."""
    model_config = ConfigDict(extra="forbid")
    
    variables: List[str] = Field(default_factory=list, description="Query variables")
    bindings: List[Dict[str, Any]] = Field(default_factory=list, description="Result bindings")
    result_count: int = Field(..., ge=0, description="Number of results")
    execution_time_ms: float = Field(..., description="Execution time in milliseconds")
    warnings: List[str] = Field(default_factory=list, description="Execution warnings")

class SparqlResponse(BaseModel):
    """Response for SPARQL query execution."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    query: str = Field(..., description="Executed SPARQL query")
    result: SparqlExecutionResult = Field(..., description="Query execution result")
    query_analysis: Optional[Dict[str, Any]] = Field(None, description="Query analysis information")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class NaturalLanguageToSparqlResponse(BaseModel):
    """Response for natural language to SPARQL conversion."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    original_question: str = Field(..., description="Original natural language question")
    generated_sparql: str = Field(..., description="Generated SPARQL query")
    explanation: Optional[str] = Field(None, description="Explanation of the generated query")
    execution_result: Optional[SparqlExecutionResult] = Field(None, description="Query execution result")
    natural_language_answer: Optional[str] = Field(None, description="Natural language answer")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Generation confidence")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class ComponentStatus(BaseModel):
    """Status of a system component."""
    model_config = ConfigDict(extra="forbid")
    
    name: str = Field(..., description="Component name")
    status: str = Field(..., description="Component status")
    healthy: bool = Field(..., description="Whether component is healthy")
    last_check: datetime = Field(..., description="Last health check time")
    details: Dict[str, Any] = Field(default_factory=dict, description="Additional status details")
    metrics: Dict[str, Union[int, float, str]] = Field(default_factory=dict, description="Component metrics")

class HealthCheckResponse(BaseModel):
    """Response for health check requests."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(..., description="Overall system status")
    healthy: bool = Field(..., description="Overall system health")
    components: List[ComponentStatus] = Field(..., description="Individual component statuses")
    uptime_seconds: Optional[float] = Field(None, description="System uptime in seconds")
    version: Optional[str] = Field(None, description="System version")
    timestamp: datetime = Field(default_factory=datetime.now, description="Health check timestamp")
    
    @computed_field
    @property
    def unhealthy_components(self) -> List[str]:
        """Get list of unhealthy component names."""
        return [comp.name for comp in self.components if not comp.healthy]

class StatisticsSummary(BaseModel):
    """Summary statistics for the knowledge base."""
    model_config = ConfigDict(extra="forbid")
    
    total_entities: int = Field(..., ge=0, description="Total number of entities")
    total_triples: int = Field(..., ge=0, description="Total number of RDF triples")
    entity_types: Dict[str, int] = Field(..., description="Count by entity type")
    namespaces: List[str] = Field(..., description="Available namespaces")
    index_size_mb: float = Field(..., ge=0.0, description="Index size in MB")
    last_updated: datetime = Field(..., description="Last update timestamp")

class PerformanceMetrics(BaseModel):
    """Performance metrics for the system."""
    model_config = ConfigDict(extra="forbid")
    
    total_requests: int = Field(..., ge=0, description="Total requests processed")
    successful_requests: int = Field(..., ge=0, description="Successful requests")
    average_response_time_ms: float = Field(..., ge=0.0, description="Average response time")
    requests_per_minute: float = Field(..., ge=0.0, description="Current requests per minute")
    cache_hit_rate: float = Field(..., ge=0.0, le=1.0, description="Cache hit rate")
    error_rate: float = Field(..., ge=0.0, le=1.0, description="Error rate")

class StatisticsResponse(BaseModel):
    """Response for statistics requests."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    knowledge_base: StatisticsSummary = Field(..., description="Knowledge base statistics")
    performance: PerformanceMetrics = Field(..., description="Performance metrics")
    system_info: Dict[str, Any] = Field(default_factory=dict, description="System information")
    timestamp: datetime = Field(default_factory=datetime.now, description="Statistics timestamp")

class InitializationProgress(BaseModel):
    """Progress information for initialization operations."""
    model_config = ConfigDict(extra="forbid")
    
    stage: str = Field(..., description="Current initialization stage")
    progress_percentage: float = Field(..., ge=0.0, le=100.0, description="Progress percentage")
    entities_processed: int = Field(..., ge=0, description="Number of entities processed")
    estimated_remaining_time_seconds: Optional[float] = Field(None, description="Estimated remaining time")
    current_operation: Optional[str] = Field(None, description="Current operation description")

class InitializationResponse(BaseModel):
    """Response for initialization requests."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(..., description="Initialization status")
    message: str = Field(..., description="Status message")
    completed: bool = Field(..., description="Whether initialization is complete")
    progress: Optional[InitializationProgress] = Field(None, description="Progress information")
    entities_indexed: int = Field(..., ge=0, description="Number of entities indexed")
    processing_time_seconds: Optional[float] = Field(None, description="Total processing time")
    errors: List[str] = Field(default_factory=list, description="Initialization errors")
    warnings: List[str] = Field(default_factory=list, description="Initialization warnings")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class QuerySuggestion(BaseModel):
    """Query suggestion with metadata."""
    model_config = ConfigDict(extra="forbid")
    
    query: str = Field(..., description="Suggested query text")
    intent: QueryIntent = Field(..., description="Query intent")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Suggestion confidence")
    example_entities: List[str] = Field(default_factory=list, description="Example entities for this query")
    explanation: Optional[str] = Field(None, description="Why this query is suggested")

class SuggestionsResponse(BaseModel):
    """Response for query suggestions."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(ResponseStatus.SUCCESS, description="Response status")
    suggestions: List[QuerySuggestion] = Field(..., description="Query suggestions")
    context: Optional[str] = Field(None, description="Context for suggestions")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

class ValidationResult(BaseModel):
    """Result of data validation."""
    model_config = ConfigDict(extra="forbid")
    
    is_valid: bool = Field(..., description="Whether data is valid")
    errors: List[ErrorDetail] = Field(default_factory=list, description="Validation errors")
    warnings: List[str] = Field(default_factory=list, description="Validation warnings")
    score: float = Field(..., ge=0.0, le=1.0, description="Validation score")

class ValidationResponse(BaseModel):
    """Response for validation requests."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(..., description="Validation status")
    result: ValidationResult = Field(..., description="Validation result")
    suggestions: List[str] = Field(default_factory=list, description="Improvement suggestions")
    timestamp: datetime = Field(default_factory=datetime.now, description="Validation timestamp")

class BulkOperationResult(BaseModel):
    """Result of a bulk operation."""
    model_config = ConfigDict(extra="forbid")
    
    total_items: int = Field(..., ge=0, description="Total number of items processed")
    successful_items: int = Field(..., ge=0, description="Number of successful items")
    failed_items: int = Field(..., ge=0, description="Number of failed items")
    errors: List[ErrorDetail] = Field(default_factory=list, description="Errors encountered")
    processing_time_seconds: float = Field(..., description="Total processing time")
    
    @computed_field
    @property
    def success_rate(self) -> float:
        """Calculate success rate."""
        if self.total_items == 0:
            return 1.0
        return self.successful_items / self.total_items

class BulkOperationResponse(BaseModel):
    """Response for bulk operations."""
    model_config = ConfigDict(extra="forbid")
    
    status: ResponseStatus = Field(..., description="Operation status")
    operation_id: str = Field(..., description="Operation identifier")
    result: BulkOperationResult = Field(..., description="Operation result")
    timestamp: datetime = Field(default_factory=datetime.now, description="Response timestamp")

# Utility functions for creating common responses
def create_success_response(data: Any = None, message: str = "Operation completed successfully") -> BaseResponse:
    """Create a success response."""
    return BaseResponse(
        status=ResponseStatus.SUCCESS,
        message=message,
        data=data
    )

def create_error_response(
    error_type: ErrorType,
    message: str,
    details: List[ErrorDetail] = None,
    suggestion: str = None
) -> ErrorResponse:
    """Create an error response."""
    return ErrorResponse(
        error_type=error_type,
        message=message,
        details=details or [],
        suggestion=suggestion
    )

def create_validation_error_response(field: str, message: str) -> ErrorResponse:
    """Create a validation error response."""
    return create_error_response(
        error_type=ErrorType.VALIDATION_ERROR,
        message=f"Validation failed for field '{field}'",
        details=[ErrorDetail(code="VALIDATION_ERROR", message=message, field=field)],
        suggestion="Please check your input and try again"
    )

def create_not_found_response(resource: str, identifier: str) -> ErrorResponse:
    """Create a not found error response."""
    return create_error_response(
        error_type=ErrorType.NOT_FOUND_ERROR,
        message=f"{resource} with identifier '{identifier}' was not found",
        suggestion=f"Please verify the {resource.lower()} identifier and try again"
    )

def create_rate_limit_response(retry_after: int) -> ErrorResponse:
    """Create a rate limit error response."""
    return create_error_response(
        error_type=ErrorType.RATE_LIMIT_ERROR,
        message="Rate limit exceeded",
        details=[ErrorDetail(
            code="RATE_LIMIT_EXCEEDED",
            message=f"Please retry after {retry_after} seconds",
            context={"retry_after": retry_after}
        )],
        suggestion=f"Please wait {retry_after} seconds before making another request"
    )

def create_paginated_response(
    items: List[Any],
    page: int,
    size: int,
    total_items: int
) -> PaginatedResponse:
    """Create a paginated response."""
    total_pages = (total_items + size - 1) // size  # Ceiling division
    
    pagination = PaginationInfo(
        page=page,
        size=size,
        total_items=total_items,
        total_pages=total_pages,
        has_next=page < total_pages,
        has_previous=page > 1
    )
    
    return PaginatedResponse(
        items=items,
        pagination=pagination
    )
