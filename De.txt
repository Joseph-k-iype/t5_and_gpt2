import requests
import json
from urllib.parse import urlparse, unquote
import uuid # For more robust edge IDs, though not strictly necessary for this example

def _get_label_from_uri(uri_str: str) -> str:
    """
    Helper function to extract a concise, human-readable label from a URI.
    It tries to get the fragment or the last significant part of the path.
    """
    if not isinstance(uri_str, str): # Handle cases where non-string might be passed
        return str(uri_str)
    try:
        parsed_uri = urlparse(uri_str)
        fragment = parsed_uri.fragment
        if fragment:
            return unquote(fragment)
        
        path_segments = [seg for seg in parsed_uri.path.split('/') if seg]
        if path_segments:
            return unquote(path_segments[-1])
        
        # Fallback for URNs or other schemes if path is not informative
        if parsed_uri.scheme and parsed_uri.opaque: # e.g. urn:isbn:12345
             # Try to get last part after ':' if multiple parts
            opaque_parts = parsed_uri.opaque.split(':')
            if len(opaque_parts) > 1:
                return unquote(opaque_parts[-1])
            return unquote(parsed_uri.opaque)

        return uri_str # Fallback to the full URI if no better label can be derived
    except Exception:
        return uri_str # Fallback for any parsing error

def query_sparql_to_graph(endpoint_url: str, 
                          sparql_query: str, 
                          bearer_token: str = None,
                          subject_var: str = 's', 
                          predicate_var: str = 'p', 
                          object_var: str = 'o',
                          group_var: str = None) -> dict:
    """
    Queries a SPARQL endpoint and transforms the results into a graph structure
    of nodes and edges. Literals associated via predicate_var are added as properties
    to the subject_var node.

    Args:
        endpoint_url: The URL of the SPARQL endpoint.
        sparql_query: The SPARQL query string.
        bearer_token: Optional Bearer token for authentication.
        subject_var: The variable name in the query SELECT clause representing the subject.
        predicate_var: The variable name in the query SELECT clause representing the predicate.
        object_var: The variable name in the query SELECT clause representing the object.
        group_var: Optional variable name in the query SELECT clause for grouping nodes.

    Returns:
        A dictionary with 'nodes', 'edges', and 'groups' lists.
        Example structure:
        {
            "nodes": [
                {"id": "uri1", "label": "Label1", "type": "uri", 
                 "properties": {"prop_uri": [{"value": "literal_val", "datatype": "xsd:string", "lang": "en"}]}, 
                 "group": "grp1"}
            ],
            "edges": [
                {"id": "edge_uuid", "source": "uri1", "target": "uri2", "label": "PredicateLabel", "uri": "predicate_uri"}
            ],
            "groups": [
                {"id": "grp1", "label": "Group 1 Label"}
            ]
        }
        Returns {"error": "message", "details": "optional_details"} on failure.
    """
    headers = {
        'Accept': 'application/sparql-results+json',
        'Content-Type': 'application/x-www-form-urlencoded' # Common for POSTing SPARQL queries
    }
    if bearer_token:
        headers['Authorization'] = f'Bearer {bearer_token}'

    payload = {'query': sparql_query}

    try:
        # It's good practice to set a timeout for network requests.
        response = requests.post(endpoint_url, data=payload, headers=headers, timeout=60) # 60 seconds timeout
        response.raise_for_status()  # Raises an HTTPError for bad responses (4XX or 5XX)
    except requests.exceptions.HTTPError as e:
        error_details = ""
        try:
            error_details = e.response.json() # Try to get JSON error details
        except json.JSONDecodeError:
            error_details = e.response.text # Fallback to text
        return {"error": f"HTTP error: {e.response.status_code} {e.response.reason}", "details": error_details}
    except requests.exceptions.Timeout:
        return {"error": "Request timed out while connecting to SPARQL endpoint."}
    except requests.exceptions.RequestException as e: # Catch other request-related errors
        return {"error": f"Request failed: {e}"}

    try:
        results_json = response.json()
    except json.JSONDecodeError:
        return {"error": "Failed to decode JSON response from SPARQL endpoint.", "details": response.text}

    # Initialize dictionaries and lists for graph components
    nodes_dict = {}  # Using a dictionary for quick lookup and to ensure unique nodes by ID
    edges_list = []
    groups_dict = {} # Using a dictionary for unique groups by ID

    # Check if specified variables are in the query results
    query_result_vars = results_json.get('head', {}).get('vars', [])
    required_vars_for_triples = [subject_var, predicate_var, object_var]
    
    missing_vars = [v for v in required_vars_for_triples if v not in query_result_vars]
    if missing_vars:
        return {
            "error": f"One or more specified variables for triple construction ({', '.join(missing_vars)}) not found in query result variables: {query_result_vars}."
        }
    
    if group_var and group_var not in query_result_vars:
        # This is more of a warning, the function can proceed without group information
        print(f"Warning: Specified group_var '{group_var}' not found in query result variables. No grouping will be applied.")
        # Alternatively, return an error or add to a warnings list in the response.

    for binding in results_json.get('results', {}).get('bindings', []):
        s_binding = binding.get(subject_var)
        p_binding = binding.get(predicate_var)
        o_binding = binding.get(object_var)

        # A valid triple requires subject, predicate, and object.
        if not (s_binding and p_binding and o_binding):
            # Log or skip rows where essential parts for a triple are missing.
            # print(f"Warning: Incomplete binding skipped (missing s, p, or o): {binding}")
            continue
        
        # Extract values and types
        s_id = s_binding['value']
        s_type = s_binding['type'] # 'uri' or 'bnode'
        
        p_uri = p_binding['value'] # Predicate is typically a URI
        
        o_id_or_val = o_binding['value']
        o_type = o_binding['type'] # 'uri', 'bnode', or 'literal'

        # --- Process Subject Node ---
        if s_id not in nodes_dict:
            nodes_dict[s_id] = {
                "id": s_id,
                "label": _get_label_from_uri(s_id),
                "type": s_type,
                "properties": {} # Initialize properties dictionary
            }
        
        current_s_node = nodes_dict[s_id]

        # --- Apply Grouping (if group_var is present and valid) ---
        if group_var and group_var in binding:
            g_binding = binding.get(group_var)
            if g_binding and g_binding.get('value'): # Ensure group variable has a value
                group_id = g_binding['value']
                current_s_node['group'] = group_id # Assign group to the subject node
                if group_id not in groups_dict:
                    groups_dict[group_id] = {"id": group_id, "label": _get_label_from_uri(group_id)}

        # --- Process Object and Edge / Literal Property ---
        if o_type == 'uri' or o_type == 'bnode':
            # Object is a resource (URI or BNode), so it's a node and an edge is formed.
            o_node_id = o_id_or_val
            if o_node_id not in nodes_dict:
                nodes_dict[o_node_id] = {
                    "id": o_node_id,
                    "label": _get_label_from_uri(o_node_id),
                    "type": o_type,
                    "properties": {}
                }
                # If group_var is meant to group edges or target nodes as well, handle here.
                # For simplicity, group_var primarily groups subject nodes based on the binding.

            # Add the edge
            edges_list.append({
                "id": str(uuid.uuid4()), # A unique ID for the edge
                "source": s_id,
                "target": o_node_id,
                "label": _get_label_from_uri(p_uri), # Use a short label for the predicate
                "uri": p_uri # Store the full predicate URI as well
            })
        elif o_type == 'literal' or o_type == 'typed-literal': # SPARQL results use 'literal' or 'typed-literal'
            # Object is a literal, add it as a property to the subject node.
            # The predicate URI becomes the key for the property.
            property_value_obj = {"value": o_id_or_val}
            if 'datatype' in o_binding:
                property_value_obj['datatype'] = o_binding['datatype']
            if 'xml:lang' in o_binding: # Note: SPARQL JSON results use 'xml:lang'
                property_value_obj['lang'] = o_binding['xml:lang']
            
            # Properties are stored as a list under the predicate URI key to allow multiple values.
            if p_uri not in current_s_node['properties']:
                current_s_node['properties'][p_uri] = []
            current_s_node['properties'][p_uri].append(property_value_obj)
        else:
            # Handle other unexpected object types if necessary
            # print(f"Warning: Unhandled object type '{o_type}' for object: {o_id_or_val}")
            pass
            
    return {
        "nodes": list(nodes_dict.values()),
        "edges": edges_list,
        "groups": list(groups_dict.values()) if group_var and groups_dict else []
    }

if __name__ == '__main__':
    # --- Example Usage ---
    # Replace with your actual endpoint, query, and token
    # Note: This example uses a public endpoint that doesn't require a token.
    # example_endpoint = "https://dbpedia.org/sparql"
    # example_query_dbpedia = """
    #     PREFIX dbo: <http://dbpedia.org/ontology/>
    #     PREFIX dbr: <http://dbpedia.org/resource/>
    #     PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    #     PREFIX foaf: <http://xmlns.com/foaf/0.1/>

    #     SELECT ?person ?label ?birthPlace ?birthPlaceLabel ?gender (SAMPLE(?country) AS ?nationalityCountry)
    #     WHERE {
    #         ?person a dbo:Person ;
    #                 rdfs:label ?label ;
    #                 dbo:birthPlace ?birthPlace .
    #         ?birthPlace rdfs:label ?birthPlaceLabel .
    #         OPTIONAL { ?person foaf:gender ?gender . }
    #         OPTIONAL { 
    #             ?person dbo:nationality ?nationalityResource .
    #             ?nationalityResource rdfs:label ?country .
    #             FILTER(LANG(?country) = "en")
    #         }
    #         FILTER(LANG(?label) = "en" && LANG(?birthPlaceLabel) = "en")
    #         FILTER(CONTAINS(STR(?person), "Tim_Berners-Lee")) # Focus on a specific person for a small result
    #     }
    #     GROUP BY ?person ?label ?birthPlace ?birthPlaceLabel ?gender
    #     LIMIT 5
    # """
    
    # For this query, we are primarily interested in ?person, its properties, and its relation to ?birthPlace.
    # Let's say we want to model ?person -> dbo:birthPlace -> ?birthPlace as nodes and edges.
    # And other things like ?label, ?gender as properties of ?person.

    # To demonstrate the function, we'd need a query that fits the s, p, o model more directly for edges.
    # Let's use a simpler conceptual query structure:
    # SELECT ?s ?p ?o ?group_val WHERE { ?s ?p ?o . OPTIONAL {?s ex:group ?group_val} }

    # Mocking a local SPARQL endpoint or a simple query:
    # This example won't run without a live endpoint and a suitable query.
    # print("Demonstrating with a conceptual query structure.")
    # print("To run a real test, set up a SPARQL endpoint or use a public one with an appropriate query.")

    # Example of how you might call it:
    # my_endpoint = "YOUR_SPARQL_ENDPOINT_URL"
    # my_query = "SELECT ?s ?p ?o ?group WHERE { ?s ?p ?o . OPTIONAL {?s <http://example.org/group> ?group} } LIMIT 10"
    # my_token = "YOUR_BEARER_TOKEN_IF_NEEDED"
    
    # graph_data = query_sparql_to_graph(
    #     endpoint_url=my_endpoint,
    #     sparql_query=my_query,
    #     bearer_token=my_token,
    #     subject_var='s',
    #     predicate_var='p',
    #     object_var='o',
    #     group_var='group' # Optional
    # )

    # if "error" in graph_data:
    #     print(f"Error fetching or processing SPARQL data: {graph_data['error']}")
    #     if "details" in graph_data:
    #         print(f"Details: {graph_data['details']}")
    # else:
    #     print("\n--- Nodes ---")
    #     for node in graph_data['nodes']:
    #         print(json.dumps(node, indent=2))
        
    #     print("\n--- Edges ---")
    #     for edge in graph_data['edges']:
    #         print(json.dumps(edge, indent=2))
        
    #     if graph_data['groups']:
    #         print("\n--- Groups ---")
    #         for group_item in graph_data['groups']:
    #             print(json.dumps(group_item, indent=2))
    #     else:
    #         print("\n--- No groups found or group_var not used ---")
    pass # Keep the if __name__ == '__main__': block for potential local testing by the user
