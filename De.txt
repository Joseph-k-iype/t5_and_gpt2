from fastapi import FastAPI, HTTPException, Body
import json
from pathlib import Path
import pandas as pd
import numpy as np
import httpx
import os
from typing import Optional
from collections import defaultdict

# ============= Configuration =============
DATA_PATH = Path(__file__).parent / "countries.json"
OPA_QUERY_URL = "https://nginx.dvc-opa.hsbc-11974748-dvcloud.dev.dev.gcp.cloud.uk.hsbc/v1/query"
DEBUG_MODE = os.getenv("DEBUG_MODE", "true").lower() == "true"

# ============= Global Cache =============
class DataCache:
    """Singleton cache for CSV data with O(1) lookups"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialized = False
        return cls._instance
    
    def initialize(self):
        if self.initialized:
            return
        
        print("Loading CSV data into memory...")
        start_time = pd.Timestamp.now()
        
        # Load CSV once
        df = pd.read_csv("Full TIA details.csv")
        load_time = (pd.Timestamp.now() - start_time).total_seconds()
        print(f"Loaded {len(df)} rows in {load_time:.2f}s")
        
        # Convert to optimized structures
        self._build_indexes(df)
        
        # Load policies
        with DATA_PATH.open(encoding="utf-8") as f:
            self.POLICIES = json.load(f)
        
        self.initialized = True
        total_time = (pd.Timestamp.now() - start_time).total_seconds()
        print(f"Total initialization time: {total_time:.2f}s")
    
    def _build_indexes(self, df: pd.DataFrame):
        """Convert DataFrame to optimized dict structures"""
        # Replace NaN with None
        df = df.replace({np.nan: None})
        
        # Convert to list of dicts (much faster than iterrows)
        records = df.to_dict('records')
        
        # Initialize indexes
        self.by_app_id = defaultdict(list)
        self.by_dv_case_id = defaultdict(list)
        self.by_business_id = defaultdict(list)
        
        # Required columns
        required_cols = {
            'ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE',
            'ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE',
            'ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME',
            'ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME',
            'CASE_MODULE_NAME',
            'CASE_MODULE_STATUS_NAME'
        }
        
        # Build indexes
        for record in records:
            compact_record = {
                k: v for k, v in record.items() 
                if k in required_cols and v is not None
            }
            
            if 'APPLICATION_INSTANCE_ID' in record and record['APPLICATION_INSTANCE_ID']:
                app_id = str(record['APPLICATION_INSTANCE_ID'])
                self.by_app_id[app_id].append(compact_record)
            
            if 'ASSURANCE_DV_CASE_ID' in record and record['ASSURANCE_DV_CASE_ID']:
                dv_id = str(record['ASSURANCE_DV_CASE_ID'])
                self.by_dv_case_id[dv_id].append(compact_record)
            
            if 'BUSINESS_APPLICATION_ID' in record and record['BUSINESS_APPLICATION_ID']:
                bus_id = str(record['BUSINESS_APPLICATION_ID'])
                self.by_business_id[bus_id].append(compact_record)
        
        # Convert to regular dicts
        self.by_app_id = dict(self.by_app_id)
        self.by_dv_case_id = dict(self.by_dv_case_id)
        self.by_business_id = dict(self.by_business_id)
        
        # Pre-compute module status
        self._build_module_cache()
        
        if DEBUG_MODE:
            print(f"Indexed: {len(self.by_app_id)} APP_IDs, "
                  f"{len(self.by_dv_case_id)} DV_CASE_IDs, "
                  f"{len(self.by_business_id)} BUSINESS_IDs")
    
    def _build_module_cache(self):
        """Pre-compute module completion status for O(1) lookups"""
        self.pia_completed = set()
        self.tia_completed = set()
        
        for id_dict, id_type in [
            (self.by_app_id, 'app'),
            (self.by_dv_case_id, 'dv'),
            (self.by_business_id, 'ba')
        ]:
            for case_id, records in id_dict.items():
                for record in records:
                    module = record.get('CASE_MODULE_NAME')
                    status = record.get('CASE_MODULE_STATUS_NAME')
                    
                    if status == 'Completed':
                        full_id = f"{id_type}:{case_id}"
                        if module == 'PIA':
                            self.pia_completed.add(full_id)
                        elif module == 'TIA':
                            self.tia_completed.add(full_id)

# Initialize cache
cache = DataCache()

# HTTP client with connection pooling
http_client = httpx.AsyncClient(
    verify=False,
    timeout=30.0,
    limits=httpx.Limits(
        max_keepalive_connections=20,
        max_connections=100,
        keepalive_expiry=30.0
    )
)

# ============= Helper Functions =============
def get_id_info(case_id):
    """Get ID column type and lookup dict"""
    case_str = str(case_id)
    
    if case_str.isdigit():
        return "APPLICATION_INSTANCE_ID", cache.by_app_id, "app"
    elif case_str.startswith("DVC"):
        return "ASSURANCE_DV_CASE_ID", cache.by_dv_case_id, "dv"
    elif case_str.startswith("BA"):
        return "BUSINESS_APPLICATION_ID", cache.by_business_id, "ba"
    else:
        return None, None, None

def check_countries(case_id, sending_country, receiving_country):
    """Ultra-fast country matching using in-memory dicts"""
    id_col, lookup_dict, _ = get_id_info(case_id)
    
    if not id_col or not lookup_dict:
        return "no_case"
    
    case_data = lookup_dict.get(str(case_id))
    
    if not case_data:
        return "no_case"
    
    # Check matches using generator expressions (faster)
    sending_match = any(
        record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE") == sending_country or
        record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME") == sending_country
        for record in case_data
    )
    
    receiving_match = any(
        record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE") == receiving_country or
        record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME") == receiving_country
        for record in case_data
    )
    
    if sending_match and receiving_match:
        return "all_match"
    elif not sending_match and not receiving_match:
        return "both_mismatch"
    elif not sending_match:
        return "sending_country_mismatch"
    elif not receiving_match:
        return "receiving_country_mismatch"

def check_module_complete(case_id, module_name):
    """O(1) module status check using pre-computed sets"""
    _, _, cache_prefix = get_id_info(case_id)
    
    if not cache_prefix:
        return False
    
    full_id = f"{cache_prefix}:{case_id}"
    
    if module_name == "PIA":
        return full_id in cache.pia_completed
    elif module_name == "TIA":
        return full_id in cache.tia_completed
    else:
        return False

async def query_opa(query: str, input_data: Optional[dict] = None) -> dict:
    """Reusable OPA query function with connection pooling"""
    payload = {"query": query}
    if input_data:
        payload["input"] = input_data
    
    try:
        if DEBUG_MODE:
            print(f"OPA Query: {query}")
            if input_data:
                print(f"OPA Input: {input_data}")
        
        response = await http_client.post(OPA_QUERY_URL, json=payload)
        response.raise_for_status()
        result = response.json()
        
        if DEBUG_MODE:
            print(f"OPA Response: {json.dumps(result, indent=2)}")
        
        return result
    except httpx.HTTPStatusError as e:
        error_detail = f"OPA HTTP Error: {e.response.status_code}"
        if DEBUG_MODE:
            error_detail += f" - {e.response.text}"
        print(error_detail)
        raise HTTPException(
            status_code=502,
            detail=f"OPA query failed: {e.response.status_code}"
        )
    except httpx.RequestError as e:
        error_msg = f"OPA Request Error: {str(e)}"
        print(error_msg)
        raise HTTPException(
            status_code=503,
            detail=f"OPA service unavailable: {str(e)}"
        )

def extract_opa_message(opa_result: dict) -> Optional[str]:
    """Extract message from OPA response (handles multiple formats)"""
    if not isinstance(opa_result, dict):
        if DEBUG_MODE:
            print(f"OPA result is not a dict: {type(opa_result)}")
        return None
    
    # Pattern 1: Direct result field
    if "result" in opa_result:
        result = opa_result["result"]
        
        # If result is a string, return it
        if isinstance(result, str):
            return result
        
        # If result is a list, check each item
        if isinstance(result, list):
            # Empty list case
            if len(result) == 0:
                if DEBUG_MODE:
                    print("OPA result is an empty list")
                return None
                
            for item in result:
                # Pattern 2: List of dicts with 'result' field
                if isinstance(item, dict) and "result" in item:
                    return item["result"]
                
                # Pattern 3: List of dicts with 'message' field
                if isinstance(item, dict) and "message" in item:
                    return item["message"]
                
                # Pattern 4: List of strings
                if isinstance(item, str):
                    return item
        
        # Pattern 5: Dict with nested result/message
        if isinstance(result, dict):
            if "result" in result:
                return result["result"]
            if "message" in result:
                return result["message"]
    
    # Pattern 6: Direct message field
    if "message" in opa_result:
        return opa_result["message"]
    
    if DEBUG_MODE:
        print(f"Could not extract message from OPA result: {opa_result}")
    
    return None

# ============= FastAPI App =============
app = FastAPI(
    title="TIA Evaluation Service",
    description="Ultra-fast TIA/PIA compliance evaluation",
    version="2.0.0"
)

@app.on_event("startup")
async def startup_event():
    """Load data on startup"""
    cache.initialize()

@app.on_event("shutdown")
async def shutdown_event():
    """Close HTTP client on shutdown"""
    await http_client.aclose()

@app.post("/data/evaluate")
async def data_evaluate(
    body: dict = Body(..., example={
        "caseId": "DVC123456",
        "sendingCountry": "GB",
        "receivingCountry": "US",
        "personalData": "Yes"
    })
):
    """Evaluate TIA/PIA requirements for a data transfer case"""
    cid = body.get("caseId")
    sending_country = body.get("sendingCountry")
    receiving_country = body.get("receivingCountry")
    personal_data = body.get("personalData")
    
    # Validation
    if not sending_country or not receiving_country or not personal_data:
        raise HTTPException(
            status_code=400,
            detail="Missing required fields. Provide sendingCountry, receivingCountry, and personalData."
        )
    
    # Normalize personal_data
    is_personal = str(personal_data).lower() not in ["no", "0", "false"]
    
    # Case 1: No case ID and no personal data
    if not cid and not is_personal:
        opa_query = "result = data.Uk.no_id_given"
        opa_input = {
            "sendingCountry": sending_country,
            "receivingCountry": receiving_country,
        }
        opa_result = await query_opa(opa_query, opa_input)
        
        opa_message = extract_opa_message(opa_result)
        
        if DEBUG_MODE:
            print(f"No ID given - Message: {opa_message}")
        
        return {
            "opa_result": opa_result,
            "message": opa_message,
            "status": "no_id_no_personal_data"
        }
    
    # Case 2: Case ID provided
    if cid:
        result = check_countries(cid, sending_country, receiving_country)
        if DEBUG_MODE:
            print(f"Country check result: {result}")
        
        # Handle no case found
        if result == "no_case":
            opa_query = "result = data.Uk.no_case_found"
            opa_result = await query_opa(opa_query)
            
            opa_message = extract_opa_message(opa_result)
            
            if DEBUG_MODE:
                print(f"No case found - Message: {opa_message}")
            
            return {
                "opa_result": opa_result,
                "message": opa_message,
                "status": "no_case"
            }
        
        # Handle country mismatches
        if result in ["sending_country_mismatch", "receiving_country_mismatch", "both_mismatch"]:
            if result == "both_mismatch":
                opa_query = "result = data.Uk.both_mismatch"
            elif result == "sending_country_mismatch":
                opa_query = "result = data.Uk.sending_mismatch"
            elif result == "receiving_country_mismatch":
                opa_query = "result = data.Uk.receiving_mismatch"
            
            opa_result = await query_opa(opa_query)
            
            if DEBUG_MODE:
                print("OPA Result for mismatch:", opa_result)
            
            # Extract the actual message/comment from Rego
            opa_message = extract_opa_message(opa_result)
            
            if DEBUG_MODE:
                print(f"Extracted mismatch message: {opa_message}")
            
            # Return structured response with extracted message
            return {
                "opa_result": opa_result,
                "message": opa_message,
                "status": result
            }
        
        # Handle all_match with no personal data
        if result == "all_match" and not is_personal:
            opa_query = "result = data.Uk.country_match_personal_no"
            opa_result = await query_opa(opa_query)
            
            opa_message = extract_opa_message(opa_result)
            
            if DEBUG_MODE:
                print(f"Countries match, no personal data - Message: {opa_message}")
            
            return {
                "opa_result": opa_result,
                "message": opa_message,
                "status": "country_match_no_personal_data"
            }
        
        # Case 3: Check TIA/PIA status
        opa_query = "result = data.Uk.check_status"
        opa_input = {
            "sendingCountry": sending_country,
            "receivingCountry": receiving_country
        }
        opa_result = await query_opa(opa_query, opa_input)
        if DEBUG_MODE:
            print("OPA Result:", opa_result)
        
        # Extract OPA message
        opa_message = extract_opa_message(opa_result)
        if DEBUG_MODE:
            print(f"Extracted message: {opa_message}")
        
        # Handle NO TIA case (PIA only)
        if opa_message == "NO TIA":
            pia_complete = check_module_complete(cid, "PIA")
            
            if pia_complete:
                opa_query = "result = data.Uk.PIA_satisfied"
                opa_result = await query_opa(opa_query)
            else:
                opa_query = "result = data.Uk.PIA_not_satisfied"
                opa_result = await query_opa(opa_query)
            
            final_message = extract_opa_message(opa_result)
            
            if DEBUG_MODE:
                print(f"PIA check result - Message: {final_message}")
            
            return {
                "opa_result": opa_result,
                "message": final_message,
                "status": "pia_satisfied" if pia_complete else "pia_not_satisfied"
            }
        
        # Handle Check TIA case (both TIA and PIA)
        elif opa_message == "Check TIA":
            tia_complete = check_module_complete(cid, "TIA")
            pia_complete = check_module_complete(cid, "PIA")
            
            if tia_complete and pia_complete:
                opa_query = "result = data.Uk.TIA_PIA_satisfied"
                opa_result = await query_opa(opa_query)
            else:
                opa_query = "result = data.Uk.TIA_PIA_not_satisfied"
                opa_result = await query_opa(opa_query)
            
            final_message = extract_opa_message(opa_result)
            
            if DEBUG_MODE:
                print(f"TIA/PIA check result - Message: {final_message}")
            
            return {
                "opa_result": opa_result,
                "message": final_message,
                "status": "tia_pia_satisfied" if (tia_complete and pia_complete) else "tia_pia_not_satisfied"
            }
        
        return {
            "opa_result": opa_result,
            "message": opa_message
        }
    
    # Fallback
    raise HTTPException(status_code=400, detail="Invalid request parameters")

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    if not cache.initialized:
        return {"status": "initializing", "cache_initialized": False}
    
    return {
        "status": "healthy",
        "cache_initialized": True,
        "indexes": {
            "application_ids": len(cache.by_app_id),
            "dv_case_ids": len(cache.by_dv_case_id),
            "business_ids": len(cache.by_business_id),
            "pia_completed_cases": len(cache.pia_completed),
            "tia_completed_cases": len(cache.tia_completed)
        }
    }

@app.get("/stats")
async def get_stats():
    """Detailed statistics"""
    if not cache.initialized:
        raise HTTPException(status_code=503, detail="Cache not initialized")
    
    return {
        "total_unique_cases": {
            "application_ids": len(cache.by_app_id),
            "dv_case_ids": len(cache.by_dv_case_id),
            "business_ids": len(cache.by_business_id)
        },
        "compliance_status": {
            "pia_completed": len(cache.pia_completed),
            "tia_completed": len(cache.tia_completed)
        },
        "performance": {
            "lookup_complexity": "O(1)",
            "module_check_complexity": "O(1)"
        }
    }

@app.post("/debug/opa")
async def debug_opa_query(
    body: dict = Body(..., example={
        "query": "result = data.Uk.check_status",
        "input": {"sendingCountry": "GB", "receivingCountry": "US"}
    })
):
    """Debug endpoint to test OPA queries directly"""
    query = body.get("query")
    input_data = body.get("input")
    
    if not query:
        raise HTTPException(status_code=400, detail="query field is required")
    
    try:
        opa_result = await query_opa(query, input_data)
        extracted_message = extract_opa_message(opa_result)
        
        return {
            "query": query,
            "input": input_data,
            "raw_opa_response": opa_result,
            "extracted_message": extracted_message,
            "extraction_successful": extracted_message is not None
        }
    except Exception as e:
        return {
            "query": query,
            "input": input_data,
            "error": str(e),
            "error_type": type(e).__name__
        }

@app.get("/debug/case/{case_id}")
async def debug_case_lookup(case_id: str):
    """Debug endpoint to check case data"""
    if not cache.initialized:
        raise HTTPException(status_code=503, detail="Cache not initialized")
    
    id_col, lookup_dict, cache_prefix = get_id_info(case_id)
    
    if not id_col:
        return {
            "case_id": case_id,
            "found": False,
            "error": "Invalid case ID format"
        }
    
    case_data = lookup_dict.get(str(case_id))
    
    if not case_data:
        return {
            "case_id": case_id,
            "id_type": id_col,
            "found": False
        }
    
    pia_complete = check_module_complete(case_id, "PIA")
    tia_complete = check_module_complete(case_id, "TIA")
    
    sending_countries = set()
    receiving_countries = set()
    
    for record in case_data:
        if record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE"):
            sending_countries.add(record["ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_CODE"])
        if record.get("ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME"):
            sending_countries.add(record["ASSURANCE_SENDING_COUNTRY_TERRITORY_ISO_NAME"])
        if record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE"):
            receiving_countries.add(record["ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_CODE"])
        if record.get("ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME"):
            receiving_countries.add(record["ASSURANCE_RECEIVING_COUNTRY_TERRITORY_ISO_NAME"])
    
    return {
        "case_id": case_id,
        "id_type": id_col,
        "found": True,
        "record_count": len(case_data),
        "compliance_status": {
            "pia_completed": pia_complete,
            "tia_completed": tia_complete
        },
        "countries": {
            "sending": list(sending_countries),
            "receiving": list(receiving_countries)
        },
        "raw_records": case_data
    }

@app.get("/debug/rego-policies")
async def debug_rego_policies():
    """
    Test all Rego policy queries to see what they return.
    Useful for debugging empty responses.
    """
    test_queries = [
        ("no_case_found", "result = data.Uk.no_case_found", None),
        ("both_mismatch", "result = data.Uk.both_mismatch", None),
        ("sending_mismatch", "result = data.Uk.sending_mismatch", None),
        ("receiving_mismatch", "result = data.Uk.receiving_mismatch", None),
        ("country_match_personal_no", "result = data.Uk.country_match_personal_no", None),
        ("PIA_satisfied", "result = data.Uk.PIA_satisfied", None),
        ("PIA_not_satisfied", "result = data.Uk.PIA_not_satisfied", None),
        ("TIA_PIA_satisfied", "result = data.Uk.TIA_PIA_satisfied", None),
        ("TIA_PIA_not_satisfied", "result = data.Uk.TIA_PIA_not_satisfied", None),
        ("check_status_GB_US", "result = data.Uk.check_status", 
         {"sendingCountry": "GB", "receivingCountry": "US"}),
        ("no_id_given_GB_US", "result = data.Uk.no_id_given",
         {"sendingCountry": "GB", "receivingCountry": "US"}),
    ]
    
    results = {}
    
    for name, query, input_data in test_queries:
        try:
            opa_result = await query_opa(query, input_data)
            extracted_message = extract_opa_message(opa_result)
            
            results[name] = {
                "query": query,
                "input": input_data,
                "raw_response": opa_result,
                "extracted_message": extracted_message,
                "has_message": extracted_message is not None,
                "is_empty": opa_result == {} or opa_result.get("result") == []
            }
        except Exception as e:
            results[name] = {
                "query": query,
                "input": input_data,
                "error": str(e),
                "error_type": type(e).__name__
            }
    
    return {
        "test_results": results,
        "summary": {
            "total_queries": len(test_queries),
            "successful": sum(1 for r in results.values() if "error" not in r),
            "with_messages": sum(1 for r in results.values() if r.get("has_message")),
            "empty_responses": sum(1 for r in results.values() if r.get("is_empty"))
        }
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
