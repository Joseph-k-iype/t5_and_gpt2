"""
Direct Azure AD token provider that exactly matches your working code pattern.
"""

import logging
import os
from typing import Optional
from azure.identity import DefaultAzureCredential, ClientSecretCredential, get_bearer_token_provider
from dotenv import dotenv_values

logger = logging.getLogger(__name__)

# Load environment variables
ENV_DIR = "env"
CONFIG_PATH = f"{ENV_DIR}/config.env"
CREDS_PATH = f"{ENV_DIR}/credentials.env"

# Load environment variables directly
config_values = {}
creds_values = {}

try:
    if os.path.isfile(CONFIG_PATH):
        logger.info(f"Loading configuration from {CONFIG_PATH}")
        config_values = dotenv_values(CONFIG_PATH)
    else:
        logger.warning(f"Config file not found: {CONFIG_PATH}")
except Exception as e:
    logger.error(f"Error loading config file: {e}")

try:
    if os.path.isfile(CREDS_PATH):
        logger.info(f"Loading credentials from {CREDS_PATH}")
        creds_values = dotenv_values(CREDS_PATH)
    else:
        logger.warning(f"Credentials file not found: {CREDS_PATH}")
except Exception as e:
    logger.error(f"Error loading credentials file: {e}")

# Combine both sets of values
all_values = {**config_values, **creds_values}

# Global provider
_token_provider = None

def get_direct_token_provider(force_refresh=False):
    """
    Get a token provider exactly as in the working code.
    This uses the exact same pattern that works in your EmbeddingClient class.
    
    Args:
        force_refresh: Whether to force a new provider
        
    Returns:
        Azure token provider
    """
    global _token_provider
    
    if _token_provider is None or force_refresh:
        # Check if we should use managed identity
        use_managed_identity = all_values.get("USE_MANAGED_IDENTITY", "").lower() == "true"
        
        if use_managed_identity:
            logger.info("Using DefaultAzureCredential for authentication")
            credential = DefaultAzureCredential()
        else:
            # Get tenant ID, client ID, and client secret from environment
            tenant_id = all_values.get("AZURE_TENANT_ID", "")
            client_id = all_values.get("AZURE_CLIENT_ID", "")
            client_secret = all_values.get("AZURE_CLIENT_SECRET", "")
            
            # Log credentials (masked)
            masked_tenant = f"{tenant_id[:4]}...{tenant_id[-4:]}" if len(tenant_id) > 8 else "***"
            masked_client = f"{client_id[:4]}...{client_id[-4:]}" if len(client_id) > 8 else "***"
            logger.info(f"Creating token provider with:")
            logger.info(f"  - Tenant ID: {masked_tenant}")
            logger.info(f"  - Client ID: {masked_client}")
            
            logger.info("Using ClientSecretCredential for authentication")
            credential = ClientSecretCredential(
                tenant_id=tenant_id,
                client_id=client_id,
                client_secret=client_secret
            )
        
        # Create token provider
        logger.info("Creating token provider with credential")
        _token_provider = get_bearer_token_provider(
            credential,
            "https://cognitiveservices.azure.com/.default"
        )
        logger.info("Token provider created successfully")
    
    return _token_provider

# Simple function to get a credential in exactly the same way
def get_direct_credential(force_refresh=False):
    """
    Get a credential exactly as in the working code.
    
    Args:
        force_refresh: Whether to force a new credential
        
    Returns:
        Azure credential
    """
    # Check if we should use managed identity
    use_managed_identity = all_values.get("USE_MANAGED_IDENTITY", "").lower() == "true"
    
    if use_managed_identity:
        logger.info("Using DefaultAzureCredential for authentication")
        return DefaultAzureCredential()
    else:
        # Get tenant ID, client ID, and client secret from environment
        tenant_id = all_values.get("AZURE_TENANT_ID", "")
        client_id = all_values.get("AZURE_CLIENT_ID", "")
        client_secret = all_values.get("AZURE_CLIENT_SECRET", "")
        
        logger.info("Using ClientSecretCredential for authentication")
        return ClientSecretCredential(
            tenant_id=tenant_id,
            client_id=client_id,
            client_secret=client_secret
        )

# Functions to maintain compatibility with existing code

def get_azure_token_cached(tenant_id: str = None, client_id: str = None, client_secret: str = None, 
                          scope: str = "https://cognitiveservices.azure.com/.default") -> Optional[str]:
    """
    Compatibility function for existing code.
    
    Returns:
        Access token if successful, None otherwise
    """
    try:
        credential = get_direct_credential()
        token = credential.get_token(scope)
        return token.token if token else None
    except Exception as e:
        logger.error(f"Error getting Azure token: {e}")
        return None

def start_token_refresh_service(refresh_interval: int = 300):
    """
    Dummy function to maintain compatibility.
    In this simplified approach, tokens are refreshed automatically by Azure SDK.
    
    Returns:
        None
    """
    logger.info("Token refresh service not needed with direct token provider")
    return None

# Simplified auth functions for FastAPI dependency injection
async def verify_api_key(api_key: str = None):
    """No API key verification required."""
    return True

async def get_current_user(token: str = None):
    """Simplified user authentication."""
    return {"username": "default_user"}
