# backend/app/api/knowledge_graph.py
from fastapi import APIRouter, HTTPException, Depends, Request
from typing import List, Dict, Any
import logging

from app.models.knowledge_graph import (
    KnowledgeGraphRequest, KnowledgeGraphResponse,
    GraphNode, GraphEdge
)
from app.core.session_manager import SessionManager
from app.utils.knowledge_extractor import KnowledgeExtractor

logger = logging.getLogger(__name__)
router = APIRouter()

def get_session_manager(request: Request) -> SessionManager:
    """Dependency to get session manager"""
    return request.app.state.session_manager

@router.post("/generate", response_model=KnowledgeGraphResponse)
async def generate_knowledge_graph(
    request: KnowledgeGraphRequest,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """
    Generate knowledge graph from research results or conversation
    """
    try:
        # Validate session if provided
        if request.session_id:
            session = await session_manager.get_session(request.session_id)
            if not session:
                raise HTTPException(status_code=404, detail="Session not found")
        
        # Initialize knowledge extractor
        extractor = KnowledgeExtractor()
        
        # Extract concepts and relationships
        graph_data = await extractor.extract_knowledge_graph(
            text=request.content,
            context=request.context,
            max_nodes=request.max_nodes,
            max_edges=request.max_edges
        )
        
        # Convert to response model
        nodes = [
            GraphNode(
                id=node["id"],
                label=node["label"],
                type=node.get("type", "concept"),
                properties=node.get("properties", {}),
                size=node.get("size", 20),
                color=node.get("color", "#4A90E2")
            )
            for node in graph_data["nodes"]
        ]
        
        edges = [
            GraphEdge(
                id=edge["id"],
                source=edge["source"],
                target=edge["target"],
                label=edge.get("label", ""),
                type=edge.get("type", "related"),
                properties=edge.get("properties", {}),
                weight=edge.get("weight", 1.0)
            )
            for edge in graph_data["edges"]
        ]
        
        return KnowledgeGraphResponse(
            nodes=nodes,
            edges=edges,
            metadata={
                "total_nodes": len(nodes),
                "total_edges": len(edges),
                "generation_method": "nlp_extraction",
                "confidence": graph_data.get("confidence", 0.8)
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating knowledge graph: {e}")
        raise HTTPException(status_code=500, detail=f"Knowledge graph generation failed: {str(e)}")

@router.get("/session/{session_id}", response_model=KnowledgeGraphResponse)
async def get_session_knowledge_graph(
    session_id: str,
    session_manager: SessionManager = Depends(get_session_manager)
):
    """
    Generate knowledge graph from entire session conversation
    """
    try:
        session = await session_manager.get_session(session_id)
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Combine all conversation content
        content_parts = []
        for message in session.conversation_history:
            if message.get("role") == "assistant":
                content_parts.append(message.get("content", ""))
        
        combined_content = " ".join(content_parts)
        
        if not combined_content.strip():
            # Return empty graph for sessions with no content
            return KnowledgeGraphResponse(
                nodes=[],
                edges=[],
                metadata={
                    "total_nodes": 0,
                    "total_edges": 0,
                    "generation_method": "session_conversation",
                    "session_id": session_id
                }
            )
        
        # Generate graph from combined content
        extractor = KnowledgeExtractor()
        graph_data = await extractor.extract_knowledge_graph(
            text=combined_content,
            context={"session_id": session_id, "type": "conversation"},
            max_nodes=30,
            max_edges=50
        )
        
        # Convert to response model
        nodes = [
            GraphNode(
                id=node["id"],
                label=node["label"],
                type=node.get("type", "concept"),
                properties=node.get("properties", {}),
                size=node.get("size", 20),
                color=node.get("color", "#4A90E2")
            )
            for node in graph_data["nodes"]
        ]
        
        edges = [
            GraphEdge(
                id=edge["id"],
                source=edge["source"],
                target=edge["target"],
                label=edge.get("label", ""),
                type=edge.get("type", "related"),
                properties=edge.get("properties", {}),
                weight=edge.get("weight", 1.0)
            )
            for edge in graph_data["edges"]
        ]
        
        return KnowledgeGraphResponse(
            nodes=nodes,
            edges=edges,
            metadata={
                "total_nodes": len(nodes),
                "total_edges": len(edges),
                "generation_method": "session_conversation",
                "session_id": session_id,
                "confidence": graph_data.get("confidence", 0.8)
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating session knowledge graph: {e}")
        raise HTTPException(status_code=500, detail="Knowledge graph generation failed")
