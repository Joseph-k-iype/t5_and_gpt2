import React, { createContext, useContext, useReducer, useCallback } from 'react';
import { chatService } from '../services/chatService';
import { useSession } from './SessionContext';
import toast from 'react-hot-toast';

// Create Chat Context
export const ChatContext = createContext();

// Chat reducer
const chatReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_MESSAGE':
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case 'SET_MESSAGES':
      return {
        ...state,
        messages: action.payload,
      };
    case 'SET_TYPING':
      return {
        ...state,
        isTyping: action.payload,
      };
    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.payload,
      };
    case 'SET_PROCESSING':
      return {
        ...state,
        isProcessing: action.payload,
      };
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload,
        isLoading: false,
        isTyping: false,
        isProcessing: false,
      };
    case 'CLEAR_MESSAGES':
      return {
        ...state,
        messages: [],
        error: null,
      };
    default:
      return state;
  }
};

// Initial state
const initialState = {
  messages: [],
  isTyping: false,
  isLoading: false,
  isProcessing: false, // New state for long-running operations
  error: null,
};

export const ChatProvider = ({ children }) => {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const { sessionId, userId, updateSessionStats } = useSession();

  const addMessage = useCallback((message) => {
    dispatch({ type: 'ADD_MESSAGE', payload: message });
  }, []);

  const sendMessage = useCallback(async (content) => {
    if (!sessionId || !content.trim()) return;

    try {
      // Add user message immediately
      const userMessage = {
        id: `user_${Date.now()}`,
        role: 'user',
        content: content.trim(),
        timestamp: new Date().toISOString(),
      };
      
      addMessage(userMessage);
      dispatch({ type: 'SET_LOADING', payload: true });
      dispatch({ type: 'SET_TYPING', payload: true });

      // Show processing message for longer operations
      const processingTimeout = setTimeout(() => {
        dispatch({ type: 'SET_PROCESSING', payload: true });
        
        // Add processing message
        const processingMessage = {
          id: `processing_${Date.now()}`,
          role: 'assistant',
          content: '🧠 Deep AI research in progress... This may take 2-5 minutes for comprehensive analysis. Please wait while I analyze multiple sources and generate insights.',
          timestamp: new Date().toISOString(),
          metadata: {
            confidence: 'high',
            approach: 'processing_indicator',
            isTemporary: true,
          },
        };
        addMessage(processingMessage);
      }, 10000); // Show after 10 seconds

      try {
        // Send to API with no timeout concerns
        const response = await chatService.sendQuickMessage({
          message: content.trim(),
          session_id: sessionId,
          user_id: userId,
        });

        // Clear processing timeout
        clearTimeout(processingTimeout);

        // Remove processing message if it was added
        dispatch({ type: 'SET_PROCESSING', payload: false });

        // Add AI response
        const aiMessage = {
          id: `ai_${Date.now()}`,
          role: 'assistant',
          content: response.answer,
          timestamp: response.timestamp,
          metadata: {
            confidence: response.confidence,
            approach: response.approach,
            real_ai: response.metadata?.real_ai || false,
          },
        };
        
        addMessage(aiMessage);
        
        // Update session stats
        updateSessionStats({
          messageCount: state.messages.length + 2,
        });

        // Show success toast for real AI responses
        if (response.metadata?.real_ai) {
          toast.success('✨ Real AI research completed!');
        }

      } catch (error) {
        clearTimeout(processingTimeout);
        dispatch({ type: 'SET_PROCESSING', payload: false });
        
        console.error('Failed to send message:', error);
        
        // Better error handling
        let errorMessage = 'I apologize, but I encountered an error processing your message.';
        let shouldShowToast = true;
        
        if (error.isResearchTimeout) {
          errorMessage = '⏰ The research is taking longer than expected, but it\'s still processing. The AI is conducting comprehensive analysis - please be patient.';
          shouldShowToast = false; // Don't show error toast for research timeouts
        } else if (!error.response) {
          errorMessage = 'Unable to connect to the AI research system. Please check if the backend is running on port 8000.';
          toast.error('Connection failed - is the backend running?');
        } else if (error.response?.status >= 500) {
          errorMessage = 'The AI research system encountered an error. Please try again in a moment.';
          toast.error('Server error - please try again');
        } else if (shouldShowToast) {
          toast.error('Failed to process message');
        }
        
        dispatch({ type: 'SET_ERROR', payload: error.message });
        
        // Add error message
        const errorMessageObj = {
          id: `error_${Date.now()}`,
          role: 'assistant',
          content: errorMessage,
          timestamp: new Date().toISOString(),
          metadata: {
            confidence: 'low',
            approach: 'error',
            isError: true,
          },
        };
        
        addMessage(errorMessageObj);
      }

    } catch (outerError) {
      console.error('Outer error in sendMessage:', outerError);
      dispatch({ type: 'SET_ERROR', payload: outerError.message });
      
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
      dispatch({ type: 'SET_TYPING', payload: false });
      dispatch({ type: 'SET_PROCESSING', payload: false });
    }
  }, [sessionId, userId, addMessage, state.messages.length, updateSessionStats]);

  const startDeepResearch = useCallback(async (topic) => {
    if (!sessionId || !topic.trim()) return;

    try {
      // Add user message
      const userMessage = {
        id: `research_user_${Date.now()}`,
        role: 'user',
        content: topic.trim(),
        timestamp: new Date().toISOString(),
        metadata: {
          type: 'research_request',
        },
      };
      
      addMessage(userMessage);
      dispatch({ type: 'SET_LOADING', payload: true });
      dispatch({ type: 'SET_PROCESSING', payload: true });

      // Start research message
      const researchMessage = {
        id: `research_start_${Date.now()}`,
        role: 'assistant',
        content: `🔬 Starting comprehensive deep research on: "${topic.trim()}"\n\n🤖 Initializing multi-agent AI research system...\n⏳ This process typically takes 2-5 minutes for thorough analysis.\n\n📊 The system will:\n• Analyze multiple data sources\n• Apply specialized research agents\n• Generate comprehensive insights\n• Synthesize findings into a detailed report\n\nPlease wait while the research is conducted...`,
        timestamp: new Date().toISOString(),
        metadata: {
          confidence: 'high',
          approach: 'deep_research_initiated',
          type: 'research_start',
        },
      };
      
      addMessage(researchMessage);

    } catch (error) {
      console.error('Failed to start research:', error);
      dispatch({ type: 'SET_ERROR', payload: error.message });
      toast.error('Failed to start research. Please try again.');
      
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [sessionId, addMessage]);

  const loadConversationHistory = useCallback(async () => {
    if (!sessionId) return;

    try {
      const history = await chatService.getConversationHistory(sessionId);
      dispatch({ type: 'SET_MESSAGES', payload: history.messages });
      
    } catch (error) {
      console.error('Failed to load conversation history:', error);
      // Don't show error toast for this, as it's not critical
    }
  }, [sessionId]);

  const clearMessages = useCallback(() => {
    dispatch({ type: 'CLEAR_MESSAGES' });
  }, []);

  const value = {
    ...state,
    sendMessage,
    startDeepResearch,
    addMessage,
    loadConversationHistory,
    clearMessages,
  };

  return (
    <ChatContext.Provider value={value}>
      {children}
    </ChatContext.Provider>
  );
};

export const useChat = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};
