from extensions import db
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from sqlalchemy import UniqueConstraint

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password_hash = db.Column(db.String(100), nullable=False)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Ontology(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    classes = db.relationship('Class', backref='ontology', lazy=True)
    properties = db.relationship('OntologyProperty', backref='ontology', lazy=True)
    namespaces = db.relationship('Namespace', backref='ontology', lazy=True)

    def __repr__(self):
        return f'<Ontology {self.name}>'

class Namespace(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    uri = db.Column(db.String(255), nullable=False)
    ontology_id = db.Column(db.Integer, db.ForeignKey('ontology.id'), nullable=False)

    def __repr__(self):
        return f'<Namespace {self.name} ({self.uri})>'

class Class(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    ontology_id = db.Column(db.Integer, db.ForeignKey('ontology.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=True)
    namespace_id = db.Column(db.Integer, db.ForeignKey('namespace.id'), nullable=True)
    subclasses = db.relationship('Class', backref=db.backref('parent', remote_side=[id]), lazy=True)
    
    equivalent_classes = db.relationship(
        'EquivalentClass',
        foreign_keys='EquivalentClass.class_id',
        backref='class',
        lazy=True
    )
    
    disjoint_classes = db.relationship(
        'DisjointClass',
        foreign_keys='DisjointClass.class_id',
        backref='class',
        lazy=True
    )

    __table_args__ = (
        UniqueConstraint('name', 'ontology_id', name='uq_class_name_ontology_id'),
    )

    def __repr__(self):
        return f'<Class {self.name}>'

class OntologyProperty(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    ontology_id = db.Column(db.Integer, db.ForeignKey('ontology.id'), nullable=False)
    domain_class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)
    range_class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('ontology_property.id'), nullable=True)
    namespace_id = db.Column(db.Integer, db.ForeignKey('namespace.id'), nullable=True)
    subproperties = db.relationship('OntologyProperty', backref=db.backref('parent', remote_side=[id]), lazy=True)

    __table_args__ = (
        UniqueConstraint('name', 'ontology_id', name='uq_property_name_ontology_id'),
    )

    def __repr__(self):
        return f'<OntologyProperty {self.name}>'

class EquivalentClass(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)
    equivalent_class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)

    __table_args__ = (
        UniqueConstraint('class_id', 'equivalent_class_id', name='uq_equivalent_class'),
    )

class DisjointClass(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)
    disjoint_class_id = db.Column(db.Integer, db.ForeignKey('class.id'), nullable=False)

    __table_args__ = (
        UniqueConstraint('class_id', 'disjoint_class_id', name='uq_disjoint_class'),
    )

ontoservice

from models import Class, OntologyProperty, EquivalentClass, DisjointClass, Namespace, db
from rdflib import Graph as RDFGraph, URIRef, RDF, OWL, RDFS

class OntologyService:
    def __init__(self, ontology_id, filename=None):
        self.graph = RDFGraph()
        self.ontology_id = ontology_id
        self.base_uri = f"http://example.org/ontology/{ontology_id}"

        # Load existing TTL file if provided
        if filename:
            self.graph.parse(filename, format='turtle')

        # Load existing data from the database
        self.load_existing_data()

    def load_existing_data(self):
        """Load existing classes, properties, etc., into the RDF graph."""
        classes = Class.query.filter_by(ontology_id=self.ontology_id).all()
        for cls in classes:
            namespace = Namespace.query.get(cls.namespace_id)
            class_uri = URIRef(f"{namespace.uri}#{cls.name}") if namespace else URIRef(f"{self.base_uri}#{cls.name}")
            self.graph.add((class_uri, RDF.type, OWL.Class))
            if cls.parent_id:
                parent_class = Class.query.get(cls.parent_id)
                parent_namespace = Namespace.query.get(parent_class.namespace_id)
                parent_class_uri = URIRef(f"{parent_namespace.uri}#{parent_class.name}") if parent_namespace else URIRef(f"{self.base_uri}#{parent_class.name}")
                self.graph.add((class_uri, RDFS.subClassOf, parent_class_uri))

        properties = OntologyProperty.query.filter_by(ontology_id=self.ontology_id).all()
        for prop in properties:
            namespace = Namespace.query.get(prop.namespace_id)
            property_uri = URIRef(f"{namespace.uri}#{prop.name}") if namespace else URIRef(f"{self.base_uri}#{prop.name}")
            domain_class = Class.query.get(prop.domain_class_id)
            range_class = Class.query.get(prop.range_class_id)
            domain_namespace = Namespace.query.get(domain_class.namespace_id)
            range_namespace = Namespace.query.get(range_class.namespace_id)
            domain_uri = URIRef(f"{domain_namespace.uri}#{domain_class.name}") if domain_namespace else URIRef(f"{self.base_uri}#{domain_class.name}")
            range_uri = URIRef(f"{range_namespace.uri}#{range_class.name}") if range_namespace else URIRef(f"{self.base_uri}#{range_class.name}")

            self.graph.add((property_uri, RDF.type, OWL.ObjectProperty))
            self.graph.add((property_uri, RDFS.domain, domain_uri))
            self.graph.add((property_uri, RDFS.range, range_uri))

    def add_class(self, class_name, parent_id=None, custom_namespace=None):
        namespace_id = Namespace.query.filter_by(uri=custom_namespace).first().id if custom_namespace else None
        new_class = Class(name=class_name, ontology_id=self.ontology_id, parent_id=parent_id, namespace_id=namespace_id)
        db.session.add(new_class)
        db.session.commit()

        namespace = Namespace.query.get(namespace_id)
        class_uri = URIRef(f"{namespace.uri}#{class_name}") if namespace else URIRef(f"{self.base_uri}#{class_name}")
        self.graph.add((class_uri, RDF.type, OWL.Class))

        if parent_id:
            parent_class = Class.query.get(parent_id)
            parent_namespace = Namespace.query.get(parent_class.namespace_id)
            parent_class_uri = URIRef(f"{parent_namespace.uri}#{parent_class.name}") if parent_namespace else URIRef(f"{self.base_uri}#{parent_class.name}")
            self.graph.add((class_uri, RDFS.subClassOf, parent_class_uri))

        return {'id': new_class.id, 'name': new_class.name}

    def add_subclass(self, class_name, parent_class_id):
        return self.add_class(class_name, parent_class_id)

    def add_equivalent_class(self, class_id, equivalent_class_id):
        eq_class = EquivalentClass(class_id=class_id, equivalent_class_id=equivalent_class_id)
        db.session.add(eq_class)
        db.session.commit()

        class_obj = Class.query.get(class_id)
        eq_class_obj = Class.query.get(equivalent_class_id)
        class_namespace = Namespace.query.get(class_obj.namespace_id)
        eq_class_namespace = Namespace.query.get(eq_class_obj.namespace_id)
        class_uri = URIRef(f"{class_namespace.uri}#{class_obj.name}") if class_namespace else URIRef(f"{self.base_uri}#{class_obj.name}")
        eq_class_uri = URIRef(f"{eq_class_namespace.uri}#{eq_class_obj.name}") if eq_class_namespace else URIRef(f"{self.base_uri}#{eq_class_obj.name}")
        self.graph.add((class_uri, OWL.equivalentClass, eq_class_uri))

        return {'id': eq_class.id, 'class_id': class_id, 'equivalent_class_id': equivalent_class_id}

    def add_disjoint_class(self, class_id, disjoint_class_id):
        disj_class = DisjointClass(class_id=class_id, disjoint_class_id=disjoint_class_id)
        db.session.add(disj_class)
        db.session.commit()

        class_obj = Class.query.get(class_id)
        disj_class_obj = Class.query.get(disjoint_class_id)
        class_namespace = Namespace.query.get(class_obj.namespace_id)
        disj_class_namespace = Namespace.query.get(disj_class_obj.namespace_id)
        class_uri = URIRef(f"{class_namespace.uri}#{class_obj.name}") if class_namespace else URIRef(f"{self.base_uri}#{class_obj.name}")
        disj_class_uri = URIRef(f"{disj_class_namespace.uri}#{disj_class_obj.name}") if disj_class_namespace else URIRef(f"{self.base_uri}#{disj_class_obj.name}")
        self.graph.add((class_uri, OWL.disjointWith, disj_class_uri))

        return {'id': disj_class.id, 'class_id': class_id, 'disjoint_class_id': disjoint_class_id}

    def add_property(self, property_name, domain_class_id, range_class_id, parent_id=None, custom_namespace=None, data_type=None):
        namespace_id = Namespace.query.filter_by(uri=custom_namespace).first().id if custom_namespace else None
        new_property = OntologyProperty(
            name=property_name, ontology_id=self.ontology_id, 
            domain_class_id=domain_class_id, range_class_id=range_class_id, 
            parent_id=parent_id, namespace_id=namespace_id
        )
        db.session.add(new_property)
        db.session.commit()

        namespace = Namespace.query.get(namespace_id)
        property_uri = URIRef(f"{namespace.uri}#{property_name}") if namespace else URIRef(f"{self.base_uri}#{property_name}")
        domain_class = Class.query.get(domain_class_id)
        range_class = Class.query.get(range_class_id)
        domain_namespace = Namespace.query.get(domain_class.namespace_id)
        range_namespace = Namespace.query.get(range_class.namespace_id)
        domain_uri = URIRef(f"{domain_namespace.uri}#{domain_class.name}") if domain_namespace else URIRef(f"{self.base_uri}#{domain_class.name}")
        range_uri = URIRef(f"{range_namespace.uri}#{range_class.name}") if range_namespace else URIRef(f"{self.base_uri}#{range_class.name}")

        self.graph.add((property_uri, RDF.type, OWL.ObjectProperty))
        self.graph.add((property_uri, RDFS.domain, domain_uri))
        self.graph.add((property_uri, RDFS.range, range_uri))

        return {'id': new_property.id, 'name': new_property.name}

    def add_namespace(self, namespace_name, namespace_uri):
        new_namespace = Namespace(name=namespace_name, uri=namespace_uri, ontology_id=self.ontology_id)
        db.session.add(new_namespace)
        db.session.commit()

        self.graph.bind(namespace_name, URIRef(namespace_uri))

        return {'id': new_namespace.id, 'name': new_namespace.name, 'uri': new_namespace.uri}

    def serialize_ontology(self, format="ttl"):
        return self.graph.serialize(format=format)

    def get_cytoscape_elements(self):
        elements = []

        classes = Class.query.filter_by(ontology_id=self.ontology_id).all()
        for cls in classes:
            elements.append({'data': {'id': cls.id, 'label': cls.name}})
            if cls.parent_id:
                elements.append({'data': {'source': cls.parent_id, 'target': cls.id}})

        properties = OntologyProperty.query.filter_by(ontology_id=self.ontology_id).all()
        for prop in properties:
            elements.append({'data': {'id': prop.id, 'label': prop.name}})
            elements.append({'data': {'source': prop.domain_class_id, 'target': prop.range_class_id, 'label': prop.name}})

        return elements
