The error "object of type int has no len()" indicates there's an issue with the embedding function. Something in the code is trying to get the length of an integer when it expects a list or array.

Let's fix this by updating the `CustomEmbeddingFunction` class in your code:

```python
class CustomEmbeddingFunction:
    """Custom embedding function class compatible with Langchain."""
    
    def __init__(self, embedding_client):
        self.embedding_client = embedding_client
        
    def embed_documents(self, texts):
        """Embed documents - this method name is required by Langchain."""
        try:
            logger.info(f"Embedding {len(texts)} documents")
            # Create a list to store embeddings
            embeddings = []
            for text in texts:
                # Create a MyDocument instance with the text
                doc = MyDocument(id=str(uuid.uuid4()), text=text)
                # Generate embedding and add to list
                embedding_result = self.embedding_client.generate_embeddings(doc)
                
                # Debug the embedding result
                logger.info(f"Embedding result type: {type(embedding_result.embedding) if hasattr(embedding_result, 'embedding') else 'No embedding attribute'}")
                
                # Handle different cases for the embedding value
                if not hasattr(embedding_result, 'embedding'):
                    logger.warning(f"No embedding attribute found, using dummy embedding")
                    dim = 1536  # Default dimension
                    embeddings.append([0.0] * dim)
                elif embedding_result.embedding is None:
                    logger.warning(f"Embedding is None, using dummy embedding")
                    dim = 1536  # Default dimension
                    embeddings.append([0.0] * dim)
                elif isinstance(embedding_result.embedding, int):
                    # Convert integer to a list with a single value
                    logger.warning(f"Got integer embedding ({embedding_result.embedding}), converting to list")
                    dim = 1536  # Default dimension
                    embeddings.append([float(embedding_result.embedding)] + [0.0] * (dim - 1))
                elif isinstance(embedding_result.embedding, (list, tuple, np.ndarray)):
                    # Normal case - embedding is a list-like object
                    embeddings.append(embedding_result.embedding)
                else:
                    # Unknown type - create dummy embedding
                    logger.warning(f"Unknown embedding type: {type(embedding_result.embedding)}, using dummy")
                    dim = 1536  # Default dimension
                    embeddings.append([0.0] * dim)
            
            return embeddings
        except Exception as e:
            logger.error(f"Error in embed_documents: {e}")
            # Return dummy embeddings with fixed dimensions
            dim = 1536  # Default dimension
            return [[0.0] * dim for _ in range(len(texts))]
    
    def embed_query(self, text):
        """Embed a single query - this method name is required by Langchain."""
        result = self.embed_documents([text])
        if result and len(result) > 0:
            return result[0]
        # Fallback
        dim = 1536
        return [0.0] * dim
```

You also need to update the `get_embedding_function` method in the `ChromaManager` class:

```python
def get_embedding_function(self):
    """Get a properly formatted embedding function for Langchain."""
    return CustomEmbeddingFunction(self.embedding_client)
```

To add a bit more debugging, you can modify the `add_documents` method in `ChromaManager`:

```python
def add_documents(self, documents: List[LC_DOCUMENT]):
    """Add documents to the vector store."""
    if not self.vectorstore:
        logger.info("Vector store not initialized, initializing now...")
        self.init_vectorstore()
        
    try:
        # Make sure we still have a valid vectorstore
        if self.vectorstore is None:
            raise ValueError("Vector store is None, cannot add documents")
        
        # Check document validity
        if not isinstance(documents, list):
            logger.error(f"Expected list of documents but got {type(documents)}")
            raise ValueError(f"Expected list of documents but got {type(documents)}")
        
        if not documents:
            logger.warning("Empty document list provided")
            return
            
        logger.info(f"Adding {len(documents)} document chunks to vector store")
        
        # Check first document for debugging
        first_doc = documents[0]
        logger.info(f"First document type: {type(first_doc)}")
        logger.info(f"First document metadata: {first_doc.metadata}")
        
        self.vectorstore.add_documents(documents)
        self.vectorstore.persist()
        logger.info(f"Added {len(documents)} documents to vector store")
    except Exception as e:
        logger.error(f"Error adding documents to vector store: {e}")
        # Print full stack trace for better debugging
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise
```

These changes should fix the "object of type int has no len()" error by:

1. Adding proper type checking for the embedding result
2. Converting integers to proper vector embeddings if they occur
3. Providing better debug information in the logs
4. Adding robust error handling for various edge cases

Additionally, make sure your `EmbeddingClient.generate_embeddings` method is returning objects with a proper `embedding` attribute that is a list or array, not an integer. If you need to check this, add a debug print inside your `process_knowledge_base` method to inspect what's coming from your embedding client.​​​​​​​​​​​​​​​​
