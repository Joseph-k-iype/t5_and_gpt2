#!/usr/bin/env python
"""
Business Terms Import Script

This script imports business terms from a CSV file into the vector database.
It uses the BusinessTermManager to handle the import process.
"""

import os
import sys
import logging
import argparse
from typing import Optional
import pandas as pd

# Add parent directory to path to import app modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app.core.business_terms import BusinessTermManager
from app.config.environment import get_os_env

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

def validate_csv(file_path: str) -> bool:
    """
    Validate the CSV file has the required columns.
    
    Args:
        file_path: Path to the CSV file
        
    Returns:
        bool: True if valid, False otherwise
    """
    try:
        # Read the first few rows to check columns
        df = pd.read_csv(file_path, nrows=1)
        required_columns = ['name', 'description']
        
        # Check if all required columns exist
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            logger.error(f"Missing required columns: {', '.join(missing_columns)}")
            return False
        
        return True
    except Exception as e:
        logger.error(f"Error validating CSV file: {e}")
        return False

def clean_csv(input_file: str, output_file: Optional[str] = None) -> Optional[str]:
    """
    Clean and prepare CSV file for import.
    
    Args:
        input_file: Path to the input CSV file
        output_file: Path to save the cleaned CSV file, if not provided, a temp file is created
        
    Returns:
        str: Path to the cleaned CSV file, or None if cleaning failed
    """
    try:
        if not os.path.exists(input_file):
            logger.error(f"Input file doesn't exist: {input_file}")
            return None
            
        # Create output file path if not provided
        if not output_file:
            basename = os.path.basename(input_file)
            dirname = os.path.dirname(input_file)
            filename, ext = os.path.splitext(basename)
            output_file = os.path.join(dirname, f"{filename}_cleaned{ext}")
        
        # Read the CSV file
        df = pd.read_csv(input_file)
        
        # Basic cleaning: remove extra whitespace, drop completely empty rows
        for col in df.columns:
            if df[col].dtype == 'object':
                df[col] = df[col].str.strip()
        
        df = df.dropna(how='all')
        
        # Ensure ID column exists
        if 'id' not in df.columns:
            logger.info("Adding 'id' column with generated UUIDs")
            import uuid
            df['id'] = [f"term-{uuid.uuid4()}" for _ in range(len(df))]
        
        # Ensure required columns exist
        for col in ['name', 'description']:
            if col not in df.columns:
                logger.error(f"Required column '{col}' missing from CSV")
                return None
        
        # Handle missing values 
        df['name'] = df['name'].fillna('')
        df['description'] = df['description'].fillna('')
        
        # Filter rows with empty name or description
        valid_rows = (df['name'] != '') & (df['description'] != '')
        invalid_count = (~valid_rows).sum()
        
        if invalid_count > 0:
            logger.warning(f"Removing {invalid_count} rows with empty name or description")
            df = df[valid_rows]
        
        # Save cleaned CSV
        df.to_csv(output_file, index=False)
        logger.info(f"Cleaned CSV saved to {output_file}")
        
        return output_file
    except Exception as e:
        logger.error(f"Error cleaning CSV: {e}")
        return None

def import_terms(file_path: str, batch_size: int = 100) -> bool:
    """
    Import business terms from a CSV file.
    
    Args:
        file_path: Path to the CSV file
        batch_size: Number of terms to process in each batch
        
    Returns:
        bool: True if import was successful, False otherwise
    """
    try:
        # Initialize business term manager
        btm = BusinessTermManager()
        
        # Import the terms
        terms_added = btm.import_terms_from_csv(file_path, batch_size=batch_size)
        
        logger.info(f"Successfully imported {terms_added} business terms")
        return True
    except Exception as e:
        logger.error(f"Error importing business terms: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description="Import business terms from a CSV file")
    parser.add_argument("csv_file", help="Path to the CSV file containing business terms")
    parser.add_argument("--batch-size", type=int, default=100, help="Number of terms to process in each batch")
    parser.add_argument("--clean", action="store_true", help="Clean and prepare the CSV file before import")
    parser.add_argument("--validate-only", action="store_true", help="Only validate the CSV file, don't import")
    parser.add_argument("--output", help="Path to save the cleaned CSV file")
    parser.add_argument("--chroma-dir", help="Override the ChromaDB directory")
    parser.add_argument("--chroma-collection", help="Override the ChromaDB collection name")
    
    args = parser.parse_args()
    
    # Set environment variables if overrides provided
    if args.chroma_dir:
        os.environ["CHROMA_PERSIST_DIR"] = args.chroma_dir
        logger.info(f"Using ChromaDB directory: {args.chroma_dir}")
    
    if args.chroma_collection:
        os.environ["CHROMA_COLLECTION"] = args.chroma_collection
        logger.info(f"Using ChromaDB collection: {args.chroma_collection}")
    
    # Validate the CSV file
    if not validate_csv(args.csv_file):
        logger.error("CSV file validation failed")
        return 1
    
    if args.validate_only:
        logger.info("CSV file validation successful")
        return 0
    
    # Clean the CSV file if requested
    csv_file_to_import = args.csv_file
    if args.clean:
        cleaned_file = clean_csv(args.csv_file, args.output)
        if not cleaned_file:
            logger.error("CSV cleaning failed")
            return 1
        csv_file_to_import = cleaned_file
    
    # Import the terms
    success = import_terms(csv_file_to_import, args.batch_size)
    
    return 0 if success else 1

if __name__ == "__main__":
    sys.exit(main())
