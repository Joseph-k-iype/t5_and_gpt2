# Data Element Enhancement and Tagging API

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [Installation](#installation)
  - [Prerequisites](#prerequisites)
  - [Setup Steps](#setup-steps)
  - [Environment Configuration](#environment-configuration)
- [API Reference](#api-reference)
  - [Authentication](#authentication)
  - [Data Enhancement](#data-enhancement)
  - [Business Term Tagging](#business-term-tagging)
  - [Settings Management](#settings-management)
  - [Dashboard and Monitoring](#dashboard-and-monitoring)
- [Monitoring Dashboard](#monitoring-dashboard)
- [Proxy Configuration](#proxy-configuration)
- [Troubleshooting](#troubleshooting)
- [Development](#development)
- [Examples](#examples)

## Overview

The Data Element Enhancement and Tagging API is a specialized service designed to improve data element metadata quality according to ISO/IEC 11179 standards and tag data elements with appropriate business terms. It uses AI-powered agents built on Azure OpenAI to analyze, enhance, and validate data elements.

This API is particularly useful for:
- Data governance teams requiring metadata standardization
- Organizations implementing ISO/IEC 11179 metadata standards
- Data dictionary and business glossary enhancement
- Semantic mapping of technical data elements to business terminology

## Features

- **Data Element Enhancement**
  - Standardize data element names according to ISO/IEC 11179
  - Enhance descriptions for clarity, completeness, and correctness
  - Validate metadata against ISO standards
  - Multi-iteration enhancement workflow with quality checks

- **Business Term Tagging**
  - Tag data elements with semantically similar business terms
  - Vector-based similarity matching using ChromaDB
  - Confidence scoring for tag matches
  - Automatic identification of elements requiring new business terms

- **Advanced Capabilities**
  - AI-powered metadata analysis
  - Confidence evaluation of enhancements and tagging
  - Asynchronous processing of large batches
  - Persistent vector database of business terminology

- **Monitoring & Configuration**
  - Real-time monitoring dashboard
  - Configurable proxy settings
  - System status monitoring
  - Job tracking and management

## Architecture

The application follows a modular architecture with several key components:

- **API Layer**: FastAPI-based REST endpoints for all functionality
- **Agent Layer**: LLM-powered agents for enhancement, validation, and evaluation
- **Core Services**: Business term management, ChromaDB integration, embedding generation
- **Monitoring**: Dashboard UI and status endpoints
- **Configuration**: Environment-based configuration with override capabilities

### Component Diagram

```
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│  API Routers  │────▶│  LLM Agents   │────▶│  Core Models  │
└───────┬───────┘     └───────────────┘     └───────────────┘
        │                     │                     │
        │                     │                     │
        ▼                     ▼                     ▼
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│  Monitoring   │     │  ChromaDB     │     │  Azure OpenAI │
└───────────────┘     └───────────────┘     └───────────────┘
```

## Installation

### Prerequisites

- Python 3.8 or higher
- Azure OpenAI API access (or equivalent)
- 4GB+ RAM for ChromaDB and application
- Network access (potentially through a proxy)

### Setup Steps

1. Clone the repository

```bash
git clone https://github.com/yourusername/data-element-api.git
cd data-element-api
```

2. Create and activate a virtual environment

```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies

```bash
pip install -r requirements.txt
```

4. Set up environment files (see [Environment Configuration](#environment-configuration))

5. Run the application

```bash
python main.py
```

For custom configuration:

```bash
python main.py --host 0.0.0.0 --port 8080 --no-proxy --config path/to/config.env
```

### Environment Configuration

The application uses two main environment files located in the `env/` directory:

#### config.env

```
# Data Element Enhancement API Configuration

# Proxy settings
PROXY_ENABLED=True
HTTPS_PROXY_DOMAIN=your.proxy.domain:port
CUSTOM_NO_PROXY=localhost,127.0.0.1

# Model settings
MODEL_NAME=gpt-4o
TEMPERATURE=0.3
MAX_TOKENS=2000
API_VERSION=2023-05-15

# Security settings
SECURED_ENDPOINTS=False

# Database settings
CHROMA_DB_DIR=./chroma_db
SIMILARITY_THRESHOLD=0.5
```

#### credentials.env

```
# Azure and Authentication Credentials

# Azure OpenAI credentials
AZURE_TENANT_ID=your-tenant-id
AZURE_CLIENT_ID=your-client-id
AZURE_CLIENT_SECRET=your-client-secret
AZURE_ENDPOINT=https://your-azure-endpoint.openai.azure.com/

# Proxy authentication credentials (if proxy is enabled)
AD_USERNAME=your-proxy-username
AD_USER_PW=your-proxy-password

# Managed identity setting (set to True if using Azure Managed Identity)
USE_MANAGED_IDENTITY=False
```

## API Reference

### Authentication

The API uses Azure AD authentication when `SECURED_ENDPOINTS=True` is set in the configuration. When secured, you need to include an Azure AD bearer token in the Authorization header.

```
Authorization: Bearer <your-azure-ad-token>
```

When running without security (`SECURED_ENDPOINTS=False`), no authentication is required.

### Data Enhancement

#### Enhance a Data Element

Enhance a data element according to ISO/IEC 11179 standards.

- **URL**: `/api/v1/enhance`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**:

```json
{
  "data_element": {
    "id": "string",
    "existing_name": "string",
    "existing_description": "string",
    "example": "string (optional)",
    "process_name": "string (optional)",
    "process_description": "string (optional)"
  },
  "max_iterations": 5
}
```

**Response**:

```json
{
  "request_id": "string",
  "status": "pending",
  "enhanced_data": null,
  "error_message": null
}
```

**Response Codes**:
- `200`: Request accepted, enhancement in progress
- `400`: Invalid request body
- `500`: Server error

#### Get Enhancement Status

Check the status of an enhancement job.

- **URL**: `/api/v1/enhance/{request_id}`
- **Method**: `GET`

**Response**:

```json
{
  "request_id": "string",
  "status": "completed",
  "enhanced_data": {
    "id": "string",
    "existing_name": "string",
    "existing_description": "string",
    "enhanced_name": "string",
    "enhanced_description": "string",
    "quality_status": "good",
    "enhancement_iterations": 3,
    "validation_feedback": ["string"],
    "enhancement_feedback": ["string"],
    "confidence_score": 0.85
  },
  "error_message": null
}
```

**Possible Status Values**:
- `pending`: Job is waiting to be processed
- `in_progress`: Job is currently being processed
- `completed`: Job is complete, result available in enhanced_data
- `failed`: Job failed, error in error_message

#### Batch Enhance Data Elements

Enhance multiple data elements in a single request.

- **URL**: `/api/v1/enhance/batch`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**:

```json
[
  {
    "data_element": {
      "id": "element1",
      "existing_name": "string",
      "existing_description": "string"
    },
    "max_iterations": 5
  },
  {
    "data_element": {
      "id": "element2",
      "existing_name": "string",
      "existing_description": "string"
    },
    "max_iterations": 3
  }
]
```

**Response**:

```json
[
  "element1",
  "element2"
]
```

The response contains request IDs that can be used to check the status of each enhancement job.

#### Validate a Data Element

Validate a data element against ISO/IEC 11179 standards without enhancement.

- **URL**: `/api/v1/validate`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**:

```json
{
  "id": "string",
  "existing_name": "string",
  "existing_description": "string",
  "example": "string (optional)",
  "process_name": "string (optional)",
  "process_description": "string (optional)"
}
```

**Response**:

```json
{
  "id": "string",
  "is_valid": false,
  "quality_status": "needs_improvement",
  "feedback": "string with detailed feedback",
  "suggested_improvements": [
    "string with improvement suggestion"
  ]
}
```

**Quality Status Values**:
- `good`: Meets ISO/IEC 11179 standards
- `needs_improvement`: Minor issues that should be addressed
- `poor`: Significant issues that must be addressed

### Business Term Tagging

#### Import Business Terms

Import business terms from a CSV file.

- **URL**: `/api/v1/terms/import`
- **Method**: `POST`
- **Content-Type**: `multipart/form-data`

**Form Parameters**:
- `file`: CSV file with business terms (required columns: id, name, description)

**Response**:

```json
{
  "success": true,
  "message": "Successfully imported business terms from filename.csv",
  "imported_count": 125
}
```

**Response Codes**:
- `200`: Terms imported successfully
- `400`: Invalid file or format
- `500`: Server error

#### Tag a Data Element

Tag a data element with the most similar business terms.

- **URL**: `/api/v1/tag`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**:

```json
{
  "element_id": "string",
  "element_name": "string",
  "element_description": "string",
  "top_k": 3
}
```

**Response**:

```json
{
  "request_id": "string",
  "element_name": "string",
  "matching_terms": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "similarity": 0.85
    }
  ],
  "confidence_scores": [0.85],
  "validation_result": {
    "is_valid": true,
    "feedback": "string",
    "suggested_alternatives": []
  },
  "modeling_required": false,
  "message": "string"
}
```

**Response Codes**:
- `200`: Tagging completed successfully
- `400`: Invalid request body
- `500`: Server error

#### Tag an Enhanced Data Element

Tag an enhanced data element (output from enhancement process).

- **URL**: `/api/v1/tag/enhanced`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**: EnhancedDataElement object (output from enhancement)

**Response**: Same as `/api/v1/tag`

#### Get All Business Terms

Retrieve all business terms in the collection.

- **URL**: `/api/v1/terms`
- **Method**: `GET`

**Response**:

```json
[
  {
    "id": "string",
    "name": "string",
    "description": "string",
    "metadata": {}
  }
]
```

#### Get Business Term by ID

Retrieve a specific business term by its ID.

- **URL**: `/api/v1/terms/{term_id}`
- **Method**: `GET`

**Response**:

```json
{
  "id": "string",
  "name": "string",
  "description": "string",
  "metadata": {}
}
```

### Settings Management

#### Get Proxy Settings

Get the current proxy configuration.

- **URL**: `/api/v1/settings/proxy`
- **Method**: `GET`

**Response**:

```json
{
  "enabled": true
}
```

#### Update Proxy Settings

Update the proxy configuration.

- **URL**: `/api/v1/settings/proxy`
- **Method**: `POST`
- **Content-Type**: `application/json`

**Request Body**:

```json
{
  "enabled": false
}
```

**Response**:

```json
{
  "enabled": false
}
```

#### Get System Status

Get the system status and configuration.

- **URL**: `/api/v1/settings/status`
- **Method**: `GET`

**Response**:

```json
{
  "proxy_enabled": true,
  "azure_endpoint": "https://your-azure-endpoint.openai.azure.com/",
  "model": "gpt-4o",
  "chroma_dir": "./chroma_db",
  "api_version": "2023-05-15",
  "temperature": 0.3,
  "max_tokens": 2000,
  "secured_endpoints": false,
  "similarity_threshold": 0.5
}
```

### Dashboard and Monitoring

#### Access Dashboard

Access the monitoring dashboard UI.

- **URL**: `/api/dashboard`
- **Method**: `GET`

**Response**: HTML dashboard page

#### System Status Component

Get the system status component for the dashboard.

- **URL**: `/api/dashboard/system-status`
- **Method**: `GET`

**Response**: HTML component

#### Proxy Status Component

Get the proxy status component for the dashboard.

- **URL**: `/api/dashboard/proxy-status`
- **Method**: `GET`

**Response**: HTML component

#### ChromaDB Status Component

Get the ChromaDB status component for the dashboard.

- **URL**: `/api/dashboard/chromadb-status`
- **Method**: `GET`

**Response**: HTML component

#### Enhancement Jobs Component

Get the enhancement jobs component for the dashboard.

- **URL**: `/api/dashboard/enhancement-jobs`
- **Method**: `GET`

**Response**: HTML component

#### Tagging Jobs Component

Get the tagging jobs component for the dashboard.

- **URL**: `/api/dashboard/tagging-jobs`
- **Method**: `GET`

**Response**: HTML component

#### Restart ChromaDB Server

Restart the ChromaDB server.

- **URL**: `/api/dashboard/restart-chroma`
- **Method**: `POST`

**Response**: HTML message with status

## Monitoring Dashboard

The monitoring dashboard provides a visual interface for system status and control. It's accessible at `/api/dashboard` and includes:

### System Status Section
- CPU and memory usage
- System uptime
- Current server time

### Proxy Settings Section
- Current proxy status
- Proxy domain information
- Enable/disable buttons

### ChromaDB Status Section
- Server status (running/stopped)
- Database directory
- Database size
- Restart button

### Job Monitoring Sections
- Active enhancement jobs with status
- Active tagging jobs with results
- Job counts and details

### API Links Section
- Quick links to API documentation
- Health check endpoint
- System configuration

## Proxy Configuration

The application supports working through a proxy for API connections, which can be configured in several ways:

### 1. Environment Variable
Set `PROXY_ENABLED=True` in `config.env` and provide proxy credentials in `credentials.env`:

```
# config.env
PROXY_ENABLED=True
HTTPS_PROXY_DOMAIN=your.proxy.domain:port

# credentials.env
AD_USERNAME=your-proxy-username
AD_USER_PW=your-proxy-password
```

### 2. Command Line Arguments
Use the `--proxy` or `--no-proxy` flags:

```bash
python main.py --proxy
# or
python main.py --no-proxy
```

### 3. API Endpoint
Use the settings API:

```bash
curl -X POST "http://localhost:8000/api/v1/settings/proxy" \
     -H "Content-Type: application/json" \
     -d '{"enabled": true}'
```

### 4. Dashboard UI
Toggle proxy settings directly from the monitoring dashboard.

## Troubleshooting

### Common Issues

#### ChromaDB Server Won't Start
```
Error: ChromaDB server could not be started
```

**Solution:**
1. Check if another process is using the port
2. Ensure the chroma_db directory exists and is writable
3. Try restarting the server via the dashboard
4. Check logs for specific errors

#### Proxy Authentication Failures
```
Error: Proxy authentication failed
```

**Solution:**
1. Verify the AD_USERNAME and AD_USER_PW in credentials.env
2. Check if the proxy domain is correct
3. Try disabling proxy with --no-proxy to confirm it's a proxy issue
4. Ensure your network allows proxy connections

#### Azure OpenAI API Errors
```
Error: Azure OpenAI API request failed
```

**Solution:**
1. Verify all Azure credentials in credentials.env
2. Check if the model name in config.env is available in your Azure OpenAI deployment
3. Ensure AZURE_ENDPOINT is correct
4. Check if your Azure subscription is active

#### Slow Performance
```
Warning: Enhancement taking longer than expected
```

**Solution:**
1. Reduce MAX_TOKENS in config.env
2. Lower the max_iterations parameter in enhancement requests
3. Ensure adequate system resources (at least 4GB RAM)
4. Check network latency, especially when using a proxy

### Logs
The application logs are output to the console by default. For more detailed logging, adjust the logging level in `main.py`:

```python
logging.basicConfig(
    level=logging.DEBUG,  # Change from INFO to DEBUG
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler()
    ]
)
```

## Development

### Extending the API

#### Adding New Endpoints
To add new endpoints, create a new router file in `app/api/routes/` following the pattern of existing routers, then include it in `main.py`:

```python
from app.api.routes.your_new_router import router as your_new_router
app.include_router(your_new_router)
```

#### Modifying LLM Behavior
To adjust the behavior of the LLM agents, modify the prompt templates in the respective agent files:
- Validator Agent: `app/agents/validator_agent.py`
- Enhancer Agent: `app/agents/enhancer_agent.py`
- Confidence Evaluator: `app/agents/confidence_evaluator.py`

#### Adding Custom Business Logic
Custom business logic should be added to the appropriate core module in `app/core/` or as a new utility in `app/utils/`.

### Testing

The following testing methodologies are recommended:

#### 1. Unit Testing
Test individual components using pytest:

```bash
pytest tests/unit/
```

#### 2. Integration Testing
Test the interaction between components:

```bash
pytest tests/integration/
```

#### 3. Manual API Testing
Use the Swagger documentation at `/docs` for manual API testing.

## Examples

### Example 1: Enhancing a Technical Data Element

**Request:**
```bash
curl -X POST "http://localhost:8000/api/v1/enhance" \
     -H "Content-Type: application/json" \
     -d '{
       "data_element": {
         "id": "DT_CUST_ID",
         "existing_name": "customerID",
         "existing_description": "ID of customer in the system",
         "example": "CUST12345"
       },
       "max_iterations": 3
     }'
```

**Response:**
```json
{
  "request_id": "DT_CUST_ID",
  "status": "pending",
  "enhanced_data": null,
  "error_message": null
}
```

**Final Result (after checking status):**
```json
{
  "request_id": "DT_CUST_ID",
  "status": "completed",
  "enhanced_data": {
    "id": "DT_CUST_ID",
    "existing_name": "customerID",
    "existing_description": "ID of customer in the system",
    "enhanced_name": "customer identifier",
    "enhanced_description": "A unique alphanumeric code that identifies a customer within the system. The identifier follows the format 'CUSTXXXXX' where X represents a digit.",
    "quality_status": "good",
    "enhancement_iterations": 2,
    "validation_feedback": [
      "Name should be in lowercase with spaces between words. Description should be more specific and provide complete information."
    ],
    "enhancement_feedback": [
      "Changed camelCase 'customerID' to lowercase with spaces 'customer identifier'. Enhanced description to be more specific, providing format information and clarifying its purpose as a unique identifier."
    ],
    "confidence_score": 0.92
  },
  "error_message": null
}
```

### Example 2: Tagging an Enhanced Element

**Request:**
```bash
curl -X POST "http://localhost:8000/api/v1/tag" \
     -H "Content-Type: application/json" \
     -d '{
       "element_id": "DT_CUST_ID",
       "element_name": "customer identifier",
       "element_description": "A unique alphanumeric code that identifies a customer within the system. The identifier follows the format 'CUSTXXXXX' where X represents a digit.",
       "top_k": 3
     }'
```

**Response:**
```json
{
  "request_id": "DT_CUST_ID",
  "element_name": "customer identifier",
  "matching_terms": [
    {
      "id": "BT_CUSTOMER_ID",
      "name": "customer identification code",
      "description": "A unique code assigned to each customer that allows them to be uniquely identified across all business systems.",
      "similarity": 0.92
    },
    {
      "id": "BT_CLIENT_ID",
      "name": "client identifier",
      "description": "A unique identifier assigned to each client for tracking and identification purposes.",
      "similarity": 0.85
    },
    {
      "id": "BT_CUST_KEY",
      "name": "customer key",
      "description": "Primary reference for a customer in the enterprise data warehouse.",
      "similarity": 0.78
    }
  ],
  "confidence_scores": [0.92, 0.85, 0.78],
  "validation_result": {
    "is_valid": true,
    "feedback": "Matching terms found with good confidence",
    "suggested_alternatives": []
  },
  "modeling_required": false,
  "message": ""
}
```

### Example 3: Toggling Proxy Settings

**Request:**
```bash
curl -X POST "http://localhost:8000/api/v1/settings/proxy" \
     -H "Content-Type: application/json" \
     -d '{
       "enabled": false
     }'
```

**Response:**
```json
{
  "enabled": false
}
```

### Example 4: Batch Enhancement

**Request:**
```bash
curl -X POST "http://localhost:8000/api/v1/enhance/batch" \
     -H "Content-Type: application/json" \
     -d '[
       {
         "data_element": {
           "id": "DT_CUST_ID",
           "existing_name": "customerID",
           "existing_description": "ID of customer in the system"
         }
       },
       {
         "data_element": {
           "id": "DT_LAST_UPD_TS",
           "existing_name": "lastUpdateTimestamp",
           "existing_description": "When the record was modified"
         }
       }
     ]'
```

**Response:**
```json
["DT_CUST_ID", "DT_LAST_UPD_TS"]
```

These request IDs can then be used to check the status of each enhancement job.
