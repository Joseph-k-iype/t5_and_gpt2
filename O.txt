import logging
from typing import Dict, Any, List
from fastapi import APIRouter, HTTPException, Depends
from app.config.environment import get_os_env, str_to_bool
from app.config.settings import get_llm
from app.core.db_manager import DBManager
from pydantic import BaseModel

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1/settings", tags=["settings"])

class ProxySettings(BaseModel):
    """Model for proxy settings."""
    enabled: bool


class DatabaseSettings(BaseModel):
    """Model for database connection settings."""
    host: str
    port: int
    database: str
    user: str
    min_connections: int
    max_connections: int


@router.get("/proxy", response_model=ProxySettings)
async def get_proxy_settings():
    """Get the current proxy settings."""
    try:
        env = get_os_env()
        proxy_enabled = str_to_bool(env.get("PROXY_ENABLED", "False"))
        
        return ProxySettings(
            enabled=proxy_enabled
        )
    except Exception as e:
        logger.error(f"Error retrieving proxy settings: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving proxy settings: {str(e)}")


@router.post("/proxy", response_model=ProxySettings)
async def update_proxy_settings(settings: ProxySettings):
    """Update the proxy settings."""
    try:
        # Update the environment with new proxy setting
        env = get_os_env(proxy_enabled=settings.enabled)
        
        # Force recreation of LLM client with new proxy settings
        _ = get_llm(proxy_enabled=settings.enabled)
        
        logger.info(f"Proxy settings updated: enabled={settings.enabled}")
        
        return ProxySettings(
            enabled=settings.enabled
        )
    except Exception as e:
        logger.error(f"Error updating proxy settings: {e}")
        raise HTTPException(status_code=500, detail=f"Error updating proxy settings: {str(e)}")


@router.get("/database", response_model=DatabaseSettings)
async def get_database_settings():
    """Get the current database connection settings."""
    try:
        env = get_os_env()
        
        return DatabaseSettings(
            host=env.get("PG_HOST", "localhost"),
            port=int(env.get("PG_PORT", "5432")),
            database=env.get("PG_DB", "metadata_db"),
            user=env.get("PG_USER", "postgres"),
            min_connections=int(env.get("PG_MIN_CONNECTIONS", "2")),
            max_connections=int(env.get("PG_MAX_CONNECTIONS", "10"))
        )
    except Exception as e:
        logger.error(f"Error retrieving database settings: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving database settings: {str(e)}")


@router.get("/database/health", response_model=Dict[str, Any])
async def get_database_health(db: DBManager = Depends(lambda: DBManager())):
    """Get the database health status."""
    try:
        health = db.health_check()
        
        return health
    except Exception as e:
        logger.error(f"Error retrieving database health: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving database health: {str(e)}")


@router.get("/status", response_model=Dict[str, Any])
async def get_system_status(db: DBManager = Depends(lambda: DBManager())):
    """Get the system status and configuration."""
    try:
        env = get_os_env()
        
        # Get basic environment settings
        status = {
            "proxy_enabled": str_to_bool(env.get("PROXY_ENABLED", "False")),
            "azure_endpoint": env.get("AZURE_ENDPOINT", ""),
            "model": env.get("MODEL_NAME", "gpt-4o"),
            "database": {
                "host": env.get("PG_HOST", "localhost"),
                "port": int(env.get("PG_PORT", "5432")),
                "database": env.get("PG_DB", "metadata_db"),
                "user": env.get("PG_USER", "postgres")
            },
            "api_version": env.get("API_VERSION", "2023-05-15"),
            "temperature": float(env.get("TEMPERATURE", "0.3")),
            "max_tokens": int(env.get("MAX_TOKENS", "2000")),
            "secured_endpoints": str_to_bool(env.get("SECURED_ENDPOINTS", "False")),
            "similarity_threshold": float(env.get("SIMILARITY_THRESHOLD", "0.5")),
        }
        
        # Get database health
        try:
            db_health = db.health_check()
            if db_health["status"] == "healthy":
                status["database"]["status"] = "connected"
                status["database"]["version"] = db_health.get("version", "unknown")
                status["database"]["vector_enabled"] = db_health.get("vector_enabled", False)
                status["database"]["size_mb"] = db_health.get("db_size_mb", 0)
                status["database"]["terms_count"] = db_health.get("terms_count", 0)
            else:
                status["database"]["status"] = "error"
                status["database"]["error"] = db_health.get("error", "unknown error")
        except Exception as db_error:
            status["database"]["status"] = "error"
            status["database"]["error"] = str(db_error)
        
        return status
    except Exception as e:
        logger.error(f"Error retrieving system status: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving system status: {str(e)}")


@router.get("/stats", response_model=List[Dict[str, Any]])
async def get_system_stats(limit: int = 24, db: DBManager = Depends(lambda: DBManager())):
    """Get historical system statistics."""
    try:
        # Get stats from database
        stats = db.get_system_stats(limit=limit)
        
        return stats
    except Exception as e:
        logger.error(f"Error retrieving system stats: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving system stats: {str(e)}")
