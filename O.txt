"""
Term Matching Agent - LangGraph-based ReAct agent for matching data elements to business terms.

This implementation uses LangGraph's built-in ReAct framework for more reliable tool usage
and better state management during the matching process.
"""

import logging
import json
import re
import os
import asyncio
from typing import List, Dict, Any, Optional, Tuple
from pydantic import BaseModel, Field

from langgraph.prebuilt import create_react_agent
from langchain_core.messages import HumanMessage
from langchain_core.tools import tool
import uuid

from app.core.models import TaggingResult
from app.config.settings import get_llm
from app.core.embedding import MyDocument

logger = logging.getLogger(__name__)

class TermMatchingAgent:
    """Agent for matching data elements to business terms using LangGraph's ReAct framework."""
    
    def __init__(self, business_term_manager):
        """Initialize the term matching agent with a business term manager."""
        self.business_term_manager = business_term_manager
        self.llm = get_llm()
        # Create agent with tools
        self.agent_executor = self._setup_react_agent()
    
    def _setup_react_agent(self):
        """Set up the ReAct agent with the necessary tools."""
        # Define tools using the @tool decorator for cleaner definition
        
        @tool
        def search_terms_by_vector(query: str, threshold: float = 0.1, max_results: int = 10) -> Dict[str, Any]:
            """
            Search for business terms similar to the data element using vector similarity.
            
            Args:
                query: The text to search for (either element name, description, or both)
                threshold: Minimum similarity threshold (0-1)
                max_results: Maximum number of results to return
                
            Returns:
                Dictionary with results list and count
            """
            try:
                logger.info(f"Searching by vector with query: {query}")
                element_id = f"temp-{uuid.uuid4()}"
                
                # Generate embedding for query
                doc = MyDocument(id=element_id, text=query)
                doc_with_embedding = self.business_term_manager.embedding_client.generate_embeddings(doc)
                
                if not doc_with_embedding.embedding:
                    return {"error": "Failed to generate embedding for query", "results": [], "count": 0}
                
                # Search for similar vectors
                similar_terms = self.business_term_manager.vector_store.find_similar_vectors(
                    query_vector=doc_with_embedding.embedding,
                    top_k=max_results,
                    threshold=threshold
                )
                
                if not similar_terms:
                    logger.info("No vector search results found")
                    return {"results": [], "count": 0}
                
                logger.info(f"Found {len(similar_terms)} terms via vector search")
                return {"results": similar_terms, "count": len(similar_terms)}
                
            except Exception as e:
                logger.error(f"Error in search_terms_by_vector: {e}")
                return {"error": str(e), "results": [], "count": 0}
        
        @tool
        def search_terms_by_text(query: str, max_results: int = 10) -> Dict[str, Any]:
            """
            Search for business terms by text match in name or description.
            
            Args:
                query: The text to search for
                max_results: Maximum number of results to return
                
            Returns:
                Dictionary with results list and count
            """
            try:
                logger.info(f"Searching by text with query: {query}")
                terms = self.business_term_manager.search_terms(query, limit=max_results)
                
                # Convert results to a list of dictionaries
                results = []
                for term in terms:
                    # Convert to dictionary if it's an object
                    if hasattr(term, "dict"):
                        term_dict = term.dict()
                    else:
                        term_dict = term
                    
                    results.append(term_dict)
                
                logger.info(f"Found {len(results)} terms via text search")
                return {"results": results, "count": len(results)}
                
            except Exception as e:
                logger.error(f"Error in search_terms_by_text: {e}")
                return {"error": str(e), "results": [], "count": 0}
        
        @tool
        def get_term_by_id(term_id: str) -> Dict[str, Any]:
            """
            Get detailed information about a specific business term by its ID.
            
            Args:
                term_id: The ID of the business term to retrieve
                
            Returns:
                Dictionary with term details or error message
            """
            try:
                term = self.business_term_manager.get_term_by_id(term_id)
                if not term:
                    return {"error": f"Term with ID {term_id} not found"}
                
                # Convert to dictionary if it's an object
                if hasattr(term, "dict"):
                    term_dict = term.dict()
                else:
                    term_dict = term
                
                return term_dict
                
            except Exception as e:
                logger.error(f"Error in get_term_by_id: {e}")
                return {"error": str(e)}
        
        @tool
        def filter_terms_by_cdm(terms: List[Dict[str, Any]], cdm: str) -> Dict[str, Any]:
            """
            Filter a list of terms to only include those from a specific CDM.
            
            Args:
                terms: List of terms to filter
                cdm: The CDM to filter by
                
            Returns:
                Dictionary with filtered results list and count
            """
            try:
                # Filter terms by CDM
                filtered_terms = []
                for term in terms:
                    # Check metadata first
                    metadata = term.get("metadata", {})
                    term_cdm = metadata.get("cdm") if metadata else None
                    
                    # If not in metadata, check direct cdm field
                    if not term_cdm:
                        term_cdm = term.get("cdm")
                    
                    if term_cdm and term_cdm.lower() == cdm.lower():
                        filtered_terms.append(term)
                
                return {"results": filtered_terms, "count": len(filtered_terms)}
                
            except Exception as e:
                logger.error(f"Error in filter_terms_by_cdm: {e}")
                return {"error": str(e), "results": [], "count": 0}
        
        @tool
        def compare_terms(element_name: str, element_description: str, terms: List[Dict[str, Any]]) -> Dict[str, Any]:
            """
            Compare multiple business terms to determine which best matches the data element.
            
            Args:
                element_name: The name of the data element
                element_description: The description of the data element
                terms: List of terms to compare
                
            Returns:
                Dictionary with matched terms and their confidence scores
            """
            try:
                if not terms:
                    return {"error": "No terms provided for comparison", "matches": []}
                
                # For each term, compute a simple semantic match score
                matches = []
                for term in terms:
                    term_id = term.get("id")
                    term_name = term.get("name", "")
                    term_description = term.get("description", "")
                    
                    # Use pre-computed similarity if available
                    similarity = term.get("similarity", 0.5)
                    
                    # Boost similarity for name matches
                    name_match = False
                    if element_name.lower() in term_name.lower() or term_name.lower() in element_name.lower():
                        name_match = True
                        similarity = max(similarity, 0.7)  # Boost score for name matches
                    
                    # Generate reasoning based on match type
                    if name_match:
                        reasoning = f"Name match between '{element_name}' and '{term_name}'"
                    else:
                        reasoning = f"Semantic similarity based on vector matching"
                    
                    matches.append({
                        "term_id": term_id,
                        "confidence": similarity,
                        "reasoning": reasoning
                    })
                
                # Sort by confidence (highest first)
                matches.sort(key=lambda x: x["confidence"], reverse=True)
                
                return {"matches": matches}
                
            except Exception as e:
                logger.error(f"Error in compare_terms: {e}")
                return {"error": str(e), "matches": []}
        
        tools = [
            search_terms_by_vector,
            search_terms_by_text,
            get_term_by_id,
            filter_terms_by_cdm,
            compare_terms
        ]
        
        # Create the agent
        agent_executor = create_react_agent(self.llm, tools)
        
        return agent_executor
    
    async def find_matching_terms(self, element_id: str, element_name: str, element_description: str, 
                               top_k: int = 3, cdm: Optional[str] = None, 
                               example: Optional[str] = None,
                               process_name: Optional[str] = None,
                               process_description: Optional[str] = None) -> Tuple[List[Dict[str, Any]], List[float]]:
        """
        Find matching business terms using the ReAct agent.
        
        Args:
            element_id: Unique identifier for the element
            element_name: Name of the data element
            element_description: Description of the data element
            top_k: Maximum number of matching terms to return
            cdm: Optional CDM to prioritize
            example: Optional example for context
            process_name: Optional process name for context
            process_description: Optional process description for context
            
        Returns:
            Tuple containing matching terms list and confidence scores list
        """
        try:
            # Prepare the prompt with clear instructions
            prompt = f"""
            You are an expert data governance agent tasked with matching data elements to appropriate business terms.
            
            DATA ELEMENT:
            Name: {element_name}
            Description: {element_description}
            """
            
            # Add context information if available
            if example:
                prompt += f"\nExample: {example}"
            if process_name:
                prompt += f"\nProcess Name: {process_name}"
            if process_description:
                prompt += f"\nProcess Description: {process_description}"
            if cdm:
                prompt += f"\nPreferred CDM: {cdm} (prioritize terms from this CDM)"
            
            prompt += f"""
            
            INSTRUCTIONS:
            1. First, search for candidate terms using vector similarity with the element name and description separately
            2. If needed, also search by text matching for additional candidates
            3. If a CDM is specified, prioritize terms from that CDM
            4. For promising candidates, get their full details
            5. Compare the terms to find the best matches
            6. Return up to {top_k} best matching terms with confidence scores
            
            IMPORTANT:
            - Focus on semantic equivalence rather than exact text matching
            - For example, "account number" may match with "account identifier" if they represent the same concept
            - Use both the name and description for matching, but prioritize name matching
            """
            
            # Invoke the agent
            response = await self.agent_executor.ainvoke({"input": prompt})
            final_response = response.get("output")
            
            logger.info(f"Agent response: {final_response}")
            
            # Parse the response to extract matching terms
            matching_terms = []
            confidence_scores = []
            
            # Try to find JSON output in the response
            json_match = re.search(r'```json\n(.*?)\n```', final_response, re.DOTALL)
            if json_match:
                try:
                    json_data = json.loads(json_match.group(1))
                    if "matches" in json_data:
                        matches = json_data["matches"]
                        
                        # Process each match
                        for match in matches[:top_k]:
                            term_id = match.get("term_id")
                            confidence = match.get("confidence", 0.5)
                            
                            # Get full term details
                            term = self.business_term_manager.get_term_by_id(term_id)
                            if term:
                                # Convert to dict if it's an object
                                if hasattr(term, "dict"):
                                    term_dict = term.dict()
                                else:
                                    term_dict = term
                                
                                # Add similarity for compatibility with existing code
                                term_dict["similarity"] = confidence
                                
                                matching_terms.append(term_dict)
                                confidence_scores.append(confidence)
                except json.JSONDecodeError:
                    logger.warning(f"Could not parse JSON from agent response")
            
            # If no valid JSON found, try to extract term IDs and scores using regex
            if not matching_terms:
                # Pattern for direct term mentions with IDs
                pattern = r'(?:term|id)[:\s]+([a-zA-Z0-9_-]+)[^\n]*?(?:confidence|score)[:\s]+(\d+\.\d+)'
                matches = re.finditer(pattern, final_response, re.IGNORECASE)
                
                for match in matches:
                    term_id = match.group(1).strip()
                    try:
                        confidence = float(match.group(2))
                        confidence = max(0.0, min(1.0, confidence))  # Ensure in range [0, 1]
                    except ValueError:
                        confidence = 0.5  # Default if parsing fails
                    
                    # Get full term details
                    term = self.business_term_manager.get_term_by_id(term_id)
                    if term:
                        # Convert to dict if it's an object
                        if hasattr(term, "dict"):
                            term_dict = term.dict()
                        else:
                            term_dict = term
                        
                        # Add similarity for compatibility with existing code
                        term_dict["similarity"] = confidence
                        
                        matching_terms.append(term_dict)
                        confidence_scores.append(confidence)
            
            # If we still have no matches, fall back to direct vector search
            if not matching_terms:
                logger.info("No matches found from agent response, falling back to direct vector search")
                try:
                    # Try searching with combined query
                    search_query = f"{element_name}. {element_description}"
                    
                    # Generate embedding
                    doc = MyDocument(id=element_id, text=search_query)
                    doc_with_embedding = self.business_term_manager.embedding_client.generate_embeddings(doc)
                    
                    if doc_with_embedding.embedding:
                        # Search with a lower threshold to get more results
                        similar_terms = self.business_term_manager.vector_store.find_similar_vectors(
                            query_vector=doc_with_embedding.embedding,
                            top_k=top_k,
                            threshold=0.1  # Lower threshold for fallback
                        )
                        
                        matching_terms = similar_terms
                        confidence_scores = [term.get("similarity", 0.5) for term in similar_terms]
                except Exception as e:
                    logger.error(f"Error in fallback vector search: {e}")
            
            # Limit to top_k
            matching_terms = matching_terms[:top_k]
            confidence_scores = confidence_scores[:top_k]
            
            return matching_terms, confidence_scores
        except Exception as e:
            logger.error(f"Error in find_matching_terms: {e}")
            return [], []
