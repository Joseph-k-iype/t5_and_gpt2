def classify_incident(self, incident_data: Dict[str, str]) -> IncidentClassification:
    """Classify a single incident using the multi-agent system"""
    # Create the initial state
    initial_state = ClassificationState(
        metadata={
            "id": incident_data.get("Id", "Unknown"),
            "summary": incident_data.get("IT_INCIDENT_SUMMARY", ""),
            "description": incident_data.get("IT_INCIDENT_DESC", ""),
            "resolution_name": incident_data.get("IT_INCIDENT_RESOLUTION_DETAILS_NAME", ""),
            "resolution_details": incident_data.get("IT_INCIDENT_RESOLUTION_DESC", ""),
            "category": incident_data.get("IT_INCIDENT_AREA_CATEGORY", ""),
            "subcategory": incident_data.get("IT_INCIDENT_AREA_SUBCATEGORY", "")
        }
    )
    
    # Run the graph
    try:
        # Execute the graph
        final_state = self.graph.invoke(initial_state)
        
        # Use dictionary access style instead of attribute access
        if "final_classification" in final_state and final_state["final_classification"] is not None:
            return final_state["final_classification"]
        else:
            logger.error("Classification graph did not produce a final classification")
            raise ValueError("Classification process did not produce a final classification")
            
    except Exception as e:
        logger.error(f"Error running classification graph: {e}")
        raise



def confidence_evaluator(self, state) -> dict:
    """Evaluate and finalize the confidence score"""
    # Make sure we always have a final_classification
    if "final_classification" not in state or state["final_classification"] is None:
        if "preliminary_classification" in state and state["preliminary_classification"] is not None:
            # Use preliminary as final
            state["final_classification"] = state["preliminary_classification"]
            state["messages"].append(
                AgentMessage(
                    content="Using preliminary classification as final classification",
                    metadata={"agent": "confidence_evaluator", "success": True}
                )
            )
        else:
            # Create a minimal classification
            state["final_classification"] = IncidentClassification(
                incident_id=state["metadata"]["id"] if "metadata" in state and "id" in state["metadata"] else "Unknown",
                is_data_issue=False,
                confidence_score=0.5,
                supporting_reasons=[ClassificationReason(reason="Default classification", impact=1.0)],
                contrary_reasons=[]
            )
    
    try:
        # Calculate confidence score
        supporting_impact = sum(reason.impact for reason in state["final_classification"].supporting_reasons)
        contrary_impact = sum(reason.impact for reason in state["final_classification"].contrary_reasons)
        
        total_impact = supporting_impact + contrary_impact
        if total_impact > 0:
            if supporting_impact > contrary_impact:
                confidence = 0.5 + (0.5 * (supporting_impact - contrary_impact) / total_impact)
            else:
                confidence = 0.5 - (0.5 * (contrary_impact - supporting_impact) / total_impact)
        else:
            confidence = 0.5
        
        # Update the final classification
        state["final_classification"].confidence_score = round(confidence, 2)
        
        state["messages"].append(
            AgentMessage(
                content=f"Final confidence score: {state['final_classification'].confidence_score}",
                metadata={"agent": "confidence_evaluator", "success": True}
            )
        )
    except Exception as e:
        logger.error(f"Error in confidence evaluation: {e}")
        state["messages"].append(
            AgentMessage(
                content=f"Error in confidence evaluation: {str(e)}",
                metadata={"agent": "confidence_evaluator", "success": False}
            )
        )
    
    # Final check
    assert "final_classification" in state and state["final_classification"] is not None
    return state








def classifier(self, state) -> dict:
    """Perform initial classification of the incident"""
    if "preliminary_classification" in state and state["preliminary_classification"]:
        return state
    
    if "incident" not in state or not state["incident"]:
        state["messages"].append(
            AgentMessage(
                content="Cannot classify without extracted features",
                metadata={"agent": "classifier", "success": False}
            )
        )
        return state
    
    try:
        # Create a simple preliminary classification
        is_data_issue = (
            state["incident"].is_categorized_as_data or 
            state["incident"].contains_data_terms
        )
        
        # Create an initial classification with a basic confidence score
        classification = IncidentClassification(
            incident_id=state["incident"].id,
            is_data_issue=is_data_issue,
            confidence_score=0.7 if is_data_issue else 0.3,
            supporting_reasons=[
                ClassificationReason(
                    reason=f"Incident {'is' if state['incident'].is_categorized_as_data else 'is not'} explicitly categorized as data-related",
                    impact=0.6
                )
            ],
            contrary_reasons=[]
        )
        
        state["preliminary_classification"] = classification
        state["current_agent"] = "reasoning_agent"
        
        state["messages"].append(
            AgentMessage(
                content=f"Initial classification: {'Data issue' if is_data_issue else 'Not a data issue'}",
                metadata={"agent": "classifier", "success": True}
            )
        )
    except Exception as e:
        logger.error(f"Error in classification: {e}")
        state["messages"].append(
            AgentMessage(
                content=f"Error in classification: {str(e)}",
                metadata={"agent": "classifier", "success": False}
            )
        )
    
    return state











def feature_extractor(self, state) -> dict:
    """Extract features from the incident text"""
    if "feature_extraction_complete" in state and state["feature_extraction_complete"]:
        return state
    
    # Using instructor to enforce structured output for feature extraction
    try:
        features = self.chatbot.structured_query(
            f"""
            Extract key features from this IT incident:
            ID: {state["metadata"].get("id", "Unknown")}
            Summary: {state["metadata"].get("summary", "")}
            Description: {state["metadata"].get("description", "")}
            Resolution Name: {state["metadata"].get("resolution_name", "")}
            Resolution Details: {state["metadata"].get("resolution_details", "")}
            Category: {state["metadata"].get("category", "")}
            Subcategory: {state["metadata"].get("subcategory", "")}
            
            Analyze the text and determine if it contains terms related to data issues,
            system issues, and if it's categorized explicitly as a data-related issue.
            """,
            IncidentFeatures
        )
        
        # Update the state with the extracted features
        state["incident"] = features
        state["feature_extraction_complete"] = True
        state["current_agent"] = "classifier"
        
        # Add a message to the state
        state["messages"].append(
            AgentMessage(
                content="Successfully extracted features from the incident",
                metadata={"agent": "feature_extractor", "success": True}
            )
        )
    except Exception as e:
        logger.error(f"Error in feature extraction: {e}")
        state["messages"].append(
            AgentMessage(
                content=f"Error extracting features: {str(e)}",
                metadata={"agent": "feature_extractor", "success": False}
            )
        )
    
    return state












def reasoning_agent(self, state) -> dict:
    """Develop reasoning and evidence for the classification"""
    if "preliminary_classification" not in state or not state["preliminary_classification"]:
        state["messages"].append(
            AgentMessage(
                content="Cannot provide reasoning without preliminary classification",
                metadata={"agent": "reasoning_agent", "success": False}
            )
        )
        return state
    
    try:
        # Use instructor for structured output
        improved_classification = self.chatbot.structured_query(
            f"""
            Analyze this IT incident in detail and provide reasoning for why it should or should not
            be classified as a data issue:
            
            ID: {state["incident"].id}
            Summary: {state["incident"].summary}
            Description: {state["incident"].description}
            Resolution Name: {state["incident"].resolution_name}
            Resolution Details: {state["incident"].resolution_details}
            Category: {state["incident"].category}
            Subcategory: {state["incident"].subcategory}
            
            Current classification: 
            - Is data issue: {state["preliminary_classification"].is_data_issue}
            - Confidence: {state["preliminary_classification"].confidence_score}
            
            Provide a detailed list of supporting reasons (evidence that it IS a data issue)
            and contrary reasons (evidence that it is NOT a data issue).
            
            Each reason should have an impact score (0.0 to 1.0) indicating how much this 
            particular reason should influence the final confidence score.
            """,
            IncidentClassification
        )
        
        # Update the state
        state["final_classification"] = improved_classification
        state["current_agent"] = "confidence_evaluator"
        
        state["messages"].append(
            AgentMessage(
                content="Developed detailed reasoning for classification",
                metadata={"agent": "reasoning_agent", "success": True}
            )
        )
    except Exception as e:
        logger.error(f"Error in reasoning: {e}")
        state["messages"].append(
            AgentMessage(
                content=f"Error in reasoning: {str(e)}",
                metadata={"agent": "reasoning_agent", "success": False}
            )
        )
        # Use preliminary classification as fallback
        state["final_classification"] = state["preliminary_classification"]
        state["current_agent"] = "confidence_evaluator"
    
    return state








def _build_graph(self):
    """Build the LangGraph for the multi-agent system"""
    # Define the graph
    graph = StateGraph(ClassificationState)
    
    # Add nodes to the graph
    graph.add_node("feature_extractor", self.feature_extractor)
    graph.add_node("classifier", self.classifier)
    graph.add_node("reasoning_agent", self.reasoning_agent)
    graph.add_node("confidence_evaluator", self.confidence_evaluator)
    
    # Add edges to connect the nodes
    graph.add_edge("START", "feature_extractor")
    graph.add_edge("feature_extractor", "classifier")
    graph.add_edge("classifier", "reasoning_agent")
    graph.add_edge("reasoning_agent", "confidence_evaluator")
    graph.add_edge("confidence_evaluator", END)
    
    # Return the compiled graph
    return graph.compile()
