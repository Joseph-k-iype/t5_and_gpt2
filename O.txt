"""
Tagging Agent - Matches enhanced data elements with business terms.
This module provides functionality to semantically match data elements with appropriate
business terms and validate the contextual correctness of matches.
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
from pydantic import BaseModel, Field
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import AzureChatOpenAI
from app.core.models import TaggingResult, TaggingValidationResult
from app.core.business_terms import BusinessTermManager

logger = logging.getLogger(__name__)

class MatchedTerm(BaseModel):
    """Model representing a matched business term."""
    id: str = Field(..., description="Unique identifier for the business term")
    name: str = Field(..., description="Name of the business term")
    description: str = Field(..., description="Description of the business term")
    confidence: float = Field(..., description="Confidence score of the match")
    category: Optional[str] = Field(None, description="Category of the business term")
    
    def dict(self) -> Dict[str, Any]:
        """Convert to dictionary with non-None values."""
        result = {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "confidence": self.confidence
        }
        if self.category:
            result["category"] = self.category
        return result

class ContextualMatchResult(BaseModel):
    """Model representing the result of contextual matching."""
    is_match: bool = Field(..., description="Whether the match is contextually correct")
    confidence: float = Field(..., description="Confidence score for the match")
    reasoning: str = Field(..., description="Reasoning for the decision")
    suggested_term_id: Optional[str] = Field(None, description="ID of a better match if any")

class TaggingAgent:
    """Agent for matching data elements with business terms based on semantic and contextual similarity."""
    
    def __init__(self, llm: AzureChatOpenAI):
        """Initialize the tagging agent with a language model."""
        self.llm = llm
        self.business_term_manager = BusinessTermManager()
        self._setup_validation_chain()
    
    def _setup_validation_chain(self):
        """Set up the LangChain prompt for contextual validation."""
        contextual_validation_template = """
        You are a data governance expert specializing in matching data elements with standard business terms.
        Your task is to evaluate whether a suggested business term is contextually appropriate for a given data element.
        
        Data Element:
        - Name: {element_name}
        - Description: {element_description}
        
        Suggested Business Term:
        - Name: {term_name}
        - Description: {term_description}
        - Category: {term_category}
        - Similarity Score: {similarity_score}
        
        Other Potential Terms:
        {other_terms}
        
        Consider the following in your evaluation:
        1. Semantic meaning - do the element and term refer to the same concept?
        2. Domain context - are they used in the same business context?
        3. Level of specificity - is the term at the appropriate level of detail?
        4. Common usage - would business users recognize this mapping as appropriate?
        
        Provide your analysis in the following format:
        1. Contextual Match: [YES/NO]
        2. Confidence (0.0-1.0): [score]
        3. Reasoning: [detailed explanation]
        4. Better Match (if any): [ID of better term from the list or "None"]
        
        Be objective and thorough in your analysis. Focus on business meaning rather than just lexical similarity.
        """
        
        self.contextual_validation_prompt = PromptTemplate(
            input_variables=["element_name", "element_description", "term_name", "term_description", 
                            "term_category", "similarity_score", "other_terms"],
            template=contextual_validation_template)
        
        self.validation_chain = self.contextual_validation_prompt | self.llm | StrOutputParser()
    
    async def tag_element(self, element_id: str, element_name: str, element_description: str, 
                         top_k: int = 3) -> TaggingResult:
        """
        Match a data element with appropriate business terms based on semantic similarity.
        
        Args:
            element_id: Unique identifier for the element
            element_name: Enhanced name of the element
            element_description: Enhanced description of the element
            top_k: Number of top matching terms to return
            
        Returns:
            TaggingResult with matching terms, confidence scores, and validation information
        """
        try:
            # Perform vector-based similarity search using the business term manager
            initial_result = self.business_term_manager.tag_element(
                element_id=element_id,
                name=element_name,
                description=element_description,
                top_k=top_k * 2  # Get more results for contextual filtering
            )
            
            # If no matches were found, return the result as is
            if not initial_result.matching_terms or len(initial_result.matching_terms) == 0:
                logger.info(f"No matching terms found for element: {element_name}")
                return initial_result
            
            # Get the top match for contextual validation
            top_match = initial_result.matching_terms[0]
            
            # Prepare other terms for comparison
            other_terms_text = ""
            if len(initial_result.matching_terms) > 1:
                for i, term in enumerate(initial_result.matching_terms[1:top_k+1]):
                    other_terms_text += f"Term {i+1}:\n"
                    other_terms_text += f"- ID: {term['id']}\n"
                    other_terms_text += f"- Name: {term['name']}\n"
                    other_terms_text += f"- Description: {term['description']}\n"
                    other_terms_text += f"- Similarity: {term['similarity']:.2f}\n\n"
            else:
                other_terms_text = "No other potential terms available."
            
            # Get the term details including category if available
            term_details = self.business_term_manager.get_term_by_id(top_match["id"])
            term_category = term_details.metadata.get("category", "Not specified") if term_details else "Not specified"
            
            # Validate the contextual match
            validation_result = await self._validate_contextual_match(
                element_name=element_name,
                element_description=element_description,
                term_name=top_match["name"],
                term_description=top_match["description"],
                term_category=term_category,
                similarity_score=top_match["similarity"],
                other_terms=other_terms_text
            )
            
            # If the match is valid, return the result with contextual validation
            if validation_result.is_match:
                # The top match is contextually appropriate
                logger.info(f"Contextually valid match found for element: {element_name}")
                
                # Adjust confidence based on contextual validation
                adjusted_confidence = (top_match["similarity"] + validation_result.confidence) / 2
                adjusted_matching_terms = initial_result.matching_terms.copy()
                adjusted_matching_terms[0]["similarity"] = adjusted_confidence
                
                # Create adjusted confidence scores
                adjusted_confidence_scores = initial_result.confidence_scores.copy()
                if adjusted_confidence_scores:
                    adjusted_confidence_scores[0] = adjusted_confidence
                
                return TaggingResult(
                    element_id=element_id,
                    element_name=element_name,
                    element_description=element_description,
                    matching_terms=adjusted_matching_terms[:top_k],
                    confidence_scores=adjusted_confidence_scores[:top_k],
                    modeling_required=False,
                    message=f"Contextually validated match found with confidence {adjusted_confidence:.2f}"
                )
            else:
                # The top match is not contextually appropriate
                logger.info(f"Contextual validation suggests a different match for element: {element_name}")
                
                # Check if a better match was suggested
                if validation_result.suggested_term_id:
                    # Find the suggested term in the matching terms
                    suggested_term = None
                    for term in initial_result.matching_terms:
                        if term["id"] == validation_result.suggested_term_id:
                            suggested_term = term
                            break
                    
                    if suggested_term:
                        # Adjust the order and confidence of the matching terms
                        reordered_terms = [suggested_term]
                        reordered_terms.extend([t for t in initial_result.matching_terms if t["id"] != suggested_term["id"]][:top_k-1])
                        
                        # Adjust confidence for the suggested term
                        suggested_term["similarity"] = max(suggested_term["similarity"], validation_result.confidence)
                        
                        # Create adjusted confidence scores
                        reordered_confidence = [suggested_term["similarity"]]
                        reordered_confidence.extend([t["similarity"] for t in initial_result.matching_terms 
                                                   if t["id"] != suggested_term["id"]][:top_k-1])
                        
                        return TaggingResult(
                            element_id=element_id,
                            element_name=element_name,
                            element_description=element_description,
                            matching_terms=reordered_terms,
                            confidence_scores=reordered_confidence,
                            modeling_required=False,
                            message=f"Found better contextual match: {suggested_term['name']}"
                        )
                
                # If no better match was suggested, keep the original results
                return initial_result
                
        except Exception as e:
            logger.error(f"Error in tagging element: {e}")
            # Return a basic result in case of error
            return TaggingResult(
                element_id=element_id,
                element_name=element_name,
                element_description=element_description,
                matching_terms=[],
                confidence_scores=[],
                modeling_required=True,
                message=f"Error during tagging: {str(e)}"
            )
    
    async def _validate_contextual_match(self, element_name: str, element_description: str,
                                        term_name: str, term_description: str, term_category: str,
                                        similarity_score: float, other_terms: str) -> ContextualMatchResult:
        """
        Validate if a business term is contextually appropriate for a data element.
        
        Args:
            element_name: Name of the data element
            element_description: Description of the data element
            term_name: Name of the business term
            term_description: Description of the business term
            term_category: Category of the business term
            similarity_score: Vector similarity score
            other_terms: Text describing other potential matches
            
        Returns:
            ContextualMatchResult indicating the validation result
        """
        try:
            result = await self.validation_chain.ainvoke({
                "element_name": element_name,
                "element_description": element_description,
                "term_name": term_name,
                "term_description": term_description,
                "term_category": term_category,
                "similarity_score": f"{similarity_score:.2f}",
                "other_terms": other_terms
            })
            
            # Parse the result
            is_match = False
            confidence = similarity_score  # Default to the vector similarity
            reasoning = ""
            suggested_term_id = None
            
            for line in result.split('\n'):
                if "Contextual Match:" in line:
                    is_match = "YES" in line.upper()
                elif "Confidence" in line and ":" in line:
                    try:
                        confidence_text = line.split(':')[1].strip()
                        confidence_value = float(confidence_text.strip('[]'))
                        confidence = max(0.0, min(1.0, confidence_value))  # Ensure valid range
                    except (ValueError, IndexError):
                        logger.warning(f"Failed to parse confidence from: {line}")
                elif "Reasoning:" in line:
                    reasoning = line.split('Reasoning:')[1].strip()
                elif "Better Match" in line:
                    match_text = line.split(':')[1].strip()
                    if match_text and "None" not in match_text and "[" in match_text:
                        # Extract the ID from the format like "[term-123]"
                        import re
                        id_match = re.search(r'\[([\w-]+)\]', match_text)
                        if id_match:
                            suggested_term_id = id_match.group(1)
            
            return ContextualMatchResult(
                is_match=is_match,
                confidence=confidence,
                reasoning=reasoning,
                suggested_term_id=suggested_term_id
            )
            
        except Exception as e:
            logger.error(f"Error in contextual validation: {e}")
            # Return a default result in case of error
            return ContextualMatchResult(
                is_match=True,  # Default to accepting the match
                confidence=similarity_score,
                reasoning=f"Error during validation: {str(e)}",
                suggested_term_id=None
            )
    
    async def validate_tagging(self, tagging_result: TaggingResult) -> TaggingValidationResult:
        """
        Validate the tagging result and provide feedback.
        
        Args:
            tagging_result: Result of the tagging process
            
        Returns:
            TaggingValidationResult with validation status and suggestions
        """
        return await self.business_term_manager.validate_tagging_with_reasoning(tagging_result)
