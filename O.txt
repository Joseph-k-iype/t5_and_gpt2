import os
import logging
import uuid
from fastapi import APIRouter, HTTPException, UploadFile, File, Form, BackgroundTasks, Depends
from typing import Dict, List, Any, Optional
import json
from app.core.business_terms import BusinessTermManager
from app.core.db_manager import DBManager
from app.core.models import EnhancedDataElement, TaggingRequest, TaggingResponse
from app.config.settings import get_llm
from app.agents.confidence_evaluator import ConfidenceEvaluator
from pydantic import BaseModel
import chardet

router = APIRouter(prefix="/api/v1", tags=["business-terms"])

logger = logging.getLogger(__name__)

# In-memory cache for tagging jobs for fast access
# The persistent storage is in PostgreSQL
tagging_jobs: Dict[str, Dict[str, Any]] = {}

# Business Term Manager instance
business_term_manager = BusinessTermManager()

def get_confidence_evaluator():
    """Get the confidence evaluator."""
    llm = get_llm()
    return ConfidenceEvaluator(llm)

def get_db():
    """Get the database manager."""
    return DBManager()

class ImportResponse(BaseModel):
    """Response model for importing business terms."""
    success: bool
    message: str
    imported_count: int

@router.post("/terms/import", response_model=ImportResponse)
async def import_business_terms(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """
    Import business terms from a CSV file.
    The CSV must have 'id', 'name', and 'description' columns.
    """
    try:
        # Create a unique temp file path
        temp_file_path = f"temp_{uuid.uuid4()}.csv"
        
        # Read and save the uploaded file
        file_content = await file.read()
        
        # Detect the encoding
        detection = chardet.detect(file_content)
        encoding = detection['encoding'] or 'utf-8'
        logger.info(f"Detected CSV encoding: {encoding} with confidence {detection['confidence']}")
        
        # Save the file with the detected encoding
        with open(temp_file_path, "wb") as buffer:
            buffer.write(file_content)
        
        # Import terms with encoding information
        try:
            logger.info(f"Importing terms from {file.filename} with encoding {encoding}")
            import_count = business_term_manager.import_terms_from_csv(temp_file_path, encoding=encoding)
            
            # Clean up the temp file
            try:
                if background_tasks:
                    background_tasks.add_task(os.unlink, temp_file_path)
                else:
                    os.unlink(temp_file_path)
            except Exception as e:
                logger.warning(f"Error deleting temporary file: {e}")
            
            return ImportResponse(
                success=True,
                message=f"Successfully imported business terms from {file.filename}",
                imported_count=import_count
            )
        except Exception as e:
            logger.error(f"Error importing terms: {str(e)}")
            raise HTTPException(status_code=500, detail=f"Error importing terms: {str(e)}")
            
    except Exception as e:
        logger.error(f"Error processing file upload: {str(e)}")
        # Clean up the temp file in case of error
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            try:
                os.unlink(temp_file_path)
            except Exception as cleanup_error:
                logger.warning(f"Error cleaning up temporary file: {cleanup_error}")
        
        raise HTTPException(status_code=500, detail=f"Error importing terms: {str(e)}")

@router.post("/tag", response_model=TaggingResponse)
async def tag_element(
    request: TaggingRequest,
    db: DBManager = Depends(get_db)
):
    """
    Tag an enhanced data element with the most similar business terms.
    Also validates if the tagging makes sense.
    """
    try:
        # Check if we already have this job in memory
        request_id = request.element_id
        if request_id in tagging_jobs:
            logger.info(f"Returning existing tagging result from memory for {request_id}")
            job = tagging_jobs[request_id]
            return TaggingResponse(
                request_id=request_id,
                element_name=job["tagging_result"]["element_name"],
                matching_terms=job["tagging_result"]["matching_terms"],
                confidence_scores=job["tagging_result"]["confidence_scores"],
                validation_result=job["validation_result"],
                modeling_required=job["tagging_result"]["modeling_required"],
                message=job["tagging_result"]["message"]
            )
        
        # Check if job exists in database
        db_job = db.get_job(request_id)
        if db_job is not None and db_job["job_type"] == "tagging":
            logger.info(f"Returning existing tagging result from database for {request_id}")
            
            # Load into memory cache
            tagging_jobs[request_id] = db_job["data"]
            
            return TaggingResponse(
                request_id=request_id,
                element_name=db_job["data"]["tagging_result"]["element_name"],
                matching_terms=db_job["data"]["tagging_result"]["matching_terms"],
                confidence_scores=db_job["data"]["tagging_result"]["confidence_scores"],
                validation_result=db_job["data"]["validation_result"],
                modeling_required=db_job["data"]["tagging_result"]["modeling_required"],
                message=db_job["data"]["tagging_result"]["message"]
            )
        
        # Tag the element
        logger.info(f"Tagging element: {request.element_id} - {request.element_name}")
        tagging_result = business_term_manager.tag_element(
            element_id=request.element_id,
            name=request.element_name,
            description=request.element_description,
            top_k=request.top_k
        )
        
        # Validate the tagging
        validation_result = await business_term_manager.validate_tagging(tagging_result)
        
        # Evaluate the confidence
        confidence_evaluator = get_confidence_evaluator()
        
        # Only evaluate if not modeling_required
        if not tagging_result.modeling_required:
            logger.info(f"Evaluating tagging confidence for {request.element_id}")
            try:
                overall_confidence = await confidence_evaluator.evaluate_tagging(tagging_result)
                
                # Adjust confidence scores with the overall evaluation
                adjusted_scores = []
                for score in tagging_result.confidence_scores:
                    # Blend the original score with overall confidence (70/30 split)
                    adjusted_score = (score * 0.7) + (overall_confidence * 0.3)
                    adjusted_scores.append(min(1.0, max(0.0, adjusted_score)))
                
                tagging_result.confidence_scores = adjusted_scores
            except Exception as e:
                logger.error(f"Error evaluating tagging confidence: {str(e)}")
        
        # Prepare the job data
        job_data = {
            "tagging_result": tagging_result.dict(),
            "validation_result": validation_result.dict()
        }
        
        # Store the result in memory
        tagging_jobs[request_id] = job_data
        
        # Store in database
        db.store_job(
            job_id=request_id,
            job_type="tagging",
            status="completed",
            data=job_data
        )
        
        return TaggingResponse(
            request_id=request_id,
            element_name=request.element_name,
            matching_terms=tagging_result.matching_terms,
            confidence_scores=tagging_result.confidence_scores,
            validation_result=validation_result.dict(),
            modeling_required=tagging_result.modeling_required,
            message=tagging_result.message
        )
    except Exception as e:
        logger.error(f"Error tagging element: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error tagging element: {str(e)}")

@router.post("/tag/enhanced", response_model=TaggingResponse)
async def tag_enhanced_element(
    element: EnhancedDataElement,
    db: DBManager = Depends(get_db)
):
    """
    Tag an enhanced data element with the most similar business terms.
    This endpoint is designed to work with the output of the enhancement process.
    """
    try:
        # Create a tagging request from the enhanced element
        request = TaggingRequest(
            element_id=element.id,
            element_name=element.enhanced_name,
            element_description=element.enhanced_description,
            top_k=3
        )
        
        # Use the main tagging endpoint
        return await tag_element(request, db)
    except Exception as e:
        logger.error(f"Error tagging enhanced element: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error tagging element: {str(e)}")

@router.get("/tag/{element_id}", response_model=TaggingResponse)
async def get_tagging_result(
    element_id: str,
    db: DBManager = Depends(get_db)
):
    """
    Get the result of a tagging request.
    """
    # Check in memory first
    if element_id in tagging_jobs:
        job = tagging_jobs[element_id]
        tagging_result = job["tagging_result"]
        validation_result = job["validation_result"]
        
        return TaggingResponse(
            request_id=element_id,
            element_name=tagging_result["element_name"],
            matching_terms=tagging_result["matching_terms"],
            confidence_scores=tagging_result["confidence_scores"],
            validation_result=validation_result,
            modeling_required=tagging_result.get("modeling_required", False),
            message=tagging_result.get("message", "")
        )
    
    # Check in database
    db_job = db.get_job(element_id)
    if db_job is None or db_job["job_type"] != "tagging":
        raise HTTPException(status_code=404, detail=f"Tagging result {element_id} not found")
    
    # Load into memory cache
    tagging_jobs[element_id] = db_job["data"]
    
    tagging_result = db_job["data"]["tagging_result"]
    validation_result = db_job["data"]["validation_result"]
    
    return TaggingResponse(
        request_id=element_id,
        element_name=tagging_result["element_name"],
        matching_terms=tagging_result["matching_terms"],
        confidence_scores=tagging_result["confidence_scores"],
        validation_result=validation_result,
        modeling_required=tagging_result.get("modeling_required", False),
        message=tagging_result.get("message", "")
    )

@router.delete("/tag/{element_id}", response_model=Dict[str, Any])
async def delete_tagging_result(
    element_id: str,
    db: DBManager = Depends(get_db)
):
    """
    Delete a tagging result from the system.
    """
    # Check if the job exists
    if element_id not in tagging_jobs and db.get_job(element_id) is None:
        raise HTTPException(status_code=404, detail=f"Tagging result {element_id} not found")
    
    # Delete from memory
    if element_id in tagging_jobs:
        del tagging_jobs[element_id]
    
    # Delete from database
    db.delete_job(element_id)
    
    return {"message": f"Tagging result for {element_id} deleted successfully"}

@router.get("/terms", response_model=List[Dict[str, Any]])
async def get_all_terms():
    """
    Get all business terms in the collection.
    """
    try:
        terms = business_term_manager.get_all_terms()
        return [term.dict() for term in terms]
    except Exception as e:
        logger.error(f"Error getting terms: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting terms: {str(e)}")

@router.get("/terms/{term_id}", response_model=Dict[str, Any])
async def get_term(term_id: str):
    """
    Get a business term by its ID.
    """
    try:
        term = business_term_manager.get_term_by_id(term_id)
        if not term:
            raise HTTPException(status_code=404, detail=f"Term {term_id} not found")
        return term.dict()
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting term: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting term: {str(e)}")

@router.post("/tag/batch", response_model=List[str])
async def batch_tag_elements(
    requests: List[TaggingRequest], 
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db)
):
    """
    Tag multiple data elements in batch mode.
    Returns a list of element IDs that can be used to check status.
    """
    element_ids = []
    
    for request in requests:
        element_id = request.element_id
        element_ids.append(element_id)
        
        # Skip if already processed
        if element_id in tagging_jobs:
            continue
            
        # Check if already in database
        db_job = db.get_job(element_id)
        if db_job is not None and db_job["job_type"] == "tagging":
            # Load into memory cache
            tagging_jobs[element_id] = db_job["data"]
            continue
        
        # Add tagging task to background tasks
        background_tasks.add_task(tag_element, request, db)
    
    return element_ids
