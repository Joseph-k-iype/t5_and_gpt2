"""
Tagging Workflow - LangGraph workflow for matching data elements with business terms.

This module provides a LangGraph-based workflow for the process of tagging data elements
with appropriate business terms, including vector-based matching and contextual validation.
"""

import logging
from typing import Dict, Any, List, Optional, TypedDict, Union
from pydantic import BaseModel, Field
from langchain_openai import AzureChatOpenAI
from langgraph.graph import StateGraph, END

from app.core.models import TaggingResult, TaggingValidationResult, EnhancedDataElement
from app.agents.tagging_agent import TaggingAgent
from app.core.business_terms import BusinessTermManager

logger = logging.getLogger(__name__)

# Define workflow state
class TaggingWorkflowState(TypedDict):
    """State for the tagging workflow."""
    element_id: str
    element_name: str
    element_description: str
    matching_terms: List[Dict[str, Any]]
    confidence_scores: List[float]
    validation_result: Optional[Dict[str, Any]]
    is_complete: bool
    modeling_required: bool
    error: Optional[str]
    message: str

class DataTaggingWorkflow:
    """LangGraph workflow for tagging data elements with business terms."""
    
    def __init__(self, llm: AzureChatOpenAI):
        """
        Initialize the tagging workflow.
        
        Args:
            llm: The language model to use for contextual validation
        """
        self.llm = llm
        self.tagging_agent = TaggingAgent(llm)
        self.business_term_manager = BusinessTermManager()
        self.graph = self._build_graph()
    
    async def _find_matching_terms(self, state: TaggingWorkflowState) -> TaggingWorkflowState:
        """
        Find matching business terms for the data element.
        
        Args:
            state: The current workflow state
            
        Returns:
            Updated workflow state
        """
        try:
            # Call the business term manager to find matching terms
            result = self.business_term_manager.tag_element(
                element_id=state["element_id"],
                name=state["element_name"],
                description=state["element_description"],
                top_k=5  # Get more for contextual validation
            )
            
            # Update state with the results
            state["matching_terms"] = result.matching_terms
            state["confidence_scores"] = result.confidence_scores
            state["modeling_required"] = result.modeling_required
            state["message"] = result.message
            
            return state
        except Exception as e:
            logger.error(f"Error finding matching terms: {e}")
            state["error"] = f"Error finding matching terms: {str(e)}"
            state["is_complete"] = True
            return state
    
    async def _validate_contextual_match(self, state: TaggingWorkflowState) -> TaggingWorkflowState:
        """
        Validate the contextual appropriateness of the matched terms.
        
        Args:
            state: The current workflow state
            
        Returns:
            Updated workflow state
        """
        try:
            # Skip if no matching terms found or modeling is required
            if not state["matching_terms"] or state["modeling_required"]:
                state["is_complete"] = True
                return state
            
            # Recreate the tagging result for validation
            tagging_result = TaggingResult(
                element_id=state["element_id"],
                element_name=state["element_name"],
                element_description=state["element_description"],
                matching_terms=state["matching_terms"],
                confidence_scores=state["confidence_scores"],
                modeling_required=state["modeling_required"],
                message=state["message"]
            )
            
            # Perform contextual validation
            validation_result = await self.tagging_agent._validate_contextual_match(
                element_name=state["element_name"],
                element_description=state["element_description"],
                term_name=state["matching_terms"][0]["name"],
                term_description=state["matching_terms"][0]["description"],
                term_category=state["matching_terms"][0].get("category", "Not specified"),
                similarity_score=state["matching_terms"][0]["similarity"],
                other_terms=self._format_other_terms(state["matching_terms"][1:])
            )
            
            # Update state with validation result
            state["validation_result"] = validation_result.dict()
            
            # If the match is not contextually appropriate, try to find a better match
            if not validation_result.is_match and validation_result.suggested_term_id:
                state["message"] = f"Original match not contextually appropriate. {validation_result.reasoning}"
                
                # Find the suggested term in the matching terms
                for i, term in enumerate(state["matching_terms"]):
                    if term["id"] == validation_result.suggested_term_id:
                        # Swap with the top match
                        if i > 0:
                            state["matching_terms"][0], state["matching_terms"][i] = state["matching_terms"][i], state["matching_terms"][0]
                            state["confidence_scores"][0], state["confidence_scores"][i] = state["confidence_scores"][i], state["confidence_scores"][0]
                        
                        # Update the confidence score
                        state["confidence_scores"][0] = validation_result.confidence
                        state["matching_terms"][0]["similarity"] = validation_result.confidence
                        state["message"] += f" Found better match: {state['matching_terms'][0]['name']}"
                        break
            
            return state
        except Exception as e:
            logger.error(f"Error validating contextual match: {e}")
            state["error"] = f"Error validating contextual match: {str(e)}"
            state["is_complete"] = True
            return state
    
    def _format_other_terms(self, terms: List[Dict[str, Any]]) -> str:
        """Format other terms for the contextual validation prompt."""
        if not terms:
            return "No other potential terms available."
        
        result = ""
        for i, term in enumerate(terms):
            result += f"Term {i+1}:\n"
            result += f"- ID: {term['id']}\n"
            result += f"- Name: {term['name']}\n"
            result += f"- Description: {term['description']}\n"
            result += f"- Similarity: {term['similarity']:.2f}\n\n"
        
        return result
    
    async def _determine_modeling_need(self, state: TaggingWorkflowState) -> TaggingWorkflowState:
        """
        Determine if a new business term needs to be modeled.
        
        Args:
            state: The current workflow state
            
        Returns:
            Updated workflow state
        """
        # Skip if no matching terms or error
        if state.get("error") or not state["matching_terms"]:
            state["modeling_required"] = True
            state["is_complete"] = True
            return state
        
        # Get the highest confidence score
        highest_confidence = max(state["confidence_scores"]) if state["confidence_scores"] else 0.0
        
        # Check confidence threshold for modeling
        if highest_confidence < 0.4:
            state["modeling_required"] = True
            state["message"] = f"Low confidence match ({highest_confidence:.2f}). Consider modeling a new term."
        else:
            state["modeling_required"] = False
            state["message"] = f"Found appropriate match with confidence {highest_confidence:.2f}"
        
        state["is_complete"] = True
        return state
    
    def _build_graph(self) -> StateGraph:
        """Build the LangGraph workflow."""
        workflow = StateGraph(TaggingWorkflowState)
        
        # Add nodes
        workflow.add_node("find_matching_terms", self._find_matching_terms)
        workflow.add_node("validate_contextual_match", self._validate_contextual_match)
        workflow.add_node("determine_modeling_need", self._determine_modeling_need)
        
        # Add edges
        workflow.add_edge("find_matching_terms", "validate_contextual_match")
        workflow.add_edge("validate_contextual_match", "determine_modeling_need")
        workflow.add_edge("determine_modeling_need", END)
        
        # Set entrypoint
        workflow.set_entry_point("find_matching_terms")
        
        return workflow.compile()
    
    async def run(self, element_id: str, element_name: str, element_description: str) -> TaggingResult:
        """
        Run the tagging workflow on a data element.
        
        Args:
            element_id: Unique identifier for the element
            element_name: Name of the element
            element_description: Description of the element
        
        Returns:
            TaggingResult containing matching terms and confidence scores
        """
        logger.info(f"Starting tagging workflow for element: {element_id}")
        
        initial_state: TaggingWorkflowState = {
            "element_id": element_id,
            "element_name": element_name,
            "element_description": element_description,
            "matching_terms": [],
            "confidence_scores": [],
            "validation_result": None,
            "is_complete": False,
            "modeling_required": False,
            "error": None,
            "message": ""
        }
        
        # Run the workflow
        result = await self.graph.ainvoke(initial_state)
        
        if result.get("error"):
            logger.error(f"Workflow error: {result['error']}")
            return TaggingResult(
                element_id=element_id,
                element_name=element_name,
                element_description=element_description,
                matching_terms=[],
                confidence_scores=[],
                modeling_required=True,
                message=result["error"]
            )
        
        return TaggingResult(
            element_id=result["element_id"],
            element_name=result["element_name"],
            element_description=result["element_description"],
            matching_terms=result["matching_terms"],
            confidence_scores=result["confidence_scores"],
            modeling_required=result["modeling_required"],
            message=result["message"]
        )
        
    async def tag_enhanced_element(self, enhanced_element: EnhancedDataElement) -> TaggingResult:
        """
        Tag an enhanced data element with appropriate business terms.
        
        Args:
            enhanced_element: The enhanced data element
            
        Returns:
            TaggingResult with matching terms and confidence scores
        """
        return await self.run(
            element_id=enhanced_element.id,
            element_name=enhanced_element.enhanced_name,
            element_description=enhanced_element.enhanced_description
        )
