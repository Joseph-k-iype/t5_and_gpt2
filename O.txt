"""
PostgreSQL Vector Store - Implementation of vector storage using PostgreSQL with pgvector extension.

This module provides a PostgreSQL-based implementation of the VectorStore interface,
utilizing the pgvector extension for efficient vector similarity search.
"""

import logging
from typing import List, Dict, Any, Optional, Tuple, Union
import numpy as np
import psycopg2.extras
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

from app.core.vector_store import VectorStore
from app.core.db_manager import DBManager

logger = logging.getLogger(__name__)

class PostgreSQLVectorStore(VectorStore):
    """
    Vector store implementation using PostgreSQL with pgvector extension.
    
    This class provides vector storage and similarity search using PostgreSQL with the
    pgvector extension, which offers efficient indexing and search for embedding vectors.
    """
    
    def __init__(self):
        """Initialize the PostgreSQL vector store with a database connection manager."""
        self.db_manager = DBManager()
        
        # Verify pgvector extension is enabled
        self._verify_pgvector()
    
    def _verify_pgvector(self) -> bool:
        """
        Verify that the pgvector extension is enabled in PostgreSQL.
        
        Returns:
            bool: True if pgvector is enabled, False otherwise
        """
        try:
            health = self.db_manager.health_check()
            if not health.get("vector_enabled", False):
                logger.warning("pgvector extension is not enabled in PostgreSQL")
                return False
            return True
        except Exception as e:
            logger.error(f"Error verifying pgvector extension: {e}")
            return False
    
    @retry(
        retry=retry_if_exception_type(Exception),
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        reraise=True
    )
    def store_vector(self, id: str, name: str, description: str, embedding: List[float], metadata: Optional[Dict[str, Any]] = None) -> bool:
        """
        Store a vector in the PostgreSQL database.
        
        Args:
            id: Unique identifier for the term
            name: Name of the term
            description: Description of the term
            embedding: Vector embedding as a list of floats
            metadata: Additional metadata as a dictionary
            
        Returns:
            bool: True if successful, False otherwise
        """
        return self.db_manager.store_vector(id, name, description, embedding, metadata)
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        retry=retry_if_exception_type((Exception,)),
        reraise=True
    )
    def batch_store_vectors(self, items: List[Dict[str, Any]]) -> int:
        """
        Store multiple vectors in the PostgreSQL database.
        
        Args:
            items: List of dictionaries with id, name, description, embedding, and optional metadata
            
        Returns:
            int: Number of items successfully stored
        """
        return self.db_manager.batch_store_vectors(items)
    
    def find_similar_vectors(self, query_vector: List[float], top_k: int = 5, threshold: float = 0.5) -> List[Dict[str, Any]]:
        """
        Find similar vectors in the PostgreSQL database using pgvector's cosine similarity.
        
        Args:
            query_vector: Vector to compare against
            top_k: Number of results to return
            threshold: Minimum similarity threshold (0-1)
            
        Returns:
            List of dictionaries with id, name, description, similarity, and metadata
        """
        try:
            return self.db_manager.find_similar_vectors(query_vector, top_k, threshold)
        except Exception as e:
            logger.error(f"Error finding similar vectors: {e}")
            return []
    
    def get_all_terms(self) -> List[Dict[str, Any]]:
        """
        Get all business terms from the PostgreSQL database.
        
        Returns:
            List of dictionaries with id, name, description, and metadata
        """
        try:
            return self.db_manager.get_all_terms()
        except Exception as e:
            logger.error(f"Error getting all terms: {e}")
            return []
    
    def get_term_by_id(self, term_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific business term by ID from PostgreSQL.
        
        Args:
            term_id: ID of the term to retrieve
            
        Returns:
            Dictionary with term details or None if not found
        """
        try:
            return self.db_manager.get_term_by_id(term_id)
        except Exception as e:
            logger.error(f"Error getting term by ID: {e}")
            return None
    
    def delete_term(self, term_id: str) -> bool:
        """
        Delete a business term from the PostgreSQL database.
        
        Args:
            term_id: ID of the term to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            return self.db_manager.delete_term(term_id)
        except Exception as e:
            logger.error(f"Error deleting term: {e}")
            return False
    
    def compute_cosine_similarity(self, vector1: List[float], vector2: List[float]) -> float:
        """
        Compute cosine similarity between two vectors.
        
        Args:
            vector1: First vector
            vector2: Second vector
            
        Returns:
            float: Cosine similarity between 0 and 1
        """
        try:
            return self.db_manager.compute_cosine_similarity(vector1, vector2)
        except Exception as e:
            logger.error(f"Error computing similarity: {e}")
            
            # Fallback implementation if db_manager method fails
            try:
                # Convert to numpy arrays
                a = np.array(vector1)
                b = np.array(vector2)
                
                # Compute cosine similarity
                dot_product = np.dot(a, b)
                norm_a = np.linalg.norm(a)
                norm_b = np.linalg.norm(b)
                
                if norm_a == 0 or norm_b == 0:
                    return 0.0
                
                similarity = dot_product / (norm_a * norm_b)
                return max(0.0, min(similarity, 1.0))  # Ensure in range [0, 1]
            except Exception as e2:
                logger.error(f"Fallback similarity computation also failed: {e2}")
                return 0.0
    
    def search_terms(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Search for terms by text query in PostgreSQL.
        
        Args:
            query: Search query
            limit: Maximum number of results
            
        Returns:
            List of matching terms
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor(cursor_factory=psycopg2.extras.DictCursor) as cursor:
                    schema_name = self.db_manager.schema_name
                    cursor.execute(f"""
                    SELECT id, name, description, metadata
                    FROM {schema_name}.business_terms
                    WHERE 
                        name ILIKE %s OR 
                        description ILIKE %s
                    ORDER BY 
                        CASE WHEN name ILIKE %s THEN 0 ELSE 1 END,
                        CASE WHEN description ILIKE %s THEN 0 ELSE 1 END,
                        name
                    LIMIT %s
                    """, (f"%{query}%", f"%{query}%", f"{query}%", f"{query}%", limit))
                    
                    return [dict(row) for row in cursor.fetchall()]
        except Exception as e:
            logger.error(f"Error searching terms: {e}")
            return []
    
    def delete_all_terms(self) -> int:
        """
        Delete all terms in the PostgreSQL database.
        
        Returns:
            int: Number of terms deleted
        """
        try:
            with self.db_manager.get_connection() as conn:
                with conn.cursor() as cursor:
                    schema_name = self.db_manager.schema_name
                    cursor.execute(f"DELETE FROM {schema_name}.business_terms")
                    deleted = cursor.rowcount
                    conn.commit()
                    return deleted
        except Exception as e:
            logger.error(f"Error deleting all terms: {e}")
            return 0
            
    def health_check(self) -> Dict[str, Any]:
        """
        Perform a detailed health check of the PostgreSQL vector store.
        
        Returns:
            Dict with health status and details
        """
        try:
            # Get database status from DB manager
            db_health = self.db_manager.health_check()
            
            # Additional pgvector-specific checks
            vector_specific = {
                "vector_enabled": db_health.get("vector_enabled", False),
                "schema_exists": db_health.get("schema_exists", False),
                "schema_name": self.db_manager.schema_name,
                "term_count": db_health.get("terms_count", 0)
            }
            
            return {
                "status": "healthy" if db_health["status"] == "healthy" and vector_specific["vector_enabled"] else "unhealthy",
                "type": "postgresql",
                "version": db_health.get("version", "unknown"),
                "details": {
                    **vector_specific,
                    "db_size_mb": db_health.get("db_size_mb", 0),
                    "active_connections": db_health.get("active_connections", 0)
                }
            }
        except Exception as e:
            return {
                "status": "unhealthy",
                "type": "postgresql",
                "error": str(e)
            }
