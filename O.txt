import os
import uuid
from fastapi import APIRouter, HTTPException, UploadFile, File, Form, BackgroundTasks, Depends
from typing import Dict, List, Any, Optional
import json
from app.core.business_terms import BusinessTermManager, TaggingResult, TaggingValidationResult
from app.core.models import EnhancedDataElement
from pydantic import BaseModel

router = APIRouter(prefix="/api/v1", tags=["business-terms"])

# In-memory storage for tagging jobs
# In a production system, this would be a database
tagging_jobs: Dict[str, Dict[str, Any]] = {}

# Business Term Manager instance with persistent storage
business_term_manager = BusinessTermManager(persistent_dir="./chroma_db")

class TaggingRequest(BaseModel):
    """Request model for tagging an enhanced data element."""
    element_name: str
    element_description: str
    top_k: int = 3

class TaggingResponse(BaseModel):
    """Response model for a tagging request."""
    request_id: str
    element_name: str
    matching_terms: List[Dict[str, Any]]
    confidence_scores: List[float]
    validation_result: Optional[Dict[str, Any]] = None

class ImportResponse(BaseModel):
    """Response model for importing business terms."""
    success: bool
    message: str
    imported_count: int

@router.post("/terms/import", response_model=ImportResponse)
async def import_business_terms(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """
    Import business terms from a CSV file.
    The CSV must have 'name' and 'description' columns.
    """
    try:
        # Save the uploaded file temporarily
        temp_file_path = f"temp_{uuid.uuid4()}.csv"
        with open(temp_file_path, "wb") as buffer:
            buffer.write(await file.read())
        
        # Import terms
        import_count = business_term_manager.import_terms_from_csv(temp_file_path)
        
        # Clean up the temp file
        if background_tasks:
            background_tasks.add_task(os.unlink, temp_file_path)
        else:
            os.unlink(temp_file_path)
        
        return ImportResponse(
            success=True,
            message=f"Successfully imported business terms from {file.filename}",
            imported_count=import_count
        )
    except Exception as e:
        # Clean up the temp file in case of error
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
        raise HTTPException(status_code=500, detail=f"Error importing terms: {str(e)}")

@router.post("/tag", response_model=TaggingResponse)
async def tag_element(request: TaggingRequest):
    """
    Tag an enhanced data element with the most similar business terms.
    Also validates if the tagging makes sense.
    """
    try:
        # Tag the element
        tagging_result = business_term_manager.tag_element(
            name=request.element_name,
            description=request.element_description,
            top_k=request.top_k
        )
        
        # Validate the tagging
        validation_result = await business_term_manager.validate_tagging(tagging_result)
        
        # Generate a request ID
        request_id = str(uuid.uuid4())
        
        # Store the result
        tagging_jobs[request_id] = {
            "tagging_result": tagging_result.dict(),
            "validation_result": validation_result.dict()
        }
        
        return TaggingResponse(
            request_id=request_id,
            element_name=request.element_name,
            matching_terms=tagging_result.matching_terms,
            confidence_scores=tagging_result.confidence_scores,
            validation_result=validation_result.dict()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error tagging element: {str(e)}")

@router.post("/tag/enhanced", response_model=TaggingResponse)
async def tag_enhanced_element(element: EnhancedDataElement):
    """
    Tag an enhanced data element with the most similar business terms.
    This endpoint is designed to work with the output of the enhancement process.
    """
    try:
        # Tag the element
        tagging_result = business_term_manager.tag_element(
            name=element.enhanced_name,
            description=element.enhanced_description,
            top_k=3
        )
        
        # Validate the tagging
        validation_result = await business_term_manager.validate_tagging(tagging_result)
        
        # Generate a request ID
        request_id = str(uuid.uuid4())
        
        # Store the result
        tagging_jobs[request_id] = {
            "tagging_result": tagging_result.dict(),
            "validation_result": validation_result.dict()
        }
        
        return TaggingResponse(
            request_id=request_id,
            element_name=element.enhanced_name,
            matching_terms=tagging_result.matching_terms,
            confidence_scores=tagging_result.confidence_scores,
            validation_result=validation_result.dict()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error tagging element: {str(e)}")

@router.get("/tag/{request_id}", response_model=TaggingResponse)
async def get_tagging_result(request_id: str):
    """
    Get the result of a tagging request.
    """
    if request_id not in tagging_jobs:
        raise HTTPException(status_code=404, detail=f"Tagging result {request_id} not found")
    
    job = tagging_jobs[request_id]
    tagging_result = job["tagging_result"]
    validation_result = job["validation_result"]
    
    return TaggingResponse(
        request_id=request_id,
        element_name=tagging_result["element_name"],
        matching_terms=tagging_result["matching_terms"],
        confidence_scores=tagging_result["confidence_scores"],
        validation_result=validation_result
    )

@router.get("/terms", response_model=List[Dict[str, Any]])
async def get_all_terms():
    """
    Get all business terms in the collection.
    """
    try:
        terms = business_term_manager.get_all_terms()
        return [term.dict() for term in terms]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting terms: {str(e)}")

@router.get("/terms/{term_id}", response_model=Dict[str, Any])
async def get_term(term_id: str):
    """
    Get a business term by its ID.
    """
    try:
        term = business_term_manager.get_term_by_id(term_id)
        if not term:
            raise HTTPException(status_code=404, detail=f"Term {term_id} not found")
        return term.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting term: {str(e)}")
