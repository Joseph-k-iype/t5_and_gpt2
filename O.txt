from typing import Dict, Any, List
import re
import logging
import os
import pandas as pd
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import AzureChatOpenAI
from app.core.models import DataElement, ValidationResult, DataQualityStatus
from app.utils.iso_standards import ISO11179Validator

logger = logging.getLogger(__name__)

class ValidatorAgent:
    
    def __init__(self, llm: AzureChatOpenAI):
        self.llm = llm
        self.iso_validator = ISO11179Validator()
        self.approved_acronyms = self._load_approved_acronyms()
        self._setup_validation_chain()
    
    def _load_approved_acronyms(self):
        """Load approved acronyms from CSV file."""
        approved_acronyms = {}
        try:
            csv_path = os.path.join("data", "acronyms.csv")
            if os.path.exists(csv_path):
                df = pd.read_csv(csv_path)
                if 'acronym' in df.columns and 'description' in df.columns:
                    for _, row in df.iterrows():
                        approved_acronyms[row['acronym'].strip().upper()] = row['description'].strip()
                logger.info(f"Loaded {len(approved_acronyms)} approved acronyms from {csv_path}")
            else:
                logger.warning(f"Acronyms file not found at {csv_path}")
        except Exception as e:
            logger.error(f"Error loading approved acronyms: {e}")
        
        return approved_acronyms
    
    def _setup_validation_chain(self):
        template = """
        You are an expert in data governance and ISO/IEC 11179 metadata standards. Your task is to evaluate the 
        given data element name and description against these standards to determine the quality of the metadata.
        
        ISO/IEC 11179 standards for data element names (adapted for business-friendly format):
        - Names MUST be in lowercase with spaces between words.
        - Names MUST NOT use technical formatting like camelCase, snake_case or PascalCase
        - Names MUST NOT contain underscores, hyphens, or special characters
        - Names should be clear, unambiguous and self-describing
        - Names should not use acronyms or abbreviations unless they are universally understood
        - Names should be concise yet descriptive
        - Names should use standard terminology in the domain
        - Names should use business language that non-technical users can understand
        
        ISO/IEC 11179 standards for data element descriptions:
        - Descriptions should clearly define what the data element represents
        - Descriptions should be complete, covering the concept fully
        - Descriptions should be precise, specific enough to distinguish from other concepts
        - Descriptions should be objective and factual, not opinion-based
        - Descriptions should use complete sentences with proper grammar and punctuation
        - Descriptions should be written in business language, not technical jargon
        
        Data Element to Evaluate:
        - ID: {id}
        - Current Name: {name}
        - Current Description: {description}
        - Example (if provided): {example}
        - Related Process Name (if provided): {process_name}
        - Related Process Description (if provided): {process_description}
        
        Based on the ISO/IEC 11179 standards, evaluate the quality of this data element.
        
        IMPORTANT: Your response MUST include ALL of the following 6 evaluation points in order:
        1. Is the name valid according to ISO/IEC 11179 standards? [yes/no]
        2. Detailed feedback on the name
        3. Is the description valid according to the standards? [yes/no]
        4. Detailed feedback on the description (pay careful attention to grammar and punctuation)
        5. Overall quality status - MUST be one of: "GOOD", "NEEDS_IMPROVEMENT", or "POOR"
        6. List of specific improvements that could be made
        
        DO NOT use any special formatting characters like asterisks (**), backticks (``), or markdown syntax.
        DO NOT include any \\n characters or other special characters in your response.
        Please be thorough and specific in your feedback, as it will be used to improve the data element.
        """
        
        self.validation_prompt = PromptTemplate(
            input_variables=["id", "name", "description", "example", "process_name", "process_description"],
            template=template)
        self.validation_chain = self.validation_prompt | self.llm | StrOutputParser()
        
    def _parse_validation_result(self, result: str) -> ValidationResult:
        # Clean up the result
        result = result.replace("**", "").replace("```", "")
        lines = result.strip().split("\n")
        
        is_name_valid = False
        is_desc_valid = False
        name_feedback = ""
        desc_feedback = ""
        quality_status = DataQualityStatus.NEEDS_IMPROVEMENT  # Default to NEEDS_IMPROVEMENT instead of POOR
        improvements = []
        
        # Extract each section
        current_section = None
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            if line.startswith("1."):
                current_section = "name_valid"
                if "yes" in line.lower():
                    is_name_valid = True
            elif line.startswith("2."):
                current_section = "name_feedback"
                name_feedback = line[2:].strip()
            elif line.startswith("3."):
                current_section = "desc_valid"
                if "yes" in line.lower():
                    is_desc_valid = True
            elif line.startswith("4."):
                current_section = "desc_feedback"
                desc_feedback = line[2:].strip()
            elif line.startswith("5."):
                current_section = "quality_status"
                if "GOOD" in line:
                    quality_status = DataQualityStatus.GOOD
                elif "NEEDS_IMPROVEMENT" in line or "NEEDS IMPROVEMENT" in line:
                    quality_status = DataQualityStatus.NEEDS_IMPROVEMENT
                elif "POOR" in line:
                    quality_status = DataQualityStatus.POOR
            elif line.startswith("6."):
                current_section = "improvements"
            elif current_section == "name_feedback":
                name_feedback += " " + line
            elif current_section == "desc_feedback":
                desc_feedback += " " + line
            elif current_section == "improvements":
                if line.startswith("-") or line.startswith("*") or (line[0].isdigit() and ". " in line):
                    # This is a new improvement item
                    line = re.sub(r'^[-*]\s+|\d+\.\s+', '', line)
                    improvements.append(line)
                elif improvements:
                    # This is a continuation of the previous improvement
                    improvements[-1] += " " + line
                else:
                    # If no previous improvement item to append to, create a new one
                    improvements.append(line)
        
        # Ensure quality status is consistent with validations
        if is_name_valid and is_desc_valid:
            # If both are valid but status wasn't explicitly GOOD, use NEEDS_IMPROVEMENT
            if quality_status == DataQualityStatus.POOR:
                quality_status = DataQualityStatus.NEEDS_IMPROVEMENT
        elif not is_name_valid and not is_desc_valid:
            # If both are invalid, it should be POOR
            quality_status = DataQualityStatus.POOR
        
        # Combine feedback
        combined_feedback = f"Name feedback: {name_feedback}\n\nDescription feedback: {desc_feedback}"
        
        # If no improvements were extracted, create some based on validation results
        if not improvements:
            if not is_name_valid:
                improvements.append("Improve the name to comply with ISO/IEC 11179 standards")
            if not is_desc_valid:
                improvements.append("Enhance the description to be more precise and complete")
            if is_name_valid and is_desc_valid and quality_status != DataQualityStatus.GOOD:
                improvements.append("Further refine name and description for better clarity")
        
        return ValidationResult(
            is_valid=is_name_valid and is_desc_valid,
            quality_status=quality_status, 
            feedback=combined_feedback,
            suggested_improvements=improvements
        )
    
    async def validate(self, data_element: DataElement) -> ValidationResult:
        """Validate a data element against ISO/IEC 11179 standards with approved acronyms."""
        try:
            # First, perform basic validation
            name_valid, name_feedback = self.iso_validator.validate_name(data_element.existing_name)
            desc_valid, desc_feedback = self.iso_validator.validate_description(data_element.existing_description)
            
            # Check for approved acronyms in the name
            words = re.findall(r'\b[A-Z]{2,}\b', data_element.existing_name.upper())
            approved_acronyms_found = []
            unapproved_acronyms = []
            
            for word in words:
                if word in self.approved_acronyms:
                    approved_acronyms_found.append(f"{word} ({self.approved_acronyms[word]})")
                else:
                    unapproved_acronyms.append(word)
            
            # Modify name feedback based on acronyms
            if approved_acronyms_found:
                name_feedback += f"\nFound approved acronyms: {', '.join(approved_acronyms_found)}"
            if unapproved_acronyms:
                name_feedback += f"\nFound unapproved acronyms: {', '.join(unapproved_acronyms)}"
                name_valid = False  # Mark as invalid if unapproved acronyms are found
            
            if not name_valid or not desc_valid:
                feedback = ""
                if not name_valid:
                    feedback += f"Name validation failed: {name_feedback}\n"
                if not desc_valid:
                    feedback += f"Description validation failed: {desc_feedback}"
                
                return ValidationResult(
                    is_valid = False,
                    quality_status = DataQualityStatus.POOR,
                    feedback = feedback.strip(),
                    suggested_improvements = ["Fix basic validation issues before proceeding with deeper analysis"]
                )
            
            # Update the prompt with approved acronyms information
            template = self.validation_prompt.template
            if self.approved_acronyms:
                acronym_info = "Approved acronyms that can be used:\n"
                for acronym, description in list(self.approved_acronyms.items())[:10]:  # Limit to first 10 for brevity
                    acronym_info += f"- {acronym}: {description}\n"
                if len(self.approved_acronyms) > 10:
                    acronym_info += f"- Plus {len(self.approved_acronyms) - 10} more approved acronyms\n"
                    
                template = template.replace("ISO/IEC 11179 standards for data element names", 
                                           f"ISO/IEC 11179 standards for data element names\n\n{acronym_info}")
            
            # Create a custom prompt for this validation
            custom_prompt = PromptTemplate(
                input_variables=["id", "name", "description", "example", "process_name", "process_description"],
                template=template)
            custom_chain = custom_prompt | self.llm | StrOutputParser()
            
            # If basic validation passes, perform more detailed evaluation
            result = await custom_chain.ainvoke({
                "id": data_element.id,
                "name": data_element.existing_name,
                "description": data_element.existing_description,
                "example": data_element.example or "Not provided",
                "process_name": data_element.process_name or "Not provided",
                "process_description": data_element.process_description or "Not provided"
            })
            
            return self._parse_validation_result(result)
        except Exception as e:
            logger.error(f"Error validating data element: {e}")
            # Return a minimal validation result in case of error
            return ValidationResult(
                is_valid = False,
                quality_status = DataQualityStatus.POOR,
                feedback = f"Error during validation: {str(e)}",
                suggested_improvements = ["Retry validation after resolving the error"]
            )
