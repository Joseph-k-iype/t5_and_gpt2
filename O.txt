"""
Main Application - Entry point for the Data Element Enhancement API.

This module initializes and configures the FastAPI application, sets up routes,
middleware, and monitoring, and handles command line arguments for configuration.
"""

import argparse
import logging
import os
import sys
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import uvicorn
from app.api.routes.enhancement import router as enhancement_router
from app.api.routes.tagging import router as tagging_router
from app.api.routes.settings import router as settings_router
from app.api.routes.dashboard import router as dashboard_router
from app.config.environment import get_os_env, str_to_bool
from app.core.system_monitor import start_monitoring, stop_monitoring
from app.core.db_manager import DBManager
from app.core.business_terms import BusinessTermManager
from app.config.settings import get_vector_store

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Make sure psutil is installed
try:
    import psutil
except ImportError:
    logger.warning("psutil not installed. Installing...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "psutil"])
    import psutil

def create_application(
    proxy_enabled: bool = None, 
    monitoring_interval: int = 300,
    vector_db_type: str = None,
    chroma_dir: str = None,
    chroma_collection: str = None
) -> FastAPI:
    """
    Create the FastAPI application.
    
    Args:
        proxy_enabled: Whether to use proxy for API connections
        monitoring_interval: Interval in seconds for system monitoring (0 to disable)
        vector_db_type: Type of vector database to use (postgresql or chroma)
        chroma_dir: ChromaDB persistent directory
        chroma_collection: ChromaDB collection name
    
    Returns:
        FastAPI: The application instance
    """
    # Initialize environment with proxy setting
    env = get_os_env(proxy_enabled=proxy_enabled)
    
    # Set vector database type if provided
    if vector_db_type:
        os.environ["VECTOR_DB_TYPE"] = vector_db_type
        
    # Set ChromaDB settings if provided
    if chroma_dir:
        os.environ["CHROMA_PERSIST_DIR"] = chroma_dir
    if chroma_collection:
        os.environ["CHROMA_COLLECTION"] = chroma_collection
    
    # Initialize database connection
    db_manager = DBManager()
    db_health = db_manager.health_check()
    if db_health["status"] == "healthy":
        logger.info(f"Database connection successful - PostgreSQL {db_health.get('version', '').split()[1] if 'version' in db_health else 'unknown'}")
        logger.info(f"pgvector extension: {'Enabled' if db_health.get('vector_enabled', False) else 'Disabled'}")
    else:
        logger.error(f"Database connection failed: {db_health.get('error', 'Unknown error')}")
    
    # Initialize vector store
    vector_store = get_vector_store()
    vector_store_health = vector_store.health_check()
    logger.info(f"Vector database: {os.environ.get('VECTOR_DB_TYPE', 'postgresql')} ({vector_store_health['status']})")
    
    # Create FastAPI app
    app = FastAPI(
        title="Data Element Enhancement and Tagging API",
        description="API for enhancing data element names and descriptions based on ISO/IEC 11179 standards, and tagging with preferred business terms",
        version="1.0.0",
    )
    
    # Configure CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Restrict in production
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Include routers
    app.include_router(enhancement_router)
    app.include_router(tagging_router)
    app.include_router(settings_router)
    app.include_router(dashboard_router, prefix="/api")
    
    # Add static files directory for dashboard assets
    static_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "static")
    os.makedirs(static_dir, exist_ok=True)
    app.mount("/static", StaticFiles(directory=static_dir), name="static")
    
    # Start system monitoring if enabled
    if monitoring_interval > 0:
        logger.info(f"Starting system monitoring with {monitoring_interval}s interval")
        start_monitoring(interval=monitoring_interval)
    
    @app.get("/health")
    async def health_check():
        """Health check endpoint."""
        db_status = db_manager.health_check()

        # Get vector database status
        vector_db_type = os.environ.get("VECTOR_DB_TYPE", "postgresql").lower()
        vector_db_status = {
            "type": vector_db_type
        }
        
        if vector_db_type == "chroma":
            vector_db_status.update({
                "persist_dir": os.environ.get("CHROMA_PERSIST_DIR", "./data/chroma_db"),
                "collection": os.environ.get("CHROMA_COLLECTION", "business_terms")
            })
        
        return {
            "status": "healthy",
            "proxy_enabled": str_to_bool(env.get("PROXY_ENABLED", "False")),
            "azure_endpoint": env.get("AZURE_ENDPOINT", ""),
            "model": env.get("MODEL_NAME", "gpt-4o"),
            "database": {
                "status": db_status["status"],
                "host": env.get("PG_HOST", "localhost"),
                "port": env.get("PG_PORT", "5432"),
                "db": env.get("PG_DB", "metadata_db")
            },
            "vector_database": vector_db_status
        }
    
    @app.get("/")
    async def root():
        """Root endpoint with basic information."""
        vector_db_type = os.environ.get("VECTOR_DB_TYPE", "postgresql").lower()
        
        return {
            "application": "Data Element Enhancement and Tagging API",
            "version": "1.0.0",
            "status": "running",
            "documentation": "/docs",
            "dashboard": "/api/dashboard",
            "proxy_enabled": str_to_bool(env.get("PROXY_ENABLED", "False")),
            "database": env.get("PG_DB", "metadata_db"),
            "vector_database": {
                "type": vector_db_type,
                "details": {
                    "chroma_persist_dir": os.environ.get("CHROMA_PERSIST_DIR", "./data/chroma_db") if vector_db_type == "chroma" else None,
                    "chroma_collection": os.environ.get("CHROMA_COLLECTION", "business_terms") if vector_db_type == "chroma" else None,
                }
            }
        }
    
    # Register shutdown event to stop monitoring
    @app.on_event("shutdown")
    def shutdown_event():
        """Shutdown event handler to clean up resources."""
        logger.info("Application shutting down...")
        
        # Stop system monitoring
        stop_monitoring()
    
    return app

def parse_args():
    """
    Parse command line arguments.
    
    Returns:
        argparse.Namespace: Parsed arguments
    """
    parser = argparse.ArgumentParser(description="ISO/IEC 11179 Data Enhancement API")
    parser.add_argument("--proxy", dest="proxy_enabled", action="store_true", 
                        help="Enable proxy for API connections")
    parser.add_argument("--no-proxy", dest="proxy_enabled", action="store_false", 
                        help="Disable proxy for API connections")
    parser.add_argument("--host", type=str, default="0.0.0.0", 
                        help="Host to bind the server to")
    parser.add_argument("--port", type=int, default=8000, 
                        help="Port to bind the server to")
    parser.add_argument("--reload", action="store_true", 
                        help="Enable auto-reload for development")
    parser.add_argument("--config", type=str, default="env/config.env", 
                        help="Path to configuration file")
    parser.add_argument("--creds", type=str, default="env/credentials.env", 
                        help="Path to credentials file")
    parser.add_argument("--cert", type=str, default="env/cacert.pem", 
                        help="Path to SSL certificate file")
    parser.add_argument("--monitoring-interval", type=int, default=300,
                        help="Interval in seconds for system monitoring (0 to disable)")
    
    # PostgreSQL settings
    parser.add_argument("--pg-host", type=str, help="PostgreSQL host")
    parser.add_argument("--pg-port", type=int, help="PostgreSQL port")
    parser.add_argument("--pg-user", type=str, help="PostgreSQL user")
    parser.add_argument("--pg-password", type=str, help="PostgreSQL password")
    parser.add_argument("--pg-db", type=str, help="PostgreSQL database name")
    
    # Vector database options
    parser.add_argument("--vector-db", type=str, choices=["postgresql", "chroma"], 
                      default="postgresql", help="Vector database backend")
    parser.add_argument("--chroma-dir", type=str, default="./data/chroma_db",
                      help="ChromaDB persistent directory (for chroma vector-db)")
    parser.add_argument("--chroma-collection", type=str, default="business_terms",
                      help="ChromaDB collection name (for chroma vector-db)")
    
    parser.set_defaults(proxy_enabled=None)  # Default values
    
    return parser.parse_args()

# Create a simple app instance for module import cases
app = create_application(monitoring_interval=0)  # Disable monitoring for imported app

if __name__ == "__main__":
    # For local development with command line arguments
    args = parse_args()
    
    # Set environment variables from command line arguments
    os.environ["ENV_CONFIG_PATH"] = args.config
    os.environ["ENV_CREDS_PATH"] = args.creds
    os.environ["ENV_CERT_PATH"] = args.cert
    
    # Set PostgreSQL environment variables if provided
    if args.pg_host:
        os.environ["PG_HOST"] = args.pg_host
    if args.pg_port:
        os.environ["PG_PORT"] = str(args.pg_port)
    if args.pg_user:
        os.environ["PG_USER"] = args.pg_user
    if args.pg_password:
        os.environ["PG_PASSWORD"] = args.pg_password
    if args.pg_db:
        os.environ["PG_DB"] = args.pg_db
    
    # Set vector database environment variables
    os.environ["VECTOR_DB_TYPE"] = args.vector_db
    if args.vector_db == "chroma":
        os.environ["CHROMA_PERSIST_DIR"] = args.chroma_dir
        os.environ["CHROMA_COLLECTION"] = args.chroma_collection
    
    # Log startup configuration
    logger.info(f"Starting server with configuration:")
    logger.info(f"  Host: {args.host}")
    logger.info(f"  Port: {args.port}")
    logger.info(f"  Proxy: {args.proxy_enabled}")
    logger.info(f"  Config file: {args.config}")
    logger.info(f"  Credentials file: {args.creds}")
    logger.info(f"  Certificate file: {args.cert}")
    logger.info(f"  Auto-reload: {args.reload}")
    logger.info(f"  Monitoring interval: {args.monitoring_interval}s")
    logger.info(f"  Vector database: {args.vector_db}")
    
    if args.vector_db == "chroma":
        logger.info(f"  ChromaDB directory: {args.chroma_dir}")
        logger.info(f"  ChromaDB collection: {args.chroma_collection}")
    
    if args.pg_host:
        logger.info(f"  PostgreSQL host: {args.pg_host}")
        logger.info(f"  PostgreSQL port: {args.pg_port}")
        logger.info(f"  PostgreSQL database: {args.pg_db}")
        logger.info(f"  PostgreSQL user: {args.pg_user}")
    
    # Override the default app with command line configured one
    app = create_application(
        proxy_enabled=args.proxy_enabled, 
        monitoring_interval=args.monitoring_interval,
        vector_db_type=args.vector_db,
        chroma_dir=args.chroma_dir,
        chroma_collection=args.chroma_collection
    )
    
    # Run application directly to avoid module import issues with reload
    if args.reload:
        # For reload mode, use string-based import but with proper error handling
        try:
            uvicorn.run(
                "main:app",
                host=args.host,
                port=args.port,
                reload=True
            )
        except ModuleNotFoundError:
            logger.error("Could not run with reload mode - check your PYTHONPATH")
            # Fallback to direct app instance
            uvicorn.run(
                app,
                host=args.host,
                port=args.port
            )
    else:
        # For normal mode, use direct app instance
        uvicorn.run(
            app,
            host=args.host,
            port=args.port
        )
