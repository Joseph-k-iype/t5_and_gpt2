"""
Tagging API - Routes for tagging data elements with business terms.

This module provides API endpoints for matching data elements with appropriate
business terms and validating those matches.
"""

import logging
import uuid
from typing import Dict, Any, List, Optional
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, File, UploadFile, Form, Query
from fastapi.responses import JSONResponse
from langchain_openai import AzureChatOpenAI
from app.core.models import (
    TaggingRequest, 
    TaggingResponse, 
    TaggingResult, 
    TaggingValidationResult,
    EnhancedDataElement
)
from app.core.db_manager import DBManager
from app.core.business_terms import BusinessTermManager
from app.agents.tagging_workflow import DataTaggingWorkflow
from app.config.settings import get_llm
import csv
import io
import os

router = APIRouter(prefix="/api/v1", tags=["tagging"])

# In-memory cache for current jobs for fast access
# The persistent storage is in PostgreSQL
tagging_jobs: Dict[str, Dict[str, Any]] = {}

logger = logging.getLogger(__name__)

def get_workflow() -> DataTaggingWorkflow:
    """
    Get the data tagging workflow.
    
    Returns:
        DataTaggingWorkflow: The tagging workflow
    """
    llm = get_llm()
    return DataTaggingWorkflow(llm)

def get_db():
    """
    Get the database manager.
    
    Returns:
        DBManager: The database manager
    """
    return DBManager()

def get_business_term_manager():
    """
    Get the business term manager.
    
    Returns:
        BusinessTermManager: The business term manager
    """
    return BusinessTermManager()

@router.post("/tag", response_model=TaggingResponse)
async def tag_data_element(
    request: TaggingRequest,
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db)
):
    """
    Tag a data element with appropriate business terms.
    This is an asynchronous operation that will run in the background.
    
    Args:
        request: Tagging request with data element
        background_tasks: FastAPI background tasks
        db: Database manager
        
    Returns:
        TaggingResponse with request ID and status
    """
    # Use the provided ID as the request ID for tracking
    request_id = request.element_id
    if not request_id:
        request_id = str(uuid.uuid4())
        
    logger.info(f"Tagging request received for element: {request_id}")
    
    # Check if this ID is already being processed in memory
    if request_id in tagging_jobs:
        logger.info(f"Tagging job already exists in memory for ID: {request_id}")
        job = tagging_jobs[request_id]
        
        # Return the current result
        return TaggingResponse(
            request_id=request_id,
            element_name=job["tagging_result"]["element_name"],
            matching_terms=job["tagging_result"]["matching_terms"],
            confidence_scores=job["tagging_result"]["confidence_scores"],
            validation_result=job.get("validation_result"),
            modeling_required=job["tagging_result"]["modeling_required"],
            message=job["tagging_result"]["message"]
        )
    
    # Check if job exists in the database
    db_job = db.get_job(request_id)
    if db_job is not None and db_job["job_type"] == "tagging":
        # Job exists in database
        logger.info(f"Found existing tagging job in database: {request_id}")
        
        # Load job data from database to memory for faster access
        job_data = db_job["data"]
        tagging_jobs[request_id] = job_data
        
        return TaggingResponse(
            request_id=request_id,
            element_name=job_data["tagging_result"]["element_name"],
            matching_terms=job_data["tagging_result"]["matching_terms"],
            confidence_scores=job_data["tagging_result"]["confidence_scores"],
            validation_result=job_data.get("validation_result"),
            modeling_required=job_data["tagging_result"]["modeling_required"],
            message=job_data["tagging_result"]["message"]
        )
    
    # Create a new tagging job and run it in the background
    # Initialize tagging result with minimal data
    initial_tagging_result = {
        "element_id": request_id,
        "element_name": request.element_name,
        "element_description": request.element_description,
        "matching_terms": [],
        "confidence_scores": [],
        "modeling_required": False,
        "message": "Tagging job started"
    }
    
    # Initialize job status in memory
    tagging_jobs[request_id] = {
        "tagging_result": initial_tagging_result,
        "validation_result": None
    }
    
    # Store job in database
    db.store_job(
        job_id=request_id,
        job_type="tagging",
        status="pending",
        data=tagging_jobs[request_id]
    )
    
    # Add the tagging task to the background tasks
    background_tasks.add_task(
        run_tagging_job,
        request_id=request_id,
        element_name=request.element_name,
        element_description=request.element_description,
        top_k=request.top_k
    )
    
    # Return the initial response
    return TaggingResponse(
        request_id=request_id,
        element_name=request.element_name,
        matching_terms=[],
        confidence_scores=[],
        modeling_required=False,
        message="Tagging job started"
    )

@router.get("/tag/{request_id}", response_model=TaggingResponse)
async def get_tagging_status(request_id: str, db: DBManager = Depends(get_db)):
    """
    Get the status of a tagging job.
    
    Args:
        request_id: ID of the tagging job
        db: Database manager
        
    Returns:
        TaggingResponse with current status and results if available
    """
    # First check in-memory cache for faster access
    if request_id in tagging_jobs:
        job = tagging_jobs[request_id]
        
        logger.debug(f"Tagging job found in memory: {request_id}")
        
        return TaggingResponse(
            request_id=request_id,
            element_name=job["tagging_result"]["element_name"],
            matching_terms=job["tagging_result"]["matching_terms"],
            confidence_scores=job["tagging_result"]["confidence_scores"],
            validation_result=job.get("validation_result"),
            modeling_required=job["tagging_result"]["modeling_required"],
            message=job["tagging_result"]["message"]
        )
    
    # If not in memory, check the database
    db_job = db.get_job(request_id)
    if db_job is None or db_job["job_type"] != "tagging":
        raise HTTPException(status_code=404, detail=f"Tagging job {request_id} not found")
    
    # Load into memory cache for future requests
    job_data = db_job["data"]
    tagging_jobs[request_id] = job_data
    
    return TaggingResponse(
        request_id=request_id,
        element_name=job_data["tagging_result"]["element_name"],
        matching_terms=job_data["tagging_result"]["matching_terms"],
        confidence_scores=job_data["tagging_result"]["confidence_scores"],
        validation_result=job_data.get("validation_result"),
        modeling_required=job_data["tagging_result"]["modeling_required"],
        message=job_data["tagging_result"]["message"]
    )

@router.post("/tag/enhanced", response_model=TaggingResponse)
async def tag_enhanced_element(
    enhanced_element: EnhancedDataElement,
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db)
):
    """
    Tag an enhanced data element with appropriate business terms.
    
    Args:
        enhanced_element: The enhanced data element to tag
        background_tasks: FastAPI background tasks
        db: Database manager
        
    Returns:
        TaggingResponse with request ID and status
    """
    # Use the element ID as the request ID
    request_id = enhanced_element.id
    logger.info(f"Tagging request received for enhanced element: {request_id}")
    
    # Check if this ID is already being processed in memory
    if request_id in tagging_jobs:
        logger.info(f"Tagging job already exists in memory for ID: {request_id}")
        job = tagging_jobs[request_id]
        
        # Return the current result
        return TaggingResponse(
            request_id=request_id,
            element_name=job["tagging_result"]["element_name"],
            matching_terms=job["tagging_result"]["matching_terms"],
            confidence_scores=job["tagging_result"]["confidence_scores"],
            validation_result=job.get("validation_result"),
            modeling_required=job["tagging_result"]["modeling_required"],
            message=job["tagging_result"]["message"]
        )
    
    # Initialize tagging result with minimal data
    initial_tagging_result = {
        "element_id": request_id,
        "element_name": enhanced_element.enhanced_name,
        "element_description": enhanced_element.enhanced_description,
        "matching_terms": [],
        "confidence_scores": [],
        "modeling_required": False,
        "message": "Tagging job started for enhanced element"
    }
    
    # Initialize job status in memory
    tagging_jobs[request_id] = {
        "tagging_result": initial_tagging_result,
        "validation_result": None
    }
    
    # Store job in database
    db.store_job(
        job_id=request_id,
        job_type="tagging",
        status="pending",
        data=tagging_jobs[request_id]
    )
    
    # Add the tagging task to the background tasks
    background_tasks.add_task(
        run_enhanced_element_tagging_job,
        request_id=request_id,
        enhanced_element=enhanced_element
    )
    
    # Return the initial response
    return TaggingResponse(
        request_id=request_id,
        element_name=enhanced_element.enhanced_name,
        matching_terms=[],
        confidence_scores=[],
        modeling_required=False,
        message="Tagging job started for enhanced element"
    )

@router.post("/terms/upload", response_model=Dict[str, Any])
async def upload_business_terms(
    file: UploadFile = File(...),
    batch_size: int = Form(100)
):
    """
    Upload a CSV file of business terms to be imported.
    
    Args:
        file: The CSV file to upload
        batch_size: Number of terms to process in each batch
        
    Returns:
        Dictionary with import results
    """
    try:
        # Verify file extension
        if not file.filename.endswith('.csv'):
            raise HTTPException(status_code=400, detail="File must be a CSV file")
        
        # Save the file temporarily
        temp_path = f"temp_business_terms_{uuid.uuid4()}.csv"
        try:
            contents = await file.read()
            with open(temp_path, 'wb') as f:
                f.write(contents)
            
            # Import the terms
            business_term_manager = get_business_term_manager()
            terms_added = business_term_manager.import_terms_from_csv(temp_path, batch_size=batch_size)
            
            return {
                "success": True,
                "terms_added": terms_added,
                "message": f"Successfully imported {terms_added} business terms"
            }
        finally:
            # Clean up temp file
            if os.path.exists(temp_path):
                os.remove(temp_path)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error importing business terms: {e}")
        raise HTTPException(status_code=500, detail=f"Error importing business terms: {str(e)}")

@router.get("/terms", response_model=List[Dict[str, Any]])
async def get_business_terms(
    query: str = Query(None),
    limit: int = Query(20, ge=1, le=100),
    btm: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Get business terms, optionally filtered by a search query.
    
    Args:
        query: Optional search query
        limit: Maximum number of terms to return
        btm: Business term manager
        
    Returns:
        List of business terms
    """
    try:
        if query:
            # Search for terms matching the query
            terms = btm.search_terms(query, limit=limit)
        else:
            # Get all terms (limited)
            terms = btm.get_all_terms()[:limit]
        
        # Convert to dictionaries
        return [term.dict() for term in terms]
    except Exception as e:
        logger.error(f"Error retrieving business terms: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving business terms: {str(e)}")

@router.get("/terms/{term_id}", response_model=Dict[str, Any])
async def get_business_term(
    term_id: str,
    btm: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Get a specific business term by ID.
    
    Args:
        term_id: ID of the term to retrieve
        btm: Business term manager
        
    Returns:
        Business term details
    """
    try:
        term = btm.get_term_by_id(term_id)
        if not term:
            raise HTTPException(status_code=404, detail=f"Business term {term_id} not found")
        
        return term.dict()
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving business term: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving business term: {str(e)}")

@router.delete("/terms/{term_id}", response_model=Dict[str, Any])
async def delete_business_term(
    term_id: str,
    btm: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Delete a business term.
    
    Args:
        term_id: ID of the term to delete
        btm: Business term manager
        
    Returns:
        Dictionary with deletion result
    """
    try:
        if not btm.get_term_by_id(term_id):
            raise HTTPException(status_code=404, detail=f"Business term {term_id} not found")
        
        success = btm.delete_term(term_id)
        if not success:
            raise HTTPException(status_code=500, detail=f"Failed to delete business term {term_id}")
        
        return {
            "success": True,
            "message": f"Business term {term_id} deleted successfully"
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting business term: {e}")
        raise HTTPException(status_code=500, detail=f"Error deleting business term: {str(e)}")

async def run_tagging_job(request_id: str, element_name: str, element_description: str, top_k: int = 3):
    """
    Run the tagging job in the background.
    
    Args:
        request_id: ID of the tagging job
        element_name: Name of the element to tag
        element_description: Description of the element to tag
        top_k: Number of top matching terms to return
    """
    logger.info(f"Starting tagging job for {request_id}")
    workflow = get_workflow()
    db = get_db()
    
    try:
        # Run the workflow
        result = await workflow.run(
            element_id=request_id,
            element_name=element_name,
            element_description=element_description
        )
        
        # Update job status in memory
        tagging_jobs[request_id]["tagging_result"] = {
            "element_id": result.element_id,
            "element_name": result.element_name,
            "element_description": result.element_description,
            "matching_terms": result.matching_terms,
            "confidence_scores": result.confidence_scores,
            "modeling_required": result.modeling_required,
            "message": result.message
        }
        
        # Update database with result
        db.store_job(
            job_id=request_id,
            job_type="tagging",
            status="completed",
            data=tagging_jobs[request_id]
        )
        
        logger.info(f"Tagging job completed for {request_id}")
        
    except Exception as e:
        # Update job status to failed in memory
        logger.error(f"Tagging job failed for {request_id}: {str(e)}")
        
        if request_id in tagging_jobs:
            tagging_jobs[request_id]["tagging_result"]["message"] = f"Error during tagging: {str(e)}"
            tagging_jobs[request_id]["tagging_result"]["modeling_required"] = True
        
            # Update database with error
            db.store_job(
                job_id=request_id,
                job_type="tagging",
                status="failed",
                data=tagging_jobs[request_id]
            )
        else:
            logger.error(f"Job {request_id} not found in memory after failure")

async def run_enhanced_element_tagging_job(request_id: str, enhanced_element: EnhancedDataElement):
    """
    Run the tagging job for an enhanced element in the background.
    
    Args:
        request_id: ID of the tagging job
        enhanced_element: The enhanced data element to tag
    """
    logger.info(f"Starting enhanced element tagging job for {request_id}")
    workflow = get_workflow()
    db = get_db()
    
    try:
        # Run the workflow for the enhanced element
        result = await workflow.tag_enhanced_element(enhanced_element)
        
        # Update job status in memory
        tagging_jobs[request_id]["tagging_result"] = {
            "element_id": result.element_id,
            "element_name": result.element_name,
            "element_description": result.element_description,
            "matching_terms": result.matching_terms,
            "confidence_scores": result.confidence_scores,
            "modeling_required": result.modeling_required,
            "message": result.message
        }
        
        # Update database with result
        db.store_job(
            job_id=request_id,
            job_type="tagging",
            status="completed",
            data=tagging_jobs[request_id]
        )
        
        logger.info(f"Enhanced element tagging job completed for {request_id}")
        
    except Exception as e:
        # Update job status to failed in memory
        logger.error(f"Enhanced element tagging job failed for {request_id}: {str(e)}")
        
        if request_id in tagging_jobs:
            tagging_jobs[request_id]["tagging_result"]["message"] = f"Error during tagging: {str(e)}"
            tagging_jobs[request_id]["tagging_result"]["modeling_required"] = True
        
            # Update database with error
            db.store_job(
                job_id=request_id,
                job_type="tagging",
                status="failed",
                data=tagging_jobs[request_id]
            )
        else:
            logger.error(f"Job {request_id} not found in memory after failure")
