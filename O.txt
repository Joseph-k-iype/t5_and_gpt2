"""
ChromaDB Vector Store - Implementation of vector storage using ChromaDB.

This module provides a ChromaDB-based implementation of the VectorStore interface,
utilizing the ChromaDB library for efficient vector similarity search with local persistence.
"""

import logging
import os
from typing import List, Dict, Any, Optional, Tuple, Union
import numpy as np
import chromadb
from chromadb.config import Settings
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

from app.core.vector_store import VectorStore

logger = logging.getLogger(__name__)

class ChromaDBVectorStore(VectorStore):
    """
    Vector store implementation using ChromaDB.
    
    This class provides vector storage and similarity search using ChromaDB,
    a lightweight vector database designed for embeddings and semantic search.
    """
    
    def __init__(self, collection_name: str = "business_terms", persist_dir: str = "./data/chroma_db"):
        """
        Initialize the ChromaDB vector store.
        
        Args:
            collection_name: Name of the ChromaDB collection
            persist_dir: Directory for persistent storage
        """
        self.persist_dir = persist_dir
        self.collection_name = collection_name
        
        # Ensure the persist directory exists
        os.makedirs(self.persist_dir, exist_ok=True)
        
        # Create ChromaDB client with telemetry disabled
        self.client = self._create_client()
        
        # Get or create collection
        self.collection = self._get_or_create_collection()
    
    def _create_client(self):
        """
        Create a ChromaDB client with appropriate settings.
        
        Returns:
            ChromaDB client instance
        """
        try:
            return chromadb.PersistentClient(
                path=self.persist_dir,
                settings=Settings(
                    anonymized_telemetry=False,  # Disable telemetry for privacy
                    allow_reset=False,  # Safety measure for production
                )
            )
        except Exception as e:
            logger.error(f"Error creating ChromaDB client: {e}")
            raise
    
    def _get_or_create_collection(self):
        """
        Get or create the ChromaDB collection.
        
        Returns:
            ChromaDB collection
        """
        try:
            # Try to get existing collection
            try:
                collection = self.client.get_collection(name=self.collection_name)
                logger.info(f"Using existing ChromaDB collection: {self.collection_name}")
                return collection
            except ValueError:
                # Collection doesn't exist, create it
                collection = self.client.create_collection(
                    name=self.collection_name,
                    metadata={"description": "Business terms collection"}
                )
                logger.info(f"Created new ChromaDB collection: {self.collection_name}")
                return collection
        except Exception as e:
            logger.error(f"Error initializing ChromaDB collection: {e}")
            raise
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        retry=retry_if_exception_type((Exception,)),
        reraise=True
    )
    def store_vector(self, id: str, name: str, description: str, embedding: List[float], metadata: Optional[Dict[str, Any]] = None) -> bool:
        """
        Store a vector in the ChromaDB collection.
        
        Args:
            id: Unique identifier for the term
            name: Name of the term
            description: Description of the term
            embedding: Vector embedding as a list of floats
            metadata: Additional metadata as a dictionary
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if metadata is None:
                metadata = {}
            
            # Prepare metadata with name and description
            full_metadata = {
                "name": name,
                "description": description,
                **metadata
            }
            
            # Check if the term already exists
            try:
                existing = self.collection.get(ids=[id], include=["metadatas"])
                if existing["ids"]:
                    # Update the existing term
                    self.collection.update(
                        ids=[id],
                        embeddings=[embedding],
                        metadatas=[full_metadata]
                    )
                    return True
            except Exception as e:
                logger.debug(f"Term not found for update: {e}")
            
            # Add the new term
            self.collection.add(
                ids=[id],
                embeddings=[embedding],
                metadatas=[full_metadata]
            )
            return True
        except Exception as e:
            logger.error(f"Error storing vector: {e}")
            return False
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10),
        retry=retry_if_exception_type((Exception,)),
        reraise=True
    )
    def batch_store_vectors(self, items: List[Dict[str, Any]]) -> int:
        """
        Store multiple vectors in the ChromaDB collection.
        
        Args:
            items: List of dictionaries with id, name, description, embedding, and optional metadata
            
        Returns:
            int: Number of items successfully stored
        """
        try:
            # Prepare batch data
            ids = []
            embeddings = []
            metadatas = []
            
            for item in items:
                ids.append(item['id'])
                embeddings.append(item['embedding'])
                
                # Combine name, description with metadata
                metadata = {
                    "name": item['name'],
                    "description": item['description'],
                    **(item.get('metadata', {}))
                }
                metadatas.append(metadata)
            
            # Use upsert method to add/update
            self.collection.upsert(
                ids=ids,
                embeddings=embeddings,
                metadatas=metadatas
            )
            
            return len(items)
        except Exception as e:
            logger.error(f"Error batch storing vectors: {e}")
            return 0
    
    def find_similar_vectors(self, query_vector: List[float], top_k: int = 5, threshold: float = 0.5) -> List[Dict[str, Any]]:
        """
        Find similar vectors in the ChromaDB collection.
        
        Args:
            query_vector: Vector to compare against
            top_k: Number of results to return
            threshold: Minimum similarity threshold (0-1)
            
        Returns:
            List of dictionaries with id, name, description, similarity, and metadata
        """
        try:
            result = self.collection.query(
                query_embeddings=[query_vector],
                n_results=top_k*2,  # Get more results to filter by threshold
                include=["metadatas", "distances"]
            )
            
            # Process results
            similar_items = []
            if not result or not result["ids"] or not result["ids"][0]:
                return []
                
            for i, id_val in enumerate(result["ids"][0]):
                # ChromaDB returns distance, not similarity
                # Convert to similarity score (1 - distance)
                distance = result["distances"][0][i]
                similarity = 1.0 - distance
                
                # Filter by threshold
                if similarity >= threshold:
                    metadata = result["metadatas"][0][i]
                    
                    # Extract name and description from metadata
                    name = metadata.get("name", "")
                    description = metadata.get("description", "")
                    
                    # Remove name and description from metadata
                    clean_metadata = {k: v for k, v in metadata.items() 
                                    if k not in ["name", "description"]}
                    
                    similar_items.append({
                        "id": id_val,
                        "name": name,
                        "description": description,
                        "similarity": similarity,
                        "metadata": clean_metadata
                    })
            
            # Sort by similarity (highest first)
            similar_items.sort(key=lambda x: x["similarity"], reverse=True)
            
            # Return only up to top_k items
            return similar_items[:top_k]
        except Exception as e:
            logger.error(f"Error finding similar vectors: {e}")
            return []
    
    def get_all_terms(self) -> List[Dict[str, Any]]:
        """
        Get all business terms from the ChromaDB collection.
        
        Returns:
            List of dictionaries with id, name, description, and metadata
        """
        try:
            # Get all items from the collection
            result = self.collection.get(include=["metadatas"])
            
            terms = []
            for i, id_val in enumerate(result["ids"]):
                metadata = result["metadatas"][i]
                
                # Extract name and description from metadata
                name = metadata.get("name", "")
                description = metadata.get("description", "")
                
                # Remove name and description from metadata
                clean_metadata = {k: v for k, v in metadata.items() 
                                if k not in ["name", "description"]}
                
                terms.append({
                    "id": id_val,
                    "name": name,
                    "description": description,
                    "metadata": clean_metadata
                })
            
            return terms
        except Exception as e:
            logger.error(f"Error getting all terms: {e}")
            return []
    
    def get_term_by_id(self, term_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a specific business term by ID from ChromaDB.
        
        Args:
            term_id: ID of the term to retrieve
            
        Returns:
            Dictionary with term details or None if not found
        """
        try:
            result = self.collection.get(ids=[term_id], include=["metadatas"])
            
            if not result["ids"]:
                return None
                
            metadata = result["metadatas"][0]
            
            # Extract name and description from metadata
            name = metadata.get("name", "")
            description = metadata.get("description", "")
            
            # Remove name and description from metadata
            clean_metadata = {k: v for k, v in metadata.items() 
                            if k not in ["name", "description"]}
            
            return {
                "id": term_id,
                "name": name,
                "description": description,
                "metadata": clean_metadata
            }
        except Exception as e:
            logger.error(f"Error getting term by ID: {e}")
            return None
    
    def delete_term(self, term_id: str) -> bool:
        """
        Delete a business term from the ChromaDB collection.
        
        Args:
            term_id: ID of the term to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self.collection.delete(ids=[term_id])
            return True
        except Exception as e:
            logger.error(f"Error deleting term: {e}")
            return False
    
    def compute_cosine_similarity(self, vector1: List[float], vector2: List[float]) -> float:
        """
        Compute cosine similarity between two vectors.
        
        Args:
            vector1: First vector
            vector2: Second vector
            
        Returns:
            float: Cosine similarity between 0 and 1
        """
        try:
            # Convert to numpy arrays
            a = np.array(vector1)
            b = np.array(vector2)
            
            # Compute cosine similarity
            dot_product = np.dot(a, b)
            norm_a = np.linalg.norm(a)
            norm_b = np.linalg.norm(b)
            
            if norm_a == 0 or norm_b == 0:
                return 0.0
            
            similarity = dot_product / (norm_a * norm_b)
            return max(0.0, min(similarity, 1.0))  # Ensure in range [0, 1]
        except Exception as e:
            logger.error(f"Error computing similarity: {e}")
            return 0.0
    
    def search_terms(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Search for terms by text query in ChromaDB collection.
        
        Args:
            query: Search query
            limit: Maximum number of results
            
        Returns:
            List of matching terms
        """
        try:
            # Get all terms first (ChromaDB doesn't have a direct text search)
            all_terms = self.get_all_terms()
            
            # Filter by query
            matching_terms = []
            for term in all_terms:
                name = term.get("name", "").lower()
                description = term.get("description", "").lower()
                query_lower = query.lower()
                
                if query_lower in name or query_lower in description:
                    matching_terms.append(term)
            
            # Sort by relevance (exact matches first)
            matching_terms.sort(key=lambda x: (
                0 if x.get("name", "").lower().startswith(query.lower()) else 1,
                0 if query.lower() in x.get("name", "").lower() else 1,
                x.get("name", "").lower()
            ))
            
            # Limit results
            return matching_terms[:limit]
        except Exception as e:
            logger.error(f"Error searching terms: {e}")
            return []
    
    def delete_all_terms(self) -> int:
        """
        Delete all terms in the ChromaDB collection.
        
        Returns:
            int: Number of terms deleted
        """
        try:
            # Get current count
            all_terms = self.get_all_terms()
            count = len(all_terms)
            
            # Delete all
            self.collection.delete(where={})
            return count
        except Exception as e:
            logger.error(f"Error deleting all terms: {e}")
            return 0
            
    def health_check(self) -> Dict[str, Any]:
        """
        Perform a health check of the ChromaDB vector store.
        
        Returns:
            Dict with health status and details
        """
        try:
            # Try to get collection info and count
            collection_info = {
                "name": self.collection_name,
                "persist_dir": self.persist_dir,
            }
            
            # Get term count
            terms = self.get_all_terms()
            
            return {
                "status": "healthy",
                "type": "chroma",
                "details": {
                    **collection_info,
                    "term_count": len(terms)
                }
            }
        except Exception as e:
            return {
                "status": "unhealthy",
                "type": "chroma",
                "error": str(e)
            }
