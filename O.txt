from typing import Dict, Any, List
import re
import logging
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_openai import AzureChatOpenAI
from app.core.models import DataElement, ValidationResult, DataQualityStatus
from app.utils.iso_standards import ISO11179Validator

logger = logging.getLogger(__name__)

class ValidatorAgent:
    
    def __init__(self, llm: AzureChatOpenAI):
        self.llm = llm
        self.iso_validator = ISO11179Validator()
        self._setup_validation_chain()
    
    def _setup_validation_chain(self):
        template = """
        You are an expert in data governance and ISO/IEC 11179 metadata standards. Your task is to evaluate the 
        given data element name and description against these standards to determine the quality of the metadata.
        
        ISO/IEC 11179 standards for data element names (adapted for business-friendly format):
        - Names MUST be in lowercase with spaces between words.
        - Names MUST NOT use technical formatting like camelCase, snake_case or PascalCase
        - Names MUST NOT contain underscores, hyphens, or special characters
        - Names should be clear, unambiguous and self-describing
        - Names should not use acronyms or abbreviations unless they are universally understood
        - Names should be concise yet descriptive
        - Names should use standard terminology in the domain
        - Names should use business language that non-technical users can understand
        
        ISO/IEC 11179 standards for data element descriptions:
        - Descriptions should clearly define what the data element represents
        - Descriptions should be complete, covering the concept fully
        - Descriptions should be precise, specific enough to distinguish from other concepts
        - Descriptions should be objective and factual, not opinion-based
        - Descriptions should use complete sentences with proper grammar and punctuation
        - Descriptions should be written in business language, not technical jargon
        
        Data Element to Evaluate:
        - ID: {id}
        - Current Name: {name}
        - Current Description: {description}
        - Example (if provided): {example}
        - Related Process Name (if provided): {process_name}
        - Related Process Description (if provided): {process_description}
        
        Based on the ISO/IEC 11179 standards, evaluate the quality of this data element.
        
        Provide your evaluation as follows:
        1. Is the name valid according to ISO/IEC 11179 standards? [yes/no]
        2. Detailed feedback on the name
        3. Is the description valid according to the standards? [yes/no]
        4. Detailed feedback on the description
        5. Overall quality status: "GOOD", "NEEDS_IMPROVEMENT" or "POOR"
        6. List of specific improvements that could be made
        
        Important: Do not use any special formatting characters like asterisks (**) in your response.
        Please be thorough and specific in your feedback, as it will be used to improve the data element.
        """
        
        self.validation_prompt = PromptTemplate(
            input_variables=["id", "name", "description", "example", "process_name", "process_description"],
            template=template)
        self.validation_chain = self.validation_prompt | self.llm | StrOutputParser()
        
    def _parse_validation_result(self, result: str) -> ValidationResult:
        lines = result.strip().split("\n")
        is_name_valid = False
        is_desc_valid = False
        
        # Check for name validity - more robustly
        for line in lines:
            if line.startswith("1.") and "yes" in line.lower():
                is_name_valid = True
                break
        
        # Check for description validity - more robustly
        for line in lines:
            if line.startswith("3.") and "yes" in line.lower():
                is_desc_valid = True
                break
        
        # Determine quality status more robustly
        quality_status = DataQualityStatus.POOR  # Default
        for line in lines:
            if "Overall quality status:" in line or "5." in line:
                if "GOOD" in line:
                    quality_status = DataQualityStatus.GOOD
                elif "NEEDS_IMPROVEMENT" in line or "NEEDS IMPROVEMENT" in line:
                    quality_status = DataQualityStatus.NEEDS_IMPROVEMENT
                break
                
        # If both name and description are valid but status wasn't explicitly stated as GOOD,
        # default to NEEDS_IMPROVEMENT rather than POOR
        if is_name_valid and is_desc_valid and quality_status == DataQualityStatus.POOR:
            quality_status = DataQualityStatus.NEEDS_IMPROVEMENT
        
        # Extract improvement suggestions more robustly
        improvements = []
        improvements_section = False
        for line in lines:
            if "6. List of specific improvements" in line or line.startswith("6."):
                improvements_section = True
                continue
            if improvements_section and line.strip() and (line.strip().startswith("- ") or 
                                                        (line[0].isdigit() and ". " in line) or 
                                                        line.startswith("* ")):
                # Clean any ** characters that might appear
                clean_line = line.replace("**", "").strip()
                improvements.append(clean_line)
        
        # Extract feedback more comprehensively
        feedback_lines = []
        for i, line in enumerate(lines):
            if i > 0 and ("Detailed feedback on the name" in line or 
                          "Detailed feedback on the description" in line or
                          line.startswith("2.") or line.startswith("4.")):
                # Clean any ** characters that might appear
                clean_line = line.replace("**", "").strip()
                feedback_lines.append(clean_line)
            elif i > 0 and line.strip() and not line.startswith("1.") and not line.startswith("3.") and not line.startswith("5.") and not line.startswith("6."):
                # Only add non-empty, non-header lines
                if improvements_section and (line.strip().startswith("- ") or 
                                           (line[0].isdigit() and ". " in line) or
                                           line.startswith("* ")):
                    # Skip lines that are already in improvements
                    continue
                # Clean any ** characters that might appear
                clean_line = line.replace("**", "").strip()
                if clean_line:
                    feedback_lines.append(clean_line)
        
        feedback = "\n".join(feedback_lines)
        
        return ValidationResult(
            is_valid=is_name_valid and is_desc_valid,
            quality_status=quality_status, 
            feedback=feedback,
            suggested_improvements=improvements
        )
    
    async def validate(self, data_element: DataElement) -> ValidationResult:
        """Validate a data element against ISO/IEC 11179 standards."""
        try:
            # First, perform basic validation
            name_valid, name_feedback = self.iso_validator.validate_name(data_element.existing_name)
            desc_valid, desc_feedback = self.iso_validator.validate_description(data_element.existing_description)
            
            if not name_valid or not desc_valid:
                feedback = ""
                if not name_valid:
                    feedback += f"Name validation failed: {name_feedback}\n"
                if not desc_valid:
                    feedback += f"Description validation failed: {desc_feedback}"
                
                return ValidationResult(
                    is_valid = False,
                    quality_status = DataQualityStatus.POOR,
                    feedback = feedback.strip(),
                    suggested_improvements = ["Fix basic validation issues before proceeding with deeper analysis"]
                )
            
            # If basic validation passes, perform more detailed evaluation
            result = await self.validation_chain.ainvoke({
                "id": data_element.id,
                "name": data_element.existing_name,
                "description": data_element.existing_description,
                "example": data_element.example or "Not provided",
                "process_name": data_element.process_name or "Not provided",
                "process_description": data_element.process_description or "Not provided"
            })
            
            return self._parse_validation_result(result)
        except Exception as e:
            logger.error(f"Error validating data element: {e}")
            # Return a minimal validation result in case of error
            return ValidationResult(
                is_valid = False,
                quality_status = DataQualityStatus.POOR,
                feedback = f"Error during validation: {str(e)}",
                suggested_improvements = ["Retry validation after resolving the error"]
            )
