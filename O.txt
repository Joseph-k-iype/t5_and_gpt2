"""
Tagging API - Routes for matching data elements with business terms.

This module provides API endpoints for matching data elements with appropriate business
terms, including both LLM-based semantic matching and vector similarity search.
"""

import logging
import uuid
from typing import Dict, Any, List, Optional
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, Query
from pydantic import BaseModel, Field
from langchain_openai import AzureChatOpenAI
from app.core.models import (
    TaggingRequest, 
    TaggingResponse, 
    TaggingResult,
    TaggingValidationResult
)
from app.core.db_manager import DBManager
from app.core.business_terms import BusinessTermManager
from app.agents.tagging_workflow import DataTaggingWorkflow
from app.config.settings import get_llm

router = APIRouter(prefix="/api/v1", tags=["tagging"])

# In-memory cache for current jobs
tagging_jobs: Dict[str, Dict[str, Any]] = {}

logger = logging.getLogger(__name__)

# Extended tagging request model with optional fields
class EnhancedTaggingRequest(BaseModel):
    """Extended tagging request model with optional context fields."""
    element_id: str
    element_name: str
    element_description: str
    top_k: int = 3
    cdm: Optional[str] = Field(None, description="Optional CDM to prioritize")
    example: Optional[str] = Field(None, description="Optional example for context")
    process_name: Optional[str] = Field(None, description="Optional process name for context")
    process_description: Optional[str] = Field(None, description="Optional process description for context")

def get_workflow() -> DataTaggingWorkflow:
    """
    Get the tagging workflow.
    
    Returns:
        DataTaggingWorkflow: The tagging workflow
    """
    llm = get_llm()
    return DataTaggingWorkflow(llm)

def get_db():
    """
    Get database manager.
    
    Returns:
        DBManager: The database manager
    """
    return DBManager()

def get_business_term_manager():
    """
    Get business term manager.
    
    Returns:
        BusinessTermManager: The business term manager
    """
    return BusinessTermManager()

@router.post("/tag", response_model=TaggingResponse)
async def tag_data_element(
    request: EnhancedTaggingRequest,
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db),
    llm_first: bool = Query(True, description="Whether to use LLM matching first before vector similarity")
):
    """
    Match a data element with appropriate business terms.
    This is an asynchronous operation that will run in the background.
    
    Args:
        request: Enhanced tagging request with data element information and optional context
        background_tasks: FastAPI background tasks
        db: Database manager
        llm_first: Whether to use LLM matching first before vector similarity
        
    Returns:
        TaggingResponse with request ID and results
    """
    # Generate a request ID if not provided
    request_id = request.element_id or str(uuid.uuid4())
    logger.info(f"Tagging request received for element ID: {request_id}")
    
    # Check if this ID is already being processed
    if request_id in tagging_jobs:
        logger.info(f"Tagging job already exists for ID: {request_id}")
        
        # Return the existing results
        job = tagging_jobs[request_id]
        tagging_result = job.get("tagging_result")
        
        if tagging_result:
            return TaggingResponse(
                request_id=request_id,
                element_name=tagging_result.element_name,
                matching_terms=tagging_result.matching_terms,
                confidence_scores=tagging_result.confidence_scores,
                validation_result=job.get("validation_result"),
                modeling_required=tagging_result.modeling_required,
                message=tagging_result.message
            )
    
    # Check if job exists in the database
    db_job = db.get_job(request_id)
    if db_job is not None and db_job.get("job_type") == "tagging":
        logger.info(f"Tagging job found in database for ID: {request_id}")
        
        # Load job data to memory for faster access
        job_data = db_job.get("data", {})
        tagging_result = job_data.get("tagging_result")
        
        if tagging_result:
            # Convert dict back to TaggingResult for easier handling
            result_obj = TaggingResult(**tagging_result)
            
            # Store in memory cache
            tagging_jobs[request_id] = {
                "tagging_result": result_obj,
                "validation_result": job_data.get("validation_result")
            }
            
            return TaggingResponse(
                request_id=request_id,
                element_name=result_obj.element_name,
                matching_terms=result_obj.matching_terms,
                confidence_scores=result_obj.confidence_scores,
                validation_result=job_data.get("validation_result"),
                modeling_required=result_obj.modeling_required,
                message=result_obj.message
            )
    
    # Initialize job in memory
    tagging_jobs[request_id] = {
        "tagging_result": None,
        "validation_result": None
    }
    
    # Store initial job in database
    db.store_job(
        job_id=request_id,
        job_type="tagging",
        status="pending",
        data={
            "request": request.dict(),
            "tagging_result": None,
            "validation_result": None
        }
    )
    
    # Add tagging task to background tasks
    background_tasks.add_task(
        run_tagging_job,
        request_id=request_id,
        element_id=request_id,
        element_name=request.element_name,
        element_description=request.element_description,
        top_k=request.top_k,
        llm_first=llm_first,
        cdm=request.cdm,
        example=request.example,
        process_name=request.process_name,
        process_description=request.process_description
    )
    
    # Return initial response
    return TaggingResponse(
        request_id=request_id,
        element_name=request.element_name,
        matching_terms=[],
        confidence_scores=[],
        validation_result=None,
        modeling_required=False,
        message="Tagging job started"
    )

@router.post("/tag-llm", response_model=TaggingResponse)
async def tag_data_element_with_llm(
    request: EnhancedTaggingRequest,
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db)
):
    """
    Match a data element with appropriate business terms using the LLM-first approach.
    
    Args:
        request: Enhanced tagging request with data element information and optional context
        background_tasks: FastAPI background tasks
        db: Database manager
        
    Returns:
        TaggingResponse with request ID and results
    """
    return await tag_data_element(request, background_tasks, db, llm_first=True)

@router.post("/tag-vector", response_model=TaggingResponse)
async def tag_data_element_with_vector(
    request: EnhancedTaggingRequest,
    background_tasks: BackgroundTasks,
    db: DBManager = Depends(get_db)
):
    """
    Match a data element with appropriate business terms using vector similarity.
    
    Args:
        request: Enhanced tagging request with data element information and optional context
        background_tasks: FastAPI background tasks
        db: Database manager
        
    Returns:
        TaggingResponse with request ID and results
    """
    return await tag_data_element(request, background_tasks, db, llm_first=False)

@router.get("/tag/{request_id}", response_model=TaggingResponse)
async def get_tagging_status(
    request_id: str,
    db: DBManager = Depends(get_db)
):
    """
    Get the status and results of a tagging job.
    
    Args:
        request_id: ID of the tagging job
        db: Database manager
        
    Returns:
        TaggingResponse with current results
    """
    # First check in-memory cache
    if request_id in tagging_jobs:
        job = tagging_jobs[request_id]
        tagging_result = job.get("tagging_result")
        
        if tagging_result:
            return TaggingResponse(
                request_id=request_id,
                element_name=tagging_result.element_name,
                matching_terms=tagging_result.matching_terms,
                confidence_scores=tagging_result.confidence_scores,
                validation_result=job.get("validation_result"),
                modeling_required=tagging_result.modeling_required,
                message=tagging_result.message
            )
    
    # Check database if not in memory
    db_job = db.get_job(request_id)
    if db_job is None or db_job.get("job_type") != "tagging":
        raise HTTPException(status_code=404, detail=f"Tagging job {request_id} not found")
    
    # Load job data
    job_data = db_job.get("data", {})
    tagging_result = job_data.get("tagging_result")
    
    if not tagging_result:
        return TaggingResponse(
            request_id=request_id,
            element_name=job_data.get("request", {}).get("element_name", ""),
            matching_terms=[],
            confidence_scores=[],
            validation_result=None,
            modeling_required=False,
            message="Tagging in progress"
        )
    
    # Convert dict to TaggingResult
    result_obj = TaggingResult(**tagging_result)
    
    # Store in memory for future requests
    tagging_jobs[request_id] = {
        "tagging_result": result_obj,
        "validation_result": job_data.get("validation_result")
    }
    
    return TaggingResponse(
        request_id=request_id,
        element_name=result_obj.element_name,
        matching_terms=result_obj.matching_terms,
        confidence_scores=result_obj.confidence_scores,
        validation_result=job_data.get("validation_result"),
        modeling_required=result_obj.modeling_required,
        message=result_obj.message
    )

@router.post("/validate", response_model=TaggingValidationResult)
async def validate_tagging(
    tagging_result: TaggingResult,
    business_term_manager: BusinessTermManager = Depends(get_business_term_manager)
):
    """
    Validate a tagging result.
    
    Args:
        tagging_result: The tagging result to validate
        business_term_manager: The business term manager
        
    Returns:
        TaggingValidationResult with validation status and suggestions
    """
    try:
        confidence, reasoning = await business_term_manager.evaluate_tagging_with_reasoning(tagging_result)
        
        is_valid = confidence >= 0.5
        
        return TaggingValidationResult(
            is_valid=is_valid,
            feedback=reasoning,
            suggested_alternatives=[]
        )
    except Exception as e:
        logger.error(f"Error validating tagging: {e}")
        return TaggingValidationResult(
            is_valid=False,
            feedback=f"Error validating tagging: {str(e)}",
            suggested_alternatives=[]
        )

async def run_tagging_job(
    request_id: str,
    element_id: str,
    element_name: str,
    element_description: str,
    top_k: int = 3,
    llm_first: bool = True,
    cdm: Optional[str] = None,
    example: Optional[str] = None,
    process_name: Optional[str] = None,
    process_description: Optional[str] = None
):
    """
    Run the tagging job in the background.
    
    Args:
        request_id: ID of the tagging job
        element_id: ID of the data element
        element_name: Name of the data element
        element_description: Description of the data element
        top_k: Number of top matching terms to return
        llm_first: Whether to use LLM matching first
        cdm: Optional CDM to prioritize
        example: Optional example for context
        process_name: Optional process name for context
        process_description: Optional process description for context
    """
    logger.info(f"Starting tagging job for {request_id}")
    
    try:
        # Get business term manager directly for more control
        business_term_manager = BusinessTermManager()
        db = DBManager()
        
        # Run the direct tagging with all context
        # IMPORTANT: Added await here to properly handle the async method
        tagging_result = await business_term_manager.tag_element(
            element_id=element_id,
            name=element_name,
            description=element_description,
            top_k=top_k,
            threshold=0.3,  # Lower threshold to get more potential matches
            cdm=cdm,
            example=example,
            process_name=process_name,
            process_description=process_description
        )
        
        logger.info(f"Tagging completed for {request_id}, found {len(tagging_result.matching_terms)} matches")
        
        # Get validation result (if matches were found)
        validation_result = None
        if tagging_result.matching_terms and not tagging_result.modeling_required:
            try:
                confidence, reasoning = await business_term_manager.evaluate_tagging_with_reasoning(tagging_result)
                
                validation_result = {
                    "is_valid": confidence >= 0.5,
                    "feedback": reasoning,
                    "suggested_alternatives": []
                }
                
                logger.info(f"Validation completed for {request_id}, valid: {validation_result['is_valid']}")
                
            except Exception as validation_error:
                logger.error(f"Error validating tagging for {request_id}: {validation_error}")
        
        # Store in memory cache
        tagging_jobs[request_id] = {
            "tagging_result": tagging_result,
            "validation_result": validation_result
        }
        
        # Store in database
        db.store_job(
            job_id=request_id,
            job_type="tagging",
            status="completed",
            data={
                "request": {
                    "element_id": element_id,
                    "element_name": element_name,
                    "element_description": element_description,
                    "top_k": top_k,
                    "cdm": cdm,
                    "example": example,
                    "process_name": process_name,
                    "process_description": process_description
                },
                "tagging_result": tagging_result.dict(),
                "validation_result": validation_result
            }
        )
        
    except Exception as e:
        logger.error(f"Error in tagging job for {request_id}: {e}")
        
        # Store error in database
        db = DBManager()
        db.store_job(
            job_id=request_id,
            job_type="tagging",
            status="failed",
            data={
                "request": {
                    "element_id": element_id,
                    "element_name": element_name,
                    "element_description": element_description,
                    "top_k": top_k,
                    "cdm": cdm,
                    "example": example,
                    "process_name": process_name,
                    "process_description": process_description
                },
                "error": str(e)
            }
        )
