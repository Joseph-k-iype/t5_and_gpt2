import os
import csv
import logging
import uuid
from typing import Dict, List, Any, Optional, Tuple
from pydantic import BaseModel, Field
import chromadb
from chromadb.config import Settings
from app.core.embedding import EmbeddingClient, MyDocument
from app.config.environment import get_os_env

logger = logging.getLogger(__name__)

class BusinessTerm(BaseModel):
    """Model representing a preferred business term."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: str
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
class TaggingResult(BaseModel):
    """Model representing the result of tagging an element with business terms."""
    element_name: str
    element_description: str
    matching_terms: List[Dict[str, Any]]
    confidence_scores: List[float]
    
class TaggingValidationResult(BaseModel):
    """Model representing the validation result of tagging."""
    is_valid: bool
    feedback: str
    suggested_alternatives: List[Dict[str, Any]] = Field(default_factory=list)
    
class BusinessTermManager:
    """Manager for business terms and tagging operations."""
    
    def __init__(self, persistent_dir: str = "./chroma_db"):
        """Initialize the business term manager."""
        self.env = get_os_env()
        self.embedding_client = EmbeddingClient()
        self.persistent_dir = persistent_dir
        self.chroma_client = self._setup_chroma_db()
        self.collection = self.chroma_client.get_or_create_collection("business_terms")
        
    def _setup_chroma_db(self):
        """Set up the ChromaDB client with persistent storage."""
        try:
            # Create directory if it doesn't exist
            os.makedirs(self.persistent_dir, exist_ok=True)
            
            # Initialize ChromaDB client with persistent storage using current API
            client = chromadb.PersistentClient(
                path=self.persistent_dir,
                settings=chromadb.Settings(
                    anonymized_telemetry=False
                )
            )
            
            logger.info(f"ChromaDB initialized with persistent storage at {self.persistent_dir}")
            return client
        except Exception as e:
            logger.error(f"Error setting up ChromaDB: {e}")
            raise
            
    def import_terms_from_csv(self, csv_path: str) -> int:
        """
        Import business terms from a CSV file.
        
        Args:
            csv_path: Path to the CSV file
            
        Returns:
            Number of terms imported
        """
        try:
            terms = []
            ids = []
            embeddings = []
            metadatas = []
            
            with open(csv_path, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                
                for row in reader:
                    if 'name' not in row or 'description' not in row:
                        logger.warning(f"Skipping row missing required fields: {row}")
                        continue
                    
                    # Create business term
                    term_id = str(uuid.uuid4())
                    term = BusinessTerm(
                        id=term_id,
                        name=row['name'],
                        description=row['description']
                    )
                    
                    # Create document for embedding
                    doc = MyDocument(
                        id=term_id,
                        text=f"{term.name}. {term.description}"
                    )
                    
                    # Generate embedding
                    doc_with_embedding = self.embedding_client.generate_embeddings(doc)
                    
                    if not doc_with_embedding.embedding:
                        logger.warning(f"Could not generate embedding for term: {term.name}. Skipping.")
                        continue
                    
                    # Add to lists for batch addition
                    terms.append(term)
                    ids.append(term_id)
                    embeddings.append(doc_with_embedding.embedding)
                    metadatas.append({
                        "name": term.name,
                        "description": term.description
                    })
            
            # Add terms to ChromaDB in batch
            if ids:
                self.collection.add(
                    ids=ids,
                    embeddings=embeddings,
                    metadatas=metadatas,
                    documents=[f"{term.name}. {term.description}" for term in terms]
                )
                
            logger.info(f"Imported {len(terms)} business terms from {csv_path}")
            return len(terms)
            
        except Exception as e:
            logger.error(f"Error importing terms from CSV: {e}")
            raise
    
    def tag_element(self, name: str, description: str, top_k: int = 3) -> TaggingResult:
        """
        Tag a data element with the most similar business terms.
        
        Args:
            name: Enhanced data element name
            description: Enhanced data element description
            top_k: Number of top terms to return
            
        Returns:
            Tagging result with matching terms and confidence scores
        """
        try:
            # Create document for embedding
            doc = MyDocument(
                id=str(uuid.uuid4()),
                text=f"{name}. {description}"
            )
            
            # Generate embedding
            doc_with_embedding = self.embedding_client.generate_embeddings(doc)
            
            if not doc_with_embedding.embedding:
                raise ValueError(f"Could not generate embedding for element: {name}")
            
            # Query the collection using cosine similarity
            results = self.collection.query(
                query_embeddings=[doc_with_embedding.embedding],
                n_results=top_k,
                include=["metadatas", "documents", "distances"],
                where={},  # Empty where clause for all documents
                where_document={},  # Empty where_document for all documents
                distance_metric="cosine"  # Use cosine similarity instead of L2
            )
            
            matching_terms = []
            confidence_scores = []
            
            if results["ids"] and len(results["ids"][0]) > 0:
                for i, term_id in enumerate(results["ids"][0]):
                    # Cosine distance is 1 - cosine similarity, so we need to convert back to similarity
                    distance = results["distances"][0][i]
                    # Convert cosine distance to cosine similarity (confidence score)
                    # Cosine similarity ranges from -1 to 1, with 1 being most similar
                    # For embeddings, we typically get positive values in [0, 1] range
                    cosine_similarity = 1 - distance
                    
                    matching_terms.append({
                        "id": term_id,
                        "name": results["metadatas"][0][i]["name"],
                        "description": results["metadatas"][0][i]["description"]
                    })
                    confidence_scores.append(cosine_similarity)
            
            return TaggingResult(
                element_name=name,
                element_description=description,
                matching_terms=matching_terms,
                confidence_scores=confidence_scores
            )
            
        except Exception as e:
            logger.error(f"Error tagging element: {e}")
            raise
    
    async def validate_tagging(self, tagging_result: TaggingResult) -> TaggingValidationResult:
        """
        Validate the tagging result to check if it makes sense.
        
        Args:
            tagging_result: The tagging result to validate
            
        Returns:
            Validation result with feedback and suggestions
        """
        try:
            # If there are no matching terms, validation fails
            if not tagging_result.matching_terms:
                return TaggingValidationResult(
                    is_valid=False,
                    feedback="No matching business terms found.",
                    suggested_alternatives=[]
                )
            
            # Check confidence scores - for cosine similarity, threshold is higher
            # With cosine similarity, good matches typically have scores > 0.75
            highest_confidence = max(tagging_result.confidence_scores) if tagging_result.confidence_scores else 0
            
            # If highest confidence is less than 0.75, validation is questionable
            if highest_confidence < 0.75:
                # Find alternative terms with a different query approach
                alternative_doc = MyDocument(
                    id=str(uuid.uuid4()),
                    # Use only the name for a different perspective
                    text=tagging_result.element_name
                )
                
                alternative_doc_with_embedding = self.embedding_client.generate_embeddings(alternative_doc)
                
                if alternative_doc_with_embedding.embedding:
                    # Also use cosine similarity for alternatives
                    alt_results = self.collection.query(
                        query_embeddings=[alternative_doc_with_embedding.embedding],
                        n_results=3,
                        include=["metadatas", "documents", "distances"],
                        distance_metric="cosine"
                    )
                    
                    alternatives = []
                    if alt_results["ids"] and len(alt_results["ids"][0]) > 0:
                        for i, term_id in enumerate(alt_results["ids"][0]):
                            if term_id not in [term["id"] for term in tagging_result.matching_terms]:
                                # Calculate confidence for alternative
                                alt_confidence = 1 - alt_results["distances"][0][i]
                                alternatives.append({
                                    "id": term_id,
                                    "name": alt_results["metadatas"][0][i]["name"],
                                    "description": alt_results["metadatas"][0][i]["description"],
                                    "confidence": alt_confidence
                                })
                    
                    return TaggingValidationResult(
                        is_valid=False,
                        feedback=f"Low confidence match ({highest_confidence:.2f}). Consider reviewing alternative terms.",
                        suggested_alternatives=alternatives
                    )
            
            # High confidence match
            return TaggingValidationResult(
                is_valid=True,
                feedback=f"Strong match with highest confidence of {highest_confidence:.2f}.",
                suggested_alternatives=[]
            )
            
        except Exception as e:
            logger.error(f"Error validating tagging: {e}")
            raise
    
    def get_all_terms(self) -> List[BusinessTerm]:
        """
        Get all business terms in the collection.
        
        Returns:
            List of all business terms
        """
        try:
            # Query all items (limited to 10000 for safety)
            results = self.collection.get(limit=10000)
            
            terms = []
            if results["ids"]:
                for i, term_id in enumerate(results["ids"]):
                    terms.append(BusinessTerm(
                        id=term_id,
                        name=results["metadatas"][i]["name"],
                        description=results["metadatas"][i]["description"]
                    ))
            
            return terms
            
        except Exception as e:
            logger.error(f"Error getting all terms: {e}")
            raise
    
    def get_term_by_id(self, term_id: str) -> Optional[BusinessTerm]:
        """
        Get a business term by its ID.
        
        Args:
            term_id: ID of the term to retrieve
            
        Returns:
            Business term if found, None otherwise
        """
        try:
            results = self.collection.get(ids=[term_id])
            
            if results["ids"] and len(results["ids"]) > 0:
                return BusinessTerm(
                    id=results["ids"][0],
                    name=results["metadatas"][0]["name"],
                    description=results["metadatas"][0]["description"]
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting term by ID: {e}")
            raise
