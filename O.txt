You're absolutely right. If `PROXY_ENABLED=False`, the application should bypass the proxy entirely, even with incorrect Azure credentials. The authentication to Azure might fail, but it should fail with an authentication error rather than a proxy connection error.

The fact that you're seeing "unable to connect to proxy" suggests that the proxy settings aren't being properly disabled. Let's fix this:

## Looking at the Core Issue in environment.py

In your `app/config/environment.py`, the problem is likely in the `set_proxy` method and how it interacts with proxy disabling. When proxy is disabled, the code should actively CLEAR proxy environment variables, not just avoid setting them.

Here's a fix for the OSEnv class in environment.py:

```python
def __init__(self, config_file: str, creds_file: str, certificate_path: str, proxy_enabled: Optional[bool] = None):
    self.var_list = []
    self.bulk_set(config_file, True)
    self.bulk_set(creds_file, False)
    self.set_certificate_path(certificate_path)
    
    # Handle proxy_enabled override
    if proxy_enabled is not None:
        self.set("PROXY_ENABLED", str(proxy_enabled))
        logger.info(f"Proxy enabled setting overridden to: {proxy_enabled}")
    
    # Set proxy if enabled, CLEAR if disabled
    proxy_enabled_env = str_to_bool(self.get("PROXY_ENABLED", "False"))
    if proxy_enabled_env:
        self.set_proxy()
        logger.info("Proxy settings applied")
    else:
        self.clear_proxy()  # Add this new method to clear proxy settings
        logger.info("Proxy disabled, clearing all proxy settings")
    
    # Handle secured endpoints
    if str_to_bool(self.get("SECURED_ENDPOINTS", "False")):
        self.token = self.get_azure_token()
    else:
        self.token = None
    
    self.credential = self._get_credential()
    
    # Set PostgreSQL environment variables if not already set
    self._set_postgres_defaults()

# Add this new method to OSEnv class
def clear_proxy(self) -> None:
    """Clear all proxy environment variables."""
    try:
        # List of proxy-related environment variables to clear
        proxy_vars = [
            'HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 
            'NO_PROXY', 'no_proxy'
        ]
        
        for var in proxy_vars:
            if var in os.environ:
                del os.environ[var]
                logger.info(f"Cleared proxy environment variable: {var}")
        
        # Also clear from our internal tracking
        for var in proxy_vars:
            if var in self.var_list:
                self.var_list.remove(var)
    except Exception as e:
        logger.error(f"Error clearing proxy settings: {e}")
```

## Modify the get_azure_token method

Also modify the get_azure_token method to not use proxy settings:

```python
def get_azure_token(self) -> str:
    """Get an Azure AD token for authenticated API calls."""
    try:
        # Check if proxy is disabled - important for token acquisition
        proxy_enabled = str_to_bool(self.get("PROXY_ENABLED", "False"))
        
        # Create credential with proxy awareness
        if proxy_enabled:
            # Use standard credential approach with proxy
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET")
            )
        else:
            # For direct connections without proxy, be explicit about it
            from azure.identity._internal.managed_identity_client import NoProxyPolicy
            from azure.core.pipeline.policies import SansIOHTTPPolicy
            
            # Create credential with custom policies that avoid proxy
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET"),
                connection_verify=False if certificate_path is None else certificate_path,
                # Add policy that skips proxy
                policies=[NoProxyPolicy()]
            )
        
        token = credential.get_token("https://cognitiveservices.azure.com/.default")
        self.set("AZURE_TOKEN", token.token, print_val=False)
        logger.info("Azure token set successfully")
        return token.token
    except Exception as e:
        logger.error(f"Error retrieving Azure token: {e}")
        return None
```

## Quick Test Without Code Changes

If you want to test this theory without modifying code, try running:

```bash
# Clear all proxies at the environment level
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy NO_PROXY no_proxy

# Set an environment variable to tell the Azure SDK to ignore proxies
export AZURE_NO_PROXY=true

# Now run your application
python main.py --host 0.0.0.0 --port 8000 --no-proxy --pg-host [YOUR_DB_HOST] --pg-user [YOUR_DB_USER] --pg-password [YOUR_DB_PASSWORD] --pg-db [YOUR_DB_NAME]
```

The issue is definitely that even with `PROXY_ENABLED=False`, the application isn't actively clearing proxy settings, which means the Azure SDK is still trying to use them.​​​​​​​​​​​​​​​​
