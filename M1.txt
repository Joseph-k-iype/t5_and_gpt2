import pandas as pd
from pptx import Presentation
from pptx.util import Pt
import copy
from rdflib import Graph, ConjunctiveGraph
import rdflib.plugins.stores.sparqlstore as store
import rdflib

endpoint = "abc.com"
st = store.SPARQLUpdateStore(endpoint)
rdf = rdflib.ConjunctiveGraph(store=st)

# Modified function to generate data based on a dynamic report value (URL)
def generate_data(report_value):
    results = []
    query = f"""
        SELECT ?reportName ?processName ?prodbdeName ?conbdeName ?conrmName ?prodrmName ?gucid ?type
        WHERE {{
            <{report_value}> a abc:Report .
            <{report_value}> abc:hasProcess ?process .
            <{report_value}> abc:reportName ?reportName .
            ?process abc:hasProcessName ?processName .
            ?process abc:hasProducedBDE ?prodbde .
            ?prodbde abc:hasBDEName ?prodbdeName .
            OPTIONAL {{?process abc:hasConsumedBDE ?conbde .
            ?conbde abc:hasBDEName ?conbdeName .}}
            OPTIONAL {{?process abc:hasConsumedMetric ?conrm .
            ?conrm abc:hasMetricName ?conrmName .}}
            OPTIONAL {{?process abc:hasProducedMetric ?prodrm .
            ?prodrm abc:hasMetricName ?prodrmName .}}
            OPTIONAL {{?process abc:hasMonitored ?guc .
            ?guc abc:hasGUCID ?gucid .}}
            OPTIONAL {{?process abc:hasFlowType ?type .}}
        }}
    """
    for (a, b, c, d, e, f, g, h) in rdf.query(query):
        results.append({
            'Report Name': str(a),
            'Process': str(b),
            'Produced BDE': str(c),
            'Consumed BDE': str(d),
            'Consumed Metric': str(e),
            'Produced Metric': str(f),
            'Monitored': str(g),
            'Flow Type': str(h)
        })
    df_data = pd.DataFrame(results)
    return df_data

# Function to generate the report name and replace in first slide
def replace_report_name(prs, report_name):
    slide = prs.slides[0]
    for shape in slide.shapes:
        if shape.has_text_frame:
            if "Report Name Analysis" in shape.text:
                shape.text = shape.text.replace("Report Name", report_name)
                for paragraph in shape.text_frame.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(10)
                        run.font.name = 'Arial'

# Function to add a row to the table by duplicating the last row
def add_row_to_table(table):
    last_row = table._tbl.tr_lst[-1]
    new_row = copy.deepcopy(last_row)
    table._tbl.append(new_row)
    for cell in new_row.iterdescendants():
        if cell.tag.endswith('}tc'):
            for text_element in cell.iter('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}t'):
                text_element.getparent().remove(text_element)

# Function to fill in the table in the second slide
import pandas as pd
from pptx.util import Pt
import copy

def fill_table_in_slide(slide, df):
    # Replace 'None', 'NA', 'N/A' with blank values and drop blanks
    df = df.replace(['None', 'NA', 'N/A'], '').fillna('')

    table = slide.shapes[0].table  # Assuming the first shape is the table
    processes = df['Process'].unique()
    row_idx = 1

    # Data collection for CSV output
    csv_data = []

    for hop_count, process in enumerate(processes, start=1):
        process_data = df[df['Process'] == process]

        # Consumed BDE data - Distinct and non-blank values only
        consumed_bdes = process_data['Consumed BDE'].loc[process_data['Consumed BDE'] != ''].nunique()
        consumed_monitored = process_data[(process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique()
        boundary_consumed_bdes = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed BDE'] != '')]['Consumed BDE'].nunique()
        boundary_consumed_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique()
        
        # Metrics data for Consumed - Distinct and non-blank values only
        consumed_metrics = process_data['Consumed Metric'].loc[process_data['Consumed Metric'] != ''].nunique()
        consumed_metrics_monitored = process_data[(process_data['Consumed Metric'] != '') & (process_data['Monitored'] != '')]['Consumed Metric'].nunique()
        boundary_consumed_metrics = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed Metric'] != '')]['Consumed Metric'].nunique()
        boundary_consumed_metrics_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed Metric'] != '') & (process_data['Monitored'] != '')]['Consumed Metric'].nunique()

        if consumed_bdes > 0 or consumed_metrics > 0:
            row_data = [
                hop_count, process, 'Consumed', consumed_bdes, consumed_monitored,
                f"{(consumed_monitored / consumed_bdes * 100) if consumed_bdes > 0 else 0:.2f}%",
                boundary_consumed_bdes, boundary_consumed_monitored,
                f"{(boundary_consumed_monitored / boundary_consumed_bdes * 100) if boundary_consumed_bdes > 0 else 0:.2f}%",
                "", "", "", consumed_metrics, consumed_metrics_monitored,
                f"{(consumed_metrics_monitored / consumed_metrics * 100) if consumed_metrics > 0 else 0:.2f}%"
            ]
            csv_data.append(row_data)
            if row_idx >= len(table.rows):
                add_row_to_table(table)
            for col, value in enumerate(row_data):
                table.cell(row_idx, col).text = str(value)
                for paragraph in table.cell(row_idx, col).text_frame.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(10)
                        run.font.name = 'Arial'
            row_idx += 1

        # Produced BDE data - Distinct and non-blank values only
        produced_bdes = process_data['Produced BDE'].loc[process_data['Produced BDE'] != ''].nunique()
        produced_monitored = process_data[(process_data['Produced BDE'] != '') & (process_data['Monitored'] != '')]['Produced BDE'].nunique()
        boundary_produced_bdes = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced BDE'] != '')]['Produced BDE'].nunique()
        boundary_produced_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced BDE'] != '') & (process_data['Monitored'] != '')]['Produced BDE'].nunique()
        
        # Metrics data for Produced - Distinct and non-blank values only
        produced_metrics = process_data['Produced Metric'].loc[process_data['Produced Metric'] != ''].nunique()
        produced_metrics_monitored = process_data[(process_data['Produced Metric'] != '') & (process_data['Monitored'] != '')]['Produced Metric'].nunique()
        boundary_produced_metrics = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced Metric'] != '')]['Produced Metric'].nunique()
        boundary_produced_metrics_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced Metric'] != '') & (process_data['Monitored'] != '')]['Produced Metric'].nunique()

        if produced_bdes > 0 or produced_metrics > 0:
            row_data = [
                hop_count, process, 'Produced', produced_bdes, produced_monitored,
                f"{(produced_monitored / produced_bdes * 100) if produced_bdes > 0 else 0:.2f}%",
                boundary_produced_bdes, boundary_produced_monitored,
                f"{(boundary_produced_monitored / boundary_produced_bdes * 100) if boundary_produced_bdes > 0 else 0:.2f}%",
                "", "", "", produced_metrics, produced_metrics_monitored,
                f"{(produced_metrics_monitored / produced_metrics * 100) if produced_metrics > 0 else 0:.2f}%"
            ]
            csv_data.append(row_data)
            if row_idx >= len(table.rows):
                add_row_to_table(table)
            for col, value in enumerate(row_data):
                table.cell(row_idx, col).text = str(value)
                for paragraph in table.cell(row_idx, col).text_frame.paragraphs:
                    for run in paragraph.runs:
                        run.font.size = Pt(10)
                        run.font.name = 'Arial'
            row_idx += 1

    # Export collected CSV data to a CSV file
    csv_df = pd.DataFrame(csv_data, columns=[
        'Hop Count', 'Process', 'Type', 'Total BDEs', 'BDEs Agreed to Monitor',
        '% BDE Monitored', 'Boundary BDEs', 'Boundary BDEs Agreed to Monitor',
        '% Boundary BDE Monitored', 'Intra Process BDEs', 'Intra Process BDE Agreed to Monitor',
        '% Intra Process BDE Monitored', 'Metrics', 'Metrics Agreed to Monitor',
        '% Metrics Monitored'
    ])
    csv_df.to_csv('Generated_Report_Table.csv', index=False)
    print("Table exported as 'Generated_Report_Table.csv'")

# Main function to generate the PowerPoint report
def create_report(template_path, output_path, report_value):
    prs = Presentation(template_path)
    report_name = report_value.split("/")[-1]  # Use last part of URL as report name for simplicity
    df = generate_data(report_value)
    replace_report_name(prs, report_name)
    fill_table_in_slide(prs.slides[1], df)
    prs.save(output_path)
    print(f"Report saved as {output_path}")

# Example usage
if __name__ == "__main__":
    TEMPLATE_PATH = "Report Name Analysis.pptx"
    OUTPUT_PATH = "Generated_Report.pptx"
    REPORT_VALUE = input("Enter the report URL: ")
    
    create_report(TEMPLATE_PATH, OUTPUT_PATH, REPORT_VALUE)
