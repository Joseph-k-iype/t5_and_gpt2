import pandas as pd
from pptx import Presentation
from pptx.util import Pt
from pptx.dml.color import RGBColor
import copy
from rdflib import ConjunctiveGraph
import rdflib.plugins.stores.sparqlstore as store
import rdflib

# Set up the RDF SPARQL endpoint and data fetching
endpoint = "abc.com"
st = store.SPARQLUpdateStore(endpoint)
rdf = rdflib.ConjunctiveGraph(store=st)

# Function to query data from RDF using a dynamic report URL
def generate_data(report_value):
    results = []
    query = f"""
        SELECT ?reportName ?processName ?prodbdeName ?conbdeName ?conrmName ?prodrmName ?gucid ?type
        WHERE {{
            <{report_value}> a abc:Report .
            <{report_value}> abc:hasProcess ?process .
            <{report_value}> abc:reportName ?reportName .
            ?process abc:hasProcessName ?processName .
            ?process abc:hasProducedBDE ?prodbde .
            ?prodbde abc:hasBDEName ?prodbdeName .
            OPTIONAL {{?process abc:hasConsumedBDE ?conbde .
            ?conbde abc:hasBDEName ?conbdeName .}}
            OPTIONAL {{?process abc:hasConsumedMetric ?conrm .
            ?conrm abc:hasMetricName ?conrmName .}}
            OPTIONAL {{?process abc:hasProducedMetric ?prodrm .
            ?prodrm abc:hasMetricName ?prodrmName .}}
            OPTIONAL {{?process abc:hasMonitored ?guc .
            ?guc abc:hasGUCID ?gucid .}}
            OPTIONAL {{?process abc:hasFlowType ?type .}}
        }}
    """
    for (a, b, c, d, e, f, g, h) in rdf.query(query):
        results.append({
            'Report Name': str(a),
            'Process': str(b),
            'Produced BDE': str(c),
            'Consumed BDE': str(d),
            'Consumed Metric': str(e),
            'Produced Metric': str(f),
            'Monitored': str(g),
            'Flow Type': str(h)
        })
    df_data = pd.DataFrame(results)
    return df_data.replace(['None', 'NA', 'N/A'], '').fillna('')

# Function to add a new row to the table by duplicating the last row
def add_row_to_table(table):
    last_row = table._tbl.tr_lst[-1]
    new_row = copy.deepcopy(last_row)
    table._tbl.append(new_row)
    for cell in new_row.iterdescendants():
        if cell.tag.endswith('}tc'):  # Table cell
            for text_element in cell.iter('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}t'):
                text_element.getparent().remove(text_element)

# Function to update the report name in the title slide (Slide 1)
def replace_report_name(slide, report_name):
    for shape in slide.shapes:
        if shape.has_text_frame:
            if "Report Name Analysis" in shape.text:
                shape.text = shape.text.replace("Report Name", report_name)

# Function to inherit font style from header in the template
def inherit_font_style_from_header(table):
    header_row = table.rows[0]
    font_size, font_name = None, None
    for cell in header_row.cells:
        for paragraph in cell.text_frame.paragraphs:
            for run in paragraph.runs:
                font_size = run.font.size
                font_name = run.font.name
                break
            if font_size and font_name:
                break
    return font_size, font_name

# Corrected function to apply styling to all rows in a table, with header having original style and others with white cell shading
def apply_table_styling(table, font_size, font_name):
    # Apply header row styling from the inherited font style
    header_row = table.rows[0]
    for cell in header_row.cells:
        for paragraph in cell.text_frame.paragraphs:
            for run in paragraph.runs:
                run.font.size = font_size
                run.font.name = font_name
    
    # Apply white background to other rows (starting from index 1)
    for i in range(1, len(table.rows)):
        row = table.rows[i]
        for cell in row.cells:
            cell.fill.solid()
            cell.fill.fore_color.rgb = RGBColor(255, 255, 255)  # White shading
            for paragraph in cell.text_frame.paragraphs:
                for run in paragraph.runs:
                    run.font.size = font_size
                    run.font.name = font_name

# Function to get the first table from a slide, regardless of placeholder type
def get_first_table_from_slide(slide):
    for shape in slide.shapes:
        if shape.has_table:
            return shape.table
    return None

# Function to fill the first table on Slide 6
def fill_first_table_in_slide(slide, df, font_size, font_name):
    table = get_first_table_from_slide(slide)
    if table is None:
        print("No table found for the first table on Slide 6.")
        return

    processes = df['Process'].unique()
    row_idx = 1

    apply_table_styling(table, font_size, font_name)  # Apply consistent styling

    for process in processes:
        process_data = df[df['Process'] == process]
        
        consumed_total = process_data['Consumed BDE'].loc[process_data['Consumed BDE'] != ''].nunique() + process_data['Consumed Metric'].loc[process_data['Consumed Metric'] != ''].nunique()
        produced_total = process_data['Produced BDE'].loc[process_data['Produced BDE'] != ''].nunique() + process_data['Produced Metric'].loc[process_data['Produced Metric'] != ''].nunique()

        if row_idx >= len(table.rows):
            add_row_to_table(table)
        table.cell(row_idx, 0).text = process
        table.cell(row_idx, 1).text = 'Consumed'
        table.cell(row_idx, 2).text = str(consumed_total)
        row_idx += 1
        if row_idx >= len(table.rows):
            add_row_to_table(table)
        table.cell(row_idx, 0).text = process
        table.cell(row_idx, 1).text = 'Produced'
        table.cell(row_idx, 2).text = str(produced_total)
        row_idx += 1

# Function to fill the second table on Slide 6 with corrected values
def fill_second_table_in_slide(slide, df, font_size, font_name):
    tables = [shape.table for shape in slide.shapes if shape.has_table]
    if len(tables) < 2:
        print("Insufficient tables on Slide 6.")
        return

    table = tables[1]
    processes = df['Process'].unique()
    row_idx = 1

    apply_table_styling(table, font_size, font_name)  # Apply consistent styling

    for hop_count, process in enumerate(processes, start=1):
        process_data = df[df['Process'] == process]
        
        total_metrics_consumed = process_data['Consumed Metric'].loc[process_data['Consumed Metric'] != ''].nunique()
        total_metrics_produced = process_data['Produced Metric'].loc[process_data['Produced Metric'] != ''].nunique()
        total_bdes_consumed = process_data['Consumed BDE'].loc[process_data['Consumed BDE'] != ''].nunique()
        total_bdes_produced = process_data['Produced BDE'].loc[process_data['Produced BDE'] != ''].nunique()
        boundary_bdes_consumed = process_data[(process_data['Flow Type'].str.contains("Inbound", case=False, na=False)) & 
                                              (process_data['Consumed BDE'] != '')]['Consumed BDE'].nunique()
        boundary_bdes_produced = process_data[(process_data['Flow Type'].str.contains("Process Output", case=False, na=False)) & 
                                              (process_data['Produced BDE'] != '')]['Produced BDE'].nunique()
        intra_process_bdes_consumed = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                                   (process_data['Consumed BDE'] != '')]['Consumed BDE'].nunique()
        intra_process_bdes_produced = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                                   (process_data['Produced BDE'] != '')]['Produced BDE'].nunique()

        # Add rows for consumed data
        row_data_consumed = [
            hop_count, process, 'Consumed',
            total_metrics_consumed, total_bdes_consumed,
            boundary_bdes_consumed, intra_process_bdes_consumed
        ]
        if row_idx >= len(table.rows):
            add_row_to_table(table)
        for col, value in enumerate(row_data_consumed):
            table.cell(row_idx, col).text = str(value)
        row_idx += 1

        # Add rows for produced data
        row_data_produced = [
            hop_count, process, 'Produced',
            total_metrics_produced, total_bdes_produced,
            boundary_bdes_produced, intra_process_bdes_produced
        ]
        if row_idx >= len(table.rows):
            add_row_to_table(table)
        for col, value in enumerate(row_data_produced):
            table.cell(row_idx, col).text = str(value)
        row_idx += 1

# Function to fill the main table on Slide 8 with both Consumed and Produced data, and save data to CSV
def fill_main_table_in_slide(slide, df, csv_data, font_size, font_name):
    table = get_first_table_from_slide(slide)
    if table is None:
        print("No table found on Slide 8.")
        return

    apply_table_styling(table, font_size, font_name)  # Apply consistent styling

    processes = df['Process'].unique()
    row_idx = 1

    for hop_count, process in enumerate(processes, start=1):
        process_data = df[df['Process'] == process]
        
        # Consumed data calculations
        consumed_bdes = process_data['Consumed BDE'].loc[process_data['Consumed BDE'] != ''].nunique()
        consumed_monitored = process_data[(process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique()
        boundary_consumed_bdes = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed BDE'] != '')]['Consumed BDE'].nunique()
        boundary_consumed_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique()
        intra_process_bdes = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                          (process_data['Consumed BDE'] != '')]['Consumed BDE'].nunique()
        intra_process_monitored = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                               (process_data['Consumed BDE'] != '') & (process_data['Monitored'] != '')]['Consumed BDE'].nunique()
        total_metrics = process_data['Consumed Metric'].loc[process_data['Consumed Metric'] != ''].nunique()
        monitored_metrics = process_data[(process_data['Consumed Metric'] != '') & (process_data['Monitored'] != '')]['Consumed Metric'].nunique()

        # Add Consumed row data
        row_data_consumed = [
            hop_count, process, 'Consumed', consumed_bdes, consumed_monitored,
            f"{(consumed_monitored / consumed_bdes * 100) if consumed_bdes > 0 else 0:.2f}%",
            boundary_consumed_bdes, boundary_consumed_monitored,
            f"{(boundary_consumed_monitored / boundary_consumed_bdes * 100) if boundary_consumed_bdes > 0 else 0:.2f}%",
            intra_process_bdes, intra_process_monitored,
            f"{(intra_process_monitored / intra_process_bdes * 100) if intra_process_bdes > 0 else 0:.2f}%",
            total_metrics, monitored_metrics,
            f"{(monitored_metrics / total_metrics * 100) if total_metrics > 0 else 0:.2f}%"
        ]
        
        csv_data.append(row_data_consumed)

        if row_idx >= len(table.rows):
            add_row_to_table(table)
        for col, value in enumerate(row_data_consumed):
            table.cell(row_idx, col).text = str(value)
        row_idx += 1

        # Produced data calculations
        produced_bdes = process_data['Produced BDE'].loc[process_data['Produced BDE'] != ''].nunique()
        produced_monitored = process_data[(process_data['Produced BDE'] != '') & (process_data['Monitored'] != '')]['Produced BDE'].nunique()
        boundary_produced_bdes = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced BDE'] != '')]['Produced BDE'].nunique()
        boundary_produced_monitored = process_data[(process_data['Flow Type'] != 'Intra Process') & (process_data['Produced BDE'] != '') & (process_data['Monitored'] != '')]['Produced BDE'].nunique()
        intra_process_produced_bdes = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                                   (process_data['Produced BDE'] != '')]['Produced BDE'].nunique()
        intra_process_produced_monitored = process_data[(process_data['Flow Type'].str.contains("Intra[- ]?Process", case=False, na=False)) & 
                                                        (process_data['Produced BDE'] != '') & (process_data['Monitored'] != '')]['Produced BDE'].nunique()
        total_produced_metrics = process_data['Produced Metric'].loc[process_data['Produced Metric'] != ''].nunique()
        monitored_produced_metrics = process_data[(process_data['Produced Metric'] != '') & (process_data['Monitored'] != '')]['Produced Metric'].nunique()

        # Add Produced row data
        row_data_produced = [
            hop_count, process, 'Produced', produced_bdes, produced_monitored,
            f"{(produced_monitored / produced_bdes * 100) if produced_bdes > 0 else 0:.2f}%",
            boundary_produced_bdes, boundary_produced_monitored,
            f"{(boundary_produced_monitored / boundary_produced_bdes * 100) if boundary_produced_bdes > 0 else 0:.2f}%",
            intra_process_produced_bdes, intra_process_produced_monitored,
            f"{(intra_process_produced_monitored / intra_process_produced_bdes * 100) if intra_process_produced_bdes > 0 else 0:.2f}%",
            total_produced_metrics, monitored_produced_metrics,
            f"{(monitored_produced_metrics / total_produced_metrics * 100) if total_produced_metrics > 0 else 0:.2f}%"
        ]
        
        csv_data.append(row_data_produced)

        if row_idx >= len(table.rows):
            add_row_to_table(table)
        for col, value in enumerate(row_data_produced):
            table.cell(row_idx, col).text = str(value)
        row_idx += 1

# Function to save data to a CSV file
def save_csv(csv_data, file_name="Generated_Report_Table.csv"):
    column_names = [
        "Hop Count", "Process", "Consumed or Produced", "Total BDEs", "Total BDEs Agreed to Monitor",
        "% BDE Monitored", "BDEs at Boundary Level", "Boundary BDEs Agreed to Monitor",
        "% Boundary BDE Monitored", "Intra Process BDEs", "Intra Process BDE Agreed to Monitor",
        "% Intra Process BDE Monitored", "Total Metrics", "Total Metrics Agreed to Monitor", "% Metrics Monitored"
    ]
    df = pd.DataFrame(csv_data, columns=column_names)
    df.to_csv(file_name, index=False)
    print(f"CSV data saved to {file_name}")

# Main function to generate the report by populating slides with data
def create_report(template_path, output_path, report_value):
    prs = Presentation(template_path)
    df = generate_data(report_value)
    report_name = df['Report Name'].iloc[0] if 'Report Name' in df.columns and not df['Report Name'].empty else "Unknown Report"

    if len(prs.slides) > 0:
        replace_report_name(prs.slides[0], report_name)

    csv_data = []

    # Inherit font style from the header row of the main table on Slide 8
    if len(prs.slides) > 7:
        table_slide_8 = get_first_table_from_slide(prs.slides[7])  # Get first table on Slide 8
        if table_slide_8:
            font_size, font_name = inherit_font_style_from_header(table_slide_8)

            # Populate Slide 8 table
            fill_main_table_in_slide(prs.slides[7], df, csv_data, font_size, font_name)

    # Populate Slide 6 tables
    if len(prs.slides) > 5:
        fill_first_table_in_slide(prs.slides[5], df, font_size, font_name)
        fill_second_table_in_slide(prs.slides[5], df, font_size, font_name)

    save_csv(csv_data)

    prs.save(output_path)
    print(f"Report saved as {output_path}")

# Example usage
if __name__ == "__main__":
    TEMPLATE_PATH = "Report Name Analysis.pptx"
    OUTPUT_PATH = "Generated_Report.pptx"
    REPORT_URL = input("Enter the report URL: ")

    create_report(TEMPLATE_PATH, OUTPUT_PATH, REPORT_URL)
