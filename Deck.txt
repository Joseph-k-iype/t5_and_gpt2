"""
Streamlined Enterprise FalkorDB Graph RAG Search Engine
Optimized for FAST simple queries with OPTIONAL business intelligence
"""

import os
import json
import asyncio
import argparse
import logging
import re
from typing import Dict, List, Any, Optional, TypedDict, Annotated, Tuple
from datetime import datetime

# Core LangChain imports
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langchain_core.tools import tool
from langchain_core.prompts import ChatPromptTemplate, PromptTemplate
from langchain_openai import ChatOpenAI, OpenAIEmbeddings

# FalkorDB-specific LangChain imports
from langchain_community.chains.graph_qa.falkordb import FalkorDBQAChain
from langchain_community.graphs import FalkorDBGraph

# Try to import vector store - it's optional
try:
    from langchain_community.vectorstores import FalkorDBVector
    VECTOR_SEARCH_AVAILABLE = True
except ImportError:
    VECTOR_SEARCH_AVAILABLE = False
    FalkorDBVector = None

# Pydantic for data validation
from pydantic import BaseModel, Field

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class FalkorDBQueryValidator:
    """Fast query validator for basic FalkorDB compatibility"""
    
    @staticmethod
    def clean_cypher_query(query: str) -> str:
        """Clean and normalize Cypher query to prevent multiple statement issues"""
        if not query or not query.strip():
            return ""
        
        # Remove extra whitespace and normalize
        cleaned = query.strip()
        
        # Remove trailing semicolons that can cause "multiple statement" errors
        cleaned = re.sub(r';\s*$', '', cleaned)
        
        # Remove multiple consecutive semicolons
        cleaned = re.sub(r';+', ';', cleaned)
        
        # If there are semicolons in the middle, keep only the first statement
        if ';' in cleaned:
            statements = [stmt.strip() for stmt in cleaned.split(';')]
            # Take the first non-empty statement
            for stmt in statements:
                if stmt and not stmt.isspace():
                    cleaned = stmt
                    break
        
        # Remove any comments that might cause issues
        lines = cleaned.split('\n')
        cleaned_lines = []
        for line in lines:
            # Remove full-line comments
            if line.strip().startswith('//'):
                continue
            # Remove inline comments
            if '//' in line:
                line = line.split('//')[0].rstrip()
            cleaned_lines.append(line)
        
        cleaned = '\n'.join(cleaned_lines).strip()
        
        return cleaned
    
    @staticmethod
    def is_safe_query(query: str) -> bool:
        """Check if query is safe and likely to work with FalkorDB"""
        if not query or not query.strip():
            return False
        
        # Clean the query first
        cleaned_query = FalkorDBQueryValidator.clean_cypher_query(query)
        query_upper = cleaned_query.upper()
        
        # Check for dangerous operations
        dangerous_keywords = ['DELETE', 'DROP', 'CREATE INDEX', 'CREATE CONSTRAINT', 'REMOVE']
        for keyword in dangerous_keywords:
            if keyword in query_upper and not query_upper.startswith('CREATE ('):
                return False
        
        # Check for multiple statements after cleaning
        if ';' in cleaned_query:
            return False
        
        return True


class StreamlinedGraphRAGEngine:
    """Streamlined Graph RAG Engine optimized for FAST responses with optional BI."""
    
    def __init__(self, 
                 openai_api_key: str,
                 openai_base_url: Optional[str] = None,
                 falkordb_host: str = 'localhost',
                 falkordb_port: int = 6379,
                 graph_name: str = 'test_cor'):
        
        self.graph_name = graph_name
        self.falkordb_host = falkordb_host
        self.falkordb_port = falkordb_port
        self.validator = FalkorDBQueryValidator()
        
        # Initialize OpenAI LLM with FASTER settings for simple queries
        self.llm_fast = ChatOpenAI(
            model="gpt-4o-mini",  # Faster model for simple queries
            api_key=openai_api_key,
            base_url=openai_base_url,
            temperature=0,
            max_tokens=500  # Limit tokens for faster responses
        )
        
        # Keep o3-mini for complex business intelligence (when requested)
        self.llm_advanced = ChatOpenAI(
            model="o3-mini",
            api_key=openai_api_key,
            base_url=openai_base_url,
            temperature=0.1,
            model_kwargs={
                "reasoning_effort": "low"  # Use low effort for faster processing
            }
        )
        
        # Initialize FalkorDB Graph wrapper with error handling
        try:
            self.graph = FalkorDBGraph(
                database=graph_name,
                host=falkordb_host,
                port=falkordb_port
            )
            logger.info(f"FalkorDB Graph connection initialized")
        except Exception as e:
            logger.error(f"Failed to initialize FalkorDB Graph: {e}")
            self.graph = None
        
        # Create FAST QA chain for simple queries
        if self.graph:
            self.qa_chain_fast = self._create_fast_qa_chain()
            self.qa_chain_advanced = self._create_advanced_qa_chain()
        else:
            self.qa_chain_fast = None
            self.qa_chain_advanced = None
        
        logger.info(f"Streamlined FalkorDB Graph RAG Engine initialized for graph: {graph_name}")
        
    def _safe_query_execution(self, query: str) -> List[Dict]:
        """Safely execute a Cypher query with proper error handling and cleaning"""
        if not self.graph:
            raise Exception("Graph not initialized")
        
        # Clean the query to prevent multiple statement issues
        cleaned_query = self.validator.clean_cypher_query(query)
        
        if not cleaned_query:
            raise Exception("Empty query after cleaning")
        
        logger.info(f"Executing cleaned query: {cleaned_query}")
        
        try:
            # Execute the cleaned query
            result = self.graph.query(cleaned_query)
            return result
        except Exception as e:
            error_msg = str(e)
            logger.error(f"Query execution failed: {error_msg}")
            
            # Provide helpful error context
            if "multiple statement" in error_msg.lower():
                raise Exception(f"Multiple statement error. Cleaned query: {cleaned_query}")
            elif "syntax error" in error_msg.lower():
                raise Exception(f"Syntax error in Cypher query: {cleaned_query}. Error: {error_msg}")
            else:
                raise Exception(f"Query execution failed: {error_msg}")
    
    def _create_fast_qa_chain(self) -> Optional[FalkorDBQAChain]:
        """Create FAST QA chain for simple, quick responses."""
        if not self.graph:
            return None
        
        fast_cypher_prompt = """
You are a FalkorDB query expert. Generate SIMPLE, FAST openCypher queries.

SPEED OPTIMIZATION RULES:
- Generate the SIMPLEST possible query that answers the question
- Use basic MATCH patterns only: MATCH (n:Label)-[r:RELATIONSHIP]->(m:Label)
- Avoid complex aggregations unless specifically needed
- Use LIMIT 10 for faster results unless user needs more
- NO multiple statements - single query only
- NO semicolons at the end
- NO comments

Schema Context: {schema}
Question: {question}

Generate a simple, fast openCypher query:
"""
        
        cypher_prompt = PromptTemplate(
            input_variables=["schema", "question"],
            template=fast_cypher_prompt
        )
        
        try:
            return FalkorDBQAChain.from_llm(
                llm=self.llm_fast,  # Use faster model
                graph=self.graph,
                verbose=False,  # Disable verbose for speed
                allow_dangerous_requests=True,
                return_intermediate_steps=True,
                cypher_prompt=cypher_prompt
            )
        except Exception as e:
            logger.error(f"Failed to create fast QA chain: {e}")
            return None
    
    def _create_advanced_qa_chain(self) -> Optional[FalkorDBQAChain]:
        """Create advanced QA chain for business intelligence (when requested)."""
        if not self.graph:
            return None
        
        business_cypher_prompt = """
You are a FalkorDB business analyst expert. Generate precise, business-focused openCypher queries.

BUSINESS QUERY GUIDELINES:
- Use SIMPLE, DIRECT queries that work reliably with FalkorDB
- Prefer basic MATCH patterns: MATCH (n:Label)-[r:RELATIONSHIP]->(m:Label)
- Use standard aggregations: count(), sum(), avg(), max(), min()
- Use proper WHERE clauses for filtering
- Use ORDER BY and LIMIT for meaningful results
- NO multiple statements - single query only
- NO semicolons at the end
- NO comments

Schema Context: {schema}
Business Question: {question}

Generate a clear, business-focused openCypher query:
"""
        
        cypher_prompt = PromptTemplate(
            input_variables=["schema", "question"],
            template=business_cypher_prompt
        )
        
        try:
            return FalkorDBQAChain.from_llm(
                llm=self.llm_advanced,
                graph=self.graph,
                verbose=True,
                allow_dangerous_requests=True,
                return_intermediate_steps=True,
                cypher_prompt=cypher_prompt
            )
        except Exception as e:
            logger.error(f"Failed to create advanced QA chain: {e}")
            return None
    
    def _is_complex_query(self, user_query: str) -> bool:
        """Determine if query needs business intelligence processing"""
        complex_indicators = [
            'business', 'strategic', 'analysis', 'implications', 'risks', 'opportunities',
            'recommendations', 'executive', 'summary', 'comprehensive', 'detailed',
            'impact', 'assessment', 'report', 'intelligence', 'insights'
        ]
        
        query_lower = user_query.lower()
        return any(indicator in query_lower for indicator in complex_indicators)
    
    def _format_simple_response(self, query: str, raw_result: str, cypher_query: str = "") -> str:
        """Format a simple, fast response without heavy AI processing"""
        
        # Simple formatting without complex AI calls
        simple_response = f"""## Query Results

**Question:** {query}

**Answer:** {raw_result}

**Technical Details:**
- Query executed successfully
- Generated Cypher: `{cypher_query}`
- Processing mode: Fast response
- No business intelligence processing applied

*For detailed business analysis, include keywords like "business analysis", "strategic implications", or "detailed report" in your question.*
"""
        return simple_response
    
    def _format_business_response(self, query: str, raw_result: str, cypher_query: str = "") -> str:
        """Format response as business report (only for complex queries)"""
        
        # Simplified business prompt for faster processing
        business_prompt = f"""
Create a concise business analysis for this query result.

Question: "{query}"
Data Results: {raw_result}

Provide a structured response with:

## Executive Summary
[2-3 sentences summarizing the key findings]

## Key Findings
â€¢ [Main finding 1]
â€¢ [Main finding 2]
â€¢ [Main finding 3]

## Recommendations
â€¢ [Action 1]
â€¢ [Action 2]

Keep it concise and business-focused. No technical jargon.
"""
        
        try:
            business_analysis = self.llm_fast.invoke(business_prompt)  # Use fast model even for BI
            return str(business_analysis.content) if business_analysis.content else "No analysis available"
        except Exception as e:
            logger.error(f"Business formatting failed: {e}")
            return self._format_simple_response(query, raw_result, cypher_query)
    
    def _generate_simple_followups(self, original_query: str) -> List[str]:
        """Generate simple follow-up questions quickly"""
        
        # Pre-defined follow-ups based on query type - no AI needed for speed
        generic_followups = [
            "Show me more details about these results",
            "What are the related patterns in this data?",
            "How can I explore this data further?",
            "What other analysis would be helpful here?"
        ]
        
        # Quick keyword-based follow-ups
        query_lower = original_query.lower()
        if 'count' in query_lower or 'how many' in query_lower:
            return [
                "What are the top categories by count?",
                "Show me the distribution over time",
                "What factors influence these numbers?",
                "How do these counts compare to benchmarks?"
            ]
        elif 'relationship' in query_lower or 'connect' in query_lower:
            return [
                "What are the strongest connections?",
                "Show me indirect relationships",
                "What patterns exist in these connections?",
                "How do these relationships impact the network?"
            ]
        else:
            return generic_followups
    
    def _generate_intelligent_followups(self, original_query: str, analysis_result: str) -> List[str]:
        """Generate intelligent follow-up questions (only for complex queries)"""
        
        # Simplified follow-up generation for speed
        followup_prompt = f"""
Generate 4 specific follow-up questions based on this analysis:

Original Question: "{original_query}"
Results Summary: {analysis_result[:300]}...

Generate practical follow-up questions that dig deeper. Format as simple questions, one per line.
"""
        
        try:
            followup_result = self.llm_fast.invoke(followup_prompt)  # Use fast model
            questions = []
            for line in followup_result.content.split('\n'):
                line = line.strip()
                line = re.sub(r'^\d+\.\s*', '', line)  # Remove numbering
                line = line.strip('â€¢-*').strip()  # Remove bullet points
                if line and '?' in line and len(line) > 10:
                    questions.append(line)
            
            return questions[:4]  # Limit to 4 for speed
        except Exception as e:
            logger.error(f"Follow-up generation failed: {e}")
            return self._generate_simple_followups(original_query)
    
    def simple_query(self, user_query: str) -> str:
        """Execute a simple, fast query without business intelligence"""
        
        logger.info(f"Processing SIMPLE query: {user_query}")
        
        if not self.graph or not self.qa_chain_fast:
            return "Graph connection not available. Please check FalkorDB status."
        
        try:
            start_time = time.time()
            
            # Execute with fast QA chain
            result = self.qa_chain_fast.invoke({"query": user_query})
            
            raw_result = result.get('result', '')
            cypher_query = ""
            
            # Extract cypher query
            if result.get('intermediate_steps'):
                step = result['intermediate_steps'][0]
                cypher_query = step.get('query', '')
                cypher_query = self.validator.clean_cypher_query(cypher_query)
            
            # Format simple response
            response = self._format_simple_response(user_query, raw_result, cypher_query)
            
            execution_time = time.time() - start_time
            logger.info(f"Simple query completed in {execution_time:.2f} seconds")
            
            return response
            
        except Exception as e:
            logger.error(f"Simple query failed: {e}")
            return f"Query failed: {str(e)}\n\nTry rephrasing your question or check if the data exists in your graph."
    
    def search_with_business_intelligence(self, user_query: str) -> Tuple[str, List[str]]:
        """Execute search with business intelligence (for complex queries only)"""
        
        logger.info(f"Processing BUSINESS INTELLIGENCE query: {user_query}")
        
        if not self.graph:
            error_report = f"""## Connection Error
FalkorDB connection not available. Please check if FalkorDB is running on {self.falkordb_host}:{self.falkordb_port}
"""
            return error_report, ["How can I verify FalkorDB is running?"]
        
        # Determine which chain to use based on query complexity
        is_complex = self._is_complex_query(user_query)
        qa_chain = self.qa_chain_advanced if is_complex else self.qa_chain_fast
        
        if not qa_chain:
            return "QA chain not available", []
        
        try:
            start_time = time.time()
            
            # Execute query
            result = qa_chain.invoke({"query": user_query})
            
            raw_result = result.get('result', '')
            cypher_query = ""
            
            # Extract cypher query
            if result.get('intermediate_steps'):
                step = result['intermediate_steps'][0]
                cypher_query = step.get('query', '')
                cypher_query = self.validator.clean_cypher_query(cypher_query)
            
            # Format response based on complexity
            if is_complex:
                business_report = self._format_business_response(user_query, raw_result, cypher_query)
                followup_questions = self._generate_intelligent_followups(user_query, business_report)
            else:
                business_report = self._format_simple_response(user_query, raw_result, cypher_query)
                followup_questions = self._generate_simple_followups(user_query)
            
            execution_time = time.time() - start_time
            logger.info(f"Query completed in {execution_time:.2f} seconds (complex: {is_complex})")
            
            return business_report, followup_questions
            
        except Exception as e:
            logger.error(f"Business intelligence search failed: {e}")
            error_report = f"""## Analysis Error

**Query:** {user_query}
**Issue:** {str(e)}

**Troubleshooting:**
â€¢ Verify FalkorDB connection and data availability
â€¢ Try a simpler, more specific query
â€¢ Check if the requested data exists in the graph
"""
            return error_report, ["What data is available in the graph?"]
    
    # Convenience methods
    def simple_business_query(self, query: str) -> str:
        """Simple business query without follow-ups"""
        result, _ = self.search_with_business_intelligence(query)
        return result
    
    def get_graph_info(self) -> Dict[str, Any]:
        """Get graph information"""
        try:
            return {
                'database_name': self.graph_name,
                'database_type': 'FalkorDB',
                'connection_info': {
                    'host': self.falkordb_host,
                    'port': self.falkordb_port,
                    'graph_name': self.graph_name,
                    'connected': self.graph is not None
                },
                'features': {
                    'fast_simple_queries': True,
                    'optional_business_intelligence': True,
                    'streamlined_processing': True,
                    'query_optimization': True
                },
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {'error': str(e), 'connected': False}
    
    def test_connection(self) -> Dict[str, Any]:
        """Test connection"""
        try:
            if not self.graph:
                return {
                    'status': 'failed',
                    'error': 'Graph not initialized',
                    'database': self.graph_name
                }
            
            # Test basic connection
            test_result = self._safe_query_execution("RETURN 'connection_test' as status")
            
            return {
                'status': 'connected',
                'database': self.graph_name,
                'database_type': 'FalkorDB',
                'test_result': test_result,
                'streamlined_processing': True,
                'fast_queries': True,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'status': 'failed',
                'error': str(e),
                'database': self.graph_name
            }


class EnterpriseConfig:
    """Enterprise configuration management."""
    
    def __init__(self):
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.openai_base_url = os.getenv("OPENAI_BASE_URL")
        self.falkordb_host = os.getenv("FALKORDB_HOST", "localhost")
        self.falkordb_port = int(os.getenv("FALKORDB_PORT", "6379"))
        self.graph_name = os.getenv("GRAPH_NAME", "test_cor")
    
    def validate(self) -> bool:
        """Validate enterprise configuration."""
        if not self.openai_api_key:
            raise ValueError("OPENAI_API_KEY is required")
        return True


# Alias for backward compatibility
EnhancedGraphRAGEngine = StreamlinedGraphRAGEngine

if __name__ == "__main__":
    print("ðŸš€ Streamlined FalkorDB Graph RAG Engine - FAST QUERIES")
    print("âš¡ Optimized for speed with optional business intelligence")
    print("=" * 60)
    
    config = EnterpriseConfig()
    config.validate()
    
    engine = StreamlinedGraphRAGEngine(
        openai_api_key=config.openai_api_key,
        openai_base_url=config.openai_base_url,
        falkordb_host=config.falkordb_host,
        falkordb_port=config.falkordb_port,
        graph_name=config.graph_name
    )
    
    print("âœ… Engine initialized successfully")
    print("ðŸ’¡ Use simple language for fast responses")
    print("ðŸ’¼ Include 'business analysis' for detailed reports")
