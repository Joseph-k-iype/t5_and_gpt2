"""
Enhanced Enterprise FalkorDB Graph RAG Search Engine
Features: Intelligent follow-up questions, indirect path exploration, conceptual schema understanding
Leverages LangChain's built-in FalkorDB integration with advanced multi-agent intelligence.

Author: Assistant
Date: 2025
Dependencies: falkordb, langchain, langchain-community, langgraph, openai
"""

import os
import json
import asyncio
import argparse
import logging
from typing import Dict, List, Any, Optional, TypedDict, Annotated, Tuple
from datetime import datetime

# Core LangChain imports
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage
from langchain_core.tools import tool, BaseTool
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

# FalkorDB-specific LangChain imports
from langchain_community.chains.graph_qa.falkordb import FalkorDBQAChain
from langchain_community.graphs import FalkorDBGraph

# LangGraph imports
from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langgraph.types import Command

# Pydantic for data validation
from pydantic import BaseModel, Field

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class GraphSearchState(TypedDict):
    """Enhanced state for the enterprise graph search system."""
    messages: Annotated[List[BaseMessage], "The conversation messages"]
    user_query: str
    graph_schema: Optional[str]
    conceptual_schema: Optional[Dict[str, Any]]
    cypher_queries: Optional[List[str]]
    graph_results: Optional[List[Dict[str, Any]]]
    indirect_relationships: Optional[List[Dict[str, Any]]]
    analysis_insights: Optional[List[str]]
    follow_up_questions: Optional[List[str]]
    final_answer: Optional[str]
    current_agent: Optional[str]
    metadata: Dict[str, Any]


class EnhancedGraphRAGEngine:
    """Enhanced Enterprise Graph RAG Engine with follow-up questions and indirect path exploration."""
    
    def __init__(self, 
                 openai_api_key: str,
                 openai_base_url: Optional[str] = None,
                 falkordb_host: str = 'localhost',
                 falkordb_port: int = 6379,
                 graph_name: str = 'test_cor'):
        
        self.graph_name = graph_name
        
        # Initialize OpenAI LLM
        self.llm = ChatOpenAI(
            model="o3-mini",
            api_key=openai_api_key,
            base_url=openai_base_url,
            temperature=0.1
        )
        
        # Initialize FalkorDB Graph wrapper
        self.graph = FalkorDBGraph(
            database=graph_name,
            host=falkordb_host,
            port=falkordb_port
        )
        
        # Initialize FalkorDB QA Chain with enhanced prompts
        self.qa_chain = FalkorDBQAChain.from_llm(
            llm=self.llm,
            graph=self.graph,
            verbose=True,
            allow_dangerous_requests=True,  # Enterprise controlled environment
            return_intermediate_steps=True
        )
        
        # Create the enhanced multi-agent workflow
        self.workflow = self._create_workflow()
        logger.info(f"Enhanced Graph RAG Engine initialized for graph: {graph_name}")
        
    def _create_tools(self) -> List[BaseTool]:
        """Create enhanced enterprise tools with indirect path exploration."""
        
        @tool
        def get_conceptual_schema() -> str:
            """Get conceptual understanding of the graph schema including business meaning and relationships."""
            try:
                # Get basic schema
                schema_info = {
                    'database': self.graph.database,
                    'raw_schema': self.graph.get_schema,
                    'structured_schema': self.graph.get_structured_schema
                }
                
                # Analyze conceptual patterns
                conceptual_analysis_query = """
                MATCH (n)-[r]->(m)
                RETURN labels(n)[0] as source_type, type(r) as relationship, labels(m)[0] as target_type, 
                       count(*) as frequency,
                       collect(DISTINCT keys(n))[0..3] as source_properties,
                       collect(DISTINCT keys(m))[0..3] as target_properties
                ORDER BY frequency DESC
                LIMIT 20
                """
                
                conceptual_patterns = self.graph.query(conceptual_analysis_query)
                schema_info['conceptual_patterns'] = conceptual_patterns
                
                # Get sample entities for context
                entity_samples_query = """
                MATCH (n)
                WITH labels(n)[0] as entity_type, collect(n)[0..2] as samples
                RETURN entity_type, samples
                LIMIT 10
                """
                
                entity_samples = self.graph.query(entity_samples_query)
                schema_info['entity_samples'] = entity_samples
                
                return json.dumps(schema_info, indent=2, default=str)
            except Exception as e:
                return f"Conceptual schema retrieval error: {str(e)}"
        
        @tool
        def execute_enhanced_graph_qa(question: str, explore_indirect: bool = True) -> str:
            """Execute enhanced question against the graph with option for indirect relationship exploration."""
            try:
                logger.info(f"Executing enhanced graph QA: {question[:100]}...")
                
                # First get direct answer
                result = self.qa_chain.invoke({"query": question})
                
                response = {
                    'direct_answer': result.get('result', ''),
                    'cypher_query': result.get('intermediate_steps', [{}])[0].get('query', '') if result.get('intermediate_steps') else '',
                    'context': result.get('intermediate_steps', [{}])[0].get('context', '') if result.get('intermediate_steps') else ''
                }
                
                # If exploring indirect paths, enhance with multi-hop analysis
                if explore_indirect:
                    indirect_query = f"""
                    Based on the question: "{question}"
                    Find indirect relationships and multi-hop connections that might provide additional insights.
                    Look for patterns that span 2-3 degrees of separation.
                    """
                    
                    try:
                        indirect_result = self.qa_chain.invoke({"query": indirect_query})
                        response['indirect_insights'] = indirect_result.get('result', '')
                        response['indirect_cypher'] = indirect_result.get('intermediate_steps', [{}])[0].get('query', '') if indirect_result.get('intermediate_steps') else ''
                    except Exception as e:
                        response['indirect_insights'] = f"Indirect analysis not available: {str(e)}"
                
                return json.dumps(response, indent=2)
            except Exception as e:
                logger.error(f"Enhanced graph QA execution failed: {e}")
                return json.dumps({'error': f"Enhanced graph QA failed: {str(e)}"}, indent=2)
        
        @tool
        def explore_multi_hop_relationships(entity_or_concept: str, max_hops: int = 3) -> str:
            """Explore multi-hop relationships to find indirect connections and hidden patterns."""
            try:
                # Multi-hop exploration query
                multi_hop_query = f"""
                Find all entities and relationships connected to '{entity_or_concept}' 
                within {max_hops} degrees of separation. Include the path and explain 
                the significance of each connection level.
                """
                
                result = self.qa_chain.invoke({"query": multi_hop_query})
                
                return json.dumps({
                    'analysis_type': 'multi_hop_exploration',
                    'focus_entity': entity_or_concept,
                    'max_hops': max_hops,
                    'result': result.get('result', ''),
                    'cypher_used': result.get('intermediate_steps', [{}])[0].get('query', '') if result.get('intermediate_steps') else ''
                }, indent=2)
            except Exception as e:
                return json.dumps({'error': f"Multi-hop exploration failed: {str(e)}"}, indent=2)
        
        @tool
        def analyze_conceptual_clusters() -> str:
            """Analyze conceptual clusters and communities in the graph to understand business domains."""
            try:
                cluster_query = """
                Identify clusters, communities, and conceptual groupings in the graph.
                Look for entities that are strongly connected and might represent 
                business domains, organizational units, or functional areas.
                """
                
                result = self.qa_chain.invoke({"query": cluster_query})
                
                return json.dumps({
                    'analysis_type': 'conceptual_clustering',
                    'result': result.get('result', ''),
                    'cypher_used': result.get('intermediate_steps', [{}])[0].get('query', '') if result.get('intermediate_steps') else ''
                }, indent=2)
            except Exception as e:
                return json.dumps({'error': f"Conceptual clustering failed: {str(e)}"}, indent=2)
        
        @tool
        def find_bridge_entities() -> str:
            """Find bridge entities that connect different parts of the graph - often critical business connectors."""
            try:
                bridge_query = """
                Find entities that act as bridges between different clusters or domains.
                These are often critical business connectors, integration points, or key stakeholders.
                """
                
                result = self.qa_chain.invoke({"query": bridge_query})
                
                return json.dumps({
                    'analysis_type': 'bridge_analysis',
                    'result': result.get('result', ''),
                    'cypher_used': result.get('intermediate_steps', [{}])[0].get('query', '') if result.get('intermediate_steps') else ''
                }, indent=2)
            except Exception as e:
                return json.dumps({'error': f"Bridge analysis failed: {str(e)}"}, indent=2)
        
        @tool
        def generate_follow_up_questions(original_query: str, analysis_result: str) -> str:
            """Generate intelligent follow-up questions based on the analysis result."""
            try:
                follow_up_prompt = f"""
                Based on the original question: "{original_query}"
                And the analysis result: "{analysis_result[:500]}..."
                
                Generate 5-7 intelligent follow-up questions that would:
                1. Explore deeper into the findings
                2. Investigate related business implications
                3. Uncover hidden patterns or relationships
                4. Address potential risks or opportunities
                5. Explore indirect connections revealed
                6. Question assumptions or explore alternatives
                7. Focus on actionable business insights
                
                Make the questions specific, business-relevant, and thought-provoking.
                """
                
                result = self.qa_chain.invoke({"query": follow_up_prompt})
                
                return json.dumps({
                    'analysis_type': 'follow_up_generation',
                    'original_query': original_query,
                    'follow_up_questions': result.get('result', ''),
                    'generated_at': datetime.now().isoformat()
                }, indent=2)
            except Exception as e:
                return json.dumps({'error': f"Follow-up generation failed: {str(e)}"}, indent=2)
        
        return [get_conceptual_schema, execute_enhanced_graph_qa, explore_multi_hop_relationships, 
                analyze_conceptual_clusters, find_bridge_entities, generate_follow_up_questions]
    
    def _create_agents(self) -> Dict[str, Any]:
        """Create enhanced specialized agents with conceptual understanding."""
        
        tools = self._create_tools()
        
        # Conceptual Schema Agent - Enhanced
        conceptual_schema_agent = create_react_agent(
            self.llm,
            tools=[tools[0], tools[3], tools[4]],  # conceptual_schema, clusters, bridges
            state_modifier="""You are an enterprise conceptual schema analyst with deep business intelligence. Your expertise includes:
            
            🧠 CONCEPTUAL UNDERSTANDING:
            • Understand not just the structure but the MEANING behind entities and relationships
            • Identify business domains, organizational patterns, and functional clusters
            • Recognize implicit business rules and conceptual hierarchies
            • Map technical schema to business concepts and strategic value
            
            🔍 ANALYSIS APPROACH:
            • Use get_conceptual_schema() to understand business meaning, not just technical structure
            • Use analyze_conceptual_clusters() to identify business domains and communities
            • Use find_bridge_entities() to identify critical business connectors
            • Focus on WHY entities are connected, not just HOW
            
            🎯 BUSINESS PERSPECTIVE:
            • Interpret schema in terms of business value and strategic importance
            • Identify conceptual patterns that indicate business processes
            • Recognize organizational hierarchies and reporting structures
            • Understand domain boundaries and integration points
            
            Always provide insights that help business leaders understand their data landscape conceptually, not just technically."""
        )
        
        # Enhanced Query Planning Agent
        strategic_query_agent = create_react_agent(
            self.llm,
            tools=[tools[0], tools[2], tools[3]],  # schema, multi_hop, clusters
            state_modifier="""You are a strategic business intelligence planner. Your expertise includes:
            
            🎯 STRATEGIC THINKING:
            • Break down complex business questions into investigative strategies
            • Always consider BOTH direct and indirect relationships
            • Think about multi-hop connections that might reveal hidden insights
            • Focus on business implications and strategic value
            
            🔍 INDIRECT EXPLORATION:
            • Use explore_multi_hop_relationships() to find indirect connections
            • Look for patterns that span multiple degrees of separation
            • Consider how entities influence each other through intermediaries
            • Identify indirect dependencies and influence chains
            
            🧠 CONCEPTUAL APPROACH:
            • Use get_conceptual_schema() to understand the business context
            • Use analyze_conceptual_clusters() to identify related business domains
            • Think about business processes, not just data relationships
            • Consider temporal aspects and business workflows
            
            Always plan analysis strategies that explore both obvious and hidden business insights."""
        )
        
        # Enhanced Graph Execution Agent
        advanced_execution_agent = create_react_agent(
            self.llm,
            tools=[tools[1], tools[2], tools[4]],  # enhanced_qa, multi_hop, bridges
            state_modifier="""You are an advanced graph analysis execution specialist. Your expertise includes:
            
            ⚡ EXECUTION EXCELLENCE:
            • Execute complex multi-dimensional graph queries
            • Always explore BOTH direct and indirect relationships using explore_indirect=True
            • Use explore_multi_hop_relationships() for comprehensive connectivity analysis
            • Use find_bridge_entities() to identify critical connection points
            
            🔍 COMPREHENSIVE ANALYSIS:
            • Never settle for simple direct path answers
            • Always consider multi-hop relationships and indirect influences
            • Look for hidden patterns and non-obvious connections
            • Analyze the full context, not just immediate relationships
            
            🎯 BUSINESS VALUE:
            • Focus on extracting insights that have business significance
            • Identify patterns that indicate business processes or risks
            • Consider how indirect relationships affect business outcomes
            • Extract actionable intelligence from complex graph patterns
            
            Always ensure your analysis explores the full depth and complexity of business relationships."""
        )
        
        # Enhanced Business Intelligence Agent
        strategic_intelligence_agent = create_react_agent(
            self.llm,
            tools=tools,  # All tools available for comprehensive analysis
            state_modifier="""You are a strategic business intelligence synthesizer. Your expertise includes:
            
            📊 STRATEGIC SYNTHESIS:
            • Transform complex graph insights into strategic business intelligence
            • Synthesize direct and indirect relationship insights into actionable recommendations
            • Identify strategic opportunities, risks, and optimization areas
            • Create executive-ready insights with clear business value
            
            💡 INSIGHT GENERATION:
            • Connect technical graph findings to business outcomes
            • Identify trends, patterns, and anomalies with business significance
            • Provide strategic recommendations based on network analysis
            • Highlight critical success factors and potential failure points
            
            🎯 EXECUTIVE COMMUNICATION:
            • Present findings in clear, jargon-free business language
            • Focus on strategic implications and actionable insights
            • Provide risk assessments and opportunity identification
            • Create summaries that support strategic decision-making
            
            Always deliver intelligence that directly supports enterprise strategy and operations."""
        )
        
        # NEW: Follow-up Question Generation Agent
        follow_up_agent = create_react_agent(
            self.llm,
            tools=[tools[5]],  # generate_follow_up_questions
            state_modifier="""You are an intelligent follow-up question specialist. Your expertise includes:
            
            🤔 QUESTION INTELLIGENCE:
            • Generate thoughtful follow-up questions that deepen business understanding
            • Consider both direct findings and indirect implications revealed in analysis
            • Focus on questions that uncover hidden business value or risks
            • Create questions that explore the "so what" and "what if" scenarios
            
            🔍 EXPLORATION DEPTH:
            • Generate questions that explore multi-hop relationships discovered
            • Ask about business implications of indirect connections
            • Question assumptions and explore alternative interpretations
            • Focus on actionable business insights and decision points
            
            🎯 BUSINESS RELEVANCE:
            • Ensure all questions have clear business value and strategic relevance
            • Focus on questions that help executives make better decisions
            • Consider operational, strategic, and risk management perspectives
            • Generate questions that explore optimization and growth opportunities
            
            Always create follow-up questions that advance business understanding and strategic thinking."""
        )
        
        return {
            'conceptual_schema_agent': conceptual_schema_agent,
            'strategic_query_agent': strategic_query_agent,
            'advanced_execution_agent': advanced_execution_agent,
            'strategic_intelligence_agent': strategic_intelligence_agent,
            'follow_up_agent': follow_up_agent
        }
    
    def _create_supervisor_agent(self) -> Any:
        """Create enhanced supervisor agent for intelligent workflow orchestration."""
        
        supervisor_prompt = ChatPromptTemplate.from_template("""
        You are supervising an advanced enterprise graph intelligence team with the following specialists:
        
        🧠 Conceptual Schema Agent: Deep conceptual understanding of business domains and relationships
        🎯 Strategic Query Agent: Plans comprehensive analysis including indirect relationships  
        ⚡ Advanced Execution Agent: Executes multi-dimensional queries with indirect path exploration
        📊 Strategic Intelligence Agent: Creates strategic business insights and recommendations
        🤔 Follow-up Agent: Generates intelligent follow-up questions for deeper exploration
        
        Current business question: "{user_query}"
        
        Conversation progress: {messages}
        
        ENHANCED DECISION FRAMEWORK:
        
        For complex business intelligence queries, follow this enhanced workflow:
        1. Conceptual Schema Agent: For deep understanding of business context and meaning
        2. Strategic Query Agent: To plan comprehensive analysis including indirect relationships
        3. Advanced Execution Agent: To extract both direct and indirect insights
        4. Strategic Intelligence Agent: To synthesize strategic business intelligence
        5. Follow-up Agent: To generate intelligent follow-up questions
        6. FINISH: When comprehensive analysis with follow-ups is complete
        
        INTELLIGENT ROUTING:
        - New complex questions → Start with conceptual_schema_agent
        - Follow-up questions → Route to most relevant specialist based on question type
        - Strategic analysis → strategic_intelligence_agent
        - Multi-hop exploration → advanced_execution_agent
        - Need follow-ups → follow_up_agent
        - Simple queries → advanced_execution_agent
        
        ALWAYS ensure both direct AND indirect relationships are explored for comprehensive insights.
        
        Options: conceptual_schema_agent, strategic_query_agent, advanced_execution_agent, strategic_intelligence_agent, follow_up_agent, FINISH
        
        Respond with just the agent name or FINISH.
        """)
        
        supervisor = supervisor_prompt | self.llm
        return supervisor
    
    def _create_workflow(self) -> StateGraph:
        """Create enhanced LangGraph workflow with follow-up question generation."""
        
        # Create agents
        agents = self._create_agents()
        supervisor = self._create_supervisor_agent()
        
        # Define workflow
        workflow = StateGraph(GraphSearchState)
        
        # Add agent nodes
        for agent_name, agent in agents.items():
            workflow.add_node(agent_name, agent)
        
        # Add supervisor node
        def supervisor_node(state: GraphSearchState) -> GraphSearchState:
            """Enhanced supervisor decision node."""
            result = supervisor.invoke({
                "user_query": state["user_query"],
                "messages": state["messages"]
            })
            
            next_agent = result.content.strip().lower()
            
            if next_agent == "finish":
                state["current_agent"] = "FINISH"
            else:
                state["current_agent"] = next_agent
                
            return state
        
        workflow.add_node("supervisor", supervisor_node)
        
        # Add edges
        workflow.add_edge(START, "supervisor")
        
        # Conditional edges from supervisor to agents
        def route_supervisor(state: GraphSearchState) -> str:
            current_agent = state.get("current_agent", "").lower()
            if current_agent == "finish":
                return END
            elif current_agent in agents:
                return current_agent
            else:
                return "strategic_query_agent"  # Default fallback
        
        workflow.add_conditional_edges(
            "supervisor",
            route_supervisor,
            {
                "conceptual_schema_agent": "conceptual_schema_agent",
                "strategic_query_agent": "strategic_query_agent", 
                "advanced_execution_agent": "advanced_execution_agent",
                "strategic_intelligence_agent": "strategic_intelligence_agent",
                "follow_up_agent": "follow_up_agent",
                END: END
            }
        )
        
        # Add edges back to supervisor from each agent
        for agent_name in agents.keys():
            workflow.add_edge(agent_name, "supervisor")
        
        # Compile workflow
        memory = MemorySaver()
        return workflow.compile(checkpointer=memory)
    
    async def search_with_followups(self, user_query: str, thread_id: str = "default") -> Tuple[str, List[str]]:
        """Execute search and return both answer and follow-up questions."""
        
        initial_state = GraphSearchState(
            messages=[HumanMessage(content=user_query)],
            user_query=user_query,
            graph_schema=None,
            conceptual_schema=None,
            cypher_queries=None,
            graph_results=None,
            indirect_relationships=None,
            analysis_insights=None,
            follow_up_questions=None,
            final_answer=None,
            current_agent=None,
            metadata={
                "timestamp": datetime.now().isoformat(),
                "thread_id": thread_id,
                "graph_database": self.graph_name,
                "analysis_type": "enhanced_enterprise_intelligence",
                "includes_followups": True
            }
        )
        
        config = {"configurable": {"thread_id": thread_id}}
        
        try:
            logger.info(f"Processing enhanced query with follow-ups: {user_query}")
            
            # Run the workflow
            final_state = await self.workflow.ainvoke(initial_state, config=config)
            
            # Extract answer and follow-up questions
            answer = None
            follow_ups = []
            
            # Get the main answer
            for message in reversed(final_state["messages"]):
                if isinstance(message, AIMessage) and not answer:
                    answer = message.content
                    break
            
            # Look for follow-up questions in the messages
            for message in final_state["messages"]:
                if isinstance(message, AIMessage) and "follow_up" in message.content.lower():
                    try:
                        # Try to extract follow-up questions from the message
                        content = message.content
                        if "follow_up_questions" in content:
                            # Parse JSON if present
                            import re
                            json_match = re.search(r'\{.*"follow_up_questions".*\}', content, re.DOTALL)
                            if json_match:
                                follow_up_data = json.loads(json_match.group())
                                follow_up_text = follow_up_data.get("follow_up_questions", "")
                                # Extract individual questions
                                lines = follow_up_text.split('\n')
                                questions = [line.strip() for line in lines if line.strip() and ('?' in line or line.startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.')))]
                                follow_ups.extend(questions[:7])  # Limit to 7 questions
                    except:
                        pass
            
            if not answer:
                answer = "I apologize, but I couldn't generate a comprehensive analysis for your query."
            
            logger.info(f"Enhanced analysis completed with {len(follow_ups)} follow-up questions")
            return answer, follow_ups
            
        except Exception as e:
            error_msg = f"Enhanced analysis failed: {str(e)}"
            logger.error(error_msg)
            return error_msg, []
    
    async def search(self, user_query: str, thread_id: str = "default") -> str:
        """Execute search (backward compatibility)."""
        answer, _ = await self.search_with_followups(user_query, thread_id)
        return answer
    
    def search_sync(self, user_query: str, thread_id: str = "default") -> str:
        """Synchronous version of search method."""
        return asyncio.run(self.search(user_query, thread_id))
    
    def search_with_followups_sync(self, user_query: str, thread_id: str = "default") -> Tuple[str, List[str]]:
        """Synchronous version of search with follow-ups."""
        return asyncio.run(self.search_with_followups(user_query, thread_id))
    
    def get_graph_info(self) -> Dict[str, Any]:
        """Get comprehensive graph information using LangChain integration."""
        try:
            return {
                'database_name': self.graph.database,
                'schema': self.graph.get_schema,
                'structured_schema': self.graph.get_structured_schema,
                'connection_info': {
                    'host': getattr(self.graph, '_host', 'localhost'),
                    'port': getattr(self.graph, '_port', 6379),
                    'connected': True
                },
                'enhanced_features': {
                    'follow_up_questions': True,
                    'indirect_path_exploration': True,
                    'conceptual_understanding': True,
                    'multi_hop_analysis': True
                },
                'generated_at': datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Failed to get graph info: {e}")
            return {'error': str(e), 'connected': False}
    
    def test_connection(self) -> Dict[str, Any]:
        """Test the FalkorDB connection using LangChain integration."""
        try:
            # Simple test query
            test_result = self.graph.query("RETURN 'connection_test' as status")
            return {
                'status': 'connected',
                'database': self.graph.database,
                'test_result': test_result,
                'enhanced_features': True,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            return {
                'status': 'failed',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }


class EnterpriseConfig:
    """Enterprise configuration management."""
    
    def __init__(self):
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.openai_base_url = os.getenv("OPENAI_BASE_URL")
        self.falkordb_host = os.getenv("FALKORDB_HOST", "localhost")
        self.falkordb_port = int(os.getenv("FALKORDB_PORT", "6379"))
        self.graph_name = os.getenv("GRAPH_NAME", "test_cor")
    
    def validate(self) -> bool:
        """Validate enterprise configuration."""
        if not self.openai_api_key:
            raise ValueError("OPENAI_API_KEY is required for enterprise deployment")
        return True


def main():
    """Enhanced command-line interface with follow-up questions and indirect exploration."""
    parser = argparse.ArgumentParser(
        description="Enhanced Enterprise FalkorDB Graph RAG Search Engine with Follow-up Questions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python graph_rag_search.py --query "What are the key business relationships?" --follow-ups
  python graph_rag_search.py --query "Find influential entities" --thread-id "analysis_001" --indirect
  python graph_rag_search.py --interactive-enhanced
  python graph_rag_search.py --test-connection
        """
    )
    
    parser.add_argument("--query", "-q", help="Business analysis query")
    parser.add_argument("--thread-id", "-t", default="default", help="Analysis session ID")
    parser.add_argument("--config-file", "-c", help="Path to configuration file")
    parser.add_argument("--interactive-enhanced", "-ie", action="store_true", help="Enhanced interactive mode with follow-ups")
    parser.add_argument("--follow-ups", "-f", action="store_true", help="Generate follow-up questions")
    parser.add_argument("--indirect", "-i", action="store_true", help="Focus on indirect relationships")
    parser.add_argument("--test-connection", action="store_true", help="Test FalkorDB connection")
    parser.add_argument("--graph-info", action="store_true", help="Show enhanced graph information")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Load configuration
    config = EnterpriseConfig()
    
    if args.config_file:
        with open(args.config_file, 'r') as f:
            config_data = json.load(f)
            for key, value in config_data.items():
                setattr(config, key, value)
    
    try:
        config.validate()
    except ValueError as e:
        print(f"❌ Configuration Error: {e}")
        return 1
    
    # Print enhanced banner
    print("🚀 Enhanced Enterprise FalkorDB Graph RAG Search Engine")
    print("=" * 65)
    print(f"📊 Graph Database: {config.graph_name}")
    print(f"🔗 FalkorDB: {config.falkordb_host}:{config.falkordb_port}")
    print(f"🤖 AI Model: OpenAI o3-mini")
    print(f"🔧 Integration: Enhanced LangChain FalkorDBQAChain")
    print(f"✨ Features: Follow-ups • Indirect Paths • Conceptual Understanding")
    print(f"🔒 Security: No external connectivity")
    print("=" * 65)
    
    try:
        engine = EnhancedGraphRAGEngine(
            openai_api_key=config.openai_api_key,
            openai_base_url=config.openai_base_url,
            falkordb_host=config.falkordb_host,
            falkordb_port=config.falkordb_port,
            graph_name=config.graph_name
        )
        
        print("✅ Enhanced enterprise engine initialized successfully")
        
    except Exception as e:
        print(f"❌ Failed to initialize engine: {e}")
        return 1
    
    # Handle different modes
    if args.test_connection:
        print("\n🔍 Testing Enhanced FalkorDB Connection...")
        result = engine.test_connection()
        if result['status'] == 'connected':
            print(f"✅ Connection successful to database: {result['database']}")
            print(f"🚀 Enhanced features: {'✅' if result.get('enhanced_features') else '❌'}")
        else:
            print(f"❌ Connection failed: {result['error']}")
        return 0
    
    if args.graph_info:
        print("\n📊 Enhanced Graph Information:")
        print("-" * 40)
        info = engine.get_graph_info()
        if 'error' not in info:
            print(f"Database: {info['database_name']}")
            print(f"Enhanced Features:")
            for feature, enabled in info.get('enhanced_features', {}).items():
                print(f"  • {feature.replace('_', ' ').title()}: {'✅' if enabled else '❌'}")
        else:
            print(f"❌ Error: {info['error']}")
        return 0
    
    if args.interactive_enhanced:
        print("\n🚀 Enhanced Interactive Analysis Mode")
        print("💡 Features:")
        print("  • Intelligent follow-up questions after each analysis")
        print("  • Automatic indirect relationship exploration")
        print("  • Conceptual understanding of business domains")
        print("  • Multi-hop relationship discovery")
        print("-" * 65)
        
        while True:
            try:
                query = input(f"\n[{args.thread_id}] 🔍 Business Query: ").strip()
                if query.lower() in ['exit', 'quit', 'q']:
                    print("👋 Ending enhanced analysis session...")
                    break
                
                if not query:
                    continue
                
                print("\n🤖 Analyzing with enhanced multi-agent intelligence...")
                print("   • Exploring direct AND indirect relationships")
                print("   • Understanding conceptual business context")
                print("   • Generating intelligent follow-up questions")
                
                # Get answer and follow-ups
                answer, follow_ups = engine.search_with_followups_sync(query, args.thread_id)
                
                print(f"\n📊 ENHANCED ANALYSIS:")
                print("=" * 60)
                print(answer)
                print("=" * 60)
                
                # Display follow-up questions
                if follow_ups:
                    print(f"\n🤔 INTELLIGENT FOLLOW-UP QUESTIONS:")
                    print("-" * 40)
                    for i, follow_up in enumerate(follow_ups[:7], 1):
                        clean_question = follow_up.strip().lstrip('0123456789.- ')
                        if clean_question and '?' in clean_question:
                            print(f"{i}. {clean_question}")
                    
                    # Allow user to select a follow-up
                    print("\n💡 Enter a number (1-7) to explore a follow-up question, or ask a new question:")
                    try:
                        follow_up_input = input("Choice (or new query): ").strip()
                        if follow_up_input.isdigit():
                            idx = int(follow_up_input) - 1
                            if 0 <= idx < len(follow_ups):
                                selected_follow_up = follow_ups[idx].strip().lstrip('0123456789.- ')
                                if selected_follow_up:
                                    print(f"\n🔍 Following up: {selected_follow_up}")
                                    follow_answer, _ = engine.search_with_followups_sync(selected_follow_up, args.thread_id)
                                    print(f"\n📋 FOLLOW-UP ANALYSIS:")
                                    print("-" * 50)
                                    print(follow_answer)
                                    print("-" * 50)
                    except (ValueError, IndexError):
                        pass
                
                print("\n" + "=" * 60)
                
            except KeyboardInterrupt:
                print("\n👋 Enhanced analysis session terminated by user")
                break
            except Exception as e:
                print(f"❌ Enhanced analysis error: {e}")
        
        return 0
    
    if args.query:
        print(f"\n🔍 Business Query: {args.query}")
        if args.indirect:
            print("🌐 Focus: Indirect relationships and multi-hop analysis")
        if args.follow_ups:
            print("🤔 Generating: Intelligent follow-up questions")
        print("-" * 65)
        
        try:
            if args.follow_ups:
                result, follow_ups = engine.search_with_followups_sync(args.query, args.thread_id)
                print(f"\n📊 ENHANCED ANALYSIS:\n{result}")
                
                if follow_ups:
                    print(f"\n🤔 FOLLOW-UP QUESTIONS:")
                    print("-" * 30)
                    for i, follow_up in enumerate(follow_ups[:7], 1):
                        clean_question = follow_up.strip().lstrip('0123456789.- ')
                        if clean_question and '?' in clean_question:
                            print(f"{i}. {clean_question}")
            else:
                result = engine.search_sync(args.query, args.thread_id)
                print(f"\n📊 ANALYSIS:\n{result}")
                
        except Exception as e:
            print(f"❌ Analysis failed: {e}")
            return 1
    else:
        print("\n⚠️  No query provided. Use --query, --interactive-enhanced, or --test-connection")
        parser.print_help()
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())
