import os
import sys
import uuid
import json
import logging
import chardet
import pandas as pd
import networkx as nx
from typing import Optional, Dict, Any, List, Union
from pathlib import Path
from pydantic import BaseModel, ValidationError

# ... [Keep all previous imports and constants unchanged] ...

###############################################################################
# Pydantic Models for Validation
###############################################################################
class QualityRating(BaseModel):
    rating: str
    reason: str

    @classmethod
    def parse_raw_safe(cls, raw_json: str) -> Optional['QualityRating']:
        """Safe parsing with error handling"""
        try:
            # First try direct parsing
            return cls.model_validate_json(raw_json)
        except (ValidationError, json.JSONDecodeError):
            try:
                # Try to extract JSON substring
                start = raw_json.find('{')
                end = raw_json.rfind('}') + 1
                if start == -1 or end == 0:
                    return None
                return cls.model_validate_json(raw_json[start:end])
            except (ValidationError, json.JSONDecodeError):
                return None

###############################################################################
# Enhanced QualityCheckChain with Pydantic
###############################################################################
class QualityCheckChain:
    """
    Uses Pydantic model for strict output validation instead of prompt engineering
    """
    def __init__(self, llm):
        self.llm = llm

        template = """
Analyze the user input and candidate document. Return JSON with:
- "rating" (Green/Amber/Red)
- "reason" (brief explanation)

User input: {user_input}
Candidate doc: {candidate_doc}
"""
        self.prompt = PromptTemplate(
            input_variables=["user_input", "candidate_doc"],
            template=template
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)

    def check_quality(self, user_input: str, candidate_doc: str) -> Dict[str, str]:
        """Validate response using Pydantic model"""
        try:
            raw_response = self.chain.run(
                user_input=user_input,
                candidate_doc=candidate_doc
            ).strip()

            # Try to parse with Pydantic
            if parsed := QualityRating.parse_raw_safe(raw_response):
                return {
                    "rating": parsed.rating, 
                    "reason": parsed.reason
                }
            
            # Fallback for invalid responses
            return {
                "rating": "Red",
                "reason": "Invalid response format"
            }

        except Exception as e:
            logger.error(f"Quality check error: {str(e)}")
            return {
                "rating": "Red",
                "reason": "Evaluation failed"
            }

# ... [Keep AzureChatbot and other classes unchanged] ...

###############################################################################
# Updated KnowledgeBase Class with Pydantic Validation
###############################################################################
class KnowledgeBase:
    def __init__(self, csv_path: str):
        """Added Pydantic validation for CSV data"""
        self.csv_path = csv_path
        self.docs: List[LC_Document] = []
        self.graph = nx.MultiDiGraph()
        self._validate_csv()
        self._read_csv_and_build()

    def _validate_csv(self):
        """Ensure CSV has required columns"""
        if not os.path.isfile(self.csv_path):
            raise FileNotFoundError(f"CSV not found: {self.csv_path}")
            
        with open(self.csv_path, "rb") as f:
            rawdata = f.read(100000)
            
        result = chardet.detect(rawdata)
        df = pd.read_csv(self.csv_path, encoding=result['encoding'])
        
        # Pydantic validation
        class CSVStructure(BaseModel):
            columns: List[str]
            
        try:
            CSVStructure(columns=list(df.columns))
        except ValidationError as e:
            raise ValueError(
                f"Invalid CSV structure: {e}\n"
                f"Required columns: name, definition"
            )

# ... [Keep rest of the code identical] ...
