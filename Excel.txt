import os
import time
import logging
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
from dotenv import load_dotenv, dotenv_values
from azure.identity import ClientSecretCredential
import pandas as pd
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.vectorstores import Milvus
from pymilvus import MilvusLite, connections

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_file_readable(filepath: str) -> bool:
    """Check if a file exists and is readable."""
    if not os.path.isfile(filepath) or not os.access(filepath, os.R_OK):
        raise FileNotFoundError(f"The file '{filepath}' does not exist or is not readable")
    return True

def str_to_bool(s: str) -> bool:
    """Convert string to boolean."""
    if s == 'True':
        return True
    elif s == 'False':
        return False
    else:
        raise ValueError(f"Invalid boolean string: {s}")

class OSEnv:
    """Environment variable and certificate management class."""
    
    def __init__(self, config_file: str, creds_file: str, certificate_path: str):
        """Initialize with configuration files and certificate."""
        self.var_list = []  # hold vars that were set via this class
        
        # Load main configuration
        self.bulk_set(config_file, True)
        logger.info(f"Loaded main configuration from {config_file}")
        
        # Load credentials
        self.bulk_set(creds_file, False)
        logger.info(f"Loaded credentials from {creds_file}")
        
        # Set up certificates
        self.set_certificate_path(certificate_path)
        logger.info("Certificate path configured")
        
        # Configure proxy if enabled
        if str_to_bool(self.get("PROXY_ENABLED", "False")):
            self.set_proxy()
            logger.info("Proxy configured")
        
        # Set up Azure token if secure endpoints enabled
        if str_to_bool(self.get("SECURED_ENDPOINTS", "False")):
            logger.info("Securing endpoints")
            self.token = self.get_azure_token()
        else:
            self.token = None

    def set_certificate_path(self, certificate_path: str) -> None:
        """Set up the certificate path for SSL verification."""
        try:
            if not os.path.isabs(certificate_path):
                certificate_path = os.path.abspath(certificate_path)
            
            if not is_file_readable(certificate_path):
                raise Exception("Certificate file missing or not readable")
            
            # Set the certificate environment variables
            self.set("REQUESTS_CA_BUNDLE", certificate_path)
            self.set("SSL_CERT_FILE", certificate_path)
            self.set("CURL_CA_BUNDLE", certificate_path)
            
            logger.info(f"Certificate path set to: {certificate_path}")
            
        except Exception as e:
            logger.error(f"Certificate configuration failed: {str(e)}")
            raise

    def bulk_set(self, dotenvfile: str, print_val: bool = False) -> None:
        """Read and set environment variables from a dotenv file."""
        try:
            if not os.path.isabs(dotenvfile):
                dotenvfile = os.path.abspath(dotenvfile)
                
            if is_file_readable(dotenvfile):
                logger.info(f"Loading environment variables from {dotenvfile}")
                temp_dict = dotenv_values(dotenvfile)
                for k, v in temp_dict.items():
                    self.set(k, v, print_val)
                del temp_dict
        except Exception as e:
            logger.error(f"Failed to load environment file {dotenvfile}: {str(e)}")
            raise

    def set(self, var_name: str, val: str, print_val: bool = True) -> None:
        """Set an environment variable."""
        try:
            os.environ[var_name] = val
            if var_name not in self.var_list:
                self.var_list.append(var_name)
            if print_val:
                logger.info(f"Set {var_name}={val}")
        except Exception as e:
            logger.error(f"Failed to set environment variable {var_name}: {str(e)}")
            raise

    def get(self, var_name: str, default: Optional[str] = None) -> Optional[str]:
        """Get an environment variable value."""
        try:
            return os.environ[var_name]
        except KeyError:
            logger.warning(f"Environment variable {var_name} not found")
            return default

    def set_proxy(self) -> None:
        """Set up proxy configuration with authentication."""
        try:
            ad_username = self.get("AD_USERNAME")
            ad_password = self.get("AD_USER_PW")
            proxy_domain = self.get("HTTPS_PROXY_DOMAIN")
            
            if not all([ad_username, ad_password, proxy_domain]):
                raise ValueError("Missing proxy credentials")
            
            proxy_url = f"http://{ad_username}:{ad_password}@{proxy_domain}"
            self.set("HTTP_PROXY", proxy_url, print_val=False)
            self.set("HTTPS_PROXY", proxy_url, print_val=False)
            
            # Set no_proxy for Azure services
            no_proxy_domains = [
                'cognitiveservices.azure.com',
                'search.windows.net',
                'openai.azure.com',
                'core.windows.net',
                'azurewebsites.net'
            ]
            self.set("NO_PROXY", ",".join(no_proxy_domains))
            
            logger.info("Proxy configuration completed")
            
        except Exception as e:
            logger.error(f"Proxy configuration failed: {str(e)}")
            raise

    def get_azure_token(self) -> str:
        """Get Azure authentication token."""
        try:
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET")
            )
            token = credential.get_token("https://cognitiveservices.azure.com/.default")
            self.set("AZURE_TOKEN", token.token, print_val=False)
            logger.info("Azure token acquired successfully")
            return token.token
            
        except Exception as e:
            logger.error(f"Failed to get Azure token: {str(e)}")
            raise

    def list_env_vars(self) -> None:
        """List all environment variables set by this class."""
        for var in self.var_list:
            if var in {'AZURE_TOKEN', 'AD_USER_PW', 'AZURE_CLIENT_SECRET'}:
                logger.info(f"{var}: [HIDDEN]")
            else:
                logger.info(f"{var}: {self.get(var)}")

class VectorSearch:
    """Vector search implementation using Azure OpenAI embeddings and Milvus Lite."""
    
    def __init__(self, env: OSEnv, milvus_lite_path: str = "./milvus_lite_data"):
        """
        Initialize with OSEnv configuration.
        
        Args:
            env: OSEnv instance for configuration
            milvus_lite_path: Path where Milvus Lite will store its data
        """
        self.env = env
        self.milvus_lite_path = milvus_lite_path
        self._setup_embeddings()
        self._setup_milvus_lite()
        
    def _setup_embeddings(self) -> None:
        """Configure Azure OpenAI embeddings."""
        try:
            self.embeddings = AzureOpenAIEmbeddings(
                deployment="text-embedding-3-large",
                model="text-embedding-3-large",
                api_version=self.env.get("API_VERSION", "2024-02-01"),
                azure_endpoint=self.env.get("AZURE_OPENAI_ENDPOINT"),
                azure_ad_token=self.env.token
            )
            logger.info("Azure OpenAI embeddings initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize embeddings: {str(e)}")
            raise

    def _setup_milvus_lite(self) -> None:
        """Configure Milvus Lite connection."""
        try:
            # Initialize Milvus Lite
            lite = MilvusLite()
            lite.config(path=self.milvus_lite_path)
            
            # Connect to Milvus Lite
            connections.connect(alias="default", lite=lite)
            
            logger.info(f"Milvus Lite initialized at {self.milvus_lite_path}")
            
        except Exception as e:
            logger.error(f"Failed to configure Milvus Lite: {str(e)}")
            raise

    def load_data(self, csv_path: str) -> pd.DataFrame:
        """Load data from CSV file."""
        try:
            df = pd.read_csv(csv_path)
            if len(df.columns) != 2:
                raise ValueError(f"CSV must have exactly 2 columns, found {len(df.columns)}")
            logger.info(f"Successfully loaded {len(df)} rows from {csv_path}")
            return df
        except Exception as e:
            logger.error(f"Failed to load CSV data: {str(e)}")
            raise

    def create_vector_store(self, 
                          data: pd.DataFrame,
                          text_column: str,
                          collection_name: str) -> None:
        """Create Milvus Lite vector store from DataFrame."""
        try:
            texts = data[text_column].tolist()
            metadatas = [{"source": str(i)} for i in range(len(texts))]
            
            # Create Milvus collection with Lite connection
            self.vector_store = Milvus.from_texts(
                texts=texts,
                embedding=self.embeddings,
                collection_name=collection_name,
                connection_args={"alias": "default"},  # Uses the default Lite connection
                metadatas=metadatas
            )
            
            logger.info(f"Successfully created Milvus Lite collection: {collection_name}")
            
        except Exception as e:
            logger.error(f"Failed to create vector store: {str(e)}")
            raise

    def similarity_search(self, 
                        query: str, 
                        k: int = 5) -> List[Tuple[str, float]]:
        """Perform similarity search."""
        try:
            results = self.vector_store.similarity_search_with_score(query, k=k)
            
            # Format results
            search_results = []
            for doc, score in results:
                search_results.append((doc.page_content, score))
            
            logger.info(f"Successfully performed similarity search for query: {query}")
            return search_results
            
        except Exception as e:
            logger.error(f"Failed to perform similarity search: {str(e)}")
            raise

    def close(self):
        """Close Milvus Lite connection."""
        try:
            connections.disconnect("default")
            logger.info("Closed Milvus Lite connection")
        except Exception as e:
            logger.error(f"Error closing Milvus Lite connection: {str(e)}")

def main():
    """Example usage of the vector search system."""
    try:
        # Define paths to config files
        env_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'env')
        config_path = os.path.join(env_dir, 'config.env')
        creds_path = os.path.join(env_dir, 'credentials.env')
        cert_path = os.path.join(env_dir, 'cacert.pem')
        
        # Check if files exist
        required_files = {
            'config.env': config_path,
            'credentials.env': creds_path,
            'cacert.pem': cert_path
        }
        
        missing_files = []
        for name, path in required_files.items():
            if not os.path.exists(path):
                missing_files.append(name)
        
        if missing_files:
            print(f"\nMissing required files in {env_dir}:")
            for file in missing_files:
                print(f"- {file}")
            return
        
        # Initialize environment
        print("\nInitializing environment...")
        env = OSEnv(config_path, creds_path, cert_path)
        
        # Initialize vector search with Milvus Lite
        print("\nInitializing vector search...")
        vector_search = VectorSearch(env, milvus_lite_path="./milvus_lite_data")
        
        try:
            # Load and process data
            csv_path = input("\nEnter the path to your CSV file: ")
            df = vector_search.load_data(csv_path)
            
            # Get column names and let user select text column
            print("\nAvailable columns:")
            for idx, col in enumerate(df.columns):
                print(f"{idx + 1}: {col}")
            col_idx = int(input("\nEnter the number of the column containing text data: ")) - 1
            text_column = df.columns[col_idx]
            
            # Create vector store
            collection_name = input("\nEnter a name for your vector collection: ")
            print("\nCreating vector store...")
            vector_search.create_vector_store(
                data=df,
                text_column=text_column,
                collection_name=collection_name
            )
            
            # Interactive search loop
            print("\nVector store created! You can now perform similarity searches.")
            print("Type 'quit' to exit")
            
            while True:
                query = input("\nEnter your search query: ")
                if query.lower() == 'quit':
                    break
                    
                k = int(input("How many results would you like? [default=5] ") or "5")
                results = vector_search.similarity_search(query, k=k)
                
                print("\nSearch Results:")
                for i, (text, score) in enumerate(results, 1):
                    print(f"\n{i}. Similarity Score: {score:.4f}")
                    print(f"Text: {text}")
                
        finally:
            # Always close the connection when done
            print("\nClosing connection...")
            vector_search.close()
            
    except Exception as e:
        logger.error(f"An error occurred: {str(e)}")
        raise

if __name__ == "__main__":
    main()
