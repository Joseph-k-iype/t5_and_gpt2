#!/usr/bin/env python3
"""
Example script demonstrating:
- OSEnv class with a fixed set_proxy() that merges NO_PROXY and adds required domains 
  (like login.microsoftonline.com) to bypass corporate proxy for client auth.
- A simple AzureChatOpenAI usage via LangChain to show the environment in action.

Edit or extend this code to match your actual usage (e.g. CSV matching, chatbot, etc.).
"""

import os
import time
import logging
from pathlib import Path
from typing import Optional

# For .env loading
from dotenv import dotenv_values

# For Azure AD token (if SECURED_ENDPOINTS=True)
from azure.identity import ClientSecretCredential

# For demonstration: use a simple AzureChatOpenAI call
from langchain.chat_models import AzureChatOpenAI
from langchain.schema import SystemMessage, HumanMessage

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

###########################
#       OSEnv Class
###########################
def is_file_readable(filepath: str) -> bool:
    """Check if file exists and is readable."""
    if not os.path.isfile(filepath) or not os.access(filepath, os.R_OK):
        raise FileNotFoundError(f"The file '{filepath}' does not exist or is not readable")
    return True

def str_to_bool(s: str) -> bool:
    ls = s.strip().lower()
    if ls == 'true':
        return True
    elif ls == 'false':
        return False
    else:
        raise ValueError(f"Invalid boolean string: {s}")

class OSEnv:
    """
    Environment variable & certificate management. 
    Includes a set_proxy() that merges NO_PROXY and adds required bypass domains.
    """
    
    def __init__(self, config_file: str, creds_file: str, certificate_path: str):
        self.var_list = []
        
        # Load main configuration
        self.bulk_set(config_file, print_val=True)
        logger.info(f"Loaded main configuration from {config_file}")
        
        # Load credentials
        self.bulk_set(creds_file, print_val=False)
        logger.info(f"Loaded credentials from {creds_file}")
        
        # Set up certificate
        self.set_certificate_path(certificate_path)
        logger.info("Certificate path configured.")
        
        # Possibly set up proxy
        if str_to_bool(self.get("PROXY_ENABLED", "false")):
            self.set_proxy()
            logger.info("Proxy configured.")
        
        # Possibly get Azure token if SECURED_ENDPOINTS=True
        if str_to_bool(self.get("SECURED_ENDPOINTS", "false")):
            logger.info("Securing endpoints (AAD token flow).")
            self.token = self.get_azure_token()
        else:
            self.token = None

    def bulk_set(self, dotenvfile: str, print_val: bool) -> None:
        """Load environment variables from a .env file."""
        try:
            if not os.path.isabs(dotenvfile):
                dotenvfile = os.path.abspath(dotenvfile)
            if is_file_readable(dotenvfile):
                env_dict = dotenv_values(dotenvfile)
                for k, v in env_dict.items():
                    self.set(k, v if v else "", print_val=print_val)
        except Exception as e:
            logger.error(f"Failed to load environment file {dotenvfile}: {str(e)}")
            raise

    def set_certificate_path(self, certificate_path: str):
        """Set the certificate env variables if file is readable."""
        if not os.path.isabs(certificate_path):
            certificate_path = os.path.abspath(certificate_path)
        if not is_file_readable(certificate_path):
            raise FileNotFoundError(f"Certificate file not found or not readable: {certificate_path}")
        
        self.set("REQUESTS_CA_BUNDLE", certificate_path)
        self.set("SSL_CERT_FILE", certificate_path)
        self.set("CURL_CA_BUNDLE", certificate_path)
        logger.info(f"Using certificate path: {certificate_path}")

    def set(self, var_name: str, val: str, print_val: bool=True):
        """Set an environment variable for this process."""
        os.environ[var_name] = val
        if var_name not in self.var_list:
            self.var_list.append(var_name)
        if print_val:
            # Hide sensitive vars
            if var_name in ['AZURE_CLIENT_SECRET', 'AD_USER_PW']:
                logger.info(f"Set {var_name}=[HIDDEN]")
            else:
                logger.info(f"Set {var_name}={val}")

    def get(self, var_name: str, default_val: str="") -> str:
        return os.getenv(var_name, default_val)

    def set_proxy(self) -> None:
        """
        Configure proxy and merge NO_PROXY with required bypass domains 
        to avoid client authentication errors.
        """
        ad_username = self.get("AD_USERNAME")
        ad_password = self.get("AD_USER_PW")
        proxy_domain = self.get("HTTPS_PROXY_DOMAIN")
        
        if not all([ad_username, ad_password, proxy_domain]):
            raise ValueError("Missing proxy credentials for PROXY_ENABLED=True.")
        
        proxy_url = f"http://{ad_username}:{ad_password}@{proxy_domain}"
        # Set HTTP_PROXY / HTTPS_PROXY
        self.set("HTTP_PROXY", proxy_url, print_val=False)
        self.set("HTTPS_PROXY", proxy_url, print_val=False)
        
        # Merge existing NO_PROXY with new domains we want to bypass
        existing_no_proxy = self.get("NO_PROXY", "")
        no_proxy_list = [d.strip() for d in existing_no_proxy.split(",") if d.strip()]

        # Add critical domains for Azure AD, OpenAI, etc.
        required_no_proxy = [
            'cognitiveservices.azure.com',
            'search.windows.net',
            'openai.azure.com',
            'core.windows.net',
            'azurewebsites.net',
            'login.microsoftonline.com',  # crucial for AAD token retrieval
            'openaiPublic.blob.core.windows.net'
        ]

        for domain in required_no_proxy:
            if domain not in no_proxy_list:
                no_proxy_list.append(domain)

        merged_no_proxy = ",".join(no_proxy_list)
        self.set("NO_PROXY", merged_no_proxy, print_val=False)
        logger.info(f"Proxy config complete. NO_PROXY={merged_no_proxy}")

    def get_azure_token(self) -> str:
        """
        Acquire Azure AD token if you have AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET.
        Bypass proxy for login.microsoftonline.com is crucial.
        """
        try:
            tenant_id = self.get("AZURE_TENANT_ID")
            client_id = self.get("AZURE_CLIENT_ID")
            client_secret = self.get("AZURE_CLIENT_SECRET")
            credential = ClientSecretCredential(tenant_id, client_id, client_secret)
            token_obj = credential.get_token("https://cognitiveservices.azure.com/.default")
            logger.info("Acquired Azure token successfully.")
            return token_obj.token
        except Exception as e:
            logger.error(f"Failed to get Azure token: {str(e)}")
            raise

###############################
# Example usage with AzureChatOpenAI
###############################
def main():
    """
    Demonstrate:
      1) Loading .env config
      2) Setting proxy with NO_PROXY merges 
      3) A simple chat call via AzureChatOpenAI
    """
    try:
        # Setup paths
        base_dir = Path(__file__).parent.parent
        env_dir = base_dir / "env"
        config_file = env_dir / "config.env"
        creds_file = env_dir / "credentials.env"
        cert_file = env_dir / "cacert.pem"

        # Validate
        for f in [config_file, creds_file, cert_file]:
            if not f.exists():
                print(f"Missing: {f}")
                return

        # Init env
        env_setup = OSEnv(str(config_file), str(creds_file), str(cert_file))

        # Construct an AzureChatOpenAI instance
        # We'll pass in the azure_ad_token if SECURED_ENDPOINTS=True
        from langchain.chat_models import AzureChatOpenAI
        model_name = env_setup.get("MODEL_NAME", "gpt-4")
        temperature = float(env_setup.get("MODEL_TEMPERATURE", "0.7"))
        max_tokens = int(env_setup.get("MAX_TOKENS", "800"))
        api_version = env_setup.get("API_VERSION","2023-03-15-preview")
        endpoint = env_setup.get("AZURE_OPENAI_ENDPOINT","")

        azure_token = env_setup.token  # if SECURED_ENDPOINTS=True, we have an AAD token
        logger.info(f"Using model '{model_name}', temp={temperature}, max_tokens={max_tokens}")

        # Create the LLM object
        llm = AzureChatOpenAI(
            model_name=model_name,
            temperature=temperature,
            max_tokens=max_tokens,
            openai_api_version=api_version,
            azure_endpoint=endpoint,
            azure_ad_token=azure_token
        )

        # Let's do a quick test call
        system_msg = SystemMessage(content="You are a helpful assistant.")
        user_msg = HumanMessage(content="Hi, can you confirm if I'm bypassing the proxy for Azure AD?")
        response = llm([system_msg, user_msg])
        print(f"\nModel's response:\n{response.content}")

    except Exception as e:
        logger.exception("Error in main()")
        print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
