def process_input_json_with_quality(chatbot: AzureChatbot, json_file: str):
    """
    Processes input JSON with duplicate removal and key safety
    """
    def deduplicate_matches(matches: List[dict]) -> List[dict]:
        """Remove matches with duplicate name+definition pairs"""
        seen = set()
        unique_matches = []
        for match in matches:
            # Create unique identifier
            match_name = match.get("name", "").strip().lower()
            match_def = match.get("definition", "").strip().lower()
            identifier = f"{match_name}|{match_def}"
            
            if identifier not in seen and match_name and match_def:
                seen.add(identifier)
                unique_matches.append(match)
        return unique_matches

    def safe_get_best_match(matches: List[dict]) -> dict:
        """Find best valid match from deduplicated list"""
        valid = [m for m in matches if m.get("rating") != "Red"]
        if not valid:
            return None
        return max(valid, key=lambda x: x.get("confidence", 0))

    results = []
    try:
        # Load and validate input
        with open(json_file, "r") as f:
            data = json.load(f)
        
        items = [data] if isinstance(data, dict) else data
        
        for idx, item in enumerate(items):
            item_result = {"index": idx+1, "errors": []}
            try:
                # Validate input
                name = str(item.get("name", "")).strip()
                definition = str(item.get("definition", "")).strip()
                if not name or not definition:
                    raise ValueError("Missing name/definition")
                
                # Get raw results
                raw_result = chatbot.rag_quality_check_item(name, definition)
                
                # Deduplicate matches
                unique_matches = deduplicate_matches(raw_result.get("matches", []))
                
                # Find best match from cleaned results
                best_match = safe_get_best_match(unique_matches)
                
                # Build final result
                item_result.update({
                    "input": {"name": name, "definition": definition},
                    "rating": best_match.get("rating", "Red") if best_match else "Red",
                    "reason": best_match.get("reason", "No valid matches") if best_match else "No valid matches",
                    "best_match": {
                        k: best_match.get(k) 
                        for k in ("name", "definition", "confidence")
                    } if best_match else None,
                    "matches": unique_matches
                })
                
            except Exception as e:
                item_result.update({
                    "error": str(e),
                    "input": item
                })
            
            results.append(item_result)
            
    except Exception as e:
        results.append({"error": f"File processing failed: {str(e)}"})
    
    print(json.dumps(results, indent=2, ensure_ascii=False))
    return results
