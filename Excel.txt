import os
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
import logging
from pathlib import Path
from tqdm import tqdm
import json
import tempfile
from datetime import datetime

# LanceDB imports
import lancedb
from lancedb.pydantic import LanceModel, Vector
from lancedb.rerankers import LinearCombinationReranker
from pydantic import BaseModel, Field

# Langchain imports
from langchain_openai import AzureOpenAIEmbeddings
from langchain.embeddings.base import Embeddings

# Your OSEnv class
class OSEnv:
    """Environment and certificate management class."""
    
    def __init__(self, config_file: str, creds_file: str, certificate_path: str):
        """Initialize with configuration files and certificate path."""
        self.var_list = []
        
        # Load main configuration
        self.bulk_set(config_file, True)
        logger.info(f"Loaded main configuration from {config_file}")
        
        # Load credentials
        self.bulk_set(creds_file, False)
        logger.info(f"Loaded credentials from {creds_file}")
        
        # Set up certificates
        self.set_certificate_path(certificate_path)
        logger.info("Certificate path configured")
        
        # Configure proxy if enabled
        if str_to_bool(self.get("PROXY_ENABLED", "False")):
            self.set_proxy()
            logger.info("Proxy configured")
        
        # Set up Azure token if secure endpoints enabled
        if str_to_bool(self.get("SECURED_ENDPOINTS", "False")):
            logger.info("Securing endpoints")
            self.token = self.get_azure_token()
        else:
            self.token = None

    def set_certificate_path(self, certificate_path: str) -> None:
        """Set up the certificate path for SSL verification."""
        try:
            if is_file_readable(certificate_path):
                cert_path = str(Path(certificate_path))
                self.set("REQUESTS_CA_BUNDLE", cert_path)
                self.set("SSL_CERT_FILE", cert_path)
                self.set("CURL_CA_BUNDLE", cert_path)
                logger.info(f"Certificate path set to: {cert_path}")
        except Exception as e:
            logger.error(f"Certificate configuration failed: {str(e)}")
            raise

    def bulk_set(self, dotenvfile: str, print_val: bool = False) -> None:
        """Read and set environment variables from a dotenv file."""
        try:
            if is_file_readable(dotenvfile):
                logger.info(f"Loading environment variables from {dotenvfile}")
                with open(dotenvfile) as f:
                    lines = f.readlines()
                
                for line in lines:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        try:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = value.strip().strip("'").strip('"')
                            self.set(key, value, print_val)
                        except ValueError:
                            continue
                            
                logger.info(f"Successfully loaded variables from {dotenvfile}")
                
        except Exception as e:
            logger.error(f"Failed to load environment file {dotenvfile}: {str(e)}")
            raise

    def set(self, var_name: str, val: str, print_val: bool = True) -> None:
        """Set an environment variable."""
        try:
            os.environ[var_name] = val
            if var_name not in self.var_list:
                self.var_list.append(var_name)
            if print_val and var_name not in ['AZURE_CLIENT_SECRET', 'AD_USER_PW']:
                logger.info(f"Set {var_name}={val}")
        except Exception as e:
            logger.error(f"Failed to set environment variable {var_name}: {str(e)}")
            raise

    def get(self, var_name: str, default: Optional[str] = None) -> Optional[str]:
        """Get an environment variable value."""
        return os.getenv(var_name, default)

    def set_proxy(self) -> None:
        """Set up proxy configuration with authentication."""
        try:
            ad_username = self.get("AD_USERNAME")
            ad_password = self.get("AD_USER_PW")
            proxy_domain = self.get("HTTPS_PROXY_DOMAIN")
            
            if not all([ad_username, ad_password, proxy_domain]):
                raise ValueError("Missing proxy credentials")
            
            proxy_url = f"http://{ad_username}:{ad_password}@{proxy_domain}"
            self.set("HTTP_PROXY", proxy_url, print_val=False)
            self.set("HTTPS_PROXY", proxy_url, print_val=False)
            
            no_proxy_domains = [
                'cognitiveservices.azure.com',
                'search.windows.net',
                'openai.azure.com',
                'core.windows.net',
                'azurewebsites.net'
            ]
            self.set("NO_PROXY", ",".join(no_proxy_domains))
            
            logger.info("Proxy configuration completed")
            
        except Exception as e:
            logger.error(f"Proxy configuration failed: {str(e)}")
            raise

    def get_azure_token(self) -> str:
        """Get Azure authentication token."""
        try:
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET")
            )
            token = credential.get_token("https://cognitiveservices.azure.com/.default")
            self.set("AZURE_TOKEN", token.token, print_val=False)
            logger.info("Azure token acquired successfully")
            return token.token
        except Exception as e:
            logger.error(f"Failed to get Azure token: {str(e)}")
            raise

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def is_file_readable(filepath: str) -> bool:
    """Check if a file exists and is readable."""
    if not os.path.isfile(filepath) or not os.access(filepath, os.R_OK):
        raise FileNotFoundError(f"The file '{filepath}' does not exist or is not readable")
    return True

def str_to_bool(s: str) -> bool:
    """Convert string to boolean."""
    if s == 'True':
        return True
    elif s == 'False':
        return False
    else:
        raise ValueError(f"Invalid boolean string: {s}")

class SourceItem(LanceModel):
    """Source item schema for LanceDB."""
    vector: Vector(3072) = Field(
        description="Embedding vector for the source item"
    )
    name: str = Field(
        description="Name of the source item"
    )
    description: str = Field(
        description="Description of the source item"
    )
    text: str = Field(
        description="Combined text representation"
    )

class TargetItem(LanceModel):
    """Target item schema for LanceDB."""
    vector: Vector(3072) = Field(
        description="Embedding vector for the target item"
    )
    pbt_name: str = Field(
        description="PBT category name"
    )
    pbt_definition: str = Field(
        description="PBT category definition"
    )
    text: str = Field(
        description="Combined text representation"
    )

class SemanticMatcherLance:
    def __init__(self, env_setup: OSEnv):
        """Initialize with environment setup."""
        self.env = env_setup
        self.batch_size = 16
        self.embedding_model = self._setup_embedding_model()
        self.temp_dir = tempfile.mkdtemp()
        self.db = lancedb.connect(self.temp_dir)
        
        # Initialize reranker with component weights
        self.reranker = LinearCombinationReranker([
            ("vector_score", 0.4),     # Base vector similarity
            ("name_match", 0.3),       # Name similarity
            ("context_match", 0.2),    # Context similarity
            ("key_terms_match", 0.1)   # Key terms overlap
        ])
        
    def _setup_embedding_model(self) -> Embeddings:
        """Configure Azure OpenAI embeddings using Langchain."""
        return AzureOpenAIEmbeddings(
            azure_deployment=self.env.get("AZURE_EMBEDDING_DEPLOYMENT"),
            openai_api_key=self.env.token if self.env.token else self.env.get("AZURE_OPENAI_API_KEY"),
            azure_endpoint=self.env.get("AZURE_OPENAI_ENDPOINT"),
            api_version=self.env.get("AZURE_OPENAI_API_VERSION", "2024-02-01"),
            chunk_size=self.batch_size
        )
