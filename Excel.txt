import json
import logging
logger = logging.getLogger(__name__)

class QualityCheckChain:
    """
    Uses an LLM to produce strictly { "rating": "...", "reason": "..." } as JSON.
    rating âˆˆ {Green, Amber, Red}.
    """
    def __init__(self, llm):
        self.llm = llm
        from langchain.prompts import PromptTemplate
        from langchain.chains import LLMChain

        template = """
You are a rating agent that receives:
- user_input: the user's name + definition
- candidate_doc: a knowledge base match (with name + definition)

You MUST return a JSON with exactly two fields: "rating" and "reason".
No extra keys, no leading/trailing whitespace in the key names.
No text outside the JSON.

"rating" must be one of ["Green","Amber","Red"].
If you think it's a strong match, rating="Green".
If partial match, rating="Amber" (explain partial reason).
If no match, rating="Red" with reason like "No data found".

Output only valid JSON. For example:
{
  "rating": "Green",
  "reason": "They match strongly"
}

---
User input: {user_input}
Candidate doc: {candidate_doc}
"""
        self.prompt = PromptTemplate(
            input_variables=["user_input", "candidate_doc"],
            template=template
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)

    def _normalize_keys(self, data: dict) -> dict:
        """
        Forcefully remove newlines, quotes, or other stray chars from each key.
        This handles issues like '\n "rating"' -> 'rating'.
        """
        normalized = {}
        for k, v in data.items():
            # remove all double quotes, single quotes, newlines, carriage returns
            # and then strip whitespace
            new_k = k.replace('"','').replace("'","").replace('\n','').replace('\r','').strip()
            normalized[new_k] = v
        return normalized

    def check_quality(self, user_input: str, candidate_doc: str) -> dict:
        """
        Returns { "rating": "...", "reason": "..." } or a fallback if parse fails.
        """
        try:
            resp = self.chain.run(
                user_input=user_input,
                candidate_doc=candidate_doc
            )
            raw_resp = resp.strip()

            # 1) Attempt direct parse
            try:
                data = json.loads(raw_resp)
                data = self._normalize_keys(data)
                rating = data.get("rating","Red")
                reason = data.get("reason","No reason provided")
                return {"rating": rating, "reason": reason}
            except:
                pass

            # 2) If direct parse fails, attempt substring extraction
            start_idx = raw_resp.find("{")
            end_idx = raw_resp.rfind("}")
            if start_idx == -1 or end_idx == -1:
                return {"rating":"Red","reason":"Failed to parse JSON (no braces)"}

            json_str = raw_resp[start_idx:end_idx+1]
            try:
                data = json.loads(json_str)
                data = self._normalize_keys(data)
                rating = data.get("rating","Red")
                reason = data.get("reason","No reason provided")
                return {"rating": rating, "reason": reason}
            except:
                return {"rating":"Red","reason":"Failed to parse JSON substring."}

        except Exception as e:
            logger.error(f"Error in check_quality: {str(e)}")
            return {"rating":"Red","reason":"Parsing or chain error."}
