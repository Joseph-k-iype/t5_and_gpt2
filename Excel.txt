class QualityCheckChain:
    """
    Uses an LLM to produce { "rating": "...", "reason": "..." } as JSON
    rating in [Green, Amber, Red]
    """
    def __init__(self, llm):
        self.llm = llm
        # define a custom prompt
        template = """
You are a rating agent that receives:
- user_input: the user's name + definition
- candidate_doc: a knowledge base match (with name + definition)

You MUST return a JSON with exactly two fields: "rating" and "reason".
No extra keys. No extra text outside JSON.

"rating" must be one of ["Green","Amber","Red"].
If you think it's a strong match, rating="Green".
If partial match, rating="Amber" (explain partial reason).
If no match, rating="Red" with reason like "No data found" or something.

Output only valid JSON. For example:
{
  "rating": "Green",
  "reason": "They match strongly"
}

---
User input: {user_input}
Candidate doc: {candidate_doc}
"""
        self.prompt = PromptTemplate(
            input_variables=["user_input", "candidate_doc"],
            template=template
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)

    def check_quality(self, user_input: str, candidate_doc: str) -> Dict[str, str]:
        """
        Returns a dict { "rating": "...", "reason": "..." }.
        If parsing fails, we default to rating=Red, reason="Failed to parse JSON".
        """
        try:
            resp = self.chain.run(
                user_input=user_input,
                candidate_doc=candidate_doc
            )
            resp = resp.strip()

            # 1) Try direct parse
            try:
                data = json.loads(resp)
                rating = data.get("rating","Red")
                reason = data.get("reason","No reason provided")
                return {"rating":rating, "reason":reason}
            except:
                pass

            # 2) If direct parse fails, attempt substring extraction
            start_idx = resp.find("{")
            end_idx = resp.rfind("}")
            if start_idx == -1 or end_idx == -1:
                # no braces found
                return {"rating":"Red","reason":"Failed to parse JSON (no braces)"}

            json_str = resp[start_idx:end_idx+1]
            try:
                data = json.loads(json_str)
                rating = data.get("rating","Red")
                reason = data.get("reason","No reason provided")
                return {"rating":rating, "reason":reason}
            except:
                return {"rating":"Red","reason":"Failed to parse JSON substring."}

        except Exception as e:
            logger.error(f"Error in check_quality: {str(e)}")
            return {"rating":"Red","reason":"Parsing or chain error."}
