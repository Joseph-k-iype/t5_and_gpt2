import json
import logging
logger = logging.getLogger(__name__)

from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate

class ISRClassificationChain:
    """
    Uses an LLM to produce a JSON with:
    {
      "classification": "...",
      "reason": "...",
      "confidence": 0.0,
      "rating": "Green"/"Amber"/"Red"
    }

    Where:
      - classification => your ISR classification label (e.g. "Secret", "Top Secret", etc.)
      - reason         => textual explanation
      - confidence     => float from 0.0 to 1.0
      - rating         => "Green", "Amber", or "Red"
    """

    def __init__(self, llm):
        self.llm = llm

        # Prompt: instruct the LLM to output strictly these keys in valid JSON
        self.template = """
You are an ISR classification agent. You receive:
- user_input: a data item containing a 'name' and 'definition'.

You must classify this data into one of the ISR classification levels (like "Top Secret", "Secret", "Confidential", "Unclassified", or whichever your system uses).
Then produce a JSON with EXACTLY these four fields:
1) "classification": the chosen classification string
2) "reason": a short explanation for why
3) "confidence": a float in [0,1] indicating how sure you are
4) "rating": "Green", "Amber", or "Red"
   - Green if you are highly confident
   - Amber if partially confident
   - Red if not confident or no valid classification

No extra text outside the JSON. For example:

{
  "classification": "Secret",
  "reason": "Definition matches secret data criteria",
  "confidence": 0.85,
  "rating": "Green"
}

---
User input: {user_input}
"""
        self.prompt = PromptTemplate(
            input_variables=["user_input"],
            template=self.template
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)

    def _normalize_keys(self, data: dict) -> dict:
        """
        Remove stray newlines, quotes, etc. from each key
        so if we get '\n "confidence"' => 'confidence'.
        """
        normalized = {}
        for k, v in data.items():
            new_k = k.replace('"','').replace("'","").replace('\n','').replace('\r','').strip()
            normalized[new_k] = v
        return normalized

    def classify_isr_data(self, user_input: str) -> dict:
        """
        Returns a dict with keys: classification, reason, confidence, rating.
        If parse fails, returns a fallback dict with rating=Red.
        """
        try:
            resp = self.chain.run(user_input=user_input).strip()

            # 1) Direct parse
            try:
                data = json.loads(resp)
                data = self._normalize_keys(data)
                classification = str(data.get("classification","Unknown"))
                reason = str(data.get("reason","No reason"))
                confidence = float(data.get("confidence", 0.0))
                rating = str(data.get("rating","Red"))
                return {
                    "classification": classification,
                    "reason": reason,
                    "confidence": confidence,
                    "rating": rating
                }
            except:
                pass

            # 2) Substring approach
            start_idx = resp.find("{")
            end_idx = resp.rfind("}")
            if start_idx == -1 or end_idx == -1:
                return {
                    "classification":"Unknown",
                    "reason":"Failed to parse JSON (no braces)",
                    "confidence":0.0,
                    "rating":"Red"
                }
            json_str = resp[start_idx:end_idx+1]
            try:
                data = json.loads(json_str)
                data = self._normalize_keys(data)
                classification = str(data.get("classification","Unknown"))
                reason = str(data.get("reason","No reason"))
                confidence = float(data.get("confidence",0.0))
                rating = str(data.get("rating","Red"))
                return {
                    "classification": classification,
                    "reason": reason,
                    "confidence": confidence,
                    "rating": rating
                }
            except:
                return {
                    "classification":"Unknown",
                    "reason":"Failed to parse JSON substring",
                    "confidence":0.0,
                    "rating":"Red"
                }

        except Exception as e:
            logger.error(f"Error in classify_isr_data: {str(e)}")
            return {
                "classification":"Unknown",
                "reason":"Parsing or chain error",
                "confidence":0.0,
                "rating":"Red"
            }
