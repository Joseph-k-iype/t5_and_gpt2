import json
import logging
logger = logging.getLogger(__name__)

from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate

class ISRClassificationChain:
    """
    Classify data into an ISR classification level, returning JSON:
    {
      "classification": "...",
      "reason": "...",
      "confidence": 0.0,
      "rating": "Green"/"Amber"/"Red"
    }
    """
    def __init__(self, llm):
        self.llm = llm

        template = """
You are an ISR classification agent. You receive a data item with:
Name + Definition

You must classify it into an ISR classification level (like "Top Secret","Secret","Confidential","Unclassified", etc.)
Then produce valid JSON with EXACTLY these fields:
{
  "classification": "...",
  "reason": "...",
  "confidence": 0.0,
  "rating": "Green"/"Amber"/"Red"
}

No extra text outside the JSON. Example:
{
  "classification": "Secret",
  "reason": "Because it meets secret data criteria",
  "confidence": 0.85,
  "rating": "Green"
}

User input: {user_input}
"""
        self.prompt = PromptTemplate(
            input_variables=["user_input"],
            template=template
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)

    def _normalize_keys(self, data: dict) -> dict:
        """Remove leftover quotes, newlines, etc. from each key."""
        new_data = {}
        for k, v in data.items():
            # aggressively strip quotes, newlines, carriage returns, etc.
            new_k = k.replace('"','').replace("'","").replace('\n','').replace('\r','').strip()
            new_data[new_k] = v
        return new_data

    def classify(self, user_input: str) -> dict:
        """
        Returns { classification, reason, confidence, rating } or fallback if parse fails.
        """
        try:
            resp = self.chain.run(user_input=user_input).strip()

            # **** 1) Aggressively remove newlines from the entire LLM output. ****
            resp = resp.replace('\n',' ').replace('\r',' ').strip()

            # 1) Attempt direct parse
            try:
                data = json.loads(resp)
                data = self._normalize_keys(data)
                classification = str(data.get("classification","Unknown"))
                reason = str(data.get("reason","No reason"))
                confidence = float(data.get("confidence",0.0))
                rating = str(data.get("rating","Red"))
                return {
                    "classification": classification,
                    "reason": reason,
                    "confidence": confidence,
                    "rating": rating
                }
            except:
                pass

            # 2) Substring parse
            start_idx = resp.find("{")
            end_idx = resp.rfind("}")
            if start_idx == -1 or end_idx == -1:
                return {
                    "classification":"Unknown",
                    "reason":"Failed to parse JSON (no braces)",
                    "confidence":0.0,
                    "rating":"Red"
                }

            # also remove newlines from the substring again, just in case
            json_str = resp[start_idx:end_idx+1].replace('\n',' ').replace('\r',' ').strip()
            try:
                data = json.loads(json_str)
                data = self._normalize_keys(data)
                classification = str(data.get("classification","Unknown"))
                reason = str(data.get("reason","No reason"))
                confidence = float(data.get("confidence",0.0))
                rating = str(data.get("rating","Red"))
                return {
                    "classification": classification,
                    "reason": reason,
                    "confidence": confidence,
                    "rating": rating
                }
            except:
                return {
                    "classification":"Unknown",
                    "reason":"Failed to parse JSON substring",
                    "confidence":0.0,
                    "rating":"Red"
                }

        except Exception as e:
            logger.error(f"Error in classify: {str(e)}")
            return {
                "classification":"Unknown",
                "reason":"Parsing or chain error",
                "confidence":0.0,
                "rating":"Red"
            }
