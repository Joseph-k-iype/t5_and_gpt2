#!/usr/bin/env python3
"""
ALTERNATIVE APPROACH: 
Use AzureChatOpenAI via your existing OSEnv to solve the CSV matching problem 
(name/definition vs. pbt-name/pbt-definition) purely through a prompt-based approach.

For each row in the 'source.csv', we pass the entire list of PBTs from 'target.csv' 
into an Azure Chat model and ask: "Which PBT is the best match for this 'name/definition'?"

Outputs a CSV file of matched results.

Configuration (from .env files):
--------------------------------
- MODEL_NAME, MODEL_TEMPERATURE, MAX_TOKENS
- API_VERSION, AZURE_OPENAI_ENDPOINT
- (If secured endpoints = True, we fetch an AAD token using OSEnv)
- Proxy, cert settings, etc. also handled by OSEnv.

Usage:
------
1. Populate your env/config.env and env/credentials.env accordingly.
2. Place source.csv + target.csv in data/.
3. Run: python semantic_chat_match.py
4. Results are saved in output/matches_<timestamp>.csv
"""

import os
import csv
import time
import json
import logging
from pathlib import Path
from typing import List, Dict

import pandas as pd

# The Azure Identity import is used by OSEnv when SECURED_ENDPOINTS=True
from azure.identity import ClientSecretCredential

# We re-use your code:
from langchain.chat_models import AzureChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from dotenv import dotenv_values

# Reuse the logging logic
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

#############################
# OSEnv + Chatbot Classes  #
#############################
def is_file_readable(filepath: str) -> bool:
    """Check if a file exists and is readable."""
    if not os.path.isfile(filepath) or not os.access(filepath, os.R_OK):
        raise FileNotFoundError(f"The file '{filepath}' does not exist or is not readable")
    return True

def str_to_bool(s: str) -> bool:
    """Convert string to boolean."""
    ls = s.strip().lower()
    if ls == 'true':
        return True
    elif ls == 'false':
        return False
    else:
        raise ValueError(f"Invalid boolean string: {s}")

class OSEnv:
    """Environment variable and certificate management class."""

    def __init__(self, config_file: str, creds_file: str, certificate_path: str):
        self.var_list = []
        
        # Load main configuration
        self.bulk_set(config_file, True)
        logger.info(f"Loaded main configuration from {config_file}")
        
        # Load credentials
        self.bulk_set(creds_file, False)
        logger.info(f"Loaded credentials from {creds_file}")
        
        # Set up certificates
        self.set_certificate_path(certificate_path)
        logger.info("Certificate path configured")
        
        # Proxy
        if str_to_bool(self.get("PROXY_ENABLED", "False")):
            self.set_proxy()
            logger.info("Proxy configured")
        
        # Possibly get Azure token
        if str_to_bool(self.get("SECURED_ENDPOINTS", "False")):
            logger.info("Securing endpoints (AAD token)")
            self.token = self.get_azure_token()
        else:
            self.token = None

    def set_certificate_path(self, certificate_path: str) -> None:
        try:
            cp_abs = os.path.abspath(certificate_path)
            if not is_file_readable(cp_abs):
                raise FileNotFoundError(f"Certificate file not found or not readable: {cp_abs}")
            self.set("REQUESTS_CA_BUNDLE", cp_abs)
            self.set("SSL_CERT_FILE", cp_abs)
            self.set("CURL_CA_BUNDLE", cp_abs)
            logger.info(f"Certificate path set to: {cp_abs}")
        except Exception as e:
            logger.error(f"Certificate configuration failed: {str(e)}")
            raise

    def bulk_set(self, dotenvfile: str, print_val: bool = False) -> None:
        try:
            df_abs = os.path.abspath(dotenvfile)
            if not is_file_readable(df_abs):
                return
            vals = dotenv_values(df_abs)
            for k, v in vals.items():
                self.set(k, v, print_val)
        except Exception as e:
            logger.error(f"Failed to load environment file {dotenvfile}: {str(e)}")
            raise

    def set(self, var_name: str, val: str, print_val: bool = True) -> None:
        os.environ[var_name] = val
        if var_name not in self.var_list:
            self.var_list.append(var_name)
        if print_val:
            logger.info(f"Set {var_name}={val}")

    def get(self, var_name: str, default_val: str = "") -> str:
        return os.getenv(var_name, default_val)

    def set_proxy(self) -> None:
        ad_username = self.get("AD_USERNAME")
        ad_password = self.get("AD_USER_PW")
        proxy_domain = self.get("HTTPS_PROXY_DOMAIN")
        if not all([ad_username, ad_password, proxy_domain]):
            raise ValueError("Missing proxy credentials for PROXY_ENABLED=True")

        proxy_url = f"http://{ad_username}:{ad_password}@{proxy_domain}"
        self.set("HTTP_PROXY", proxy_url, print_val=False)
        self.set("HTTPS_PROXY", proxy_url, print_val=False)
        
        no_proxy_list = [
            'cognitiveservices.azure.com',
            'search.windows.net',
            'openai.azure.com',
            'core.windows.net',
            'azurewebsites.net'
        ]
        # Join them into NO_PROXY
        self.set("NO_PROXY", ",".join(no_proxy_list), print_val=False)

    def get_azure_token(self) -> str:
        try:
            credential = ClientSecretCredential(
                tenant_id=self.get("AZURE_TENANT_ID"),
                client_id=self.get("AZURE_CLIENT_ID"),
                client_secret=self.get("AZURE_CLIENT_SECRET")
            )
            token_obj = credential.get_token("https://cognitiveservices.azure.com/.default")
            token_val = token_obj.token
            logger.info("Acquired Azure token successfully")
            return token_val
        except Exception as e:
            logger.error(f"Failed to get Azure token: {str(e)}")
            raise

class AzureChatbot:
    """
    A light wrapper around Azure Chat openai (LangChain's AzureChatOpenAI) 
    for a single prompt/response approach.
    """
    
    def __init__(self, env: OSEnv):
        self.env = env
        self._setup_chat_model()

    def _setup_chat_model(self) -> None:
        """Set up the chat model with environment variables."""
        model_name = self.env.get("MODEL_NAME", "gpt-4o-mini")
        temperature = float(self.env.get("MODEL_TEMPERATURE", "0.7"))
        max_tokens = int(self.env.get("MAX_TOKENS", "800"))
        api_version = self.env.get("API_VERSION", "2024-02-01")
        azure_endpoint = self.env.get("AZURE_OPENAI_ENDPOINT")
        azure_token = self.env.token  # AAD token if SECURED_ENDPOINTS=True

        # Create the LLM object
        self.llm = AzureChatOpenAI(
            model_name=model_name,
            temperature=temperature,
            max_tokens=max_tokens,
            openai_api_version=api_version,
            azure_endpoint=azure_endpoint,
            azure_ad_token=azure_token
        )
        logger.info(f"Chat model '{model_name}' initialized (temp={temperature}, max_tokens={max_tokens}).")

    def match_single_record(self, 
                            name: str, 
                            definition: str, 
                            pbt_list: List[Dict[str, str]]) -> str:
        """
        For one row from the source CSV, 
        pass 'name'/'definition' + the entire pbt_list into a single prompt,
        and let the model pick the best PBT.
        
        Returns: The model's direct response (which hopefully names the best PBT).
        """
        # 1) Create the system & user messages
        #    (System message: instruction to pick best matching PBT. 
        #     User message: includes the actual data.)
        
        system_text = (
            "You are a helpful assistant. Your job: given a concept 'name'/'definition' and "
            "a list of possible 'pbt-name'/'pbt-definition', pick the best matching PBT."
        )
        # Build the user message to contain the full context
        user_text = (
            f"Original name: {name}\n"
            f"Original definition: {definition}\n\n"
            f"Potential PBTs:\n"
        )
        for pbt in pbt_list:
            user_text += f"- pbt-name: {pbt['pbt-name']}\n  pbt-definition: {pbt['pbt-definition']}\n\n"

        user_text += (
            "Which 'pbt-name' is the best match for the original name? "
            "Justify your answer briefly."
        )

        # 2) Call the chat model
        try:
            messages = [
                SystemMessage(content=system_text),
                HumanMessage(content=user_text)
            ]
            response = self.llm(messages)
            return response.content.strip()
        except Exception as e:
            logger.error(f"Error calling the model: {str(e)}")
            return f"ERROR: {str(e)}"

###########################
#   MAIN LOGIC
###########################
def main():
    """
    - Initialize environment
    - Load CSVs
    - For each row in source.csv, ask the chat model which pbt in target.csv is best
    - Save results
    """
    try:
        base_dir = Path(__file__).parent.parent
        env_dir = base_dir / "env"
        data_dir = base_dir / "data"
        output_dir = base_dir / "output"
        log_dir = base_dir / "logs"

        for d in [env_dir, data_dir, output_dir, log_dir]:
            d.mkdir(exist_ok=True)

        # .env files
        config_file = env_dir / "config.env"
        creds_file = env_dir / "credentials.env"
        cert_file = env_dir / "cacert.pem"

        # CSV files
        source_csv = data_dir / "source.csv"
        target_csv = data_dir / "target.csv"

        # Check existence
        missing = []
        for f in [config_file, creds_file, cert_file, source_csv, target_csv]:
            if not f.exists():
                missing.append(str(f))
        if missing:
            print("Missing required files:")
            for m in missing:
                print(f"- {m}")
            return

        # 1) ENV
        logger.info("Initializing OSEnv and reading environment configs...")
        env_setup = OSEnv(str(config_file), str(creds_file), str(cert_file))

        # 2) Chat model
        logger.info("Initializing Azure Chat model (AzureChatbot)...")
        chatbot = AzureChatbot(env_setup)

        # 3) Load data
        logger.info("Loading CSV data...")
        src_df = pd.read_csv(str(source_csv), dtype=str).fillna("")
        tgt_df = pd.read_csv(str(target_csv), dtype=str).fillna("")

        if not {"name", "definition"}.issubset(src_df.columns):
            raise ValueError("source.csv must have columns: name, definition")
        if not {"pbt-name", "pbt-definition"}.issubset(tgt_df.columns):
            raise ValueError("target.csv must have columns: pbt-name, pbt-definition")

        # Convert target DF into a list of dicts for easy iteration
        pbt_list = tgt_df.to_dict('records')

        logger.info(f"Source CSV has {len(src_df)} rows, target CSV has {len(tgt_df)} PBT rows.")
        
        # 4) For each row in source, prompt the model
        results = []
        for idx, row in src_df.iterrows():
            name_val = row["name"].strip()
            def_val = row["definition"].strip()

            logger.info(f"Processing row {idx+1}/{len(src_df)}: '{name_val}'")

            # Query the model
            model_answer = chatbot.match_single_record(name_val, def_val, pbt_list)

            # Append to results
            results.append({
                "source_name": name_val,
                "source_definition": def_val,
                "model_answer": model_answer
            })
        
        # 5) Save results
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        out_file = output_dir / f"chat_matches_{timestamp}.csv"
        pd.DataFrame(results).to_csv(str(out_file), index=False)

        json_file = out_file.with_suffix(".json")
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        print(f"\nDone! Results saved to:\n  - {out_file}\n  - {json_file}")

    except Exception as e:
        logger.exception(f"Unexpected error: {str(e)}")
        print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
